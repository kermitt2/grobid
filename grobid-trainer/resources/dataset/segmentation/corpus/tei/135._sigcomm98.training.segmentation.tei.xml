<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>Secure Group Communications Using Key Graphs <lb/>Chung Kei Wong <lb/>Mohamed Gouda <lb/>Simon S. Lam <lb/>Department of Computer Sciences <lb/>University o f T exas at Austin <lb/>Austin, TX 78712-1188 <lb/>fckwong,gouda,lamg@cs.utexas.edu <lb/>Abstract <lb/>Many emerging applications (e.g., teleconference, real-time <lb/>information services, pay per view, distributed interactive <lb/>simulation, and collaborative w ork) are based upon a group <lb/>communications model, i.e., they require packet delivery <lb/>from one or more authorized senders to a very large number <lb/>of authorized receivers. As a result, securing group commu-<lb/>nications (i.e., providing con dentiality, integrity, and au-<lb/>thenticity of messages delivered between group members) <lb/>will become a critical networking issue. <lb/>In this paper, we present a novel solution to the scal-<lb/>ability problem of group/multicast key management. We <lb/>formalize the notion of a secure group as a triple (U K R) <lb/>where U denotes a set of users, K a set of keys held by the <lb/>users, and R a user-key relation. We then introduce key <lb/>graphs to specify secure groups. For a special class of key <lb/>graphs, we present three strategies for securely distribut-<lb/>ing rekey messages after a join/leave, and specify protocols <lb/>for joining and leaving a secure group. The rekeying strate-<lb/>gies and join/leave protocols are implemented in a prototype <lb/>group key server we have built. We present measurement <lb/>results from experiments and discuss performance compar-<lb/>isons. We s h o w that our group key management service, us-<lb/>ing any of the three rekeying strategies, is scalable to large <lb/>groups with frequent joins and leaves. In particular, the <lb/>average measured processing time per join/leave increases <lb/>linearly with the logarithm of group size. <lb/></front>

			<body>1 Introduction <lb/>Most network applications are based upon the client-server <lb/>paradigm and make use of unicast (or point-to-point) packet <lb/>delivery. Many emerging applications (e.g., teleconference, <lb/>real-time information services, pay per view, distributed in-<lb/>teractive s i m ulation, and collaborative w ork), on the other <lb/>hand, are based upon a group communications model. That <lb/>is, they require packet delivery from one or more authorized <lb/>sender(s) to a large number of authorized receivers. In the <lb/>Internet, multicast has been used successfully to provide an <lb/></body>

			<front>Research sponsored in part by T exas Advanced Research Pro-<lb/>gram grant n o . 003658-063 and by NSA INFOSEC University R e -<lb/>search Program grant no. MDA 904-94-C-6106. Experiments were <lb/>performed on equipment procured with National Science Foundation <lb/>grant no. CDA-9624082. <lb/> To appear in Proceedings of ACM SIGCOMM &apos;98, S e p t e m -<lb/>b e r 2 -4 , 1 9 9 8 , V ancouver, Canada. <lb/></front>

			<body>e cient, best-e ort delivery service to large groups 6]. We <lb/>envision that deployment o f n e t work applications requiring <lb/>group communications will accelerate in coming years. <lb/>While the technical issues of securing unicast commu-<lb/>nications for client-server computing are fairly well under-<lb/>stood, the technical issues of securing group communications <lb/>are not. Yet group communications have a m uch greater ex-<lb/>posure to security b r e a c hes than unicast communications. In <lb/>particular, copies of a group communication packet traverse <lb/>many more links than those of a unicast packet, thereby cre-<lb/>ating more opportunity for tra c interception. We believe <lb/>that securing group communications (i.e., providing con -<lb/>dentiality, i n tegrity, and authenticity of messages delivered <lb/>between group members) will become a critical issue of net-<lb/>working in the near future. <lb/>Conceptually, since every point-to-multipoint communi-<lb/>cation can be represented as a set of point-to-point commu-<lb/>nications, the current t e c hnology base for securing unicast <lb/>communications can be extended in a straightforward man-<lb/>ner to secure group communications 9, 10]. However, such <lb/>an extension is not scalable to large groups. <lb/>For a more concrete illustration of this point, we outline <lb/>a t ypical procedure for securing unicast communications be-<lb/>tween a client a n d a s e r v er. Initially, the client and server <lb/>mutually authenticate each other using an authentication <lb/>protocol or service subsequently, a symmetric key is cre-<lb/>ated and shared by them to be used for pairwise con den-<lb/>tial communications 4, 17, 19, 22]. This procedure can be <lb/>extended to a group as follows: Let there be a trusted group <lb/>server which is given membership information to exercise <lb/>group access control. When a client w ants to join the group, <lb/>the client and group server mutually authenticate using an <lb/>authentication protocol. Having been authenticated and ac-<lb/>cepted into the group, each member shares with the group <lb/>server a key, 1 to be called the member&apos;s individual key. For <lb/>group communications, the group server distributes to each <lb/>member a group key to be shared by all members of the <lb/>group. 2 <lb/>For a group of n members, distributing the group key <lb/>securely to all members requires n messages encrypted with <lb/>individual keys (a computation cost proportional to group <lb/>size n). Each s u c h message may b e s e n t separately via uni-<lb/>cast. Alternatively, t h e n messages may be sent a s a c o m -<lb/>bined message to all group members via multicast. Either <lb/>way, there is a communication cost proportional to group <lb/></body>

			<note place="footnote">1 In this paper, key means a key from a symmetric cryptosystem, <lb/>such as DES, unless explicitly stated otherwise. <lb/></note>

			<note place="footnote">2 It is easy to see that sharing a group key enables con dential <lb/>group communications. In addition to con dentiality, a u t h e n ticity <lb/>and integrity can be provided in group communications using stan-<lb/>dard techniques such as digital signature and message digest. We will <lb/>not elaborate upon these techniques since the focus of this paper is <lb/>key management. <lb/></note>

			<page>1 <lb/></page>

			<body>size n (measured in terms of the number of messages or the <lb/>size of the combined message). <lb/>Observe that for a point-to-point session, the costs of <lb/>session establishment a n d k ey distribution are incurred just <lb/>once, at the beginning of the session. A group session, on <lb/>the other hand, may persist for a relatively long time with <lb/>members joining and leaving the session. Consequently, the <lb/>group key should be changed frequently. To a c hieve a high <lb/>level of security, the group key should be changed after every <lb/>join and leave so that a former group member has no access <lb/>to current communications and a new member has no access <lb/>to previous communications. <lb/>Consider a group server that creates a new group key <lb/>after eve r y j o i n a n d l e a ve. After a join, the new group key <lb/>can be sent via unicast to the new member (encrypted with <lb/>its individual key) and via multicast to existing group mem-<lb/>bers (encrypted with the previous group key). Thus, chang-<lb/>ing the group key securely after a join is not too much w ork. <lb/>After a leave, however, the previous group key can no longer <lb/>be used and the new group key must be encrypted for each <lb/>remaining group member using its individual key. Thus we <lb/>see that changing the group key securely after a leave in-<lb/>curs computation and communication costs proportional to <lb/>n, the same as initial group key distribution. That is, large <lb/>groups whose members join and leave frequently pose a scal-<lb/>ability problem. <lb/>The topic of secure group communications has been in-<lb/>vestigated 1, 2, 8, 15]. Also the problem of how to dis-<lb/>tribute a secret to a group of users has been addressed in <lb/>the cryptography literature 3, 5, 7, 18]. However, with the <lb/>exception of 15], no one has addressed the need for frequent <lb/>key changes and the associated scalability problem for a very <lb/>large group. The approach p r o p o s e d i n I o l u s 1 5 ] t o i m p r o ve <lb/>scalability is to decompose a large group of clients into many <lb/>subgroups and employ a hierarchy of group security agents. <lb/>1.1 Our approach <lb/>We present in this paper a di erent hierarchical approach t o <lb/>improve scalability. Instead of a hierarchy of group security <lb/>agents, we e m p l o y a hierarchy o f k eys. A detailed compari-<lb/>son of our approach and the Iolus approach 1 5 ] i s g i v en in <lb/>Section 6. <lb/>We begin by formalizing the notion of a secure group as <lb/>a t r i p l e ( U K R) where U denotes a set of users, K a set <lb/>of keys, and R U K a user-key relation which speci es <lb/>keys held by each user in U. In particular, each u s e r i s g i v en <lb/>a s u b s e t o f k eys which includes the user&apos;s individual key and <lb/>a group key. We next illustrate how scalability of group key <lb/>management can be improved by organizing the keys in K <lb/>into a hierarchy and giving users additional keys. <lb/>Let there be a trusted group server responsible for group <lb/>access control and key management. In particular, the server <lb/>securely distributes keys to group members and maintains <lb/>the user-key relation. 3 To illustrate our approach, con-<lb/>sider the following simple example of a secure group with <lb/>nine members partitioned into three subgroups, fu1 u 2 u 3 g, <lb/>fu4 u 5 u 6g, and fu7 u 8 u 9 g. Each member is given three <lb/>keys, its individual key, a key for the entire group, and a <lb/>key for its subgroup. Suppose that u1 leaves the group, the <lb/>remaining eight m e m bers form a new secure group and re-<lb/>quire a new group key also, u2 and u3 form a new subgroup <lb/>and require a new subgroup key. To send the new subgroup <lb/></body>

			<note place="footnote">3 In practice, such a s e r v er may be distributed or replicated to <lb/>enhance reliability and performance. <lb/></note>

			<body>key securely to u2 (u3), the server encrypts it with the indi-<lb/>vidual key of u2 (u3). Subsequently, the server can send the <lb/>new group key securely to members of each subgroup by e n -<lb/>crypting it with the subgroup key. T h us by giving each user <lb/>three keys instead of two, the server performs ve encryp-<lb/>tions instead of eight. As a more general example, suppose <lb/>the number n of users is a power of d, and the keys in K <lb/>are organized as the nodes of a full and balanced d-ary tree. <lb/>When a user leaves the secure group, to distribute new keys, <lb/>the server needs to perform approximately d log d (n) encryp-<lb/>tions (rather than n ; 1 encryptions). 4 For a large group, <lb/>say 100,000, the savings can be very substantial. <lb/>1.2 Contributions of this paper <lb/>With a hierarchy of keys, there are many di erent ways <lb/>to construct rekey messages and securely distribute them <lb/>to users. We investigate three rekeying strategies, user-<lb/>oriented, key-oriented and group-oriented. We design and <lb/>specify join/leave protocols based upon these rekeying stra-<lb/>tegies. For key-oriented and user-oriented rekeying, which <lb/>use multiple rekey messages per join/leave, we present a <lb/>technique for signing multiple messages with a single digital <lb/>signature operation. Compared to using one digital signa-<lb/>ture per rekey message, the technique provides a tenfold re-<lb/>duction in the average server processing time of a join/leave. <lb/>The rekeying strategies and protocols are implemented in <lb/>a prototype group key server we h a ve built. We performed <lb/>experiments on two l i g h tly loaded SGI Origin 200 machines, <lb/>with the server running on one and up to 8,192 clients on the <lb/>other. From measurement results, we s h o w that our group <lb/>key management service, using any of the rekeying strategies <lb/>with a key tree, is scalable in particular, the average server <lb/>processing time per join/leave increases linearly with the <lb/>logarithm of group size. We found that the optimal key tree <lb/>degree is around four. Group-oriented rekeying provides the <lb/>best performance of the three strategies on the server side, <lb/>but is worst of the three on the client s i d e . User-oriented <lb/>rekeying has the best performance on the client side, but <lb/>worst on the server side. <lb/>The balance of this paper is organized as follows. In <lb/>Section 2, we i n troduce key graphs as a method for speci-<lb/>fying secure groups. In Section 3, we present protocols for <lb/>users to join and leave a secure group as we l l a s t h e t h r e e <lb/>rekeying strategies. In Section 4, we present a technique for <lb/>signing multiple rekey messages using a single digital sig-<lb/>nature operation. Experiments and performance results are <lb/>presented in Section 5. A comparison of our approach a n d <lb/>the Iolus approach is given in Section 6. Our conclusions <lb/>are in Section 7. <lb/>2 Secure Groups <lb/>A secure g r oup is a triple (U K R) where <lb/>U is a nite and nonempty set of users, <lb/>K is a nite and nonempty set of keys, and <lb/>R is a binary relation between U and K, that <lb/>is, R U K, called the user-key relation of <lb/>the secure group. User u has key k if and only if <lb/>(u k) i s i n R. <lb/></body>

			<note place="footnote">4 A similar observation was independently made in 20] at about <lb/>the same time as when this paper was rst published as a technical <lb/>report 21]. <lb/></note>

			<page>2 <lb/></page>

			<body>Each secure group has a trusted group server responsible for <lb/>generating and securely distributing keys in K to users in <lb/>the group. 5 Speci cally, the group server knows the user set <lb/>U and the key set K, and maintains the user-key relation <lb/>R. Every user in U h a s a k ey in K, called its individual key, <lb/>which is shared only with the group server, and is used for <lb/>pairwise con dential communication with the group server. <lb/>There is a group key in K, shared by the group server and <lb/>all users in U. The group key can be used by each user to <lb/>send messages to the entire group con dentially. <lb/>2.1 Key graphs <lb/>A k ey graph is a directed acyclic graph G with two t ypes <lb/>of nodes, u-nodes representing users and k-nodes represent-<lb/>ing keys. Each u-node has one or more outgoing edges but <lb/>no incoming edge. Each k-node has one or more incoming <lb/>edges. If a k-node has incoming edges only and no outgoing <lb/>edge, then this k-node is called a root. (A key graph can <lb/>have m ultiple roots.) <lb/>Given a key graph G, it speci es a secure group (U K R) <lb/>as follows: <lb/>i. There is a one-to-one correspondence between U <lb/>and the set of u-nodes in G. <lb/>ii. There is a one-to-one correspondence between K <lb/>and the set of k-nodes in G. <lb/>iii. (u k) i s i n R if and only if G has a directed path <lb/>from the u-node that corresponds to u to the k-<lb/>node that corresponds to k. <lb/>k 3 <lb/>u 3 <lb/>u 4 <lb/>k 4 <lb/>k 1 <lb/>k 2 <lb/>u 1 <lb/>u 2 <lb/>k 12 <lb/>k 234 <lb/>k 1234 <lb/>u-nodes <lb/>k-nodes <lb/>Figure 1: A k ey graph. <lb/>As an example, the key graph in Figure 1 speci es the <lb/>following secure group: <lb/>U = fu1 u 2 u 3 u 4 g <lb/>K = fk1 k 2 k 3 k 4 k 12 k 234 k 1234 g <lb/>R = f (u1 k 1), (u1 k 12 ), (u1 k 1234 ), <lb/>(u2 k 2), (u2 k 12 ), (u2 k 234 ), (u2 k 1234 ), <lb/>(u3 k 3), (u3 k 234 ), (u3 k 1234 ), <lb/>(u4 k 4), (u4 k 234 ), (u4 k 1234 ) g <lb/>2 <lb/>Associated with each secure group (U K R) a r e t wo func-<lb/>tions, keyset() and userset(), de ned as follows: <lb/>keyset(u) = f k j (u k) 2 R g <lb/>userset(k) = f u j (u k) 2 R g <lb/>Intuitively, keyset(u) i s t h e s e t o f k eys that are held by u s e r <lb/></body>

			<note place="footnote">5 Note that individual keys may h a ve been generated and securely <lb/>distributed by an authentication service and do not have t o b e g e n -<lb/>erated by the group server. <lb/></note>

			<body>u in U, and userset(k) i s the set of users that hold key k <lb/>in K. For examples, referring to the key graph in Figure 1, <lb/>we h a ve keyset(u4) = fk4 k 234 k 1234 g and userset(k234) = <lb/>fu2 u 3 u 4 g. <lb/>We generalize the de nition of function keyset() to any <lb/>subset U 0 of U, and function userset() to any subset K 0 of <lb/>K, in a straighforward manner, i.e., keyset(U 0 ) is the set of <lb/>keys each of which is held by at least one user in U 0 , and <lb/>userset(K 0 ) is the set of users each o f w h i c h holds at least <lb/>one key in K 0 . <lb/>When a user u leaves a secure group (U K R), every <lb/>key that has been held by u and shared by other users <lb/>in U should be changed. Let k be such a key. To re-<lb/>place k, the server randomly generates a new key knew and <lb/>sends it to every user in userset(k) except u. To d o s o s e -<lb/>curely, the server needs to nd a subset K 0 of keys such <lb/>that userset(K 0 ) = userset(k) ; f ug, and use keys in K 0 <lb/>to encrypt knew. To minimize the work of rekeying, the <lb/>server would like to nd a minimal size set K 0 . This sug-<lb/>gests the following key-covering problem: Given a secure <lb/>group (U K R), and a subset S of U, n d a m i n i m um size <lb/>subset K 0 of K such that userset(K 0 ) = S. Unfortunately, <lb/>the key-covering problem in general is NP-hard 21]. <lb/>2.2 Special classes of key graphs <lb/>We next consider key graphs with special structures for <lb/>which the key covering problem can be easily solved. <lb/>Star: This is the special class of a secure group (U K R) <lb/>where each user in U has two k eys: its individual key and a <lb/>group key that is shared by e v ery user in U. 6 <lb/>Tree: This is the special class of a secure group (U K R) <lb/>whose key graph G is a single-root tree. A tree key graph <lb/>(or key tree) is speci ed by t wo parameters. <lb/>The height h of the tree is the length (in number <lb/>of edges) of the longest directed path in the tree. <lb/>The degree d of the tree is the maximum number <lb/>of incoming edges of a node in the tree. <lb/>Note that since the leaf node of each path is a u-node, each <lb/>user in U has at most h keys. Also the key at the root of the <lb/>tree is shared by e v ery user in U, and serves as the group <lb/>key. Lastly, it is easy to see that star is a special case of <lb/>tree. <lb/>Complete: This is the special class of a secure group <lb/>(U K R), where for every nonempty s u b s e t S of U, there <lb/>is a key k in K such that userset(k) = S. Let n be the <lb/>number of users in U. There are 2 n ; 1 k eys in K, one for <lb/>each o f t h e 2 n ; 1 nonempty subsets of U. Moreover, each <lb/>user u in U has 2 n;1 keys, one for each of the 2 n;1 subsets <lb/>of U that contains u. Since U is a subset of U, there is a key <lb/>shared by e v ery user in U which serves as the group key. <lb/>The total number of keys held by the server and the <lb/>numberofkeys held by a user are present e d i n T able 1 where <lb/>n is the size of U. In particular, in the case of a complete key <lb/>graph, each user needs to hold 2 n;1 keys which is practical <lb/>only for small n. Note that the number of keys in a key <lb/>tree is d h ;1 <lb/>d;1 <lb/>d <lb/>d;1 n when the tree is full and balanced (i.e. <lb/>n = d h;1 ). <lb/></body>

			<note place="footnote">6 This is the base case where no additional keys are used to improve <lb/>scalability of group key management. <lb/></note>

			<page>3 <lb/></page>

			<body>Class of key graph <lb/>Star <lb/>Tree Complete <lb/>Total numberofkeys <lb/>n+1 <lb/>d <lb/>d;1 n <lb/>2 n ;1 <lb/>Numberofkeys per user <lb/>2 <lb/>h <lb/>2 n;1 <lb/>Table 1: Number of keys held by the server and by each <lb/>user. <lb/>3 Rekeying Strategies and Protocols <lb/>A u s e r u who wants to join (leave) a secure group sends a join <lb/>(leave) request to the group server, denoted by s. For a join <lb/>request from user u, w e assume that group access control is <lb/>performed by s e r v er s using an access control list provided by <lb/>the initiator of the secure group. 7 A join request initiates an <lb/>authentication exchange between u and s, possibly with the <lb/>help of an authentication server. If user u is not authorized <lb/>to join the group, server s sends a join-denied reply to u. <lb/>If the join request is granted, we assume that the session <lb/>key distributed as a result of the authentication exchange <lb/>17, 22] will be used as the individual key ku of u. T o simplify <lb/>protocol speci cations below, we use the following notation <lb/>s , u : authenticate u and distribute ku <lb/>to represent the authentication exchange between server s <lb/>and user u, and secure distribution of key ku to be shared <lb/>by u and s. <lb/>After each join or leave, a new secure group is formed. <lb/>Server s has to update the group&apos;s key graph by replacing <lb/>the keys of some existing k-nodes, deleting some k-nodes (in <lb/>the case of a leave), and adding some k-nodes (in the case <lb/>of a join). It then securely sends rekey messages containing <lb/>new group/subgroup keys to users of the new secure group. <lb/>(A reliable message delivery system, for both unicast and <lb/>multicast, is assumed.) In protocol speci cations below, we <lb/>also use the following notation <lb/>x ! y : z <lb/>to denote <lb/>if y is a single user, the sending of message z from <lb/>x to y <lb/>if y is a set of users, the sending of message z from <lb/>x to every user in y (via multicast or unicast). <lb/>In the following subsections, we rst present protocols for <lb/>joining and leaving a secure group speci ed by a star key <lb/>graph. These protocols correspond to conventional rekey-<lb/>ing procedures informally described in the Introduction 9, <lb/>10]. We then consider secure groups speci ed by t r e e k ey <lb/>graphs. With a hierarchy of group and subgroup keys, rekey-<lb/>ing after a join/leave can be carried out in a variety of <lb/>ways. We present three rekeying strategies, user-oriented, <lb/>key-oriented, and group-oriented, as well as protocols for <lb/>joining and leaving a secure group. <lb/>3.1 Joining a star k ey graph <lb/>After granting a join request from user u, server s updates <lb/>the key graph by creating a new u-node for u and a new <lb/>k-node for ku, and attaching them to the root node. Server <lb/></body>

			<note place="footnote">7 The authorization function may be o oaded to an authorization <lb/>server. In this case, the authorization server provides an authorized <lb/>user with a ticket to join the secure group 16, 23]. The user submits <lb/>the ticket together with its join request to server s. <lb/></note>

			<body>s also generates a new group key k U 0 for the root node, <lb/>encrypts it with the individual key ku of user u, and sends <lb/>the encrypted new group key to u. To notify other users <lb/>of the new group key, s e r v er s encrypts the new group key <lb/>k U 0 with the old group key kU, and then multicasts the <lb/>encrypted new group key to every user in the group. (See <lb/>Figure 2.) <lb/>(1) u ! s : join request <lb/>(2) s , u : authenticate u and distribute ku <lb/>(3) <lb/>s : randomly generate a new group key k U 0 <lb/>(4) s ! u : fk U 0g ku <lb/>(5) s ! U : fk U 0g k U <lb/>Figure 2: Join protocol for a star key graph. <lb/>k 1 <lb/>k 2 <lb/>u 1 <lb/>u 2 <lb/>k 3 <lb/>u 3 <lb/>k 123 <lb/>000 000 000 <lb/>000 000 000 <lb/>111 111 111 <lb/>111 111 111 <lb/>k 1 <lb/>k 2 <lb/>u 1 <lb/>u 2 <lb/>u 4 <lb/>k 4 <lb/>k 3 <lb/>u 3 <lb/>1234 <lb/>k <lb/>000 000 000 <lb/>000 000 <lb/>111 111 111 <lb/>111 111 <lb/>u 4 joins <lb/>u 4 leaves <lb/>Figure 3: Star key graphs before and after a join (leave). <lb/>For example, as shown in Figure 3, suppose user u4 wants <lb/>to join the left secure group in the gure, and it is allowed <lb/>to join. After server s changes the group key from k123 to a <lb/>new key k1234, s e r v er s needs to send out the following two <lb/>rekey messages. <lb/>s ! f u1 u 2 u 3 g : fk1234g k 123 <lb/>s ! u4 <lb/>: fk1234g k 4 <lb/>For clarity of presentation, we h a ve assumed that rekey <lb/>messages contain new keys only and secure distribution <lb/>means that the new keys are encrypted just for con den-<lb/>tiality. In our prototype implementation, rekey messages <lb/>have additional elds, such as, subgroup labels for new keys, <lb/>server digital signature, message integrity c heck, timestamp, <lb/>etc. (See 21] for rekey message format.) <lb/>3.2 Leaving a star k ey graph <lb/>(1) u ! s : f leave-request g ku <lb/>(2) s ! u : f leave-granted g ku <lb/>(3) <lb/>s : randomly generate a new group key k U 0 <lb/>(4) for each u s e r v in U except user u do <lb/>s ! v : fk U 0 g kv <lb/>Figure 4: Leave protocol for a star key graph. <lb/>After granting a leave request from user u, server s up-<lb/>dates the key graph by deleting the u-node for user u and <lb/>the k-node for its individual key ku from the key graph. <lb/>Server s generates a new group key k U 0 for the new secure <lb/>group without u, encrypts it with the individual key of each <lb/>remaining user, and unicasts the encrypted new group key <lb/>to the user. (See Figure 4.) <lb/></body>

			<page>4 <lb/></page>

			<body>000 000 <lb/>000 000 <lb/>111 111 <lb/>111 111 <lb/>00 00 <lb/>00 00 <lb/>11 11 <lb/>11 11 <lb/>1-9 <lb/>k-node x <lb/>k 123 <lb/>k 456 <lb/>k 789 <lb/>2 <lb/>k 1 <lb/>k <lb/>k 4 <lb/>k 5 <lb/>k 6 <lb/>k 7 <lb/>k 8 <lb/>k 9 <lb/>u 9 <lb/>u 8 <lb/>u 7 <lb/>u 6 <lb/>u 5 <lb/>u 4 <lb/>u 3 <lb/>u 2 <lb/>u 1 <lb/>k <lb/>k-node x 1 <lb/>0 <lb/>3 <lb/>k <lb/>000 000 <lb/>000 000 000 <lb/>111 111 <lb/>111 111 111 <lb/>00 00 <lb/>00 00 00 <lb/>11 11 <lb/>11 11 11 <lb/>leaves <lb/>9 <lb/>u 9 <lb/>u <lb/>joins <lb/>1-8 <lb/>k-node x <lb/>k 123 <lb/>k 456 <lb/>k 78 <lb/>2 <lb/>k 1 <lb/>k <lb/>k 4 <lb/>k 5 <lb/>k 6 <lb/>k 7 <lb/>k 8 <lb/>u 8 <lb/>u 7 <lb/>u 6 <lb/>u 5 <lb/>u 4 <lb/>u 3 <lb/>u 2 <lb/>u 1 <lb/>k <lb/>k-node x 1 <lb/>0 <lb/>3 <lb/>k <lb/>Figure 5: Key trees before and after a join (leave). <lb/>3.3 Joining a tree key graph <lb/>After granting a join request from u, s e r v er s creates a new <lb/>u-node for user u and a new k-node for its individual key ku. <lb/>Server s nds an existing k-node (called the joining point for <lb/>this join request) in the key tree and attaches k-node ku to <lb/>the joining point a s i t s c hild. <lb/>To p r e v ent the joining user from accessing past commu-<lb/>nications, all keys along the path from the joining point t o <lb/>the root node need to be changed. After generating new <lb/>keys for these nodes, server s needs to securely distribute <lb/>them to the existing users as well as the joining user. For <lb/>example, as shown in Figure 5, suppose u9 is granted to <lb/>join the upper key graph in the gure. The joining point i s <lb/>k-node k78 in the key graph, and the key of this k-node is <lb/>changed to k789 in the new key graph below. Moreover, the <lb/>group key at the root is changed from k1;8 to k1;9. Users <lb/>u1 : : : u 6 only need the new group key k1;9, while users <lb/>u7 u 8 , a n d u9 need the new group key k1;9 as well as the <lb/>new key k789 to be shared by them. <lb/>To securely distribute the new keys to the users, the <lb/>server constructs and sends rekey messages to the users. A <lb/>rekey message contains one or more encrypted new key(s), <lb/>and a user needs to decrypt it with appropriate keys in or-<lb/>der to get the new keys. We next present three di erent <lb/>approaches to construct and send rekey messages. <lb/>User-oriented rekeying. Consider each user and the subset <lb/>of new keys it needs. The idea of user-oriented rekeying <lb/>is that for each user, the server constructs a rekey message <lb/>that contains precisely the new keys needed by the user, and <lb/>encrypts them using a key held by the user. <lb/>For example, as shown in Figure 5, for user u9 to join <lb/>the upper secure group in the gure, server s needs to send <lb/>the following three rekey messages. <lb/>s ! f u1 : : : u 6 g : fk1;9g k 1;8 <lb/>s ! f u7 u 8g <lb/>: fk1;9 k 789 g k 78 <lb/>s ! u9 <lb/>: fk1;9 k 789 g k 9 <lb/>Note that users u1 : : : u 6 need to get the new group key <lb/>k1;9. There is no single key that is shared only by u1 : : : u 6. <lb/>However, key k1;8 can be used to encrypt the new key k1;9 <lb/>for u1 : : : u 6 without security b r e a c h since users u7 and u8 <lb/>will also get this new group key from another rekey message. <lb/>User-oriented rekey messages can be constructed as fol-<lb/>lows. For each k -n o d e x whose key has been changed, say <lb/>from k to k 0 , the server constructs a rekey message by e n -<lb/>crypting the new keys of k-node x and all its ancestors (upto <lb/>the root) by the old key k. This rekey message is then sent <lb/>to the subset of users that need precisely these new keys. Ei-<lb/>ther unicast or subgroup multicast may be used. 8 Moreover, <lb/>one rekey message is sent to the joining user which c o n tains <lb/>all of the new keys encrypted by the individual key of the <lb/>joining user. <lb/>This approach needs h rekey messages. Counting the <lb/>numberofkeys encrypted, the encryption cost for the server <lb/>is given by <lb/>1 + 2 + : : : + h ; 1 + h ; 1 = h(h+1) <lb/>2 <lb/>; 1. <lb/>Key-oriented rekeying. In this approach, each n e w k ey is <lb/>encrypted individually (except keys for the joining user). <lb/>For each k-node x whose key has been changed, say from k <lb/>to k 0 , the server constructs two r e k ey messages. First, the <lb/>server encrypts the new key k 0 with the old key k, and sends <lb/>it to userset(k) which is the set of users that share k. All of <lb/>the original users that need the new key k 0 can get it from <lb/>this rekey message. The other rekey message contains the <lb/>new key k 0 encrypted by the individual key of the joining <lb/>user, and is sent to the joining user. <lb/>As described, a user may h a ve to get multiple rekey mes-<lb/>sages in order to get all the new keys it needs. For example, <lb/>as shown in Figure 5, for user u9 to join the upper secure <lb/>group in the gure, server s needs to send the following four <lb/>rekey messages. Note that users u7 u 8 and u9 need to get <lb/>two r e k ey messages each. <lb/>s ! f u1 : : : u 8 g : fk1;9g k 1;8 <lb/>s ! u9 <lb/>: fk1;9g k 9 <lb/>s ! f u7 u 8g <lb/>: fk789g k 78 <lb/>s ! u9 <lb/>: fk789g k 9 <lb/>Compared to user-oriented rekeying, the above approach <lb/>reduces the encryption cost of the server from h(h+1) <lb/>2 <lb/>;1 t o <lb/>2(h;1), but it requires 2(h;1) rekey messages instead of h. <lb/>To reduce the number of rekey messages, all of the rekey <lb/>messages for a particular user can be combined and sent a s <lb/>one message. Thus, server s can send the following three <lb/>rekey messages instead of the four rekey messages shown <lb/>above. <lb/>s ! f u1 : : : u 6 g : fk1;9g k 1;8 <lb/>s ! f u7 u 8g <lb/>: fk1;9g k 1;8 fk789g k 78 <lb/>s ! u9 <lb/>: fk1;9 k 789 g k 9 <lb/>The join protocol based upon this rekeying strategy is <lb/>presented in Figure 6. Steps (4) and (5) in Figure 6 spec-<lb/>ify how the combined rekey messages are constructed and <lb/>distributed by s e r v er s. <lb/>Using combined rekey messages, the number of rekey <lb/>messages for key-oriented rekeying is h (same as user-<lb/></body>

			<note place="footnote">8 A rekey message can be sent via multicast to a subgroup if a <lb/>multicast address has been established for the subgroup in addition to <lb/>the multicast address for the entire group. Alternatively, the method <lb/>in 13] may be used in lieu of allocating a large numberofmulticast <lb/>addresses for subgroups. See Section 7 for more discussion. <lb/></note>

			<page>5 <lb/></page>

			<body>oriented rekeying) while the encryption cost is 2(h ; 1). <lb/>From this analysis, key-oriented rekeying is clearly better <lb/>for the server than user-oriented rekeying. (This conclusion <lb/>is con rmed by measurement results presented in Section 5.) <lb/>(1) u ! s : join request <lb/>(2) s , u : authenticate u and distribute ku <lb/>(3) <lb/>s : nd a joining point and attach ku, <lb/>let xj denote the joining point, x0 the root, <lb/>and xi;1 the parent o f xi for i = 1 : : : j , <lb/>let Kj+1 denote ku, <lb/>and K0 : : : K j the old keys of x0 : : : x j, <lb/>randomly generate new keys K 0 <lb/>0 : : : K 0 <lb/>j <lb/>(4) for i = 0 upto j do <lb/>let M = fK 0 <lb/>0 gK 0 : : : fK 0 <lb/>i gK i <lb/>s ! (userset(Ki) ; userset(Ki+1)) : M <lb/>(5) s ! u : fK 0 <lb/>0 : : : K 0 <lb/>j g ku <lb/>Figure 6: Join protocol for a tree key graph (key-oriented <lb/>rekeying). <lb/>Group-oriented rekeying. In key-oriented rekeying, each <lb/>new key is encrypted individually (except keys for the join-<lb/>ing user). The server constructs multiple rekey messages, <lb/>each tailored to the needs of a subgroup. Speci cally, the <lb/>users of a subgroup receive a rekey message containing pre-<lb/>cisely the new keys each needs. <lb/>An alternative approach, called group-oriented, is for the <lb/>server to construct a single rekey message containing all new <lb/>keys. This rekey message is then multicasted to the en-<lb/>tire group. Clearly such a r e k ey message is relatively large <lb/>and contains information not needed by individual users. <lb/>However, scalability is not a concern because the message <lb/>size is O(log d (n)) for group size n and key tree degree d. <lb/>The group-oriented approach has several advantages over <lb/>key-oriented and user-oriented rekeying. First, there is no <lb/>need for subgroup multicast. Second, with fewer rekey mes-<lb/>sages, the server&apos;s per rekey message overheads are reduced. <lb/>Third, the total numberof bytes transmitted by the server <lb/>per join/leave request is less than those of key-oriented and <lb/>user-oriented rekeying which duplicate information in rekey <lb/>messages. (See Section 5 and Section 7 for a more thorough <lb/>discussion on performance comparisons.) <lb/>For example, as shown in Figure 5, for user u9 to join <lb/>the upper secure group in the gure, server s needs to send <lb/>the following two rekey messages one is multicasted to the <lb/>group, and the other is unicasted to the joining user. <lb/>s ! f u1 : : : u 8 g : fk1;9g k 1;8 fk789g k 78 <lb/>s ! u9 <lb/>: fk1;9 k 789 g k 9 <lb/>The join protocol based upon group-oriented rekeying is <lb/>presented in Figure 7. This approach reduces the number <lb/>of rekey messages to one multicast message and one unicast <lb/>message, while maintaining the encryption cost at 2(h ; 1) <lb/>(same as key-oriented rekeying). <lb/>(1) -(3) (same as Figure 6) <lb/>(4) s ! userset(K0) : fK 0 <lb/>0 gK 0 : : : fK 0 <lb/>j gK j <lb/>(5) <lb/>s ! u : fK 0 <lb/>0 : : : K 0 <lb/>j g ku <lb/>Figure 7: Join protocol for a tree key graph (group-oriented <lb/>rekeying). <lb/>3.4 Leaving a tree key graph <lb/>After granting a leave request from user u, s e r v er s updates <lb/>the key graph by deleting the u-node for user u and the k-<lb/>node for its individual key from the key graph. The parent <lb/>of the k-node for its individual key is called the leaving point. <lb/>To p r e v ent the leaving user from accessing future com-<lb/>munications, all keys along the path from the leaving point <lb/>t o t h e r o o t n o d e n e e d t o b e c hanged. After generating new <lb/>keys for these k-nodes, server s needs to securely distribute <lb/>them to the remaining users. For example, as shown in Fig-<lb/>ure 5, suppose u9 is granted to leave t h e l o wer key graph in <lb/>the gure. The leaving point is the k-node for k789 in the <lb/>key graph, and the key of this k-node is changed to k78 in <lb/>the new key graph above. Moreover, the group key is also <lb/>changed from k1;9 to k1;8. Users u1 : : : u 6 only need to <lb/>know the new group key k1;8. Users u7 and u8 need to <lb/>know the new group key k1;8 and the new key k78 shared <lb/>by them. <lb/>To securely distribute the new keys to users after a leave, <lb/>we revisit the three rekeying strategies. <lb/>User-oriented rekeying In this approach, each user gets a <lb/>rekey message in which all the new keys it needs are en-<lb/>crypted using a key it holds. For example, as shown in <lb/>Figure 5, for user u9 to leave t h e l o wer secure group in the <lb/>gure, server s needs to send the following four rekey mes-<lb/>sages. <lb/>s ! f u1 u 2 u 3 g : fk1;8g k 123 <lb/>s ! f u4 u 5 u 6 g : fk1;8g k 456 <lb/>s ! u7 <lb/>: fk1;8 k 78 g k 7 <lb/>s ! u8 <lb/>: fk1;8 k 78 g k 8 <lb/>User-oriented rekey messages for a leave can be con-<lb/>structed as follows. For each k-node x whose key has been <lb/>changed, say f r o m k to k 0 , a n d f o r e a c h u n c hanged child y <lb/>of x, the server constructs a rekey message by encrypting <lb/>the new keys of k-node x and all its ancestors (upto the <lb/>root) by t h e k ey K of k-node y. This rekey message is then <lb/>multicasted to userset(K). <lb/>This approach requires (d ; 1)(h ; 1) rekey messages. <lb/>The encryption cost for the server is given by <lb/>(d ; 1)(1 + 2 + : : : + h ; 1) = (d;1)h(h;1) <lb/>2 <lb/>. <lb/>Key-oriented rekeying In this approach, each new key is <lb/>encrypted individually. For example, as shown in Figure 5, <lb/>for user u9 to leave the lower secure group in the gure, <lb/>server s needs to send the following four rekey messages. <lb/>s ! f u1 u 2 u 3 g : fk1;8g k 123 <lb/>s ! f u4 u 5 u 6 g : fk1;8g k 456 <lb/>s ! u7 <lb/>: fk1;8g k 78 fk78g k 7 <lb/>s ! u8 <lb/>: fk1;8g k 78 fk78g k 8 <lb/>The leave protocol based upon key-oriented rekeying is <lb/>presented in Figure 8. Step (4) in Figure 8 speci es how the <lb/>rekey messages are constructed and distributed to users. <lb/>Note that by storing encrypted new keys for use in dif-<lb/>ferent r e k ey messages, the encryption cost of this approach <lb/>is d(h ; 1), which is much l e s s than that of user-oriented <lb/>rekeying. The numberof rekey messages is (d ; 1)(h ; 1), <lb/>same as user-oriented rekeying. <lb/>Group-oriented rekeying. A single rekey message is con-<lb/>structed containing all new keys. For example, as shown in <lb/>Figure 5, for user u9 to leave t h e l o wer secure group in the <lb/>gure, server s needs to send the following rekey message: <lb/></body>

			<page>6 <lb/></page>

			<body>(1) u ! s : f leave-request g ku <lb/>(2) s ! u : f leave-granted g ku <lb/>(3) <lb/>s : nd the leaving point (the parent o f ku), <lb/>remove ku from the tree, <lb/>let xj+1 denote the deleted k-node for ku, <lb/>xj the leaving point, x0 the root, <lb/>and xi;1 the parent o f xi for i = 1 : : : j , <lb/>randomly generate keys K 0 <lb/>0 : : : K 0 <lb/>j <lb/>as the new keys of x0 : : : x j <lb/>(4) for i = 0 upto j do <lb/>for each c hild y of xi do <lb/>let K denote the key at k-node y <lb/>if y 6 = xi+1 then do <lb/>let M = fK 0 <lb/>i gK fK 0 <lb/>i;1 g K 0 <lb/>i : : : fK 0 <lb/>0 g K 0 <lb/>1 <lb/>s ! userset(K) : M <lb/>Figure 8: Leave protocol for a tree key graph (key-oriented <lb/>rekeying). <lb/>let L0 denote fk1;8g k 123 fk1;8g k 456 fk1;8g k 78 <lb/>let L1 denote fk78g k 7 fk78g k 8 <lb/>s ! f u1 : : : u 8 g : L0 L 1 <lb/>Note that for a leave, this single rekey message is about <lb/>d times bigger than the rekey message for a join, where d is <lb/>the average degree of a k-node. <lb/>The leave protocol based upon group-oriented rekeying <lb/>is presented in Figure 9. This approach uses only one rekey <lb/>message which i s m ulticasted to the entire group, and the <lb/>encryption cost is d(h ; 1), same as key-oriented rekeying. <lb/>(1) -(3) (same as Figure 8) <lb/>(4) for i = 0 upto j do <lb/>let fz1 : : : z rg be the set of the children of xi <lb/>let J1 : : : J r denote the keys at z1 : : : z r <lb/>let Li denote fK 0 <lb/>i gJ 1 : : : fK 0 <lb/>i gJ r <lb/>s ! userset(K 0 <lb/>0 ) : L0 : : : L j <lb/>Figure 9: Leave protocol for a tree key graph (group-oriented <lb/>rekeying). <lb/>3.5 Cost of encryptions and decryptions <lb/>An approximate measure of the computational costs of the <lb/>server and users is the number of key encryptions and de-<lb/>cryptions required by a join/leave operation. Let n be the <lb/>number of users in a secure group. For each join/leave o p -<lb/>eration, the user that requests the operation is called the <lb/>requesting user, and the other users in the group are non-<lb/>requesting users. For a join/leave operation, we tabulate the <lb/>cost of a requesting user in Table 2(a), the cost of a non-<lb/>requesting user in Table 2(b), and the cost of the server in <lb/>Table 2(c). These costs are from the protocols described <lb/>above for star and tree key graphs, and from 21] for com-<lb/>plete key graphs. (Key-oriented or group-oriented rekeying <lb/>is assumed for tree key graphs.) <lb/>For a key tree, recall that d and h denote the degree <lb/>and height of the tree respectively. In this case, for a non-<lb/>requesting user u, t h e a verage cost of u for a join or a leave <lb/>is less than d <lb/>d;1 which is independent of the size of the tree <lb/>(derivation in 21]). <lb/>Assuming that the number of join operations is the same <lb/>as the number of leave operations, the average costs per <lb/>operation are tabulated in Table 3 for the server and a user <lb/>in the group. <lb/>(a) <lb/>the requesting user <lb/>Star <lb/>Tree <lb/>Complete <lb/>join <lb/>1 <lb/>h;1 <lb/>2 n <lb/>leave <lb/>0 <lb/>0 <lb/>0 <lb/>(b) <lb/>a non-requesting user <lb/>Star <lb/>Tree <lb/>Complete <lb/>join <lb/>1 <lb/>d <lb/>d;1 <lb/>2 n;1 <lb/>leave <lb/>1 <lb/>d <lb/>d;1 <lb/>0 <lb/>(c) <lb/>the server <lb/>Star <lb/>Tree <lb/>Complete <lb/>join <lb/>2 <lb/>2(h;1) <lb/>2 n+1 <lb/>leave <lb/>n;1 <lb/>d(h;1) <lb/>0 <lb/>Table 2: Cost of a join/leave operation. <lb/>cost <lb/>Star <lb/>Tree <lb/>Complete <lb/>cost of the server n=2 (d + 2 ) ( h ; 1)=2 <lb/>2 n <lb/>cost of a user <lb/>1 <lb/>d=(d ; 1) <lb/>2 n <lb/>Table 3: Average cost per operation. <lb/>From Table 3, it is obvious that complete key graphs <lb/>should not be used. On the other hand, scalable group key <lb/>management can be achieved by using tree key graphs. Note <lb/>that for a full and balanced d-ary tree, the average server <lb/>cost is (d + 2)(h ;1)=2 = ( d + 2)(log d (n))=2. However, each <lb/>user has to do slightly more work (from 1 to d <lb/>d;1 ). For d = 4 , <lb/>a user needs to do 1:33 decryptions on the average instead <lb/>of one. (It can be shown that the server cost is minimized <lb/>for d = 4, i.e., the optimal degree of key trees is four.) <lb/>4 Technique for Signing Rekey Messages <lb/>In our join/leave protocols, each r e k ey message contains one <lb/>or more new keys. Each n e w k ey, destined for a set of users, <lb/>is encrypted by a key known only to these users and the <lb/>server. It is possible for a user to masquerade as the server <lb/>and send out rekey messages to other users. Thus if users <lb/>cannot be trusted, then each r e k ey message should be digi-<lb/>tally signed by the server. <lb/>We note that a digital signature operation is around two <lb/>orders of magnitude slower than a key encryption using DES. <lb/>For this reason, it is highly desirable to reduce the numberof <lb/>digital signature operations required per join/leave. If each <lb/>rekey message is signed individually, then group-oriented <lb/>rekeying, using just one rekey message per join/leave, would <lb/>be far superior to key-oriented (user-oriented) rekeying, <lb/>which u s e s m a n y r e k ey messages per join/leave. <lb/>Consider m rekey messages, M1 : : : M m, with message <lb/>digests, di = h(Mi) f o r i = 1 : : : m , where h() is a secure <lb/>message digest function such a s M D 5 . The standard way t o <lb/>provide authenticity is for the server to sign each message <lb/>digest (with its private key) and send the signed message <lb/>digest together with the message. This would require m <lb/>digital signature operations for m messages. <lb/>We next describe a technique, implemented in our pro-<lb/>totype key server, for signing a set of messages using just <lb/>a single digital signature operation. The technique is based <lb/>upon a scheme proposed by Merkle 14]. <lb/>Suppose there are four messages with message digests <lb/>d1 d 2 d 3 , and d4. Construct message D12 containing d1 <lb/>and d2, and compute message digest d12 = h(D12). Simi-<lb/>larly, construct message D34 containing d3 and d4, and com-<lb/>pute message digest d34 = h(D34). Then construct message <lb/></body>

			<page>7 <lb/></page>

			<body>key tree <lb/>one signature per rekey msg <lb/>one signature for all rekey msgs <lb/>degree 4 msg size (byte) proc time (msec) msg size (byte) proc time (msec) <lb/>join <lb/>leave join leave ave join <lb/>leave join leave ave <lb/>user <lb/>263.1 233.8 76.7 204.6 140.6 312.8 306.9 13.6 17.1 15.3 <lb/>key <lb/>303.0 270.9 76.3 203.8 140.1 352.8 344.0 13.1 15.9 14.5 <lb/>group <lb/>525.5 1005.7 11.9 12.0 11.9 525.5 1005.7 11.9 12.0 11.9 <lb/>Table 4: Average rekey message size and server processing time (n=8192, DES, MD5, RSA) <lb/>0 <lb/>0.5 <lb/>1 <lb/>1.5 <lb/>2 <lb/>2.5 <lb/>3 <lb/>3.5 <lb/>4 <lb/>32 <lb/>64 <lb/>128 <lb/>256 <lb/>512 1024 2048 4096 8192 <lb/>processing time (msec) <lb/>group size <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>10 <lb/>11 <lb/>12 <lb/>13 <lb/>14 <lb/>15 <lb/>16 <lb/>32 <lb/>64 <lb/>128 <lb/>256 <lb/>512 1024 2048 4096 8192 <lb/>processing time (msec) <lb/>group size <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>(a) with encryption only <lb/>(b) with encryption and signature <lb/>Figure 10: Server processing time per request vs group size (key tree degree 4). <lb/>D1;4 containing d12 and d34, and compute message digest <lb/>d1;4 = h(D1;4). The server signs message digest d1;4 with <lb/>its private key. The server then sends the signed message <lb/>digest, sign(d1;4), together with D1;4, D34, and M4 to a <lb/>user that needs M4. <lb/>The user veri es, by rst decrypting sign(d1;4), that <lb/>d1;4 = h(D1;4). Subsequently, the user veri es that d34 <lb/>in D1;4 is equal to h(D34), and also d4 in D34 is equal to <lb/>h(M4), which assures that M4 was indeed sent b y the server. <lb/>The above example can be easily extended to m messages <lb/>in general. <lb/>The bene ts of this technique for signing rekey messages <lb/>are demonstrated in Table 4 for both key-oriented and user-<lb/>oriented rekeying. (Note that it is not needed by group-<lb/>oriented rekeying which uses one rekey message per join/ <lb/>leave.) The average rekey message size per join/leave is <lb/>shown, as well as the server&apos;s processing time per join/leave <lb/>(ave denotes the ave r a g e o f a verage join and leave process-<lb/>ing times). The experiments were performed for an initial <lb/>g r o u p s i z e o f 8 1 9 2 , with DES-CBC encryption, MD5 mes-<lb/>sage digest, and RSA digital signature (512-bit modulus). <lb/>Additional details of our experimental setup can be found <lb/>in Section 5. With the technique for signing rekey mes-<lb/>sages, the processing time reduction for key-oriented and <lb/>user-oriented rekeying is about a factor of ten (for exam-<lb/>ple, 14.5 msec versus 140.1 msec in the case of key-oriented <lb/>rekeying). There is however a small increase (around 50-70 <lb/>bytes) in the average rekey message size. <lb/>5 Experiments and Performance Comparisons <lb/>We have designed and constructed a prototype group key <lb/>server, as well as a client l a yer, which implement join/leave <lb/>protocols for all three rekeying strategies in Section 3 and <lb/>the technique for signing rekey messages in Section 4. <lb/>We performed a large number of experiments to evaluate <lb/>the performance of the rekeying strategies and the technique <lb/>for signing rekey messages. The experiments were carried <lb/>out on two l i g h tly loaded SGI Origin 200 machines running <lb/>IRIX 6.4. The machines were connected by a 100 Mbps <lb/>Ethernet. The group key server process runs on one SGI <lb/>machine. The server is initialized from a speci cation le <lb/>which determines the inital group size, the rekeying strat-<lb/>egy, t h e k ey tree degree, the encryption algorithm, the mes-<lb/>sage digest algorithm, the digital signature algorithm, etc. <lb/>A c l i e n t-simulator runs on the other SGI simulating a large <lb/>number of clients. Actual rekey messages, as well as join, <lb/>join-ack, leave, leave-ack messages, are sent between indi-<lb/>vidual clients and the server using UDP over the 100 Mbps <lb/>Ethernet. Cryptographic routines from the publicly avail-<lb/>able CrytoLib library are used 11]. <lb/>For each experiment with an initial group size n, the <lb/>client-simulator rst sent n join requests, and the server <lb/>built a key tree. Then the client-simulator sent 1000 join/ <lb/>leave requests. The sequence of 1000 join/leave requests was <lb/>generated randomly according to a given ratio (the ratio was <lb/>1:1 in all our experiments to be presented). Each experi-<lb/>ment w as performed with three di erent sequences of 1000 <lb/>join/leave requests. For fair comparisons (between di erent <lb/>rekeying strategies, key trees of di erent degrees, etc.), the <lb/>same three sequences were used for a given group size. The <lb/>server employs a heuristic that attempts to build and main-<lb/>tain a key tree that is full and balanced. However, since the <lb/>sequence of join/leave requests is randomly generated, it is <lb/>unlikely that the tree is truly full and balanced at any time. <lb/>To e v aluate the performance of di erent rekeying strate-<lb/>gies as well as the technique for signing rekey messages, we <lb/>measured rekey message sizes (in bytes) and processing time <lb/>(in msec) used by the server per join/leave request. Specif-<lb/>ically, the processing time per join/leave request consists of <lb/>the following components. First, the server parses a request, <lb/>traverses the key graph to determine which k eys are to be <lb/>updated, generates new keys, and updates the key graph. <lb/></body>

			<page>8 <lb/></page>

			<body>key tree <lb/>rekey msg size (byte) <lb/>no. of rekey msgs <lb/>degree 4 <lb/>per join <lb/>perleave <lb/>per join <lb/>perleave <lb/>ave min max <lb/>ave min max ave min max ave min max <lb/>user <lb/>312.8 196 552 306.9 228 412 7.00 <lb/>6 <lb/>7 19.02 18 20 <lb/>key <lb/>352.8 212 616 344.0 244 476 7.00 <lb/>6 <lb/>7 19.02 18 20 <lb/>group <lb/>525.5 356 564 1005.7 968 1076 1.00 <lb/>1 <lb/>1 1.00 <lb/>1 <lb/>1 <lb/>key tree <lb/>rekey msg size (byte) <lb/>no. of rekey msgs <lb/>degree 8 <lb/>per join <lb/>perleave <lb/>per join <lb/>perleave <lb/>ave min max <lb/>ave min max ave min max ave min max <lb/>user <lb/>287.3 196 496 285.9 228 356 5.00 <lb/>4 <lb/>5 29.01 28 30 <lb/>key <lb/>319.3 212 544 314.3 244 404 5.00 <lb/>4 <lb/>5 29.01 28 30 <lb/>group <lb/>464.5 284 492 1293.1 1256 1364 1.00 <lb/>1 <lb/>1 1.00 <lb/>1 <lb/>1 <lb/>key tree <lb/>rekey msg size (byte) <lb/>no. of rekey msgs <lb/>degree 16 <lb/>per join <lb/>perleave <lb/>per join <lb/>perleave <lb/>ave min max <lb/>ave min max ave min max ave min max <lb/>user <lb/>274.0 180 452 282.4 244 344 4.00 <lb/>3 <lb/>4 46.01 45 47 <lb/>key <lb/>302.0 196 492 306.6 260 384 4.00 <lb/>3 <lb/>4 46.01 45 47 <lb/>group <lb/>427.8 248 456 1869.1 1832 1940 1.00 <lb/>1 <lb/>1 1.00 <lb/>1 <lb/>1 <lb/>Table 5: Number and size of rekey messages, with encryption and signature, sent b y the server (initial group size 8192) <lb/>Second, the server performs encryption of new keys and con-<lb/>structs rekey messages. Third, if message digest is speci ed, <lb/>the server computes message digests of the rekey messages. <lb/>Fourth, if digital signature is speci ed, the server computes <lb/>message digests and a digital signature as described in Sec-<lb/>tion 4. Lastly, t h e s e r v er sends out rekey messages as UDP <lb/>packets using socket system calls. 9 <lb/>The server processing time per request (averaged over <lb/>joins and leaves) versus group size (from 32 to 8192) is shown <lb/>in Figure 10. Note that the horizontal axis is in log scale. <lb/>The left gure is for rekey messages with DES-CBC encryp-<lb/>tion only (no message digest and no digital signature). The <lb/>right gure is for rekey messages with DES-CBC encryption, <lb/>MD5 message digest, and RSA-512 digital signature. The <lb/>key tree degree was four in all experiments. We conclude <lb/>from the experimental results that our group key manage-<lb/>ment service is scalable to very large groups since the pro-<lb/>cessing time per request increases (approximately) linearly <lb/>with the logarithm of group size for all three rekeying strate-<lb/>gies. Other experiments support the same conclusion for key <lb/>tree degrees of 8 and 16. <lb/>The average server processing time versus key tree de-<lb/>gree is shown in Figure 11. These experimental results illus-<lb/>trate three observations. First, the optimal degree for key <lb/>trees is around four. Second, with respect to server process-<lb/>ing time, group-oriented rekeying has the best performance, <lb/>with key-oriented rekeying in second place. Third, signing <lb/>rekey messages increases the server processing time by a n <lb/>order of magnitude (it would be another order of magnitude <lb/>more for key-oriented and user-oriented rekeying without a <lb/>special technique for signing multiple messages). The left <lb/>hand side of the gure is for rekey messages with DES-CBC <lb/>encryption only (no message digest and no digital signature). <lb/>The right hand side of the gure is for rekey messages with <lb/>DES-CBC encryption, MD5 message digest, and RSA-512 <lb/>digital signature. The initial group size was 8192 in these <lb/>experiments. <lb/>9 The processing time is measured using the UNIX system call <lb/>getrusage() which returns processing time (including time of sys-<lb/>tem calls) used by a process. In the results presented herein, the <lb/>processing time for a join request does not include any time used to <lb/>authenticate the requesting user (i.e., step (2) in the join protocols <lb/>of Figure 6 and Figure 7). We f e e l t h a t a n y authentication overhead <lb/>should be accounted for separately. <lb/>key tree <lb/>rekey msg size (byte) no. of rekey <lb/>degree 4 <lb/>perjoin <lb/>perleave <lb/>msgs per <lb/>ave <lb/>ave join/leave <lb/>user <lb/>209.3 <lb/>237.4 <lb/>1 <lb/>key <lb/>227.9 <lb/>256.0 <lb/>1 <lb/>group <lb/>525.5 <lb/>1005.7 <lb/>1 <lb/>key tree <lb/>rekey msg size (byte) no. of rekey <lb/>degree 8 <lb/>perjoin <lb/>perleave <lb/>msgs per <lb/>ave <lb/>ave join/leave <lb/>user <lb/>200.0 <lb/>242.0 <lb/>1 <lb/>key <lb/>217.2 <lb/>259.2 <lb/>1 <lb/>group <lb/>464.5 <lb/>1293.1 <lb/>1 <lb/>key tree <lb/>rekey msg size (byte) no. of rekey <lb/>degree 16 perjoin <lb/>perleave <lb/>msgs per <lb/>ave <lb/>ave join/leave <lb/>user <lb/>197.8 <lb/>246.7 <lb/>1 <lb/>key <lb/>214.3 <lb/>263.2 <lb/>1 <lb/>group <lb/>427.8 <lb/>1869.1 <lb/>1 <lb/>Table 6: Number and size of rekey messages, with encryp-<lb/>tion and signature, received by a client (initial group size <lb/>8192) <lb/>Table 5 presents the size and number of rekey messages <lb/>sent b y the server. Note that group-oriented rekeying uses a <lb/>single large rekey message per request (sent via group mul-<lb/>ticast), while key-oriented and user-oriented rekeying use <lb/>multiple smaller rekey messages per request (sent via sub-<lb/>group multicast or unicast). 10 Note that the total number <lb/>of bytes per join/leave transmitted by the server is much <lb/>higher in key-oriented and user-oriented rekeying than in <lb/>group-oriented rekeying. <lb/>Table 6 presents the size and number of rekey messages <lb/>received by a client. Only the average message sizes are <lb/>shown, because the minimum and maximum sizes are the <lb/>same as those in Table 5. Note that each client gets exactly <lb/>one rekey message for all three rekeying strategies. For key-<lb/>oriented and user-oriented rekeying, the average message <lb/>size is smaller than the corresponding average message size <lb/>in Table 5. The is because the average message size here <lb/></body>

			<note place="footnote">10 The experiments reported herein were performed with each r e k ey <lb/>message sent just once by the server via subgroup multicast. <lb/></note>

			<page>9 <lb/></page>

			<body>0 <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>8 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>18 <lb/>20 <lb/>22 <lb/>24 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>(a) per join with encryption only <lb/>(d) per join with encryption and signature <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>8 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>18 <lb/>20 <lb/>22 <lb/>24 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>(b) per leave with encryption only <lb/>(e) per leave with encryption and signature <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>8 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>18 <lb/>20 <lb/>22 <lb/>24 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>processing time (msec) <lb/>key tree degree <lb/>user-oriented <lb/>key-oriented <lb/>group-oriented <lb/>(c) per request with encryption only <lb/>(f) per request with encryption and signature <lb/>Figure 11: Server processing time vs key tree degree (initial group size 8192). <lb/>was calculated over all clients, and many more clients re-<lb/>ceived small rekey messages than clients that received large <lb/>rekey messages. The results in this table show that group-<lb/>oriented rekeying, which has the best performance on the <lb/>server side, requires more work on the client side to process <lb/>a larger message than key-oriented and user-oriented rekey-<lb/>ing. The average rekey message size on the client side is the <lb/>smallest in user-oriented rekeying. <lb/>From the contents of rekey messages, we counted and <lb/>computed the average number of key changes by a client <lb/>per join/leave request, which is shown in Figure 12. The <lb/>top gure shows the average numberof key changes versus <lb/>the key tree degree, and the bottom gure shows the average <lb/>numberof key changes versus the initial group size of each <lb/>experiment. Note that the average numberofkey changes by <lb/>a client is relatively small, and is very close to the analytical <lb/>result, d=(d ; 1) shown in Table 3 in Section 3. <lb/></body>

			<page>10 <lb/></page>

			<body>1 <lb/>1.2 <lb/>1.4 <lb/>1.6 <lb/>1.8 <lb/>2 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>16 <lb/>number of key changes <lb/>key tree degree <lb/>n = 1024 <lb/>n = 2048 <lb/>n = 4086 <lb/>n = 8192 <lb/>analysis <lb/>1 <lb/>1.05 <lb/>1.1 <lb/>1.15 <lb/>1.2 <lb/>1.25 <lb/>1.3 <lb/>1.35 <lb/>1.4 <lb/>1.45 <lb/>1.5 <lb/>32 <lb/>64 <lb/>128 <lb/>256 <lb/>512 1024 2048 4096 8192 <lb/>number of key changes <lb/>group size <lb/>tree degree is 4 <lb/>tree degree is 8 <lb/>tree degree is 16 <lb/>Figure 12: Numberofkey changes by a client per request. <lb/>6 Related Work <lb/>The scalability problem of group key management for a <lb/>large group with frequent joins and leaves was previously ad-<lb/>dressed by Mittra with his Iolus system 15]. Both Iolus and <lb/>our approach solve the scalability problem by making use of <lb/>a hierarchy. The similarity, h o wever, ends here. The system <lb/>architectures are very di erent in the two approaches. We <lb/>next compare them by considering a tree hierarchy w i t h a <lb/>single root (i.e., a single secure group). <lb/>Iolus&apos;s tree hierarchy consists of clients at the leaves with <lb/>multiple levels of group security agents (agents, in short) <lb/>above. For each tree node, the tree node (an agent) and its <lb/>children (clients or lower-level agents) form a subgroup and <lb/>share a subgroup key. There is no globally shared group key. <lb/>Thus a join and leave in a subgroup does not a ect other <lb/>subgroups only the local subgroup key needs to be changed. <lb/>Our tree hierarchy consists of keys, with individual keys <lb/>at leaves, the group key at the root, and subgroup keys <lb/>elsewhere. There is a single key server for all the clients. <lb/>There are no agents, but each client is given multiple keys <lb/>(its individual key, the group key, and some subgroup keys). <lb/>In comparing the two approaches, there are several issues <lb/>to consider: performance, trust, and reliability. <lb/>Performance. Roughly speaking, since both approaches <lb/>make use of a hierarchy, both attempt to change a O(n) <lb/>problem into a O(log(n)) problem where n denotes group <lb/>size. They di er however in where and when work is per-<lb/>formed to achieve secure rekeying when a client joins/leaves <lb/>the secure group. <lb/>Secure rekeying after a leave requires more work than <lb/>after a join because, unlike a j o i n , the previous group key <lb/>cannot used and n rekey messages are required (this is re-<lb/>ferred to in 15] as a 1 does not equal n type problem). <lb/>This is precisely the problem solved by using a hierarchy i n <lb/>both approaches. <lb/>The main di erence between Iolus and our approach i s i n <lb/>how the 1 a ects n type problem 15] is addressed. In our <lb/>approach, every time a client joins/leaves the secure group a <lb/>rekeying operation is required which a ects the entire group. <lb/>Note that this is not a scalability concern in our approach <lb/>because the server cost is O(log(n)) and the client cost is <lb/>O(1). <lb/>In Iolus, there is no globally shared group key with the <lb/>apparent advantage that whenever a client joins/leaves a <lb/>subgroup only the subgroup needs to be rekeyed. However, <lb/>for a client to send a message con dentially to the entire <lb/>group, the client needs to generate a message key for en-<lb/>crypting the message and the message key has to be securely <lb/>distributed to the entire group via agents. Each agent d e -<lb/>crypts using one subgroup key to retrieve the message key <lb/>and reencrypts it with another subgroup key for forwarding <lb/>15]. <lb/>That is, most of the work in handling the 1 a ects n <lb/>type problem is performed in Iolus when a client sends a <lb/>message con dentially to the entire group (rather than when <lb/>a client joins/leaves the group). In our approach, most of <lb/>the work in handling the 1 a ects n type problem is per-<lb/>formed when a client joins/leaves the secure group (rather <lb/>than when a client sends messages con dentially to the en-<lb/>tire group). <lb/>Trust. Our architecture requires a single trusted entity, <lb/>namely, the key server. The key server may be replicated <lb/>for reliability/performance enhancement, in which case, sev-<lb/>eral trusted entities are needed. Each trusted entity should <lb/>be protected using strong security measures (e.g. physical <lb/>security, k ernel security, etc.). In Iolus, however, there are <lb/>many agents and all of the agents are trusted entities. Thus <lb/>the level of trust required of the system components is much <lb/>greater in Iolus than in our approach. <lb/>Reliability. In Iolus, agents are needed to securely forward <lb/>message keys. When an agent fails, a backup is needed. <lb/>It would appear that replicating a single key server (in our <lb/>approach) to improve reliability is easier than back i n g u p a <lb/>large number of agents. 11 <lb/>7 Conclusions <lb/>We present three rekeying strategies, user-oriented, key-<lb/>oriented and group-oriented and specify join/leave proto-<lb/>cols based upon these strategies. For key-oriented and user-<lb/>oriented rekeying, which use multiple rekey messages per <lb/>join/leave, we p r e s e n t a t e c hnique for signing multiple mes-<lb/>sages with a single digital signature operation. Compared to <lb/>using one digital signature per rekey message, the technique <lb/>provides a tenfold reduction in the average server processing <lb/>time of a join/leave. <lb/>The rekeying strategies and protocols are implemented <lb/>in a prototype group key server we h a ve built. From mea-<lb/>surement results of a large number of experiments, we con-<lb/>clude that our group key management service using any o f <lb/>the three rekeying strategies is scalable to large groups with <lb/>frequent joins and leaves. In particular, the average server <lb/>processing time per join/leave increases linearly with the <lb/></body>

			<note place="footnote">11 Craig Partridge observed that agents can be implemented in ex-<lb/>isting rewalls and derive their reliability and trustworthiness from <lb/>those of rewalls. <lb/></note>

			<page>11 <lb/></page>

			<body>logarithm of group size. We found that the optimal key tree <lb/>degree is around four. <lb/>On the server side, group-oriented rekeying provides the <lb/>best performance, with key-oriented rekeying in second <lb/>place, and user-oriented rekeying in third place. On the <lb/>client side, user-oriented rekeying provides the best per-<lb/>formance, with key-oriented rekeying in second place, and <lb/>group-oriented rekeying in third place. In particular, for a <lb/>very large group whose clients are connected to the network <lb/>via low-speed connections (modems), key-oriented or user-<lb/>oriented rekeying would be more appropriate than group-<lb/>oriented rekeying. <lb/>We next consider the amount o f network tra c gener-<lb/>ated by the three rekeying strategies. With group-oriented <lb/>rekeying, a single rekey message is sent p e r join/leave via <lb/>multicast to the entire group, the network load generated <lb/>would depend upon the network con guration (local area <lb/>network, campus network, wide area Internet, etc.) and <lb/>the group&apos;s geographic distribution. With key-oriented and <lb/>user-oriented rekeying, many smaller rekey messages are sent <lb/>per join/leave to subgroups. If the rekey messages are sent <lb/>via unicast (because the network provides no support for <lb/>subgroup multicast), the network load generated would be <lb/>much greater than that of group-oriented rekeying. <lb/>It is possible to support subgroup multicast by the <lb/>method in 13] or by allocating a large number of multi-<lb/>cast addresses, one for each subgroup that share a key in <lb/>the key tree being used. A more practical approach, how-<lb/>ever, is to allocate just a small numberofmulticast addresses <lb/>(e.g., one for each c hild of the key tree&apos;s root node) and use <lb/>a r e k eying strategy that is a hybrid of group-oriented and <lb/>key-oriented rekeying. It is straightforward to design such <lb/>a h ybrid strategy and specify the join/leave protocols. Fur-<lb/>thermore a hybrid approach, involving the use of some Iolus <lb/>agents at certain locations, such as rewalls, may also be <lb/>appropriate. <lb/>Lastly, the reader may w onder why w e u s e k ey graphs to <lb/>specify a secure group even though key trees are su cient <lb/>for scalable management of a group key. This is because we <lb/>are constructing a group key management service for appli-<lb/>cations that require the formation of multiple secure groups <lb/>over a population of users and a user can join several secure <lb/>groups. For these applications, the key trees of di erent <lb/>group keys are merged to form a key graph 12]. <lb/></body>

			<div type="acknowledgement">Acknowledgement <lb/>We thank Craig Partridge for his constructive comments in <lb/>shepherding the nal revision of this paper. <lb/></div>

			<listBibl>References <lb/>1] Tony Ballardie. Scalable Multicast Key Distribution, <lb/>RFC 1 9 4 9 , M a y 1996. <lb/>2] Tony Ballardie and Jon Crowcroft. Multicast-Speci c <lb/>Security Threats and Counter-Measures. In Proceedings <lb/>Symposium on Network and Distributed System Secu-<lb/>rity, 1995. <lb/>3] Shimshon Berkovits. How to Broadcast a Secret. In <lb/>D.W. Davies, editor, Advances in cryptology, EURO-<lb/>CRYPT &apos;91, v olume 547 of Lecture Notes in Computer <lb/>Science, pages 535{541. Springer Verlag, 1991. <lb/>4] R. Bird, I. Gopal, A. Herzberg, P. Janson, S. Kutten, <lb/>R. Molva, and M. Yung. The KryptoKnight family of <lb/>light-weight protocols for authentication and key distri-<lb/>bution. IEEE/ACM Transactions on Networking, 3(1), <lb/>February 1995. <lb/>5] Guang-Huei Chiou and Wen-Tsuen Chen. Secure <lb/>Broadcasting Using the Secure Lock. IEEE Transac-<lb/>tions on Software Engineering, 15(8):929{934, August <lb/>1989. <lb/>6] Stephen E. Deering. Multicast Routing in Internet-<lb/>works and Extended LANs. In Proceedings of ACM <lb/>SIGCOMM &apos;88, August 1988. <lb/>7] Amos Fiat and Moni Naor. Broadcast Encryption. <lb/>In Douglas R. Stinson, editor, Advances in cryptology, <lb/>CRYPTO &apos;93, volume 773 of Lecture Notes in Com-<lb/>puter Science, pages 480{491. Springer Verlag, 1994. <lb/>8] Li Gong. Enclaves: Enabling Secure Collaboration over <lb/>the Internet. IEEE Journal on Selected A reas in Com-<lb/>munications, pages 567{575, April 1997. <lb/>9] H. Harney and C. Muckenhirn. Group Key Management <lb/>Protocol (GKMP) Architecture, RFC 2094, July 1997. <lb/>10] H. Harney and C. Muckenhirn. Group Key Management <lb/>Protocol (GKMP) Speci cation, RFC 2 0 9 3 , July 1997. <lb/>11] J. B. Lacy, D . P . M i t c hell, and W. M. Schell. CryptoLib: <lb/>cryptography i n s o f t ware. In Proceedings of USENIX: <lb/>4th UNIX Security Symposium, October 1993. <lb/>12] Simon S. Lam and Chung Kei Wong. Keystone: A <lb/>Group Key Management Service. Work in progress, <lb/>Department o f Computer Sciences, The University of <lb/>Texas at Austin. <lb/>13] Brian Neil Levine and J.J. Garcia-Luna-Aceves. Im-<lb/>proving Internet Multicast with Routing Labels. In <lb/>Proceedings of International Conference on Network <lb/>Protocols, 1997. <lb/>14] Ralph C. Merkle. A Certi ed Digital Signature. In <lb/>Advances in Cryptology -CRYPTO &apos;89, 1989. <lb/>15] Suvo Mittra. Iolus: A F ramework for Scalable Secure <lb/>Multicasting. In Proceedings of ACM SIGCOMM &apos;97, <lb/>1997. <lb/>16] B. Cli ord Neuman. Proxy-Based Authorization and <lb/>Accounting for Distributed Systems. In Proceedings of <lb/>13th International Conference on Distributed Comput-<lb/>ing Systems, pages 283{291, May 1993. <lb/>17] Jennifer G. Steiner, Cli ord Neuman, and Je rey I. <lb/>Schiller. Kerberos: An Authentication Service for Open <lb/>Network Systems. In USENIX Winter Conference, <lb/>pages 191{202, February 1988. <lb/>18] D.R. Stinson. On Some Methods for Unconditionally <lb/>Secure Key Distribution and Broadcast Encryption. <lb/>Designs, Codes and Cryptography, (12):215{243, 1997. <lb/>19] J.J. Tardo and K. Alagappan. SPX: Global authentica-<lb/>tion using public key certi cates. In Proceedings of 12th <lb/>IEEE Symposium on Research in Security and Privacy, <lb/>pages 232{244, May 1991. <lb/>20] Debby M . W allner, Eric J. Harder, and Ryan C. Agee. <lb/>Key Management for Multicast: Issues and Architec-<lb/>tures. Working draft, National Security Agency, J u l y <lb/>1997. <lb/>21] Chung Kei Wong, Mohamed Gouda, and Simon S. Lam. <lb/>Secure Group Communications Using Key Graphs. <lb/>Technical Report TR 97-23, Department of Computer <lb/>Sciences, The University o f T exas at Austin, July 1997. <lb/>22] Thomas Y.C. Woo, Raghuram Bindignavle, Shaowen <lb/>Su, and Simon S. Lam. SNP: An interface for secure <lb/>network programming. In Proceedings of USENIX&apos;94 <lb/>Summer Technical Conference, June 1994. <lb/>23] Thomas Y.C. Woo and Simon S. Lam. Designing a Dis-<lb/>tributed Authorization Service. In Proceedings IEEE <lb/>INFOCOM &apos;98, San Francisco, March 1998. <lb/></listBibl>

			<page>12 </page>


	</text>
</tei>
