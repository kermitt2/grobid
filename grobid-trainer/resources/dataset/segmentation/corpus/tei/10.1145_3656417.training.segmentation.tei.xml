<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">Scaling Type-Based Points-to Analysis with Saturation</title>
        <author>
          <persName>
            <forename>Christian</forename>
            <surname>Wimmer</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Codrut</forename>
            <surname>Stancu</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>David</forename>
            <surname>Kozak</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Thomas</forename>
            <surname>Würthinger</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-30T11:36:27.826273Z">30.10.2025 11:36:27</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3656417</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3656417</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Christian Wimmer, Codrut Stancu, David Kozak, Thomas Würthinger. (2024). Scaling Type-Based Points-to Analysis with Saturation. Proceedings of the ACM on Programming Languages, 8(PLDI), 990-1013. DOI: 10.1145/3656417</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-30T11:36:27.826273Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-30T11:36:27.826273Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
        <front>Synthetiq: Fast and Versatile <lb/>antum Circuit Synthesis <lb/>ANOUK PARADIS * , ETH Zurich, Switzerland <lb/>JASPER DEKONINCK * , ETH Zurich, Switzerland <lb/>BENJAMIN BICHSEL, ETH Zurich, Switzerland <lb/>MARTIN VECHEV, ETH Zurich, Switzerland <lb/>To implement quantum algorithms on quantum computers it is crucial to decompose their operators into the <lb/>limited gate set supported by those computers. Unfortunately, existing works automating this essential task are <lb/>generally slow and only applicable to narrow use cases. We present Synthetiq, a method to synthesize quantum <lb/>circuits implementing a given specification over arbitrary finite gate sets, which is faster and more versatile <lb/>than existing works. Synthetiq utilizes Simulated Annealing instantiated with a novel, domain-specific energy <lb/>function that allows developers to leverage partial specifications for better efficiency. Synthetiq further couples <lb/>this synthesis method with a custom simplification pass, to ensure efficiency of the found circuits. <lb/>We experimentally demonstrate that Synthetiq can generate better implementations than were previously <lb/>known for multiple relevant quantum operators including RCCCX, CCT, CCiSWAP, C <lb/>√ <lb/>SWAP, and C <lb/>√ <lb/>iSWAP. <lb/>Our extensive evaluation also demonstrates Synthetiq frequently outperforms a wide variety of more special-<lb/>ized tools in their own domains, including (i) the well-studied task of synthesizing fully specified operators <lb/>in the Clifford+T gate set, (ii) -approximate synthesis of multi-qubit operators in the same gate set, and <lb/>(iii) synthesis tasks with custom gate sets. On all those tasks, Synthetiq is typically one to two orders of <lb/>magnitude faster than previous state-of-the-art and can tackle problems that were previously out of the reach <lb/>of any synthesis tool. <lb/>CCS Concepts: • Hardware → Quantum computation; • Software and its engineering → Compilers. <lb/>Additional Key Words and Phrases: Quantum Circuits, Synthesis, Clifford+T <lb/>ACM Reference Format: <lb/>Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev. 2024. Synthetiq: Fast and Versatile <lb/>Quantum Circuit Synthesis. Proc. ACM Program. Lang. 8, OOPSLA1, Article 96 (April 2024), 28 pages. https: <lb/>//doi.org/10.1145/3649813 <lb/></front>

        <body>1 INTRODUCTION <lb/>Quantum computing promises to gain a significant advantage over classical computing by leveraging <lb/>the principles of quantum mechanics [Arute et al. 2019; de Wolf 2017; Shor 1997]. However, for such <lb/>an advantage to be realized in practice, quantum algorithms must be implemented and executed on <lb/>a quantum computer. This requires bridging the gap between the high level constructs used in the <lb/>description of those quantum algorithms, and the limited set of operations that can be executed on <lb/>a quantum computer. <lb/></body>

        <front> * Equal Contribution <lb/>Authors&apos; addresses: Anouk Paradis, ETH Zurich, Zurich, Switzerland, anouk.paradis@inf.ethz.ch; Jasper Dekoninck, ETH <lb/>Zurich, Zurich, Switzerland, jasper.dekoninck@inf.ethz.ch; Benjamin Bichsel, ETH Zurich, Zurich, Switzerland, benjamin. <lb/>bichsel@inf.ethz.ch; Martin Vechev, ETH Zurich, Zurich, Switzerland, martin.vechev@inf.ethz.ch. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/4-ART96 <lb/>https://doi.org/10.1145/3649813 <lb/>Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/></front>

        <page>96:2 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>Decomposing Arbitrary Operators. Typically, quantum algorithms rely on arbitrary operators, <lb/>described by input-output pairs. Such operators may act on many qubits simultaneously. In contrast, <lb/>quantum computers, both existing [Alvarez-Rodriguez et al. 2018; Arute et al. 2019; Steffen et al. <lb/>2011] and planned [Bravyi et al. 2022; Gill et al. 2022] can only execute a limited set of operations <lb/>acting on one or two qubits, often referred to as gates. Hence, implementing a quantum algorithm <lb/>requires decomposing its operators into these supported gates. We refer to the resulting decompo-<lb/>sition as a circuit. Crucially, the performance of quantum algorithms hinges on the efficiency of the <lb/>circuits resulting from the decomposition. <lb/>Compilation to Finite Gate Sets. We focus on the problem of operator decomposition to a finite <lb/>gate set. This is in particular relevant for fault-tolerant quantum computing, which invariably <lb/>depends on finite gate sets, most frequently the Clifford+T gate set. Almost all existing synthesis <lb/>tools [Gheorghiu et al. 2022a,b; Matteo and Mosca 2016; Mosca and Mukhopadhyay 2021; Niemann <lb/>et al. 2020] for finite gate sets only support decomposition to this gate set. Further, they are generally <lb/>slow and limited to decomposing fully specified operators, adding unnecessary constraints when an <lb/>operator is only specified on selected inputs. Only three works [Amy et al. 2013; Chou et al. 2022; <lb/>Kang and Oh 2023] allow for custom gate sets or partially specified operators. They are however <lb/>prohibitively slow, and can therefore only handle really short decompositions of at most 20 gates. <lb/>This Work: Simulated Annealing for Circuit Synthesis. We present Synthetiq, a method to syn-<lb/>thesize circuits over arbitrary finite gate sets using Simulated Annealing (SA), which iteratively <lb/>modifies circuits until they meet a given specification. Our key insight is that SA is particularly <lb/>well-suited for this problem when instantiated with a novel, domain-specific energy function that <lb/>allows for partial specifications of quantum operators. Due to the inherent parallelizability of SA, <lb/>Synthetiq is not only more versatile but also significantly faster than existing works, typically by <lb/>one to two orders of magnitude on common synthesis tasks. <lb/>Versatility. Unlike prior works, Synthetiq can be employed in a wide range of different scenarios. <lb/>First, as it does not rely on properties specific to the Clifford+T gate set, it supports adding custom <lb/>gates or even changing the gate set completely. Crucially, composite gates, that is small operators <lb/>whose decomposition in the original gate set is already known, can be added to the gate set in <lb/>order to speed up Synthetiq. <lb/>Second, Synthetiq naturally supports partially specified operators. This is essential, as requiring <lb/>developers to arbitrarily refine an underspecified operator restricts the search space and results in <lb/>sub-optimal decompositions. <lb/>Third, Synthetiq can synthesize efficient circuits for many performance metrics, from total gate <lb/>count to a specific gate depth. We note that, like most existing methods, Synthetiq cannot guarantee <lb/>optimal circuits, but empirically succeeds in finding them given enough time. <lb/>Finally, for the cases where an operator cannot be exactly decomposed into the chosen finite <lb/>gate set, Synthetiq can synthesize quantum circuits that approximate the given operator with a <lb/>specified accuracy level. <lb/>Results. Leveraging Synthetiq, we can effectively synthesize a broader range of operators than <lb/>any previous work. This allows us to uncover more efficient implementations of the operators <lb/>RCCCX, CCT, CCiSWAP, C <lb/>√ <lb/>SWAP, and C <lb/>√ <lb/>iSWAP using the Clifford+T gate set. When applied <lb/>to five problems from StackExchange, Synthetiq outperforms the expert-written accepted answer <lb/>twice and matches its efficiency otherwise. <lb/>Additionally, our evaluation shows that Synthetiq surpasses more specialized tools in performance <lb/>and results, despite addressing a broader range of synthesis tasks. First, Synthetiq outperforms <lb/>synthesis tools for both partially specified operators in custom gate sets [Kang and Oh 2023] and fully <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:3 <lb/></page>

        <body>specified operators in the Clifford+T gate set [Gheorghiu et al. 2022a; Mosca and Mukhopadhyay <lb/>2021] by a factor of one to two orders of magnitude, often producing more efficient circuits. <lb/>Second, Synthetiq&apos;s performance is on par with the state-of-the-art approach for -approximate <lb/>synthesis of fully specified multi-qubit operators in the Clifford+T gate set [Gheorghiu et al. 2022b]. <lb/>Finally, Synthetiq stands out as the first tool to successfully synthesize relative phase operators, <lb/>an important case of incomplete specification. Those operators are in particular crucial for the <lb/>efficient implementation of operators with multiple controls [Maslov 2016], and are used by Qiskit <lb/>as one of the standard decompositions of the MCX operator [Qiskit 2023]. <lb/>Main Contributions. To summarize, our main contributions are: <lb/>• Synthetiq, a fast and versatile synthesis algorithm for quantum operators over finite gate <lb/>sets based on Simulated Annealing ( §3- §4), <lb/>• a natural framework for partial specifications addressing common synthesis tasks ( §5), <lb/>• an implementation 1 and thorough evaluation of Synthetiq, showing that it outperforms more <lb/>specialized tools and can tackle synthesis problems that were previously out of reach ( §6). <lb/>In the following, we present the necessary background ( §2), exemplify Synthetiq on an exam-<lb/>ple ( §3), formally describe Synthetiq ( §4) and how it handles partial specifications ( §5), evaluate <lb/>Synthetiq ( §6) and discuss related work ( §7). <lb/>2 BACKGROUND <lb/>We now present the necessary background on quantum computation and Simulated Annealing. <lb/>Qubit. A qubit is the quantum counterpart of a classical bit. The state of a qubit is a linear <lb/>combination of the basis states |0⟩ and |1⟩ , which we can write as = 0 |0⟩ + 1 |1⟩ with <lb/>0 , 1 ∈ C. In the following, we often omit the subscript indicating the qubit name when it is not <lb/>relevant. The state of qubit can equivalently be described by a state vector = 0 <lb/>1 . <lb/>To describe a system with multiple qubits, we use the tensor product ⊗. For instance, we can <lb/>write the state of a system with two qubits and as <lb/>= 0 |0⟩ ⊗ |0⟩ + 1 |1⟩ ⊗ |0⟩ + 2 |0⟩ ⊗ |1⟩ + 3 |1⟩ ⊗ |1⟩ , or = <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>with ∈ C. We often abbreviate | ⟩ ⊗ | ⟩ to | ⟩ . We say the state vector describes in the <lb/>computational basis {|00⟩ , |10⟩ , |01⟩ , |11⟩}. <lb/>Quantum Gates and Circuits. Quantum compiling aims to produce circuits to be run on a quantum <lb/>computer. Quantum circuits consist of a fixed number of qubits, and gates to be applied to some <lb/>of those qubits. For instance, the X gate acts on one qubit and flips its value, or more formally <lb/>X | ⟩ = | ⊕ 1⟩. More generally, X maps the state 0 |0⟩ + 1 |1⟩ to 0 |1⟩ + 1 |0⟩. Using the state <lb/>vector representation, this operation can be described by the following matrix in C 2 1 ×2 1 , which we <lb/>refer to as ⟦X⟧: <lb/>⟦ ⟧ = 0 1 <lb/>1 0 <lb/>Applying gate X to a qubit described by the state vector yields the new state vector ⟦X⟧ . Some <lb/>quantum gates act on multiple qubits at the same time. For instance, the controlled X gate CX maps <lb/>| ⟩ to | ⟩ X | ⟩ = | ⟩ | ⊕ ⟩; the second qubit is flipped iff the first one is 1. Again, the effect of <lb/>CX can be described as a matrix. We finally introduce the identity gate I. It is the no-op of quantum <lb/>gates, and its matrix representation when applied to qubits is the identity matrix in C 2 ×2 . <lb/></body>

        <note place="footnote">1 Our implementation is available at https://github.com/eth-sri/synthetiq. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:4 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>Quantum Circuit Semantics. We can think of a quantum circuit as a list of gates and qubits to <lb/>which each gate is applied. For instance, we can consider the circuit on two qubits which applies <lb/>the X gate to its first qubit, followed by the CX gate on both of its qubits. The effect of this circuit <lb/>on two qubits can again be described by a matrix, which is simply the product of the matrices of <lb/>each of its gates: ⟦ ⟧ = ⟦CX⟧ • (⟦X⟧ ⊗ ⟦I⟧). Note how we used the tensor product of ⟦X⟧ with the <lb/>identity I to extend the semantics of this one qubit gate to two qubits. In slight abuse of notation, <lb/>we will typically write instead of ⟦ ⟧ throughout this work. <lb/>Quantum Operators. In the above, we described how the effect of a quantum gate or circuit on <lb/>qubits can be described by a matrix in C 2 ×2 . It is worth noting that all matrices representing <lb/>the action of gates or circuits are unitary 2 . We say a quantum operator is an operation on qubits <lb/>described by a unitary matrix . We then say that a circuit implements this operator if ⟦ ⟧ = . <lb/>Clifford+T Gate Set. To implement a general quantum operator on a given quantum computer, <lb/>we must decompose it into gates from the gate set G supported by this computer. Such gate sets G <lb/>are usually universal, meaning that every quantum operator can be decomposed into gates from G, <lb/>with arbitrary precision &gt; 0. More formally, for any unitary matrix ∈ C 2 ×2 and &gt; 0, there <lb/>exists some circuit on qubits using only gates from G such that ( , ) ⩽ , for some distance <lb/>metric . Fault-tolerant quantum computers will likely rely on the so-called Clifford+T gate set <lb/>[Terhal 2015], which consists of the following gates: <lb/>H = 1 <lb/>√ <lb/>2 <lb/>1 -1 <lb/>1 1 , <lb/>S = 1 0 <lb/>0 i , <lb/>S † = 1 0 <lb/>0 -i , <lb/>T = 1 0 <lb/>0 i /4 , T † = 1 0 <lb/>0 -i /4 , and CX = <lb/>1 0 0 0 <lb/>0 0 0 1 <lb/>0 0 1 0 <lb/>0 1 0 0 <lb/>. <lb/>The Clifford+T gate set is known to be universal [Nielsen and Chuang 2002]. Further, Giles and <lb/>Selinger [2013] showed that based on the coefficients of an operator we can decide whether <lb/>it can be decomposed exactly in the Clifford+T gate set, meaning there is a circuit such that <lb/>( , ) = 0. Based on the determinant of , we can decide if this decomposition requires an ancilla, <lb/>that is if acts on qubits, its decomposition will be a circuit acting on + 1 qubits, where the <lb/>last extra qubit is assumed to be in state |0⟩ initially, and must be returned to this state at the end. <lb/>Simulated Annealing. Simulated Annealing (SA) allows to efficiently find a state which approxi-<lb/>mately minimizes an energy function ( ), often referred to as an energy. Starting from some initial <lb/>state, each SA step picks a randomly sampled neighbor state ′ ∼ N ( ) of the current state , and <lb/>selects ′ as the current state with some probability ( , ′ , ). Here, ∈ R &gt;0 denotes a progres-<lb/>sively decreasing temperature. In this work, we set the acceptance probability using the common <lb/>approach ( , ′ , ) = min 1, exp -( ′ )-( ) . Thus a better ′ (meaning ( ′ ) &lt; ( )) ensures <lb/>( , ′ , ) = 1 and therefore is always accepted. In contrast, a worse ′ has ( , ′ , ) &lt; 1 and thus <lb/>can be rejected or accepted, where acceptance is particularly likely initially, at high temperatures <lb/>. <lb/>3 OVERVIEW <lb/>We now explain the approach of Synthetiq by synthesizing a circuit over the Clifford+T gate set <lb/>for an example operator. First, we introduce this operator and translate it to a partial specification <lb/>( §3.1). We then show how Synthetiq finds an implementation for it ( §3.2) and how composite gates <lb/>can be used to speed up this search ( §3.3). We describe Synthetiq in more detail in later sections. <lb/></body>

        <note place="footnote">2 We say a matrix is unitary if <lb/> † = , where † is the conjugate transpose of . <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:5 <lb/></page>

        <body>3.1 Creating a Partial Specification <lb/>Controlled-T. The Controlled-T (CT) operator acts on two qubits, and applies the T gate to the <lb/>second qubit if and only if the first qubit is 1. More formally, for , ∈ {0, 1}: <lb/>CT | ⟩ | ⟩ = | ⟩ T | ⟩ . <lb/>In matrix notation, CT corresponds to the operator shown below: <lb/>1 0 0 0 <lb/>0 1 0 0 <lb/>0 0 1 0 <lb/>0 0 0 i /4 <lb/>We note that CT can be represented exactly by a Clifford+T circuit [Giles and Selinger 2013, Theorem <lb/>1], but only if its circuit can make use of an ancilla [Giles and Selinger 2013, Corollary 2]. We now <lb/>show how to encode the CT specification, taking into account this ancilla. <lb/>Encoding Ancillae. The effect of CT when given an ancilla is the following, again for , ∈ {0, 1}: <lb/>CT | ⟩ | ⟩ |0⟩ = | ⟩ T | ⟩ |0⟩ <lb/>(1) <lb/>CT | ⟩ | ⟩ |1⟩ = ? <lb/>(2) <lb/>Note how the operator is undefined when the ancilla is not in state |0⟩. This specification corresponds <lb/>to the following underspecified matrix 3 : <lb/>1 0 0 0 ? ? ? ? <lb/>0 1 0 0 ? ? ? ? <lb/>0 0 1 0 ? ? ? ? <lb/>0 0 0 i /4 ? ? ? ? <lb/>0 0 0 0 ? ? ? ? <lb/>0 0 0 0 ? ? ? ? <lb/>0 0 0 0 ? ? ? ? <lb/>0 0 0 0 ? ? ? ? <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>CT |000⟩ = |000⟩ <lb/>CT |110⟩ = i /4 |110⟩ <lb/>CT |101⟩ = ? <lb/>(3) <lb/>Here we denote all unspecified elements with &quot;?&quot;. When comparing such an underspecified matrix <lb/>to the operator induced by a given circuit, Synthetiq only takes the specified elements into account. <lb/>More precisely, we say a circuit satisfies the specification if the matrix of the circuit operator <lb/>matches all specified coefficients of the underspecified matrix. Although our example matrix consists <lb/>of only fully known or fully unknown columns (i.e., isometries), we note that Synthetiq can also <lb/>handle partially specified columns. <lb/>3.2 Running Synthetiq <lb/>We now describe how Synthetiq builds a quantum circuit from a gate set and a partial specification, <lb/>following Fig. 1. <lb/>Sampling an Initial Circuit. For a given input, Synthetiq executes multiple separate runs of SA. <lb/>Each run starts by sampling a random circuit . To this end, Synthetiq first samples a circuit size <lb/>within the circuit size bounds ℓ min and ℓ max , and then a gate from the gate set (augmented with the <lb/>identity gate) for each position in the circuit. Then, Synthetiq runs SA starting from . <lb/></body>

        <note place="footnote">3 We use the little-endian convention, i.e., input state | <lb/>⟩ corresponds to column • 4 + • 2 + • 1 in Eq. (3). This is <lb/>analogous to existing tools such as Qiskit [Abraham et al. 2019]. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:6 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>Parallel runs of simulated annealing <lb/>Circuit size bound <lb/>ℓ min , ℓ max <lb/>Circuit <lb/>Circuit ′ <lb/>Best circuit <lb/>Gate set <lb/>G = {H, S.. } <lb/>Specification <lb/>S = 1 ? <lb/>0 ? <lb/>C sat. S? <lb/>#iter &lt; <lb/>Update circuit size bounds <lb/>Probabilistically <lb/>Accept/Reject ′ <lb/>No <lb/>Yes: Randomly <lb/>change one gate <lb/>Sample <lb/>init circuit <lb/>Yes: Simplify <lb/>and update best <lb/>No: <lb/>restart <lb/>Fig. 1. Synthetiq overview. Here = 200 • len( ) is the maximum number of iterations of each SA run. <lb/>Simulated Annealing. Each SA step randomly replaces one gate in the current circuit , yielding <lb/>the circuit ′ . Synthetiq decides whether to keep or replace it by ′ using a custom energy function <lb/>. Specifically, if ′ is strictly better, we always replace , otherwise we do so probabilistically. <lb/>Energy Function. We describe our energy function in detail in §4.4. In a nutshell, it measures <lb/>how close the operator implemented by the circuit is to the given specification. The key insight of <lb/>Synthetiq is the extension of an energy function used in e.g. [Chou et al. 2022; Khatri et al. 2019; <lb/>Meister et al. 2023] to work for partial specifications. Such an extension is non-trivial, as it must <lb/>gracefully decrease for circuits that &quot;almost&quot; satisfy a specification in order to guide SA efficiently. <lb/>Further, it must be scaled to work for all possible underspecified operator sizes without requiring <lb/>tuning of Synthetiq to each underspecified case. <lb/>Found Circuit. At every step of the SA algorithm, we check whether the current circuit satisfies <lb/>this specification. If so, we run a simplification pass on it. This simplification is a simple and fast <lb/>algorithm that heuristically optimizes both the total gate cost and the depth of user specified gates. <lb/>Here, the total gate cost is the sum of the implementation cost for each gate, which is specified <lb/>by the user. If the simplified circuit is the best one found so far, we record it. Finally, we use this <lb/>best circuit to update the circuit size bounds for the next initial circuit. If no circuit is found in a <lb/>reasonable number of steps, we abort SA and start a new run from a fresh random circuit. <lb/>Parallelization. As Synthetiq executes many short runs of SA, we can easily parallelize it. This <lb/>leads to an almost linear speedup in the number of cores, greatly increasing Synthetiq&apos;s speed and <lb/>allowing it to synthesize larger circuits than previous work, as demonstrated in §6. <lb/>3.3 Speeding up Synthetiq with Composite Gates <lb/>The versatility of Synthetiq extends beyond the Clifford+T gate set, as it is designed to work <lb/>with any finite gate set. This includes the ability to integrate composite gates, that is operators <lb/>whose decomposition in the gate set is already known. This stratified synthesis [Heule et al. 2016] <lb/>significantly broadens the size of operators that Synthetiq can decompose as it can dramatically <lb/>boost the speed of the search process. This is because a single circuit mutation can introduce a <lb/>complex operator that would otherwise require a large amount of precise mutations. For instance, <lb/>the inclusion of the RCCX operator as a composite gate enabled us to find an optimal implementation <lb/>of the CT-operator within seconds, while finding one without the composite gate took 12 hours. <lb/>However, it is important to note that while the direct insertion of a complex gate can speed up the <lb/>search process, it may not always yield the most efficient circuits. There could be a simpler, more <lb/>efficient implementation that could only be discovered after a more thorough run of Synthetiq. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:7 <lb/></page>

        <body>Algorithm 1 Our main algorithm, Synthetiq. <lb/>1: function Synthetiq(G: Gate set, S: Circuit specification) <lb/>2: <lb/>best ← ∅ <lb/>3: <lb/>for = 1, ..., iter do <lb/>4: <lb/>ℓ ← uniform(ℓ min , ℓ max ) <lb/>5: <lb/>← RandomCircuit( G, ℓ) <lb/>6: <lb/>for = 1, ..., steps do <lb/>7: <lb/>′ ← RandomMutation( , G) <lb/>8: <lb/>, ′ ← ( , S), ( ′ , S) <lb/>9: <lb/>if Accept( , ′ ) then <lb/>10: <lb/>← ′ <lb/>11: <lb/>if satisfies S then <lb/>12: <lb/>← Simplify( ) <lb/>13: <lb/>if Cost( ) &lt; Cost( best ) then <lb/>14: <lb/>best ← <lb/>15: <lb/>ℓ min , ℓ max ← UpdateBounds( best ) <lb/>16: <lb/>break <lb/>17: <lb/>return best <lb/>4 SYNTHETIQ <lb/>We now describe our method in more detail. For more details on hyperparameter optimization and <lb/>values, we refer to Tab. 3 in §6.1. <lb/>End-to-End Procedure. Alg. 1 describes our main algorithm, Synthetiq. It takes as input a gate <lb/>set ( §4.1) and a (partial) specification ( §4.2). Lin. 3-16 then execute multiple separate runs of SA. <lb/>The starting point of each run is a fresh random circuit (Lin. 5) made of ℓ randomly chosen gates. <lb/>We select the number of gates ℓ uniformly at random within the current circuit size bounds ℓ min <lb/>and ℓ max (Lin. 4). Lin. 6-16 then run steps SA steps from this initial circuit. <lb/>At each SA step, Lin. 7 creates a new candidate circuit ′ by randomly changing one gate in the <lb/>current circuit ( §4.3) and scores the two circuits using the energy function (Lin. 8). This energy <lb/>function captures how close the circuit is to the given specification (see §4.4). Lin. 9 then accepts <lb/>the new circuit ′ with a probability depending on the energy of both and ′ (see §4.5). <lb/>If the current circuit does not satisfy the specification, Synthetiq proceeds to the next SA step <lb/>(Lin. 11). Otherwise, Lin. 12 simplifies it ( §4.6). If it is the best circuit found so far (Lin. 13), Lin. 14 <lb/>records it. Finally, Lin. 15 uses the best circuit to update the circuit size bounds ℓ min and ℓ max ( §4.3). <lb/>4.1 Gate Sets <lb/>Synthetiq searches for a circuit implementing the given specification using the gates in the input <lb/>gate set G. This can be any finite set of gates, for instance the Clifford+T gate set or a user supplied <lb/>custom gate set. As discussed in §3.3, we can also add composite gates to G to speed up Synthetiq. <lb/>4.2 Expressing Partial Specifications <lb/>A partial specification S = ( , ) consists of two matrices ∈ C 2 ×2 and ∈ {0, 1} 2 ×2 . is <lb/>the operation we aim to implement and is a boolean mask specifying which elements of should <lb/>be matched (marked with 1) and which can be ignored (marked with 0). Note that elements of <lb/>corresponding to a 0 in can be omitted in S-we typically write them as &quot;?&quot;. We say a unitary <lb/>matrix ∈ C 2 ×2 matches the specification S = ( , ) if and only if • = exp( ) • for <lb/>some ∈ R, where &quot;•&quot; denotes element-wise multiplication and is a global phase difference. Of <lb/>course, there may be many such matrices. We will show in §5 how this natural framework for <lb/>underspecification can be used to specify various useful applications in quantum computing. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:8 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>ℓ min <lb/>3 <lb/>3ℓ best <lb/>(a) Case: ℓ min ≤ 3 ≤ 3ℓ best . <lb/>3 <lb/>ℓ min <lb/>3ℓ best <lb/>(b) Case: 3 ≤ ℓ min ≤ 3ℓ best . <lb/>3 <lb/>3ℓ best <lb/>ℓ min <lb/>(c) Case: 3 ≤ 3ℓ best ≤ ℓ min . <lb/>Fig. 2. Updating bounds on circuit size. <lb/>4.3 Building Circuits <lb/>We now explain how Synthetiq builds and modifies circuits. <lb/>Randomly Mutating Gates. To mutate a given circuit into a new candidate ′ , Synthetiq picks <lb/>a gate position uniformly at random, and replaces it with a randomly selected gate. <lb/>To this end, Synthetiq first decides whether or not to replace the selected gate by a placeholder <lb/>&quot;identity&quot; gate, with probability Id ∈ [0, 1]. This replacement step is analogous to deleting a gate, <lb/>while replacing an identity gate by another is analogous to inserting a gate. Hence, this approach <lb/>allows us to work with fixed size circuits, while keeping the flexibility of gate insertion and deletion. <lb/>If the identity gate was not selected, Synthetiq chooses which gate to insert. It picks a gate in G <lb/>uniformly at random and then select the qubits it acts on. Further, we multiply the probability of <lb/>sampling composite gates by comp ∈ [0, 1] in order to avoid inserting these more expensive gates <lb/>into the circuit too frequently. <lb/>Building the Initial Circuit. To build the initial circuit, we select a circuit size ℓ, and generate a <lb/>circuit by randomly selecting ℓ gates as described above. <lb/>We have found empirically that Synthetiq performs best when ℓ is around 3 times the length <lb/>of the optimal circuit for the given specification, which we denote here by . As is not known <lb/>when running Synthetiq, we use an adaptive scheme to pick ℓ. To this end, we define minimal and <lb/>maximal sizes ℓ min and ℓ max , and sample ℓ uniformly between the two for each new initial circuit. If <lb/>a circuit is found that implements the specification in an SA step, we use the length of the current <lb/>optimal circuit ℓ best to move ℓ min closer to 3 , and analogously for ℓ max : <lb/>ℓ min = <lb/>min ℓ best <lb/>if min ℓ best ≤ ℓ min <lb/>ℓ min + max 1, ( min ℓ best -ℓ min ) <lb/>otherwise <lb/>(4) <lb/>ℓ max = <lb/>max ℓ best <lb/>if max ℓ best ≤ ℓ max <lb/>ℓ max + max 1, ( max ℓ best -ℓ max ) <lb/>otherwise <lb/>(5) <lb/>We now explain how Eq. (4) moves ℓ min closer to 3 ; the intuition behind Eq. (5) is analogous. <lb/>Suppose for now that we set min = 3, then Fig. 2 illustrates three possible situations. In all <lb/>three situations, 3 ≤ 3ℓ best , as is the theoretical best circuit size, while ℓ best is the best size <lb/>found so far. Fig. 2a shows the typical case in the first steps of SA: as we pick ℓ min to be small, it is <lb/>typically smaller than 3 . Then, the second case in Eq. (4) increases ℓ min slightly, where the gray <lb/>part accounts for rounding and increments smaller than 1. Fig. 2b shows a case where ℓ min was <lb/>increased to surpass 3 , but still lies below 3ℓ best . In this case, the second case in Eq. (4) further <lb/>increases ℓ min , which moves us further from 3 , but eventually Synthetiq will find better circuits, <lb/>thus decreasing 3ℓ best . Finally, Fig. 2c shows a case where ℓ min is larger than 3ℓ best . Then, we know <lb/>for sure that 3ℓ best is closer to the optimal value 3 , so we directly update ℓ min to 3ℓ best . <lb/>We note that since our estimate ℓ best of becomes better with every circuit found (no matter <lb/>whether the current circuit improved ℓ best or not), we apply this update rule every time a circuit is <lb/>found. When Synthetiq is run on multiple threads, ℓ min and ℓ max are synchronized across threads. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:9 <lb/></page>

        <body>4.4 Evaluating Circuits <lb/>To evaluate a circuit with respect to a specification S, we need to define an energy function <lb/>(S, ) that measures the distance between and S. <lb/>Various works have used measures inspired by fidelity to compare the matrices of quantum <lb/>operators [Chou et al. 2022; Khatri et al. 2019; Meister et al. 2023]. Such measures are typically <lb/>of the shape 4 ( , ) = 1 -|Tr( † ) | <lb/>2 <lb/>and have the important property that if and differ by a <lb/>global phase, i.e., if = i for some ∈ R, then ( , ) = 0. <lb/>Intuitively, we want to generalize ( , ) to account for partial specifications by replacing <lb/>and by • and • , respectively. Unfortunately, the resulting energy ˜ is useless if only 0s <lb/>are specified in , which is relevant, e.g., when specifying relative phase operators ( §5). In such a <lb/>case, since • = 0, the suggested energy ˜ is constant regardless of the current circuit: <lb/>˜ ( , ) = 1 -|Tr( ( • ) † ( • )) | <lb/>2 <lb/>= 1 -|Tr(0) | <lb/>2 <lb/>= 1. <lb/>To address this problem, we first rewrite ( , ) to 5 (derived in App. A.1): <lb/>( , ) = <lb/>1 <lb/>2 <lb/>-Tr( † ) <lb/>|Tr( † ) | <lb/>2 <lb/>2 <lb/>. <lb/>(6) <lb/>After this rewrite, we generalize to account for partial specifications by replacing and : <lb/>¯ (S, ) = <lb/>1 <lb/>2 <lb/>• -<lb/>Tr( ( • ) † ( • )) <lb/>|Tr(( • ) † ( • )) | <lb/>• <lb/>2 <lb/>2 <lb/>. <lb/>(7) <lb/>Here, we define 0/0 := 1 to account for the fact that Tr(( • ) † ( • )) could be zero. If S only <lb/>specifies 0s, that is • = 0, ¯ simplifies to 1 <lb/>2 <lb/>∥ • ∥ 2 <lb/>2 <lb/>, which still provides valuable information; <lb/>at the entries where is 0 (and is 1), might not be and the higher its values, the higher ¯ is. <lb/>Further, we also adapt the normalization factor of 2 in ¯ . This is crucial, as an incorrect <lb/>normalization would make the magnitude of ( , ) sensitive to the number of specified elements <lb/>|| || 2 . To this end, we note that 2 is equal to ∥1 ∥ , where 1 is the matrix of dimension 2 × 2 <lb/>with all ones, that is the boolean mask for a complete specification. Therefore, we replace the <lb/>normalization of 2 by || || . Taking the square root of all squared norms and dropping the factor <lb/>of 1 <lb/>2 for simplicity then yields: <lb/>(S, ) = <lb/>• -<lb/>Tr( ( • ) † ( • )) <lb/>|Tr(( • ) † ( • )) | <lb/>• <lb/>∥ ∥ <lb/>. <lb/>(8) <lb/>Measuring Distance Between Circuit and Specification. To speed up the search for circuits, we <lb/>always evaluate not only the current circuit against the specification S = ( , ), but also all the <lb/>circuits <lb/>that can be built from by permuting its qubits following some permutation . Note <lb/>that this is equivalent to evaluating against any permutation S = ( , ) of the specification. <lb/>Here <lb/>(resp. ) is defined as -1 <lb/>(resp. -1 <lb/>) where <lb/>is the change-of-basis matrix <lb/>from the original qubit order to their permutation. This gives finally: <lb/>(S, ) = min <lb/>∈ <lb/>(S , ), <lb/></body>

        <note place="footnote">4 For a matrix , Tr( ) is its trace and † its conjugate transpose. <lb/>5 For a matrix , ∥ ∥ = Tr( <lb/> † ) is its Frobenius norm. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:10 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>where <lb/>is the set of all permutations of {1, ..., }. This is inspired by the equality metric for <lb/>classical programs presented in [Heule et al. 2016]. There, if a program gives the correct result in <lb/>the wrong register, the penalty is much smaller than if the result is not present at all. <lb/>Efficiently Computing the Circuit Matrix. To compute , we need the matrix of the operator <lb/>implemented by . To compute it efficiently, we maintain a binary tree over the matrices of the <lb/>list of gates in . Hence, as each mutation only modifies one gate, we can update the complete <lb/>matrix in only O (log(len( ))) matrix multiplications. This comes at the cost of an extra memory <lb/>requirement, but this is not a limiting factor in practice. <lb/>Approximate Synthesis. Synthetiq can be readily adapted for approximate circuit synthesis. We <lb/>simply treat a circuit as discovered once the condition ( , ) ⩽ <lb/>√ <lb/>2 is met (see Lin. 11 in Alg. 1). <lb/>In the context of a complete specification, this corresponds exactly to the global phase invariant <lb/>distance employed in previous studies, such as Gheorghiu et al. [2022b]. <lb/>4.5 Updating the Current Circuit <lb/>As mentioned in §2, SA accepts a new circuit ′ with a certain probability depending on a tem-<lb/>perature function . Modifications leading to a better circuit ( (S, ) &lt; (S, ′ )) are therefore <lb/>always accepted, whereas modifications leading to a worse circuit are only accepted occasionally. <lb/>The temperature function ( ) governs the acceptance rate of such worse modifications: increasing <lb/>it means that worse modifications are more likely to be accepted. We define as: <lb/>( ) = (0) exp <lb/>-accept <lb/>ℓ norm <lb/>, <lb/>where accept is the total number of accepted modifications since the start of the SA run, ℓ is the <lb/>number of gates in the circuit currently under consideration, and (0) and norm are hyperparame-<lb/>ters. Intuitively, after many modifications were accepted, acceptance of a worse circuit becomes <lb/>less likely, allowing to focus on a local optimum. <lb/>4.6 Simplifying a Circuit <lb/>SA allows Synthetiq to discover many new circuits implementing the given specification. However, <lb/>in many cases, we are specifically looking for efficient circuits implementing this specification. The <lb/>circuits found by SA can often be trivially simplified, for instance by replacing two consecutive <lb/>gates that cancel out by the no-op identity gate I. We therefore developed a fast simplification pass <lb/>to remove such inefficiencies from the found circuits. We first discuss two ways of measuring the <lb/>efficiency of a circuit and then describe our simplification pass. <lb/>Cost of a Circuit. The first way of measuring efficiency is by looking at the number of gates the <lb/>circuit is made of. Typically, if each gate has a cost of execution on the quantum computer (be it in <lb/>time or loss of precision), the cost of a circuit is simply the sum of the cost of each of its gates. For <lb/>some applications (see §6.3), we assume the cost of all gates is the same and equal to 1. In contrast, <lb/>for fault-tolerant quantum computing, the T gate is much more expensive to implement than any <lb/>of the other gates in the Clifford+T gate set. To compute the cost of a circuit in this gate set, we use <lb/>the following gates costs, roughly reflecting gate complexity on hardware: <lb/>Cost(T) = Cost(T † ) = 1, Cost(CX) = 0.1 and Cost(H) = Cost(S) = Cost(S † ) = 0.01. (9) <lb/>In all gate sets, the identity gate has cost 0, as it does not apply any operation to the qubits. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:11 <lb/></page>

        <body>Algorithm 2 Simplification applied as post-processing. denotes the i-th gate in , [ , ] is the <lb/>subset of consisting of its i-th to k-th gates, and ↔ is after swapping the i-th and k-th gates. <lb/>1: function Simplify( : Circuit, G: Gate set) <lb/>2: <lb/>, ← 0, 0 <lb/>3: <lb/>while &lt; len( ) do <lb/>4: <lb/>for = 1, 2, . . . , 12 do <lb/>5: <lb/>if [ , + ] = ⟦ ⟧ with ∈ G and Cost( [ , + ] ) &gt; Cost( ) then <lb/>6: <lb/>[ , + ] ← [ , , ..., ] <lb/>7: <lb/>← -1 <lb/>8: <lb/>if <lb/>and +1 commute and +1 ≺ <lb/>then <lb/>9: <lb/>← ↔ +1 <lb/>10: <lb/>← -2 <lb/>11: <lb/>← + 1 <lb/>12: <lb/>← reverse( ) <lb/>13: <lb/>while &lt; len( ) do <lb/>14: <lb/>if <lb/>and +1 commute then <lb/>15: <lb/>diff = Depth( ↔ -1 ) -Depth( ) <lb/>16: <lb/>if diff &lt; 0 or ( diff = 0 and +1 ≺ ) then <lb/>17: <lb/>← ↔ +1 <lb/>18: <lb/>← -2 <lb/>19: <lb/>← + 1 <lb/>20: <lb/>return reverse( ) <lb/>Depth of a Circuit. The second way of defining a circuit cost takes parallelism in its execution <lb/>into account. If a circuit applies one gate on its first qubit and another on its second qubit, those <lb/>two gates can often be executed at the same time. Therefore, the cost of the execution is only the <lb/>cost of one gate, and not the sum of the two. The depth of a circuit reflects this cost. It is the length <lb/>on the execution of the circuit, assuming all operations that can be are parallelized 6 . Further, in <lb/>cases where some gates take much longer to execute than others, we may use as cost for the circuit <lb/>its depth when only considering those expensive gates. This is typically the case for the Clifford+T <lb/>gate set, where we measure T-depth. <lb/>Optimizing Found Circuits. We show our simplification pass in Alg. 2. It consists of two main <lb/>parts. The first aims at minimizing the gate cost of the circuit (Lin. 3-11). More specifically, it <lb/>replaces sequences of gates in the circuit with gates from G that have the same semantics if this <lb/>gate has a lower cost than the complete sequence (Lin. 4-7). Note that we only consider sequences <lb/>of up to 12 gates since higher values did not result in more efficient circuits. The second part aims <lb/>at minimizing the depth of the circuit (Lin. 13-19). Here, it swaps gates that commute 7 if doing so <lb/>would reduce the depth of the circuit. Finally, to create more opportunities for both optimizations, <lb/>Alg. 2 also swaps any gates that commute, in both parts (Lin. 8-10 and Lin. 17). To ensure we don&apos;t <lb/>endlessly swap gates back and forth, we only do so according to a custom total order on gates ≺. <lb/>We give more details about this order in App. A.2. <lb/>A Custom Pass. We note that this simplification pass is specifically tuned to our SA algorithm. It <lb/>is both fast and focused on simple optimizations that are easily missed by SA and can be applied for <lb/>any finite gate set. Further, we found in practice that for a given circuit, optimizing for gate count <lb/>and depth were not at odds. We therefore always optimize for both. This simplification pass is an <lb/>essential part of the algorithm and is not meant to be used as a standalone procedure. Indeed, when <lb/>applied to circuits found by other synthesis tools, it most often does not find any simplifications. <lb/></body>

        <note place="footnote">6 This can be computed in time linear in the number of gates in the circuit. <lb/>7 That is applying one then the other has the same effect on qubits as doing the opposite. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:12 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>Table 1. Translating common tasks to incomplete specifications. <lb/>Task <lb/>Full Isometry Element-wise <lb/>State Preparation <lb/>Relative Phase Operators <lb/>Ancillae <lb/>Oracles <lb/>Dirty Qubits <lb/>Isometry + Ancilla <lb/>5 LEVERAGING PARTIAL SPECIFICATIONS <lb/>We now show how to leverage our partial specification framework to express common tasks when <lb/>implementing quantum algorithms. <lb/>Classification. Recall that in a partial specification S = ( , ), the boolean matrix specifies <lb/>which elements of matrix should be matched. When each column of is either all ones or <lb/>all zeros (i.e., each column is fully specified or not at all), the partial specification is an isometry. <lb/>Otherwise, we refer to the specification as element-wise. <lb/>Tasks. Tab. 1 summarizes the tasks discussed in §5.1- §5.5, and whether they can be expressed as <lb/>a full specification, an isometry, or require element-wise specification in the general case. We note <lb/>that multiple tasks can be combined. For instance, allowing an isometry to use an ancilla yields a <lb/>new, element-wise specification. <lb/>5.1 State Preparation <lb/>The task of state preparation asks to implement an operator that brings qubits from some initial <lb/>state (typically |0...0⟩) to some target state . This operator is only specified for the input |0...0⟩ <lb/>and can be written as = <lb/>? , where denotes the vector representation of the target state. <lb/>State preparation applications include quantum chemistry ([Cao et al. 2019]), quantum machine <lb/>learning ([Araujo et al. 2021]), and solving systems of linear equations ([Harrow et al. 2009]). For <lb/>example, the specification to prepare the GHZ state for two qubits |GHZ⟩ = 1 <lb/>√ <lb/>2 <lb/>(|00⟩ + |11⟩) is <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>1 <lb/>√ <lb/>2 <lb/>? ? ? <lb/>0 ? ? ? <lb/>0 ? ? ? <lb/>1 <lb/>√ <lb/>2 <lb/>? ? ? <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>. <lb/>5.2 Relative Phase Operators <lb/>We say an operator ′ is a relative phase operator for operator if for any input state in the <lb/>computational basis | ⟩ there exists some phase such that ′ | ⟩ = i <lb/>| ⟩. Such relative phase <lb/>operators often have a shorter circuit implementation than their non-relative original. Therefore, it <lb/>can be interesting to replace with its relative counterpart when it is used in a bigger computation, <lb/>if this replacement does not change the overall computation. Common use cases for relative phase <lb/>operators include their use in more efficient implementations of their non-relative counterpart <lb/>[Maslov 2016], replacing the CCX gate by a relative RCCX gate when it is later uncomputed [Paradis <lb/>et al. 2021], or when the non-relative counterpart is used in a circuit that is measured directly after <lb/>the application of the operator. <lb/>When can be described classically, i.e., when it maps all computational basis states to another <lb/>basis state, we know that its matrix representation consists of 0s and 1s. In this case, we can simply <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:13 <lb/></page>

        <body>replace each &quot;1&quot; with a question mark. As any operator built by Synthetiq is unitary, any circuit it <lb/>produces matching the specification will have values of norm 1 in place of the question marks. <lb/>For example, the partial specification for a relative phase operator of CCX transforms: <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>1 0 0 0 0 0 0 0 <lb/>0 1 0 0 0 0 0 0 <lb/>0 0 1 0 0 0 0 0 <lb/>0 0 0 1 0 0 0 0 <lb/>0 0 0 0 1 0 0 0 <lb/>0 0 0 0 0 1 0 0 <lb/>0 0 0 0 0 0 0 1 <lb/>0 0 0 0 0 0 1 0 <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>to <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>? 0 0 0 0 0 0 0 <lb/>0 ? 0 0 0 0 0 0 <lb/>0 0 ? 0 0 0 0 0 <lb/>0 0 0 ? 0 0 0 0 <lb/>0 0 0 0 ? 0 0 0 <lb/>0 0 0 0 0 ? 0 0 <lb/>0 0 0 0 0 0 0 ? <lb/>0 0 0 0 0 0 ? 0 <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>. <lb/>5.3 Operators with Ancillae <lb/>As discussed in §3, an ancilla is an extra qubit used to help implementing an operator on the other <lb/>qubits. We assume the ancilla is initially in state |0⟩ and must be returned to the same state. In <lb/>some cases, such an ancilla is necessary to implement the given operator using the chosen gate <lb/>set [Giles and Selinger 2013]. In other cases, ancillae are not necessary but may allow for a shorter <lb/>circuit implementation, e.g., CCX has lower T-depth when implemented with one ancilla [Amy <lb/>et al. 2013]. To represent an operator with ancillae , we observe that any state ⊗ |0⟩ maps to <lb/>( ) ⊗ |0⟩ , while the result on any state ⊗ |1⟩ is unspecified. The resulting specification is <lb/>thus: <lb/>? <lb/>0 ? , where 0 is the null matrix. <lb/>More generally, for an already partial specification S = ( , ), adding an ancilla changes the <lb/>specification to S ′ = <lb/>? <lb/>0 ? , <lb/>0 <lb/>1 0 <lb/>, where 1 is the all ones matrix of appropriate size. For example, <lb/>adding an ancilla to an isometry gives an element-wise underspecification. An example of ancilla <lb/>underspecification for the CT operator can be found in §3. <lb/>5.4 Oracles <lb/>Quantum algorithms often require computing a classical boolean function . For instance, in <lb/>Grover&apos;s algorithm [Grover 1996] decides if a candidate value is a solution to a given task. The <lb/>quantum circuit implementation of is called an oracle. Typically, this oracle O is assumed to be <lb/>such that for any computational basis state | ⟩, we have O | ⟩ |-⟩ = (-1) ( ) | ⟩ |-⟩ where |-⟩ is <lb/>the shorthand notation for the state 1 <lb/>√ <lb/>2 <lb/>(|0⟩ -|1⟩). Using that ( ⊗ ) | ⟩ |-⟩ = | ⟩ |1⟩, we can build <lb/>this oracle as O = O ′ • ( ⊗ ), where O ′ is such that O ′ | ⟩ |1⟩ = (-1) ( ) | ⟩ |-⟩. Such an O ′ can <lb/>easily be specified in our framework. <lb/>Take for instance the classical identity function : ↦ → , where the corresponding O ′ is <lb/>undefined on inputs | ⟩ |0⟩ for ∈ {0, 1}. For the other computational basis states, we have that <lb/>O ′ |0⟩ |1⟩ = (-1) 0 |0⟩ |-⟩ = 1 <lb/>√ <lb/>2 <lb/>|0⟩ (|0⟩ -|1⟩), and O ′ |1⟩ |1⟩ = (-1) 1 |1⟩ |-⟩ = 1 <lb/>√ <lb/>2 <lb/>|1⟩ (-|0⟩ + |1⟩). <lb/>This corresponds to the following incomplete specification: <lb/>1 <lb/>√ <lb/>2 <lb/>? ? 1 0 <lb/>? ? 0 -1 <lb/>? ? -1 0 <lb/>? ? 0 1 <lb/>. <lb/>5.5 Dirty <lb/>bits <lb/>Dirty qubits are similar to ancillae, with the difference that they can initially be in any state and must <lb/>return to that same state after the computation. Therefore, they allow for less underspecification, <lb/>but have the advantage of not requiring any preparation for the extra qubit. Dirty qubits are for <lb/>example used in Low et al. [2018] to do state preparation, allowing them to achieve significantly <lb/>shorter circuits. <lb/>Given a specification S = ( , ), we can allow for an extra dirty qubit by using the specification <lb/>S ′ = <lb/>0 <lb/>0 <lb/>, <lb/>1 <lb/>1 <lb/>, where 1 is the all-ones matrix of appropriate size. The null matrices 0 in S <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:14 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>ensure that the dirty qubits remain in the same state before and after the computation, since a state <lb/>flip of the dirty qubits would require a non-zero element at any of the positions of the null matrices. <lb/>Note that dirty qubits only lead to underspecification if S is already underspecified, and are <lb/>therefore especially useful in this case. When we allow the use of a dirty qubit in the implementation <lb/>of the example in §5.4, we get the specification: <lb/>1 <lb/>√ <lb/>2 <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>? ? 1 0 0 0 0 0 <lb/>? ? 0 -1 0 0 0 0 <lb/>? ? -1 0 0 0 0 0 <lb/>? ? 0 1 0 0 0 0 <lb/>0 0 0 0 ? ? 1 0 <lb/>0 0 0 0 ? ? 0 -1 <lb/>0 0 0 0 ? ? -1 0 <lb/>0 0 0 0 ? ? 0 1 <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>. <lb/>6 EXPERIMENTAL EVALUATION <lb/>We now experimentally evaluate Synthetiq. We first explain our process for optimizing the hyper-<lb/>parameters occurring in the SA algorithm ( §6.1). We then demonstrate that due to its versatility <lb/>and speed, Synthetiq can push the limits of circuit synthesis, synthesizing previously unknown <lb/>decompositions of relevant quantum operators ( §6.2). We finally evaluate the versatility of Synthetiq <lb/>by running it in different modes ( §6.3- §6.6) and comparing the results to synthesis tools specialized <lb/>for each of these modes. Overall, our main findings are: <lb/> §6.2 Better operator decompositions. We show that Synthetiq finds better implementations than <lb/>the currently best known ones for RCCCX, CCT, CCiSWAP, C <lb/>√ <lb/>SWAP, and C <lb/>√ <lb/>iSWAP. <lb/> §6.3 Custom gates. We show that Synthetiq can efficiently synthesize circuits with user-supplied <lb/>custom gate sets, and outperforms the state-of-the-art [Kang and Oh 2023] in 50% of the cases <lb/>(including 27% of cases where Kang and Oh [2023] fails to return any decomposition) while being <lb/>equally optimal in all other cases. <lb/> §6.4 Clifford+T gate set. We show that when synthesizing completely specified operators over <lb/>the Clifford+T gate set, Synthetiq outperforms the specialized state-of-the-art [Gheorghiu et al. <lb/>2022a; Mosca and Mukhopadhyay 2021]. Synthetiq is able to find circuits for more operators and <lb/>those circuits are often more efficient and typically found one to two orders of magnitude faster. <lb/> §6.5 Approximate synthesis for the Clifford+T gate set. We show that for approximate synthesis <lb/>on the Clifford+T gate set, Synthetiq is 6 times faster than the state-of-the-art approach specialized <lb/>to this task [Gheorghiu et al. 2022b] for complex multi-qubit operators and, while slower, can find <lb/>circuits that are on par with Gheorghiu et al. [2022b] for simpler single qubit operators. <lb/> §6.6 Relative phase gates. Finally, we show how using Synthetiq to synthesize small components <lb/>of a bigger circuit allows for more efficient implementations. Specifically, by synthesizing a relative <lb/>phase carry operator, we can reduce the T-count of the Cirq Adder [Cirq 2023] by more than 3x. <lb/>Implementation. We implemented Synthetiq using C++17 with the Eigen matrix library [Guen-<lb/>nebaud et al. 2010] and openMP [OpenMP Architecture Review Board 2021] for parallelization. <lb/>All experiments are conducted on a Linux machine with 500 GB RAM and two AMD EPYC 7601 <lb/>2200MHz processors, with a total of 64 cores. In the practical implementation of Synthetiq, we <lb/>do not specify iter (see Alg. 1). Instead, we report the average runtime averaged over 100 runs, <lb/>where each run finishes as soon as a circuit with the desired property (e.g., T-count optimal) is <lb/>found. For particularly time-consuming tasks, we instead average on as many runs as fit within <lb/>a set time-limit (12 hours per task). Unless specified otherwise, we run Synthetiq on all 64 cores. <lb/>Finally, for Tab. 4, we do not average over multiple runs and instead mention the total timeout <lb/>instead, as well as the best circuit found within this time-out. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:15 <lb/></page>

        <body>Table 2. Ablation study of Synthetiq. We report the average speedup of Synthetiq compared to Synthetiq <lb/>with a specific component removed. <lb/>Full Specification Isometry Element-Wise Averaged <lb/>Circuit Cost Rewrite <lb/>0.94 <lb/>1.30 <lb/>47.01 <lb/>16.42 <lb/>Permutation of Qubits in Cost <lb/>1.12 <lb/>1.25 <lb/>1.41 <lb/>1.26 <lb/>Simplification Pass <lb/>3642.10 <lb/>2056.13 <lb/>2387.31 <lb/>2695.18 <lb/>Results Format and Correctness. The energy function of Synthetiq naturally checks correctness <lb/>of the synthesized circuits, as we only consider a circuit to be found if its distance to the specifi-<lb/>cation is 0. Further, Synthetiq explicitly produces the found circuit in the standard OpenQASM <lb/>2.0 language [Cross et al. 2017] and can therefore easily be imported to other frameworks such as <lb/>Qiskit [Abraham et al. 2019]. Note that this is in contrast to other tools which often only output a <lb/>resource count [Gheorghiu et al. 2022a,b; Mosca and Mukhopadhyay 2021]. Finally, all synthesized <lb/>implementations from this section are made available with our implementation. <lb/>6.1 Hyperparameter Optimization <lb/>We describe how we validated Synthetiq&apos;s design choices and fine-tuned its hyperparameters, using <lb/>a randomly generated benchmark of operators. <lb/>Generating Random Operators. To optimize Synthetiq&apos;s hyperparameters without overfitting to <lb/>a specific domain, we built a set of random operators covering the many use cases of Synthetiq. <lb/>The benchmark consists of 90 operators acting on 2, 3, or 4 qubits, whose shortest decomposition <lb/>contains 10 gates in the Clifford+T gate set 8 . A third of these operators have full specifications, <lb/>another third are isometries, and the last third have element-wise specifications. The performance <lb/>metric for circuits is T-count for the remainder of this section. <lb/>Ablation Study. To evaluate our design choices, we ran Synthetiq on the benchmark described <lb/>above (i) without rewriting the energy function (instead using Eq. (6)), (ii) without using qubit <lb/>permutations to speed up the search (outlined in §4.4) and (iii) without the simplification pass <lb/>(outlined in §4.6). The results, shown in Tab. 2, demonstrate the significant impact on runtime <lb/>of each of these choices. In particular, the simplification pass is essential, increasing Synthetiq <lb/>speed by orders of magnitude. Note that the speedup is less than one in only one case, namely <lb/>not applying cost rewriting for full specification. As the two energy functions (Eq. (6) and Eq. (8)) <lb/>are equivalent for fully specified operators, the slowdown is solely due to the slightly higher <lb/>computational complexity of the rewritten energy function. <lb/>Optimizing Hyperparameters. We optimize the hyperparameters for Synthetiq, recalled in Tab. 3. <lb/>We first optimize the optimal number of starting gates ℓ on our random benchmark where all <lb/>operators have shortest decomposition length 10. ℓ = 30 was the optimal value. Optimizing ℓ on a <lb/>few other random operators of different lengths, we confirmed that the optimal ℓ was consistently <lb/>around three times the decomposition length size. As we aim to synthesize decompositions of 10 to <lb/>40 gates, we use this factor 3 and set ℓ min,init to 30 and ℓ max,init to 120. <lb/>Since min and max only start playing a large role for bigger operators, we could not optimize <lb/>them efficiently on our benchmark. We chose to set min to 2.5 and max to 3.5, to achieve a higher <lb/>variety of initial number of starting gates and while staying close to the optimal value 3. <lb/>Subsequently, we conduct a grid search for every parameter but , scanning over a range of <lb/>plausible values for each parameter and optimizing the average time taken to solve the random <lb/>operators introduced above. <lb/></body>

        <note place="footnote">8 More precisely, we ran Synthetiq for 10 minutes for each of those operators, and made sure that no decomposition shorter <lb/>than 10 gates was found. It is hence likely that no shorter one exists. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:16 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>Table 3. Hyperparameter values used in Synthetiq. is the number of qubits (fixed by the operator specifica-<lb/>tion) and ℓ the number of starting gates in a run (randomly sampled in [ℓ min , ℓ max ] for each run). <lb/>Parameter name Parameter value Description <lb/>steps <lb/>40 ℓ <lb/>number of SA steps <lb/>Id <lb/>0.3 <lb/>probability of replacing a gate by the identity gate <lb/>(0) <lb/>0.1 <lb/>2 <lb/>initial temperature in SA <lb/>norm <lb/>80.0 <lb/>normalization constant in the temperature function <lb/>[ℓ min,init , ℓ max,init ] <lb/>[30, 120] <lb/>initial circuit size bounds <lb/>[ min , max ] <lb/>[2.5, 3.5] <lb/>factors in the update of the circuit size bounds <lb/>0.05 <lb/>moving average factor in the update of the circuit size bounds <lb/>comp <lb/>0.2 <lb/>factor for reduced mutation selection of composite gates <lb/>For the hyperparameters Id and comp we follow a slightly adjusted grid search procedure to <lb/>ensure the found values perform well for larger operators too. First, as small operators do not <lb/>require composite gates, optimizing comp directly is impossible. Instead, we add the RCCX gate as <lb/>a composite gate and set comp to the highest value that does not slow down the synthesis speed by <lb/>more than a factor of 2. This ensures that the inclusion of a unneeded composite gate does not slow <lb/>down the synthesis process too much, while ensuring composite gates are still likely to be used for <lb/>operators that do require this additional gate. In the case of Id , we observe that its optimal value is <lb/>heavily influenced by the ratio of the optimal circuit size to the number of initial gates, ℓ. Indeed, <lb/>as ℓ increases, the proportion of identity gates in the optimal circuit also increases, which in turn <lb/>raises the optimal value of Id . Therefore, when optimizing Id , we set ℓ to 30 for all operators, <lb/>which is the optimal value of ℓ for operators with 10 gates. <lb/>Lastly, we optimize , the moving average factor used in updating circuit size bounds. As <lb/>is largely dependent on the size of the found circuits and is not significantly influenced by the <lb/>specifications, we use one larger operator -the 4-qubit adder operator -to optimize this parameter. <lb/>6.2 Be er Operator Decompositions <lb/>Using Synthetiq, we were able to provide new and more efficient decompositions of multiple <lb/>relevant operators, shown in Tab. 4. <lb/>Operators. We briefly describe each of the operators in Tab. 4. The first is RCCCX, that is a relative <lb/>controlled X with three controls. For any , , , in {0, 1}, it maps | ⟩ | ⟩ to | ⟩ i <lb/>X | ⟩, <lb/>flipping the last qubit with unspecified phase <lb/>∈ R if and only if all three controls are 1. <lb/>This gate is extremely useful to decompose controlled X operators with more than three controls, <lb/>as described in Maslov [2016]. Hence, finding a better implementation of RCCCX directly gives a <lb/>better implementation of the controlled X with four controls, when using only Clifford+T gates. <lb/>The next operator is CCT, that is the T gate with two controls, mapping | ⟩ | ⟩ to | ⟩ T | ⟩. <lb/>CCiSWAP maps | ⟩ | ⟩ to i | ⟩ | ⟩ if both and are 1, and to | ⟩ | ⟩ otherwise. C <lb/>√ <lb/>SWAP is <lb/>√ <lb/>SWAP controlled by one qubit and C <lb/>√ <lb/>iSWAP is <lb/>√ <lb/>iSWAP controlled by one qubit where we used: <lb/>√ <lb/>SWAP = <lb/>1 <lb/>0 <lb/>0 <lb/>0 <lb/>0 1 <lb/>2 (1+ ) 1 <lb/>2 (1-) 0 <lb/>0 1 <lb/>2 (1-) 1 <lb/>2 (1+ ) 0 <lb/>0 <lb/>0 <lb/>0 <lb/>1 <lb/>and <lb/>√ <lb/>iSWAP = <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>1 0 <lb/>0 0 <lb/>0 <lb/>1 <lb/>√ <lb/>2 <lb/>i <lb/>1 <lb/>√ <lb/>2 <lb/>0 <lb/>0 i <lb/>1 <lb/>√ <lb/>2 <lb/>1 <lb/>√ <lb/>2 <lb/>0 <lb/>0 0 <lb/>0 1 <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/> <lb/>. <lb/>Baselines. No existing circuit synthesis tool could synthesize the operators in Tab. 4. First, Kang <lb/>and Oh [2023] is the only tool that can express the partially specified synthesis problems of RCCCX, <lb/>CCT, and C <lb/>√ <lb/>SWAP. It is however too slow to obtain results within any reasonable timeframe, as it <lb/>times out for the much simpler circuit CCX after 1 day. The remaining operators (CCiSWAP and <lb/>C <lb/>√ <lb/>iSWAP) are beyond the capabilities of all existing tools due to their size: the fastest synthesis <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:17 <lb/></page>

        <body>Table 4. New operator decompositions found with Synthetiq, using 64 cores. For each operator we gave <lb/>Synthetiq the composite gate RCCX, except for CCiSWAP where we used CCX. Previous Best is the result of <lb/>a best-effort search either found in previous work or using a standard decomposition as discussed in §6.2. <lb/>Operator <lb/>Synthetiq <lb/>Previous Best <lb/>Ancillae T-depth Time Ancillae T-depth <lb/>RCCCX <lb/>0 <lb/>5 <lb/>8h <lb/>0 <lb/>8 <lb/>CCT <lb/>1 <lb/>9 <lb/>2h <lb/>2 <lb/>9 <lb/>CCiSWAP <lb/>0 <lb/>9 <lb/>4h <lb/>1 <lb/>6 <lb/>C <lb/>√ <lb/>SWAP <lb/>1 <lb/>6 <lb/>4h <lb/>1 <lb/>29 <lb/>C <lb/>√ <lb/>iSWAP <lb/>0 <lb/>6 <lb/>4h <lb/>1 <lb/>27 <lb/>tool for T-depth, Gheorghiu et al. [2022a] again fails to find any result in 2 days for CCiSWAP, <lb/>and yields incorrect results for C <lb/>√ <lb/>iSWAP 9 . We hence had to manually combine existing operator <lb/>decompositions and generic decomposition techniques for each of the operators in Tab. 4. We <lb/>describe this manual effort in App. A.3. <lb/>Results. Qubits are often the scarcest resource in quantum computers. Reducing the number of <lb/>ancillae, and hence qubits used by a quantum operator is crucial. For three of the operators shown <lb/>in Tab. 4, Synthetiq was able to find a decomposition using fewer ancillae than previous state of <lb/>the art 10 . Only for the CCiSWAP operator does this come at the cost of a slightly higher T-depth. <lb/>For the two operators where state of the art decompositions already used the minimum amount <lb/>of ancillae, Synthetiq was able to significantly reduce the T-depth of the operators: from 8 to 5 <lb/>for RCCX, and 29 to 8 for C <lb/>√ <lb/>SWAP. Further, note that all those results were obtained in only a <lb/>few hours. Finally, now that those decompositions are known, they can easily be reused by any <lb/>quantum compiler. <lb/>Exploiting Versatility. To generate the decompositions in Tab. 4, we heavily relied on the versatility <lb/>of Synthetiq. First, incomplete specification was necessary for all operators requiring an ancilla and <lb/>for RCCCX. Further, we used composite gates to speed up synthesis and hence boost the chances <lb/>of success. More precisely, we added to the Clifford+T gate set the RCCX gate for all operators <lb/>but CCiSWAP, where we instead added CCX. This allows the synthesis to directly leverage those <lb/>complex gates, and hence speeds up the search. To pick which composite gate to add to the gate <lb/>set, we consistently used the following procedure. If after running for one minute Synthetiq could <lb/>not find any circuit satisfying the specification, we added RCCX to the gate set. If no circuit was <lb/>found after running one more minute with RCCX, we replaced RCCX with CCX in the gate set. <lb/>Note that these intermediate runs take at most 2 minutes, which is negligible compared to the total <lb/>runtime for each operator. <lb/>6.3 Mode: Custom Gates <lb/>As mentioned above, Synthetiq can synthesize circuits using any finite custom gates set. The most <lb/>recent work on quantum circuit synthesis also allowing for custom finite gate sets is Kang and Oh <lb/>[2023]. We evaluate the applicability of both tools on the benchmark described below. <lb/></body>

        <note place="footnote">9 More precisely, the implementation requires a circuit of the given operator, but different circuits all representing C <lb/>√ <lb/>iSWAP <lb/>are encoded differently. This indicates something in the encoding phase of the implementation is wrong. <lb/>10 We used the characterization from Giles and Selinger [2013] (mentioned in §2) to find out which operators can be <lb/>implemented on Clifford+T with 0 (resp. one) ancilla. We then ran Synthetiq with the corresponding complete (resp. partial) <lb/>specification. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:18 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>t h r e e _ s u p e r p o s e <lb/>i n d e x e d _ b e l l <lb/>t e l e p o r t a t i o n <lb/>d r a p e r <lb/>t o f f o l i _ b y _ s q r t _ X <lb/>G <lb/>H <lb/>Z _ f r o m <lb/>_ 1 0 0 <lb/>f l i p <lb/>G <lb/>H <lb/>Z _ b y _ Q <lb/>F T <lb/>M <lb/>_ v a l u e d <lb/>W <lb/>_ f o u r <lb/>Q <lb/>F T <lb/>W <lb/>_ p h a s e d <lb/>W <lb/>_ o r t h o g <lb/>G <lb/>H <lb/>Z _ G <lb/>a m <lb/>e <lb/>G <lb/>H <lb/>Z _ b y _ i S W <lb/>A P c l u s t e r 1 <lb/>b i t _ m <lb/>e a s u r e <lb/>2 <lb/>5 <lb/>4 <lb/>3 <lb/>0 <lb/>5 <lb/>10 <lb/>15 <lb/>T/O <lb/>N/A <lb/>N/A <lb/>T/O <lb/>N/A <lb/>T/O <lb/>Gate Count <lb/>Synthetiq <lb/>Kang et al. <lb/>10 0 <lb/>10 2 <lb/>10 4 <lb/>Speedup <lb/>Fig. 3. Comparison between Synthetiq and [Kang and Oh 2023] on the benchmark used by [Kang and Oh <lb/>2023]. A time-out of 1 day was set for both tools, but Synthetiq always reached a solution within 1 hour. N/A <lb/>means that the tool returned an empty solution set. <lb/>Table 5. Operators synthesis for several questions on StackExchange. Expensive gate count is the count of <lb/>the most expensive gate (highlighted in bold). Time for Synthetiq is on 64 cores. [Kang and Oh 2023] was le <lb/>out as it timed out (1 day) or returned an empty solution set for every problem. <lb/>Source <lb/>Operator <lb/>Qubits Gate Set <lb/>Expensive Gate Count Time Ours (s) <lb/>Ours StackExchange <lb/>[StackExchange 2018] <lb/>√ <lb/>SWAP <lb/>2 <lb/>H, S, S -1 , CX, T, T -1 <lb/>3 <lb/>3 <lb/>0.04 <lb/>[StackExchange 2021] CX <lb/>2 <lb/>H, S, S -1 , T, T -1 , U <lb/>1 <lb/>1 <lb/>0.02 <lb/>[StackExchange 2022] Oracle <lb/>4 <lb/>H, S, S -1 , CX, T, T -1 <lb/>4 <lb/>8 <lb/>3.08 <lb/>[StackExchange 2023] <lb/>√ <lb/>iSWAP <lb/>2 <lb/>H, S, S -1 , T, T -1 , <lb/>√ <lb/>CZ <lb/>2 <lb/>4 <lb/>0.09 <lb/>[StackExchange 2020] Permutation <lb/>3 <lb/>H, S, S -1 , CX, T, T -1 <lb/>7 <lb/>7 <lb/>0.32 <lb/>Benchmark. Each element in the benchmark consists of a circuit specification and a custom gate <lb/>set. The first part of the benchmark (three _ superpose to bit _ measure in Fig. 3) is the evaluation <lb/>benchmark from Kang and Oh [2023]. However, these synthesis problems are not entirely realistic. <lb/>They assume the gates required to build a circuit for the specification are known ahead of time, and <lb/>supply exactly those gates in the gate set. This results in small gate sets (three or less gates for 11 of <lb/>the 17 problems), and hence easier synthesis. We therefore complete the benchmark with real-world <lb/>problems taken directly from Quantum Computing Stack Exchange. Gate sets and specifications <lb/>are taken directly from the questions, resulting in bigger gate sets, where some gates are not used <lb/>in the optimal decomposition. <lb/>Results. We show the results in Fig. 3 and Tab. 5. Fig. 3 shows the results when optimizing for <lb/>gate count. We see that Synthetiq outperforms Kang and Oh [2023] in 50% of cases, and matches <lb/>it on the rest. Further, Kang and Oh [2023] is not able to find any decomposition for one of their <lb/>problems as well as the more complex problems we added to the benchmark, even with a one day <lb/>time out. This shows that Kang and Oh [2023] is not scalable to those new complex problems, <lb/>whereas Synthetiq still easily handles those in less than 4 seconds. <lb/>In Tab. 5, we focus on the questions taken from StackOverflow, for the more realistic objective of <lb/>minimizing the use of the most expensive gate in the gate set. We compare Synthetiq results to the <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:19 <lb/></page>

        <body>Table 6. Synthesis of common fully specified operators using Clifford+T. We denote Mosca and Mukhopad-<lb/>hyay [2021] as Mosca and Gheorghiu et al. [2022a] as Gheorghiu. Speedup is the ratio of the time taken by <lb/>the other tool to the time taken by Synthetiq. Times were measured on 64 cores for Synthetiq and Gheorghiu, <lb/>and on a single core for Mosca. <lb/>T-count <lb/>Time <lb/>T-depth <lb/>Time <lb/>Operator Synthetiq Mosca Synthetiq (s) Speedup Synthetiq Gheorghiu Synthetiq (s) Speedup <lb/>CCX <lb/>7 <lb/>7 <lb/>0.1 <lb/>107.5 <lb/>3 <lb/>3 <lb/>0.3 <lb/>449.1 <lb/>CCH <lb/>9 <lb/>-<lb/>6.4 <lb/>-<lb/>4 <lb/>4 <lb/>55.9 <lb/>0.5 <lb/>Adder <lb/>7 <lb/>7 <lb/>11.0 <lb/>78.9 <lb/>2 <lb/>-<lb/>43 200.0 <lb/>-<lb/>U 1 <lb/>11 <lb/>11 <lb/>2273.7 <lb/>6.2 <lb/>5 <lb/>6 <lb/>6171.4 <lb/>6.5 <lb/>U 1 var. <lb/>11 <lb/>14 <lb/>2700.0 <lb/>6.0 <lb/>5 <lb/>-<lb/>6171.4 <lb/>-<lb/>U 2 <lb/>7 <lb/>7 <lb/>12.9 <lb/>62.3 <lb/>3 <lb/>-<lb/>111.0 <lb/>-<lb/>expert accepted answer on StackExchange. Note that we do not show results from Kang and Oh <lb/>[2023] as they could not find any of the circuits within a day. We find that Synthetiq outperforms <lb/>the expert answer in two out of five cases, and matches it in the remaining three cases. Further, <lb/>all results were found within a few seconds, confirming the usefulness of Synthetiq for quantum <lb/>programmers. <lb/>6.4 Mode: Clifford+T Gate Set <lb/>We now compare Synthetiq to the state of the art for the well-studied problem of synthesizing fully <lb/>specified quantum operators over the Clifford+T gate set. When optimizing T-count, the current <lb/>state of the art is Mosca and Mukhopadhyay [2021], while for T-depth it is Gheorghiu et al. [2022a]; <lb/>we provide a broader overview of existing tools in §7. <lb/>Overall, we find that Synthetiq is generally faster than both tools, and finds strictly better or <lb/>equally good implementations compared to either of them. <lb/>Benchmarks. Tab. 6 shows the comparison of Synthetiq to both works on a benchmark of common <lb/>quantum operators, which is based on the original benchmark of Mosca and Mukhopadhyay <lb/>[2021]. CCX, Adder, U 1 , and U 2 are taken directly from their benchmark, where U 1 is defined as <lb/>CCX( , , ); CCX( , , ) and U 2 as CCX( , , ); CCX( , , ); CCX( , , ). We exclude the other <lb/>3-qubit operators from the original benchmark as they are affine equivalents of CCX and add the <lb/>CCH operator to the benchmark instead. Based on U 1 , we additionally introduce U 1 var. which <lb/>we define as CCX( , , ); CCX( , , ), allowing us to evaluate the sensitivity of all tools to simple <lb/>changes of specifications. <lb/>We additionally show in Fig. 4 the comparison of Synthetiq with both tools on a benchmark of <lb/>3-qubits permutations, following Gheorghiu et al. [2022a] 11 . We built this benchmark by clustering <lb/>all 40320 permutations on 3 qubits by Clifford equivalence 12 , and picking one representative for <lb/>each of the resulting 30 equivalence classes. <lb/>Results for Common Operators. We find that Synthetiq consistently finds the best implementation <lb/>for each operator in the benchmark, outperforming Mosca and Mukhopadhyay [2021] in 33% of the <lb/>cases and Gheorghiu et al. [2022a] in 66% of the cases. Further, Synthetiq finds these implementations <lb/>faster than both tools in every example but one (CCH for T-depth). <lb/></body>

        <note place="footnote">11 Gheorghiu et al. [2022a] only evaluated their tool on a few randomly generated permutations. We here systematize this <lb/>benchmark. <lb/>12 We say two permutations 1 and 2 are Clifford equivalent iff there exists some circuit made of the Clifford gates H, S, <lb/>CX and S † such that 1 = ⟦ ⟧ 2 . <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:20 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>0 <lb/>5 <lb/>10 <lb/>15 <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>0 <lb/>T-Count <lb/>Synthetiq <lb/>Mosca et al. <lb/>10 0 <lb/>10 2 <lb/>10 4 <lb/>Speedup <lb/>(a) Comparison with Mosca and Mukhopadhyay [2021] for the T-count of permutations. <lb/>0 <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>T/O <lb/>0 <lb/>T-Depth <lb/>Synthetiq <lb/>10 0 <lb/>10 2 <lb/>10 4 <lb/>Speedup <lb/>Gheorghiu et al. <lb/>(b) Comparison with Gheorghiu et al. [2022a] for the T-depth of permutations. <lb/>Fig. 4. Comparison between Synthetiq and previous works on 3-qubit permutation synthesis. Each bar <lb/>represents one of the 30 evaluated permutations. Speedups are only included for cases where both tools <lb/>return a result. Time-out set at 1h per example for all tools. <lb/>More importantly, Synthetiq does not time out (&gt; 2 days compute) on any of the examples <lb/>whereas Mosca and Mukhopadhyay [2021] and Gheorghiu et al. [2022a] do, showing that Synthetiq <lb/>can handle more difficult problems than what could previously be done. We also note that Synthetiq <lb/>is the first to automatically synthesize a T-depth 2 circuit for the Adder operator. <lb/>Results for Permutations. The results are shown in Fig. 4. For the largest eight operators. We added <lb/>RCCX to the gate set for Synthetiq, following the procedure described in §6.2. Note that neither <lb/>Mosca and Mukhopadhyay [2021] nor Gheorghiu et al. [2022a] allow for composite gates, and <lb/>hence cannot be extended when used for complex operators. We find that Synthetiq significantly <lb/>outperforms both tools. Synthetiq finds a better T-count than Mosca and Mukhopadhyay [2021] in <lb/>43% cases, including 27% where their tool times out. Further, Synthetiq is one order of magnitude <lb/>faster on problems where Mosca and Mukhopadhyay [2021] does not time out. <lb/>For T-depth, Synthetiq finds more efficient circuits than Gheorghiu et al. [2022a] in 93% of cases, <lb/>including 50% where Gheorghiu et al. [2022a] fails to find any. Excluding the cases where Gheorghiu <lb/>et al. [2022a] times out, Synthetiq is two orders of magnitude faster than Gheorghiu et al. [2022a]. <lb/>6.5 Mode: Approximate Circuit Synthesis <lb/>We compare Synthetiq with Gheorghiu et al. [2022b], the state-of-the-art method for approximate <lb/>synthesis of multi-qubit operators in the Clifford+T gate set. Approximate synthesis is important as <lb/>many operators cannot be implemented exactly with Clifford+T gates, but all can be approximated <lb/>up to an arbitrary distance (see for instance [Nielsen and Chuang 2002, Chap. 4.5.3]). <lb/>Tab. 7 shows the results of this comparison on the benchmark from Gheorghiu et al. [2022b]. We <lb/>report results for all operators present in their evaluation, except for trivial operators with T-count <lb/>less than 2 or for operators where neither tool reported any result. 13 <lb/></body>

        <note place="footnote">13 Further, we note that Gheorghiu et al. [2022b] reports finding a circuit with 26 gates for the operators <lb/>2 /2 10 and <lb/>2 /2 11 with = 0.001, but we were not able to reproduce this result using their implementation. We confirmed with <lb/>the authors that their reported result may indeed have been erroneous and we therefore dropped these operators as well. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:21 <lb/></page>

        <body>Table 7. Results for approximate synthesis compared to [Gheorghiu et al. 2022b]. We run Synthetiq and <lb/>[Gheorghiu et al. 2022b] for an hour on 1 or 2 qubit tasks and for two hours on the 3 qubit task and report the <lb/>best found circuit. Synthetiq is run on 64 cores and [Gheorghiu et al. 2022b] is run on one. We tried running <lb/>the code of [Gheorghiu et al. 2022b] on 64 cores, but this resulted in runtimes about 50 times slower. <lb/>Operator <lb/>Qubits <lb/>k <lb/>T-Count <lb/>Time <lb/>Synthetiq Gheorghiu Synthetiq Speedup <lb/>(2 /2 ) <lb/>1 <lb/>0.05 <lb/>4 <lb/>7 <lb/>8 <lb/>0.059 <lb/>0.085 <lb/>5 <lb/>9 <lb/>9 <lb/>0.825 <lb/>0.015 <lb/>0.01 <lb/>4 <lb/>16 <lb/>18 <lb/>3600 <lb/>0.004 <lb/>5 <lb/>-<lb/>17 <lb/>-<lb/>x <lb/>6 <lb/>16 <lb/>16 <lb/>1800 <lb/>0.001 <lb/>7 <lb/>11 <lb/>11 <lb/>19.883 <lb/>0.003 <lb/>(2 /2 ) <lb/>2 <lb/>0.05 <lb/>2 <lb/>2 <lb/>2 <lb/>0.001 <lb/>11.048 <lb/>0.01 <lb/>2 <lb/>2 <lb/>2 <lb/>0.004 <lb/>4.847 <lb/>2 <lb/>0.05 <lb/>2 <lb/>3 <lb/>3 <lb/>0.001 <lb/>8.981 <lb/>0.01 <lb/>2 <lb/>3 <lb/>3 <lb/>0.005 <lb/>2.296 <lb/>(2 /2 ) 3 <lb/>0.001 2 <lb/>12 <lb/>-<lb/>1800 <lb/>-<lb/>5 <lb/>10 <lb/>15 <lb/>20 <lb/># Qubits <lb/>0 <lb/>50 <lb/>100 <lb/>150 <lb/>T-Depth <lb/>5 <lb/>10 <lb/>15 <lb/>20 <lb/># Qubits <lb/>0 <lb/>100 <lb/>200 <lb/>300 <lb/>400 <lb/>500 <lb/>T-Count <lb/>5 <lb/>10 <lb/>15 <lb/>20 <lb/># Qubits <lb/>0 <lb/>100 <lb/>200 <lb/>300 <lb/>CX-Depth <lb/>5 <lb/>10 <lb/>15 <lb/>20 <lb/># Qubits <lb/>0 <lb/>100 <lb/>200 <lb/>300 <lb/>400 <lb/>500 <lb/>CX-Count <lb/>Fig. 5. Adder circuit performance with the original carry operator (-) and with the Synthetiq synthesized <lb/>relative carry operator (-). <lb/>For operators on one qubit, Synthetiq finds more efficient circuits than Gheorghiu et al. [2022b] <lb/>for two out of six operators, despite their claim of optimality 14 . Synthetiq is only outperformed once, <lb/>when it fails to find any circuit. It is however several orders of magnitude slower than Gheorghiu <lb/>et al. [2022b]. For operators on two qubits, Synthetiq is five times faster than Gheorghiu et al. <lb/>[2022b] and finds circuits as efficient as Gheorghiu et al. [2022b] does. Further, Gheorghiu et al. <lb/>[2022b] could not synthesize the three qubits operator, whereas Synthetiq succeeds. <lb/>6.6 Mode: Relative Phase Operators <lb/>We now showcase the use of Synthetiq for relative phase operators, and their use in bigger circuits. <lb/>We do so using the Adder implementation from Cirq [Cirq 2023]. This implementation relies on the <lb/>interleaving of three small operators: sum, carry, and uncarry (which uncomputes carry). To build <lb/>an adder for two operands of qubits with ancilla qubits, this implementation uses of each of <lb/>the three operators. As we explained in §5.2, relative phase operators can be used to replace their <lb/>non-relative counterpart in a circuit when this counter-part is later uncomputed. We can hence <lb/>replace the carry operator by a relative implementation, and uncarry by the inverse of the relative <lb/>operator, without changing the semantics of the resulting Adder circuit. <lb/></body>

        <note place="footnote">14 We confirmed with the authors that their implementation may indeed return sub-optimal results, which they conjecture <lb/>may be due to various optimizations implemented but not discussed in the publication. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:22 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <body>We used Synthetiq to synthesize such relative operators. This yielded two circuits: one optimized <lb/>for T-count and T-depth, and one optimized for CX-count and CX-depth, each synthesized in less <lb/>than 1h. Using those relative operators, we built the complete Adder circuit for different number <lb/>of qubits. Note that all Adder circuits, no matter the number of qubits, use the same carry and <lb/>uncarry operators. We therefore only synthesized two operators, and were able to use them for all <lb/>adder operators. <lb/>We show the resulting circuit performance in Fig. 5. Using the relative operators allowed for <lb/>significantly more efficient circuits; with a reduction in T-count by 3.5, in T-depth by 2.3, in CX-<lb/>count by 2 and in CX-depth by 1.5. This demonstrates the usefulness of relative phase operators, <lb/>and the need for a synthesis tool that can easily synthesize such operators for any specification. <lb/>7 RELATED WORK <lb/>We now discuss works related to Synthetiq. <lb/>Clifford+T Synthesis. Meet-in-the-middle (MITM) algorithms have been extensively explored <lb/>for synthesizing circuits with finite gate sets. The original implementation by Amy et al. [2013] <lb/>ensures gate-depth or T-depth optimality but is much slower than other methods, taking over <lb/>four days to find a T-depth CCX circuit. It supports ancillae by treating specifications that <lb/>allow for ancillae as isometries, but does not discuss extending it to element-wise specifications. A <lb/>later iteration of MITM [Gosset et al. 2013] focuses on optimizing T-count rather than T-depth, <lb/>but sacrifices the use of ancillae. Matteo and Mosca [2016] improved upon Gosset et al. [2013] by <lb/>introducing a parallel framework, thereby reducing runtime. Overall, those three MITM algorithms <lb/>are extremely slow. For instance, the most efficient among them, Matteo and Mosca [2016], requires <lb/>approximately 30 seconds to execute on 4096 cores for the smallest operator we considered, which <lb/>is the CCX gate. Due to these excessive runtimes, they were not incorporated in the evaluation <lb/>conducted in §6.4. <lb/>The more recent Mosca and Mukhopadhyay [2021] and Gheorghiu et al. [2022a] further refined <lb/>the original MITM algorithm, optimizing for T-count and T-depth, respectively. However, they <lb/>lost the original algorithm&apos;s optimality guarantees and cannot deal with ancillae 15 . It is worth <lb/>noting that the former cannot be parallelized, and the latter gains only marginal benefits from <lb/>parallelization. In §6.4, we demonstrate that Synthetiq outperforms both of those works, in terms <lb/>of runtime and efficiency of the generated circuits. <lb/>Another work [Giles and Selinger 2013] suggests an algorithm to synthesize any circuit that can <lb/>be exactly synthesized over Clifford+T. However, this work does not target efficient decompositions, <lb/>instead often producing expensive ones. Niemann et al. [2020] implement and evaluate an improved <lb/>version of this approach. Unfortunately, we were unable to compare their results to Synthetiq <lb/>because we could not run their implementation and their publication does not report results on the <lb/>circuits we consider here. 16 <lb/>Synthesis on Other Gate Sets. We now discuss methods capable of handling gate sets other than <lb/>Clifford+T and compare their capabilities with Synthetiq. Kang and Oh [2023] recently proposed a <lb/>new circuit synthesis method focusing on finite gate sets and provide a framework for specifying <lb/>isometries in any basis. Synthetiq, on the other hand, naturally handles partial specifications like <lb/>relative phase operators that cannot be specified as isometries in any basis. More importantly, we <lb/>demonstrated in §6.3 that Synthetiq significantly outperforms Kang and Oh [2023] in all tasks, both <lb/></body>

        <note place="footnote">15 The ancillae mentioned by Gheorghiu et al. [2022a]; Mosca and Mukhopadhyay [2021] correspond to our notion of dirty <lb/>qubits-any work that can handle full specification can trivially handle this. <lb/>16 While the authors shared their implementation with us, we were unable to compile it, despite being in contact with them <lb/>for over two months. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:23 <lb/></page>

        <body>in terms of speed and efficiency of the generated circuits, even when restricted to a single core. <lb/>Allowing Synthetiq to use multiple cores would only increase the performance gap further. <lb/>Chou et al. [2022] suggested an evolutionary algorithm that incrementally modifies a circuit to <lb/>meet a specification. Even though it exploits known aspects of an optimal CCX gate decomposition, <lb/>its reported runtime on CCX is orders of magnitude higher than Synthetiq, namely 600s. Unfor-<lb/>tunately, implementation is not available, so we were unable to compare it to Synthetiq. 17 Its <lb/>publication does not address parallelization, partial specifications, or ancillae. Further, it assumes <lb/>incorrect definitions of gate depth and T-depth. 18 <lb/>-Approximate Clifford+T Synthesis. Since not all unitaries can be implemented exactly in the <lb/>Clifford+T gate set, some works have focused on implementing circuits up to a distance , where the <lb/>distance can be measured using distances that allow for a global phase difference (e.g., [Gheorghiu <lb/>et al. 2022b; Kliuchnikov et al. 2016]) or not (e.g., [Ross and Selinger 2016; Selinger 2014]). Most of <lb/>these works [Kliuchnikov et al. 2016; Ross and Selinger 2016; Selinger 2014] focus on single qubit <lb/>operators; only Gheorghiu et al. [2022b] considers multi-qubit operators. While the latter claims <lb/>its algorithm produces optimal circuits, our experiments demonstrate its implementation is not <lb/>optimal for all tasks. As shown in §6.5, Synthetiq performs similarly to Gheorghiu et al. [2022b] on <lb/>the subdomain of -approximate Clifford+T synthesis. <lb/>Synthesis in Other Settings. In contrast to the finite gate sets assumed by Synthetiq, various works <lb/>have studied synthesis using parametrized gate sets such as CX+Rot [Davis et al. 2019; Khatri et al. <lb/>2019; Meister et al. 2023; Smith et al. 2023; Younis et al. 2021]. However, synthesis over CX+Rot <lb/>relies on the optimization of the parameters in the rotational gates, which is not possible for finite <lb/>gate sets such as Clifford+T. State preparation synthesis for the CX+Rot gate set has also been <lb/>studied extensively, see e.g., [Araujo et al. 2021; Iten et al. 2016; Plesch and Brukner 2011]. <lb/>A plethora of works synthesizes circuits for specific use cases. Various works decompose classical <lb/>oracles into quantum circuits [Amy et al. 2017; Biswal et al. 2018; Green et al. 2013; Parent et al. <lb/>2015, 2017; Rand et al. 2019], or help with this task [Bhattacharjee et al. 2019; Paradis et al. 2021]. <lb/>In contrast to these specialized algorithms, Synthetiq synthesizes general circuits. <lb/>8 CONCLUSION <lb/>We presented Synthetiq, a novel method and tool to synthesize quantum circuits over finite gate sets. <lb/>Synthetiq is based on Simulated Annealing (SA) and allows us to solve a wide range of synthesis <lb/>tasks from relative phase operators over Clifford+T to operators with ancillae over custom gates. <lb/>Our evaluation shows that Synthetiq (i) is able to synthesize more efficient implementations <lb/>of relevant quantum operators, (ii) frequently outperforms more specialized synthesis tools such <lb/>as synthesis for complete specification in the Clifford+T gate set, and (iii) can use relative phase <lb/>operators to build more efficient implementations large qubit operators. <lb/>We believe there are many more applications of Synthetiq worth exploring, such as topology-<lb/>aware synthesis [Davis et al. 2020] or incomplete specifications of operators in different bases. <lb/></body>

        <div type="availability">DATA-AVAILABILITY STATEMENT <lb/>The implementation of Synthetiq and all evaluations results are available on github 19 and Zen-<lb/>odo[Paradis et al. 2024]. <lb/></div>

        <note place="footnote">17 We asked the authors for the implementation but did not receive a response within six months. <lb/>18 The T-depth is measured as the number T-gates in different vertical layers in a drawing of the circuit. We tried to confirm <lb/>this mistake with the authors but did not receive a response within six months. <lb/>19 https://github.com/eth-sri/synthetiq <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:24 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <div type="annex">A APPENDIX <lb/>A.1 Energy Function Derivation <lb/>Here, we demonstrate our rewrite of the typical energy function used by e.g. [Chou et al. 2022; <lb/>Khatri et al. 2019; Meister et al. 2023]. <lb/>Lemma 1. Let , ∈ C 2 ×2 be two unitary matrices. Then <lb/>1 -<lb/>|Tr( † )| <lb/>2 <lb/>= <lb/>1 <lb/>2 <lb/>-Tr( † ) <lb/>|Tr( † ) | <lb/>2 <lb/>2 <lb/>Proof. We show that <lb/>2 +1 -2|Tr( † )| = <lb/>-<lb/>Tr( † ) <lb/>|Tr( † )| <lb/>2 <lb/>. <lb/>(10) <lb/>The lemma follows by multiplying Eq. (10) with 1 <lb/>2 +1 . <lb/>We first note that for any matrix , ∈ C 2 ×2 , the following well-known properties hold: <lb/>(1) || || 2 = Tr( † ) <lb/>(2) Tr( ) † = Tr( † ) <lb/>(3) Linearity of the trace, Tr( + ) = Tr( ) + Tr( ) <lb/>(4) If is also a unitary matrix, then || || 2 = 2 . <lb/>We can use these properties to prove the lemma. Starting from the right-hand side in Eq. (10) we <lb/>get: <lb/>-<lb/>Tr( † ) <lb/>|Tr( † )| <lb/>2 <lb/>=Tr <lb/>-<lb/>Tr( † ) <lb/>|Tr( † )| <lb/> † <lb/>-<lb/>Tr( † ) <lb/>|Tr( † )| <lb/>=Tr( † ) -<lb/>Tr( † ) <lb/>|Tr( † )| <lb/>Tr( † ) -<lb/>Tr( † ) † <lb/>|Tr( † )| <lb/>Tr( † ) + <lb/>Tr( † ) † <lb/>|Tr( † )| <lb/>Tr( † ) <lb/>|Tr( † )| <lb/>Tr( † ) <lb/>=∥ ∥ 2 + ∥ ∥ 2 -2|Tr( † )| <lb/>=2 • 2 -2|Tr( † )| <lb/>which proves the equality. <lb/>□ <lb/>A.2 Simplification Order <lb/>We define the order ≺ that is used in Alg. 2 to determine if two gates should be swapped in a circuit <lb/>. The goal of ≺ is to ensure that as many gates as possible can be swapped and to define some <lb/>strict order on the set of gates. <lb/>We therefore first define the functions comm , act and . comm ( , , ) is the number of con-<lb/>secutive gates that commute with starting from and going down until 1 . Mathematically, this <lb/>means <lb/>comm ( , , ) = max -0 ⩽ ⩽ ∧ commutes with <lb/>. <lb/>act ( ) is the number of qubits on which gate acts and ( ) is the indices of the qubits on which <lb/>acts. We then define ≺ alpabet as the alphabetical order on the name of the gates (e.g. H, S, CX, ...) and <lb/>≺ as the standard order on R . Alg. 3 shows the definition of ≺. As shown, the order prioritizes a <lb/>difference between commutating gates, than acting qubits, than the alphabetical order of the gates <lb/>and finally the order of the qubits on which the gates act. <lb/></div>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:25 <lb/></page>

        <div type="annex">Algorithm 3 Definition of the order ≺. <lb/>1: function ≺ +1 <lb/>2: <lb/>if comm ( , , ) ≠ comm ( +1 , , ) then <lb/>3: <lb/>return comm ( , , ) &lt; comm ( +1 , , ) <lb/>4: <lb/>if act ( ) ≠ act ( +1 ) then <lb/>5: <lb/>return act ( ) &lt; act ( +1 ) <lb/>6: <lb/>if ≠ +1 then <lb/>7: <lb/>return &lt; alphabet +1 <lb/>8: <lb/>if ( ) ≤ <lb/>( +1 ) then <lb/>9: <lb/>return true <lb/>10: <lb/>return false <lb/>A.3 Baseline for Operators Decomposition <lb/>We describe our best effort construction of the baselines for Tab. 4. <lb/>[Maslov 2016] gives the best decomposition of RCCCX we could find, with a T-depth of 8. <lb/>We were unable to find any explicit decomposition of CCT in published work. We therefore used <lb/>the construction from [Maslov 2016] and the minimal implementation of the CT gate from [Amy <lb/>et al. 2013], decomposing CCT( , , ) as RCCX( , , ); CT( , ); RCCX( , , ) where is an ancilla <lb/>qubit. Altogether, this yields an implementation with T-depth 9 and 2 ancilla qubits, as CT requires <lb/>its own extra ancilla. <lb/>For CCiSWAP, we used the same construction as above, with CiSWAP decomposed as in [Crooks <lb/>2023] instead of CT. This yields an implementation with 1 ancilla. <lb/>For C <lb/>√ <lb/>SWAP (resp. C <lb/>√ <lb/>iSWAP), we could not find a better existing implementation than control-<lb/>ling every gate in the best known decomposition of <lb/>√ <lb/>SWAP (resp. <lb/>√ <lb/>iSWAP). This yields for each <lb/>of those two gates a decomposition with an ancilla and a T-depth higher than 25. <lb/></div>

        <listBibl>REFERENCES <lb/>Héctor Abraham, AduOffei, Rochisha Agarwal, Ismail Yunus Akhalwaya, Gadi Aleksandrowicz, Thomas Alexander, Matthew <lb/>Amy, Eli Arbel, Arijit02, Abraham Asfaw, Artur Avkhadiev, Carlos Azaustre, AzizNgoueya, Abhik Banerjee, Aman <lb/>Bansal, Panagiotis Barkoutsos, George Barron, George S. Barron, Luciano Bello, Yael Ben-Haim, Daniel Bevenius, Arjun <lb/>Bhobe, Lev S. Bishop, Carsten Blank, Sorin Bolos, Samuel Bosch, Brandon, Sergey Bravyi, Bryce-Fuller, David Bucher, <lb/>Artemiy Burov, Fran Cabrera, Padraic Calpin, Lauren Capelluto, Jorge Carballo, Ginés Carrascal, Adrian Chen, Chun-Fu <lb/>Chen, Edward Chen, Jielun (Chris) Chen, Richard Chen, Jerry M. Chow, Spencer Churchill, Christian Claus, Christian <lb/>Clauss, Romilly Cocking, Filipe Correa, Abigail J. Cross, Andrew W. Cross, Simon Cross, Juan Cruz-Benito, Chris <lb/>Culver, Antonio D. Córcoles-Gonzales, Sean Dague, Tareq El Dandachi, Marcus Daniels, Matthieu Dartiailh, DavideFrr, <lb/>Abdón Rodríguez Davila, Anton Dekusar, Delton Ding, Jun Doi, Eric Drechsler, Drew, Eugene Dumitrescu, Karel Dumon, <lb/>Ivan Duran, Kareem EL-Safty, Eric Eastman, Grant Eberle, Pieter Eendebak, Daniel Egger, Mark Everitt, Paco Martín <lb/>Fernández, Axel Hernández Ferrera, Romain Fouilland, FranckChevallier, Albert Frisch, Andreas Fuhrer, Bryce Fuller, <lb/>MELVIN GEORGE, Julien Gacon, Borja Godoy Gago, Claudio Gambella, Jay M. Gambetta, Adhisha Gammanpila, Luis <lb/>Garcia, Tanya Garg, Shelly Garion, Austin Gilliam, Aditya Giridharan, Juan Gomez-Mosquera, Salvador de la Puente <lb/>González, Jesse Gorzinski, Ian Gould, Donny Greenberg, Dmitry Grinko, Wen Guan, John A. Gunnels, Mikael Haglund, <lb/>Isabel Haide, Ikko Hamamura, Omar Costa Hamido, Frank Harkins, Vojtech Havlicek, Joe Hellmers, \Lukasz Herok, Stefan <lb/>Hillmich, Hiroshi Horii, Connor Howington, Shaohan Hu, Wei Hu, Junye Huang, Rolf Huisman, Haruki Imai, Takashi <lb/>Imamichi, Kazuaki Ishizaki, Raban Iten, Toshinari Itoko, JamesSeaward, Ali Javadi, Ali Javadi-Abhari, Jessica, Madhav <lb/>Jivrajani, Kiran Johns, Scott Johnstun, Jonathan-Shoemaker, Vismai K, Tal Kachmann, Naoki Kanazawa, Kang-Bae, <lb/>Anton Karazeev, Paul Kassebaum, Josh Kelso, Spencer King, Knabberjoe, Yuri Kobayashi, Arseny Kovyrshin, Rajiv <lb/>Krishnakumar, Vivek Krishnan, Kevin Krsulich, Prasad Kumkar, Gawel Kus, Ryan LaRose, Enrique Lacal, Raphaël <lb/>Lambert, John Lapeyre, Joe Latone, Scott Lawrence, Christina Lee, Gushu Li, Dennis Liu, Peng Liu, Yunho Maeng, Kahan <lb/>Majmudar, Aleksei Malyshev, Joshua Manela, Jakub Marecek, Manoel Marques, Dmitri Maslov, Dolph Mathews, Atsushi <lb/>Matsuo, Douglas T. McClure, Cameron McGarry, David McKay, Dan McPherson, Srujan Meesala, Thomas Metcalfe, <lb/>Martin Mevissen, Andrew Meyer, Antonio Mezzacapo, Rohit Midha, Zlatko Minev, Abby Mitchell, Nikolaj Moll, Jhon <lb/>Montanez, Michael Duane Mooring, Renier Morales, Niall Moran, Mario Motta, MrF, Prakash Murali, Jan Müggenburg, <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:26 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <listBibl>David Nadlinger, Ken Nakanishi, Giacomo Nannicini, Paul Nation, Edwin Navarro, Yehuda Naveh, Scott Wyman Neagle, <lb/>Patrick Neuweiler, Johan Nicander, Pradeep Niroula, Hassi Norlen, NuoWenLei, Lee James O&apos;Riordan, Oluwatobi <lb/>Ogunbayo, Pauline Ollitrault, Raul Otaolea, Steven Oud, Dan Padilha, Hanhee Paik, Soham Pal, Yuchen Pang, Simone <lb/>Perriello, Anna Phan, Francesco Piro, Marco Pistoia, Christophe Piveteau, Pierre Pocreau, Alejandro Pozas-iKerstjens, <lb/>Viktor Prutyanov, Daniel Puzzuoli, Jesús Pérez, Quintiii, Rafey Iqbal Rahman, Arun Raja, Nipun Ramagiri, Anirudh <lb/>Rao, Rudy Raymond, Rafael Martín-Cuevas Redondo, Max Reuter, Julia Rice, Marcello La Rocca, Diego M. Rodríguez, <lb/>RohithKarur, Max Rossmannek, Mingi Ryu, Tharrmashastha SAPV, SamFerracin, Martin Sandberg, Hirmay Sandesara, <lb/>Ritvik Sapra, Hayk Sargsyan, Aniruddha Sarkar, Ninad Sathaye, Bruno Schmitt, Chris Schnabel, Zachary Schoenfeld, <lb/>Travis L. Scholten, Eddie Schoute, Joachim Schwarm, Ismael Faro Sertage, Kanav Setia, Nathan Shammah, Yunong <lb/>Adenilton Silva, Andrea Simonetto, Nick Singstock, Yukio Siraichi, Iskandar Sitdikov, Seyon Sivarajah, Magnus Berg <lb/>Sletfjerding, John A. Smolin, Mathias Soeken, Igor Olegovich Sokolov, Igor Sokolov, SooluThomas, Starfish, Dominik <lb/>Steenken, Matt Stypulkoski, Shaojun Sun, Kevin J. Sung, Hitomi Takahashi, Tanvesh Takawale, Ivano Tavernelli, Charles <lb/>Taylor, Pete Taylour, Soolu Thomas, Mathieu Tillet, Maddy Tod, Miroslav Tomasik, Enrique de la Torre, Kenso Trabing, <lb/>Matthew Treinish, TrishaPe, Davindra Tulsi, Wes Turner, Yotam Vaknin, Carmen Recio Valcarce, Francois Varchon, <lb/>Almudena Carrera Vazquez, Victor Villar, Desiree Vogt-Lee, Christophe Vuillot, James Weaver, Johannes Weidenfeller, <lb/>Rafal Wieczorek, Jonathan A. Wildstrom, Erick Winston, Jack J. Woehr, Stefan Woerner, Ryan Woo, Christopher J. Wood, <lb/>Ryan Wood, Stephen Wood, Steve Wood, James Wootton, Daniyar Yeralin, David Yonge-Mallo, Richard Young, Jessie Yu, <lb/>Christopher Zachow, Laura Zdanski, Helena Zhang, Christa Zoufal, Zoufalc, a-kapila, a-matsuo, bcamorrison, brandhsn, <lb/>nick bronn, chlorophyll-zz, dekel.meirom, dekelmeirom, dekool, dime10, drholmie, dtrenev, ehchen, elfrocampeador, <lb/>faisaldebouni, fanizzamarco, gabrieleagl, gadial, galeinston, georgios-ts, gruu, hhorii, hykavitha, jagunther, jliu45, jscott2, <lb/>kanejess, klinvill, krutik2966, kurarrr, lerongil, ma5x, merav-aharoni, michelle4654, ordmoj, sagar pahwa, rmoyard, <lb/>saswati-qiskit, scottkelso, sethmerkel, strickroman, sumitpuri, tigerjack, toural, tsura-crisaldo, vvilpas, welien, willhbang, <lb/>yang.luh, yotamvakninibm, and Mantas Čepulkovskis. 2019. Qiskit: An Open-source Framework for Quantum Computing. <lb/>https://doi.org/10.5281/zenodo.2562110 <lb/>U. Alvarez-Rodriguez, M. Sanz, L. Lamata, and E. Solano. 2018. Quantum Artificial Life in an IBM Quantum Computer. <lb/>Scientific Reports 8, 1 (Oct. 2018), 14793. https://doi.org/10.1038/s41598-018-33125-3 <lb/>Matthew Amy, Dmitri Maslov, Michele Mosca, and Martin Roetteler. 2013. A Meet-in-the-Middle Algorithm for Fast <lb/>Synthesis of Depth-Optimal Quantum Circuits. IEEE Transactions on Computer-Aided Design of Integrated Circuits and <lb/>Systems 32, 6 (2013), 818-830. https://doi.org/10.1109/TCAD.2013.2244643 <lb/>Matthew Amy, Martin Roetteler, and Krysta M. Svore. 2017. Verified Compilation of Space-Efficient Reversible Circuits. In <lb/>Computer Aided Verification, Rupak Majumdar and Viktor Kunčak (Eds.). Vol. 10427. Springer International Publishing, <lb/>Cham, 3-21. https://doi.org/10.1007/978-3-319-63390-9_1 <lb/>Israel F. Araujo, Daniel K. Park, Francesco Petruccione, and Adenilton J. da Silva. 2021. A divide-and-conquer algorithm for <lb/>quantum state preparation. Scientific Reports 11, 1 (March 2021), 6329. https://doi.org/10.1038/s41598-021-85474-1 <lb/>Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando <lb/>G. S. L. Brandao, David A. Buell, Brian Burkett, Yu Chen, Zijun Chen, Ben Chiaro, Roberto Collins, William Courtney, <lb/>Andrew Dunsworth, Edward Farhi, Brooks Foxen, Austin Fowler, Craig Gidney, Marissa Giustina, Rob Graff, Keith Guerin, <lb/>Steve Habegger, Matthew P. Harrigan, Michael J. Hartmann, Alan Ho, Markus Hoffmann, Trent Huang, Travis S. Humble, <lb/>Sergei V. Isakov, Evan Jeffrey, Zhang Jiang, Dvir Kafri, Kostyantyn Kechedzhi, Julian Kelly, Paul V. Klimov, Sergey Knysh, <lb/>Alexander Korotkov, Fedor Kostritsa, David Landhuis, Mike Lindmark, Erik Lucero, Dmitry Lyakh, Salvatore Mandrà, <lb/>Jarrod R. McClean, Matthew McEwen, Anthony Megrant, Xiao Mi, Kristel Michielsen, Masoud Mohseni, Josh Mutus, Ofer <lb/>Naaman, Matthew Neeley, Charles Neill, Murphy Yuezhen Niu, Eric Ostby, Andre Petukhov, John C. Platt, Chris Quintana, <lb/>Eleanor G. Rieffel, Pedram Roushan, Nicholas C. Rubin, Daniel Sank, Kevin J. Satzinger, Vadim Smelyanskiy, Kevin J. <lb/>Sung, Matthew D. Trevithick, Amit Vainsencher, Benjamin Villalonga, Theodore White, Z. Jamie Yao, Ping Yeh, Adam <lb/>Zalcman, Hartmut Neven, and John M. Martinis. 2019. Quantum supremacy using a programmable superconducting <lb/>processor. Nature 574, 7779 (Oct. 2019), 505-510. https://doi.org/10.1038/s41586-019-1666-5 <lb/>Debjyoti Bhattacharjee, Mathias Soeken, Srijit Dutta, Anupam Chattopadhyay, and Giovanni De Micheli. 2019. Reversible <lb/>Pebble Games for Reducing Qubits in Hierarchical Quantum Circuit Synthesis. In 2019 IEEE 49th International Symposium <lb/>on Multiple-Valued Logic (ISMVL). 102-107. https://doi.org/10.1109/ISMVL.2019.00026 ISSN: 2378-2226. <lb/>Laxmidhar Biswal, Rakesh Das, Chandan Bandyopadhyay, Anupam Chattopadhyay, and Hafizur Rahaman. 2018. A template-<lb/>based technique for efficient Clifford+T-based quantum circuit implementation. Microelectronics Journal 81 (2018), 58-68. <lb/>https://doi.org/10.1016/j.mejo.2018.08.011 <lb/>Sergey Bravyi, Oliver Dial, Jay M. Gambetta, Darío Gil, and Zaira Nazario. 2022. The future of quantum computing <lb/>with superconducting qubits. Journal of Applied Physics 132, 16 (10 2022), 160902. https://doi.org/10.1063/5.0082975 <lb/>arXiv:https://pubs.aip.org/aip/jap/article-pdf/doi/10.1063/5.0082975/16515734/160902_1_online.pdf <lb/>Yudong Cao, Jonathan Romero, Jonathan P. Olson, Matthias Degroote, Peter D. Johnson, Má ria Kieferová, Ian D. Kivlichan, <lb/>Tim Menke, Borja Peropadre, Nicolas P. D. Sawaya, Sukin Sim, Libor Veis, and Alán Aspuru-Guzik. 2019. Quantum <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <note place="headnote">Synthetiq: Fast and Versatile antum Circuit Synthesis <lb/></note>

        <page>96:27 <lb/></page>

        <listBibl>Chemistry in the Age of Quantum Computing. Chemical Reviews 119, 19 (aug 2019), 10856-10915. https://doi.org/10. <lb/>1021/acs.chemrev.8b00803 <lb/>Yao-Hsin Chou, Shu-Yu Kuo, Yu-Chi Jiang, Ching-Hsuan Wu, Jyun-Yi Shen, Cheng-Yen Hua, Pei-Shin Huang, Yun-Ting Lai, <lb/>Yong Feng Tong, and Ming-He Chang. 2022. A novel quantum-inspired evolutionary computation-based quantum circuit <lb/>synthesis for various universal gate libraries. In Proceedings of the Genetic and Evolutionary Computation Conference <lb/>Companion (&lt;conf-loc&gt;, &lt;city&gt;Boston&lt;/city&gt;, &lt;state&gt;Massachusetts&lt;/state&gt;, &lt;/conf-loc&gt;) (GECCO &apos;22). Association for <lb/>Computing Machinery, New York, NY, USA, 2182-2189. https://doi.org/10.1145/3520304.3533956 <lb/>Cirq. 2023. Examples: Basic Arithmetic. https://github.com/quantumlib/Cirq/blob/master/examples/basic_arithmetic.py. <lb/>Gavin E. Crooks. 2023. Gates, States, and Circuits. Technical report. https://threeplusone.com/gates,https://github.com/ <lb/>gecrooks/on_gates Tech. Note 014 v0.9.0 beta. <lb/>Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. 2017. Open Quantum Assembly Language. (2017). <lb/>arXiv:1707.03429 [quant-ph] https://doi.org/10.48550/arXiv.1707.03429 <lb/>Marc Grau Davis, Ethan Smith, Ana Tudor, Koushik Sen, Irfan Siddiqi, and Costin Iancu. 2019. Heuristics for Quantum <lb/>Compiling with a Continuous Gate Set. (2019). arXiv:1912.02727 [cs.ET] https://doi.org/10.48550/arXiv.1912.02727 <lb/>Marc G. Davis, Ethan Smith, Ana Tudor, Koushik Sen, Irfan Siddiqi, and Costin Iancu. 2020. Towards Optimal Topology <lb/>Aware Quantum Circuit Synthesis. In 2020 IEEE International Conference on Quantum Computing and Engineering (QCE). <lb/>223-234. https://doi.org/10.1109/QCE49297.2020.00036 <lb/>Ronald de Wolf. 2017. The potential impact of quantum computers on society. Ethics and Information Technology 19, 4 (Dec. <lb/>2017), 271-276. https://doi.org/10.1007/s10676-017-9439-z <lb/>Vlad Gheorghiu, Michele Mosca, and Priyanka Mukhopadhyay. 2022a. A (quasi-)polynomial time heuristic algorithm for <lb/>synthesizing T-depth optimal circuits. npj Quantum Information 8, 1 (Sept. 2022), 110. https://doi.org/10.1038/s41534-<lb/>022-00624-1 <lb/>Vlad Gheorghiu, Michele Mosca, and Priyanka Mukhopadhyay. 2022b. T-count and T-depth of any multi-qubit unitary. npj <lb/>Quantum Information 8, 1 (Nov. 2022), 141. https://doi.org/10.1038/s41534-022-00651-y <lb/>Brett Giles and Peter Selinger. 2013. Exact synthesis of multiqubit Clifford+ circuits. Phys. Rev. A 87 (Mar 2013), 032332. <lb/>Issue 3. https://doi.org/10.1103/PhysRevA.87.032332 <lb/>Sukhpal Singh Gill, Adarsh Kumar, Harvinder Singh, Manmeet Singh, Kamalpreet Kaur, Muhammad Usman, and Rajkumar <lb/>Buyya. 2022. Quantum computing: A taxonomy, systematic review and future directions. Software: Practice and Experience <lb/>52, 1 (2022), 66-114. https://doi.org/10.1002/spe.3039 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.3039 <lb/>David Gosset, Vadym Kliuchnikov, Michele Mosca, and Vincent Russo. 2013. An algorithm for the T-count. (2013). <lb/>arXiv:1308.4134 [quant-ph] https://doi.org/10.48550/arXiv.1308.4134 <lb/>Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter Selinger, and Benoît Valiron. 2013. Quipper: a scalable <lb/>quantum programming language. In PLDI&apos;13. ACM Press, Seattle, Washington, USA. https://doi.org/10.1145/2491956. <lb/>2462177 <lb/>Lov K. Grover. 1996. A fast quantum mechanical algorithm for database search. In Proceedings of the Twenty-Eighth Annual <lb/>ACM Symposium on Theory of Computing (Philadelphia, Pennsylvania, USA) (STOC &apos;96). Association for Computing <lb/>Machinery, New York, NY, USA, 212-219. https://doi.org/10.1145/237814.237866 <lb/>Gaël Guennebaud, Benoît Jacob, et al. 2010. Eigen v3. http://eigen.tuxfamily.org. <lb/>Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. 2009. Quantum Algorithm for Linear Systems of Equations. Phys. <lb/>Rev. Lett. 103 (Oct 2009), 150502. Issue 15. https://doi.org/10.1103/PhysRevLett.103.150502 <lb/>Stefan Heule, Eric Schkufza, Rahul Sharma, and Alex Aiken. 2016. Stratified synthesis: automatically learning the x86-64 <lb/>instruction set. SIGPLAN Not. 51, 6 (jun 2016), 237-250. https://doi.org/10.1145/2980983.2908121 <lb/>Raban Iten, Roger Colbeck, Ivan Kukuljan, Jonathan Home, and Matthias Christandl. 2016. Quantum circuits for isometries. <lb/>Phys. Rev. A 93 (Mar 2016), 032318. Issue 3. https://doi.org/10.1103/PhysRevA.93.032318 <lb/>Chan Gu Kang and Hakjoo Oh. 2023. Modular Component-Based Quantum Circuit Synthesis. Proc. ACM Program. Lang. 7, <lb/>OOPSLA1, Article 87 (apr 2023), 28 pages. https://doi.org/10.1145/3586039 <lb/>Sumeet Khatri, Ryan LaRose, Alexander Poremba, Lukasz Cincio, Andrew T. Sornborger, and Patrick J. Coles. 2019. Quantum-<lb/>assisted quantum compiling. Quantum 3 (may 2019), 140. https://doi.org/10.22331/q-2019-05-13-140 <lb/>Vadym Kliuchnikov, Dmitri Maslov, and Michele Mosca. 2016. Practical Approximation of Single-Qubit Unitaries by Single-<lb/>Qubit Quantum Clifford and T Circuits. IEEE Trans. Comput. 65, 1 (2016), 161-172. https://doi.org/10.1109/TC.2015.2409842 <lb/>Guang Hao Low, Vadym Kliuchnikov, and Luke Schaeffer. 2018. Trading T-gates for dirty qubits in state preparation and <lb/>unitary synthesis. (2018). arXiv:1812.00954 [quant-ph] https://doi.org/10.48550/arXiv.1812.00954 <lb/>Dmitri Maslov. 2016. Advantages of using relative-phase Toffoli gates with an application to multiple control Toffoli <lb/>optimization. Phys. Rev. A 93 (Feb 2016), 022311. Issue 2. https://doi.org/10.1103/PhysRevA.93.022311 <lb/>Olivia Di Matteo and Michele Mosca. 2016. Parallelizing quantum circuit synthesis. Quantum Science and Technology 1, 1 <lb/>(oct 2016), 015003. https://doi.org/10.1088/2058-9565/1/1/015003 <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. <lb/></note>

        <page>96:28 <lb/></page>

        <note place="headnote">Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev <lb/></note>

        <listBibl>Richard Meister, Cica Gustiani, and Simon C Benjamin. 2023. Exploring ab initio machine synthesis of quantum circuits. <lb/>New Journal of Physics 25, 7 (July 2023), 073018. https://doi.org/10.1088/1367-2630/ace077 <lb/>Michele Mosca and Priyanka Mukhopadhyay. 2021. A polynomial time and space heuristic algorithm for T-count. Quantum <lb/>Science and Technology 7, 1 (oct 2021), 015003. https://doi.org/10.1088/2058-9565/ac2d3a <lb/>Michael A Nielsen and Isaac Chuang. 2002. Quantum computation and quantum information. <lb/>Philipp Niemann, Robert Wille, and Rolf Drechsler. 2020. Advanced exact synthesis of Clifford+T circuits. Quantum <lb/>Information Processing 19, 9 (Aug. 2020), 317. https://doi.org/10.1007/s11128-020-02816-0 <lb/>OpenMP Architecture Review Board. 2021. OpenMP Application Program Interface Version 5.2. https://www.openmp.org/ <lb/>wp-content/uploads/OpenMP-API-Specification-5-2.pdf <lb/>Anouk Paradis, Benjamin Bichsel, Samuel Steffen, and Martin Vechev. 2021. Unqomp: synthesizing uncomputation in <lb/>Quantum circuits. In Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design <lb/>and Implementation. Association for Computing Machinery, New York, NY, USA, 222-236. https://doi.org/10.1145/ <lb/>3453483.3454040 <lb/>Anouk Paradis, Jasper Dekoninck, Benjamin Bichsel, and Martin Vechev. 2024. Synthetiq: Fast and Versatile Quantum Circuit <lb/>Synthesis. https://doi.org/10.5281/zenodo.10777503 <lb/>Alex Parent, Martin Roetteler, and Krysta M. Svore. 2015. Reversible circuit compilation with space constraints. https: <lb/>//doi.org/10.48550/arXiv.1510.00377 arXiv:1510.00377 [quant-ph]. <lb/>Alex Parent, Martin Roetteler, and Krysta M. Svore. 2017. REVS: A Tool for Space-Optimized Reversible Circuit Synthesis. <lb/>In Reversible Computation (Lecture Notes in Computer Science), Iain Phillips and Hafizur Rahaman (Eds.). Springer <lb/>International Publishing, Cham, 90-101. https://doi.org/10.1007/978-3-319-59936-6_7 <lb/>Martin Plesch and Časlav Brukner. 2011. Quantum-state preparation with universal gate decompositions. Phys. Rev. A 83 <lb/>(Mar 2011), 032302. Issue 3. https://doi.org/10.1103/PhysRevA.83.032302 <lb/>Qiskit. 2023. Implement the multi-controlled X gate using a V-chain of CX gates. https://qiskit.org/documentation/stubs/ <lb/>qiskit.circuit.library.MCXVChain.html. <lb/>Robert Rand, Jennifer Paykin, Dong-Ho Lee, and Steve Zdancewic. 2019. ReQWIRE: Reasoning about Reversible Quantum <lb/>Circuits. Electronic Proceedings in Theoretical Computer Science 287 (Jan. 2019), 299-312. https://doi.org/10.4204/EPTCS. <lb/>287.17 <lb/>Neil J. Ross and Peter Selinger. 2016. <lb/>Optimal ancilla-free Clifford+T approximation of z-rotations. <lb/>(2016). <lb/>arXiv:1403.2975 [quant-ph] https://doi.org/10.48550/arXiv.1403.2975 <lb/>Peter Selinger. 2014. Efficient Clifford+T approximation of single-qubit operators. arXiv:1212.6253 [quant-ph] https: <lb/>//doi.org/10.48550/arXiv.1212.6253 <lb/>Peter W. Shor. 1997. Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer. <lb/>SIAM J. Comput. 26, 5 (oct 1997), 1484-1509. https://doi.org/10.1137/S0097539795293172 <lb/>Ethan Smith, Marc Grau Davis, Jeffrey Larson, Ed Younis, Lindsay Bassman Oftelie, Wim Lavrijsen, and Costin Iancu. 2023. <lb/>LEAP: Scaling Numerical Optimization Based Synthesis Using an Incremental Approach. ACM Transactions on Quantum <lb/>Computing 4, 1 (feb 2023), 1-23. https://doi.org/10.1145/3548693 <lb/>Quantum Computing StackExchange. 2018. How to implement the &quot;Square root of Swap gate&quot; on the IBM Q (com-<lb/>poser)? https://quantumcomputing.stackexchange.com/questions/2228/how-to-implement-the-square-root-of-swap-<lb/>gate-on-the-ibm-q-composer. <lb/>Quantum Computing StackExchange. 2020. Decomposition of |110&gt; &lt;-&gt; |000&gt; Exchange Gate. https://quantumcomputing. <lb/>stackexchange.com/questions/13644/decomposition-of-110-rangle-leftrightarrow-000-rangle-exchange-gate. <lb/>Quantum Computing StackExchange. 2021. How to create CX from an entangling gate and arbitrary single-qubit <lb/>gates? https://quantumcomputing.stackexchange.com/questions/17656/how-to-create-cnot-from-an-entangling-gate-<lb/>and-arbitrary-single-qubit-gates. <lb/>Quantum Computing StackExchange. 2022. Qiskit: How to implement a classical function? https://quantumcomputing. <lb/>stackexchange.com/questions/26505/qiskit-how-to-implement-a-classical-function. <lb/>Quantum Computing StackExchange. 2023. <lb/>How to decompose root iswap into root cz and single-qubit <lb/>gates. https://quantumcomputing.stackexchange.com/questions/29617/how-to-decompose-root-iswap-into-root-cz-<lb/>and-single-qubit-gates. <lb/>M. Steffen, D. P. DiVincenzo, J. M. Chow, T. N. Theis, and M. B. Ketchen. 2011. Quantum computing: An IBM perspective. <lb/>IBM Journal of Research and Development 55, 5 (2011), 13:1-13:11. https://doi.org/10.1147/JRD.2011.2165678 <lb/>Barbara M. Terhal. 2015. Quantum error correction for quantum memories. Rev. Mod. Phys. 87 (Apr 2015), 307-346. Issue 2. <lb/>https://doi.org/10.1103/RevModPhys.87.307 <lb/>Ed Younis, Koushik Sen, Katherine Yelick, and Costin Iancu. 2021. QFAST: Conflating Search and Numerical Optimization <lb/>for Scalable Quantum Circuit Synthesis. arXiv:2103.07093 [quant-ph] https://doi.org/10.48550/arXiv.2103.07093 <lb/></listBibl>

        <front>Received 09-OCT-2023; accepted 2024-02-24 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 96. Publication date: April 2024. </note>


	</text>

</TEI>