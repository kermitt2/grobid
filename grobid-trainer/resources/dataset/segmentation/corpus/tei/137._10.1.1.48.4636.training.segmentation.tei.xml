<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<page>1 <lb/></page>

			<front>Products of Domain Models 1 <lb/>Don Batory <lb/>Department of Computer Sciences <lb/>The University of Texas <lb/>Austin, Texas 78712 <lb/>batory@cs.utexas.edu <lb/>Abstract <lb/>We argue that domain models should produce four basic products: identification of reusable soft-<lb/>ware components, definition of software architectures that explain how components can be com-<lb/>posed, a demonstration of architecture scalability, and a direct relationship of these results to <lb/>software generation of target systems. <lb/></front>

			<body>1 Introduction <lb/>Conventional application modeling is aimed at producing software designs for one-of-a-kind applications. <lb/>Domain modeling, in contrast, takes a broader view to address designs for families of related applications. <lb/>The issues or products that distinguish domain modeling form application modeling include: <lb/>• reusable software components <lb/>• software architectures <lb/>• scalability <lb/>• software system generators <lb/>Although domain modeling can be justified for many reasons, we feel the ultimate benefit of domain mod-<lb/>eling is the development of tools that eliminate the mundane tasks of application programming within a <lb/>mature domain. That is, the automatic construction of software seems to be an inevitable end-product of <lb/>the evolution for a well-understood domain; we see domain modeling as the means to achieve this end. <lb/>2 Products of Domain Models <lb/>The identification of reusable software components is a critical product of domain modeling. The key to <lb/>their identification is recognizing fundamental abstractions of the domain. These recurring abstractions <lb/>appear in most systems of a family; by standardizing their programming interfaces, components that <lb/>implement these abstractions are plug-compatible, interchangeable, and interoperable. Plug-compatibility, <lb/>interchangeability, and interoperability increases likelihood that components will be reused. <lb/>The second product of domain modeling is software architectures for a domain. A software architecture <lb/>basically is a blue-print or template for defining how components fit together to form systems. Software <lb/>architectures express patterns of composition that recur within a domain, it explains various means by <lb/></body>

			<front>1. This research was sponsored, in part, by the U.S. Department of Defense Advanced Research Projects Agency in <lb/>cooperation with the U.S. Air Force Wright Laboratory Avionics Directorate under contract F33615-91C-1788. <lb/></front>

			<page>2 <lb/></page>

			<body>which compositions (or component communications) can physically occur, and it suggests guidelines for <lb/>selecting compositions for a given task [Gar92]. <lb/>Scalability is the third product. It addresses the need for architectures and their components to evolve. The <lb/>ability to add new features to systems is the driving force for modeling families of systems; the need for <lb/>new features will always be present. Domain models must clearly demonstrate the capability of scaling to <lb/>ever larger families of systems without requiring significant revisions [Big94]. <lb/>Domain models should be detailed enough to be used as blue-prints for software system generators; i.e., <lb/>tools that can produce a target system from a domain directly from specifications. Specifications may <lb/>express high-level constraints to be satisfied, thereby entailing a degree of automatic programming on the <lb/>part of the generator to &quot;fill in the gaps&quot;, or it could rely exclusively on the domain analyst for specific <lb/>selections and compositions of components [Pou94]. Software system generators are among the most visi-<lb/>ble and concrete products that can come from domain modeling; a generator is often the centerpiece for <lb/>other analysis tools that are critical to applications development [Bat93]. <lb/>3 Recap <lb/>We have an admittedly narrow focus on what should be the products of domain modeling; we concur that a <lb/>broader vision should be adopted by the software engineering community. However, we feel our focus is <lb/>justified as a consequence of years of work in the areas of reuse, software architectures, and software gen-<lb/>erators [Bat92-94]. For us to have demonstrated anything less than software system generation on our <lb/>projects would not have been sufficient to convince sponsors of the importance and viability of our con-<lb/>cepts of domain modeling. We believe that the demand for such concrete results is universal, and the prod-<lb/>ucts that we have identified go a long way for justifying the effort and commitment needed for domain <lb/>modeling. <lb/></body>

			<listBibl>4 References <lb/>[Bat92] <lb/>D. Batory and S. O&apos;Malley, &quot;The Design and Implementation of Hierarchical Software <lb/>Systems with Reusable Components&quot;, ACM Transactions on Software Engineering and <lb/>Methodology, October 1992. <lb/>[Bat93] <lb/>D. Batory, L. Coglianese, M. Goodwin, and S. Shafer. &quot;Creating Reference Architectures: An <lb/>Example from Avionics&quot;, ADAGE Tech. Rep. UT-93-06, 1993. <lb/>[Bat94] <lb/>D. Batory, V. Singhal, J. Thomas, S. Dasari, B. Geraci, and M. Sirkin, &quot;The GenVoca Model of <lb/>Software-System Generators&quot;, to appear in IEEE Software, September 1994. <lb/>[Big93] <lb/>T. Biggerstaff, &quot;An Assessment and Analysis of Software Reuse&quot;, in Advances in Computers, <lb/>Vol. 34, Academic Press, 1992. <lb/>[Big94] <lb/>T. Biggerstaff, &quot;The Library Scaling Problem and the Limits of Concrete Component Reuse&quot;, <lb/>3rd Conference on Software Reuse, Rio de Janerio, November 1994. <lb/>[Gar94] <lb/>D. Garlan and M. Shaw, &quot;An Introduction to Software Architecture&quot;, in Adances in Software <lb/>Engineering and Knowledge Engineering, Volume I, World Scientific Publishing Company, <lb/>1993. <lb/>[Pou94] <lb/>J. Poulin and W. Tracz, &quot;WISR&apos;93 Reuse Workshop Summary&quot;, ACM Software Engineering <lb/>Notes, Vol. 19 #1, January 1994. </listBibl>


	</text>
</tei>
