<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>Protocols for Collecting Responses <lb/>in Multi-hop Radio Networks <lb/>Chungki Lee <lb/>James E. Burns <lb/>Mostafa H. Ammar <lb/>GIT{CC{92/28 <lb/>June 1992 <lb/>Abstract <lb/>The problem of collecting responses in multi-hop radio networks is consid-<lb/>ered. A given node, called the source, is to collect a speci ed number of <lb/>responses from nodes in a radio network. The problem arises in several <lb/>applications of distributed systems. A deterministic and a randomized pro-<lb/>tocol for the problem are presented. The two protocols are analyzed and <lb/>their performance is compared. Conclusions are drawn about the suitability <lb/>of our protocols in various network environments. <lb/>College of Computing <lb/>Georgia Institute of Technology <lb/>Atlanta, Georgia 30332{0280 <lb/>THIS PAGE INTENTIONALLY LEFT BLANK. <lb/></front>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/>1 <lb/></note>

			<body>1 Introduction <lb/>A radio network is a collection of radios that communicate with each other over radio <lb/>channels. If all units in a radio network can hear each other, the radio network is <lb/>single-hop; otherwise it is multi-hop and repeaters must be used to provide network <lb/>connectivity. In this paper, the problem of collecting responses in multi-hop radio <lb/>networks is considered. A given node, called the source, is to collect a speci ed number <lb/>of responses from nodes in a radio network. Developing protocols for the problem in <lb/>multi-hop radio networks is a complicated task. The di culties emerge both from the <lb/>unknown topology of the network and from the possibility of con icts (i.e., situations <lb/>when several neighbors of a node transmit simultaneously and the node receives only <lb/>noise). The collection problem arises in several applications of distributed systems. In <lb/>a distributed database system, a central node broadcasts a series of queries and collects <lb/>the responses to the queries from multiple nodes Nat85]. In a computer network, a <lb/>node may need to nd the location of multiple instances of a resource MV88], or to <lb/>know the network topology for routing and control purposes HS88]. <lb/>The collection problem has been studied in several di erent contexts AS87, AR90, <lb/>BII89, WS89]. Afek and Saks AS87] introduced a \token collection&quot; problem, in which <lb/>a distinguished node collects a speci ed number of tokens from other nodes in a point-to-<lb/>point computer network. Tokens appear spontaneously at the nodes at arbitrary times. <lb/>Ammar and Rouskas AR90] introduced a \response collection&quot; problem in which a <lb/>collector is interested in gathering a set of responses from a number of potential respon-<lb/>dents. The collector and respondents communicate over a shared single-hop channel <lb/>with feedback. They de ned three collection objectives and investigated a suite of <lb/>protocols that can be used to achieve these objectives. Wang and Silvester WS89] pre-<lb/>sented protocols to optimize the performance of response tra c for broadcast messages <lb/>in a single-hop radio network. They assumed that the exact number of nodes is un-<lb/>known, which makes the problem nontrivial. In multi-hop radio networks, Bar-Yehuda <lb/>et al. BII89] developed a randomized collection protocol as a subprotocol of multiple <lb/>broadcasts. This protocol sends the broadcast messages from multiple sources to the <lb/>root of the BFS tree that has been constructed before any broadcasts are performed. <lb/>In this paper, a deterministic protocol and a randomized protocol for collecting <lb/>responses in multi-hop radio networks are presented. The performance of the two <lb/>protocols is analyzed and conclusions are drawn about the suitability of the protocols <lb/>in various network environments. <lb/>This paper is organized as follows. In Section 2, a model of radio networks is <lb/>presented, and in Section 3 the collection problem is de ned. A simple depth rst search <lb/>protocol is described in Section 4, while Sections 5 and 6 describe our deterministic <lb/>and randomized protocols, respectively. Section 7 compares the performance of our <lb/>protocols. Section 8 concludes the paper. <lb/></body>

			<page>2 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>2 The Model <lb/>A radio network is modeled by a connected, undirected graph whose vertices represent <lb/>nodes (radios) and whose edges represent two-way communication channels between <lb/>their incident vertices. Thus, we assume that adjacent radios are of comparable power <lb/>and are within range of each other. Nodes communicate in synchronous timeslots using <lb/>radio transmissions. All nodes agree on the beginning of each timeslot. The length <lb/>of a timeslot is assumed to be at least as long as the transmission time of the longest <lb/>message plus the maximum propagation delay of messages between any pair of nodes. <lb/>The properties of radio communication are described by the following rules. In each <lb/>timeslot, a node can act either as a transmitter or as a receiver, but not both. Thus, a <lb/>transmitting node cannot directly detect whether or not its transmission is successful. <lb/>A node receives a message in a timeslot if it acts as a receiver and exactly one of its <lb/>neighbors transmits. If more than one neighbor of a node transmits, a collision occurs. <lb/>Except for collisions, channels are assumed to be error-free. We consider two possible <lb/>cases for collisions: <lb/>1. Collision Detection (CD). If a collision occurs, a receiving node detects the <lb/>presence of a collision by the amplitude of noise during the timeslot. <lb/>2. No Collision Detection (NCD). Collisions are indistinguishable from back-<lb/>ground noise, so receiving nodes cannot determine reliably that a collision has <lb/>occurred. <lb/>Obviously, protocols that do not rely on collision detection are more robust than those <lb/>that do. Our deterministic protocol does not rely on collision detection, while our <lb/>randomized protocol uses collision detection only for initial synchronization. In the <lb/>concluding section we consider methods for eliminating the CD assumption of the ran-<lb/>domized protocol. <lb/> 3 The Collection Problem <lb/>The Collection Problem simulates the task of gathering information (referred to as <lb/>responses) from remote nodes and consolidating it within a single node (referred to as <lb/>the source). A given execution of a protocol for the Collection Problem is parameterized <lb/>by an integer K, 0 &lt; K &lt; N, indicating the number of responses to be gathered, where <lb/>N is the number of nodes in the network. Other parameters of the network that are <lb/>important for analysis are <lb/>D, the diameter of the network. <lb/>, the maximum degree over all nodes in the network. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>3 <lb/></page>

			<body>Our randomized protocol makes use of the quantity , and so assumes this to be known <lb/>globally (it is su cient to know an upper bound on ). The only other knowledge about <lb/>the network required by our protocols is that each node has a unique identi er (ID) <lb/>and initially knows the ID&apos;s of its neighbors. <lb/>The primary complexity measure considered in this paper is the expected execution <lb/>time (i.e., the number of timeslots to collect at least K responses). Secondary cost <lb/>items, message size and local time and space requirements, are not considered here. <lb/>Besides the communication characteristics of the radio network, the e ciency of <lb/>collection protocols is sensitive to the initial conditions of the network. For simplicity <lb/>in this paper, we assume that <lb/>Only a single collection by a single source is in progress at any point in time. <lb/>Each node has a response to send. <lb/>For the randomized protocol, the type of information to be collected is known in <lb/>advance. <lb/>In the absence of the last assumption, a preliminary broadcast phase could be used to <lb/>designate the information to be collected. <lb/>4 The Depth First Search Protocol <lb/>A simple and obvious protocol, based on depth rst search, exists for any (connected) <lb/>radio network. The depth rst search (DFS) protocol can be viewed as moving a token <lb/>along the edges of a depth rst search tree. The token contains the ID&apos;s of previously <lb/>visited nodes, so that back edges (i.e., those edges (u; v) that are not in the DFS tree <lb/>and are connecting a node u to a previously visited node v) need not be followed. When <lb/>backing up from a fully explored node, the token adds the response of that node to its <lb/>information. Thus, a token message must be large enough to contain O(N) ID&apos;s and <lb/>O(K) responses. Since back edges are not traversed, the DFS protocol takes exactly <lb/>2K timeslots to explore the whole network (if K &lt; N 1, only part of the network is <lb/>explored). <lb/>The DFS protocol as described does not make use of the broadcast nature of the <lb/>radio medium. Therefore, it will be e cient only if the diameter of the network is <lb/>approximately equal to the number of nodes, e.g., a line graph. For arbitrary networks <lb/>with diameter typically less than N we expect other approaches to be superior. We <lb/>consider two protocols, one deterministic and one randomized. <lb/></body>

			<page>4 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>5 The Deterministic Collection Protocol <lb/>5.1 Informal Description <lb/>De ne the l-hop nodes to be those that are at distance l from the source and the lth <lb/>level, or level(l), to be the set of l-hop nodes. The main idea of the protocol is to <lb/>collect responses in phases: rst from one-hop nodes, then two-hop nodes, then three-<lb/>hop nodes, etc., until at least K responses are collected. <lb/>The l-hop topology of the network is a graph consisting of all the ID&apos;s of all nodes <lb/>within distance l of the source and of all edges between such nodes, except for edges <lb/>between nodes at distance l. At the end of phase (l 1) of the protocol, the source knows <lb/>the l-hop topology. (Note that initially, l = 1 and the source knows its neighbors | the <lb/>one-hop nodes, so this condition is true at the beginning of the protocol.) The lth phase <lb/>consists of a sequence of rounds, each of which gathers information from some of the <lb/>l-hop nodes. In addition to the responses from the l-hop nodes, information about the <lb/>ID&apos;s of their neighbors is also returned. This allows the source to determine the (l + 1)-<lb/>hop topology in preparation for the next phase. The protocol terminates when the <lb/>source has received at least K responses, after at most D phases. The major nontrivial <lb/>parts of the protocol are described next. A complete description of the protocol is given <lb/>in the appendix. <lb/>5.1.1 Collecting Responses from l-hop Nodes <lb/>Assume that the source knows the l-hop topology at the beginning of phase l. The source <lb/>uses two dynamic storage structures, called the current topology and the new topology, <lb/>during the phase. At the beginning of the phase, current topology = new topology = <lb/>l-hop topology. <lb/>From any topology, we can construct a directed acyclic graph (DAG) by deleting <lb/>edges between nodes at the same level and directing the remaining edges away from the <lb/>source. In discussing the protocol, it is convenient to de ne a node u to be a descendant <lb/>of a node v if v is on some path in the DAG from the source to u. In this case, we also <lb/>say v is above u and u is below v. Similarly, messages going to descendants on the next <lb/>level go down, while those going to ancestors above go up. <lb/>At the beginning of each round of the phase, the source constructs a communication <lb/>tree for a subset of nodes within the current topology. The communication tree assigns <lb/>a timeslot for each node in the tree to send (or forward) responses from the l-hop <lb/>nodes. The construction technique guarantees that there is at least one (previously <lb/>uncollected) l-hop node in the tree and that all communications are collision-free (as <lb/>far as the intended recipient of each message is concerned). At the end of the round, <lb/>the source modi es the new topology to include information from the leaves of the <lb/>communication tree. The current topology is also modi ed: All leaves in that round&apos;s <lb/>communication tree are deleted from the current topology. Also, a recursive procedure <lb/>is used to delete any nodes that no longer have l-hop nodes as descendants. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>5 <lb/></page>

			<body>In each round, at least one l-hop node is eliminated from the current topology. <lb/>The phase terminates when all l-hop nodes have been eliminated. At this point, the <lb/>new topology is equal to the (l + 1)-hop topology, and the next phase is ready to begin <lb/>(unless at least K responses have already been collected, in which case the protocol <lb/>terminates). <lb/>Two types of messages are used by the protocol. <lb/>Collect messages are sent down the communication tree from the source and <lb/>forwarded in the next timeslot after reception by all internal nodes in the tree. <lb/>(If necessary, Collect messages can also specify what type of information is to <lb/>be collected.) A Collect message contains the communication tree (with timeslot <lb/>assignments) for the current round. Collect messages do not collide at any nodes <lb/>in the communication tree at the next level, and so are received at the leaves of <lb/>the communication tree in exactly l timeslots. <lb/>Reply messages are sent up from the leaves and forwarded by the internal nodes. <lb/>Unlike Collect messages, Reply messages are only sent when the timeslot assigned <lb/>to the sending node arrives (timeslot assignment is done relative to the time a node <lb/>is ready to send). These timeslot assignments are designed to avoid collisions at <lb/>the receiving nodes in the level above. The Reply message sent by a leaf contains <lb/>the response of that node, its ID, and the IDs of its neighbors. Each internal node <lb/>aggregates the Reply messages from its children and sends the aggregated Reply <lb/>message to its parent in its assigned timeslot. <lb/>The protocol to collect responses from all l-hop nodes is described in Figure 1. <lb/>The value numwaitslot i represents the assigned timeslot of node i as stored in the <lb/>communication tree T. An explanation of how communication trees are built and <lb/>timeslots are assigned is presented in the following subsections. <lb/> 5.1.2 Building a Communication Tree of Height l <lb/>We build communication trees so that a message initiated by the source will be for-<lb/>warded to the leaves of the tree in l timeslots without collisions. Note that there is at <lb/>least one uncollected l-hop node before we begin building a tree, since otherwise the <lb/>lth phase would terminate. The tree is constructed level by level top-down. That is, <lb/>nodes of level h, 1 h &lt; l, are included in the tree before any node of level h + 1. <lb/>Nodes from level h are added to the tree one node at a time. If a node of level h is <lb/>included in the tree, another node of level h cannot be included whose simultaneous <lb/>transmission would collide at their common neighbor(s) at level h + 1, because collision <lb/>is not allowed at intended receivers in the protocol. We could add nodes of level h in <lb/>any order, but the heuristic attempts to cover as many leaves as possible by including <lb/>nodes in the order of the number of l-hop nodes that are their descendants. <lb/>The heuristic is based on the rate of a node. Let node i be an internal node in the <lb/>current topology. The rate of node i, Rate i], is de ned to be the number of l-hop nodes <lb/></body>

			<page>6 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>1. Sketch of the protocol at the source: <lb/>(Initially, new topology contains the source and its neighbors.) <lb/>current topology = new topology. <lb/>repeat <lb/>Build a communication tree T (a subgraph of the current topology) <lb/>with some l-hop nodes as leaves. <lb/>Assign timeslots for nodes in the tree to send their Reply messages. <lb/>send a Collect message (which includes T). <lb/>receive a Reply message from each child in the communication tree. <lb/>if at least K responses from distinct nodes have been received, then exit. <lb/>Update new topology using new neighbors of leaves from Reply messages. <lb/>Update current topology by deleting leaves of the communication tree <lb/>and (recursively) internal nodes without l-hop nodes as descendants. <lb/>until the source receives responses from all l-hop nodes. <lb/>2. Sketch of the protocol at non-source node i: <lb/>Set Counting := False; t := 0. <lb/>a. On receiving a Collect message containing communication tree T, <lb/>if i is an internal node in T, <lb/>then forward Collect in the following timeslot; <lb/>also, set M to empty. <lb/>else if i is a leaf node in T, <lb/>then set M to the Reply message for this node; <lb/>also, set Counting := True. <lb/>else do nothing. <lb/>b. On receiving a Reply message, <lb/>if i is in T and Reply is from a child of i, <lb/>then concatenate Reply to M; <lb/>also, if Reply&apos;s have been received from all children, set Counting := True. <lb/>else do nothing. <lb/>c. For each timeslot, <lb/>if Counting <lb/>then if t = numwaitslot i , <lb/>then send M; <lb/>also, set Counting := False; t := 0. <lb/>else t := t + 1. <lb/>Figure 1: The Protocol to Collect Responses from l-hop Nodes <lb/>in the current topology that are descendants of node i. In the absence of collisions, <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>7 <lb/></page>

			<body>Rate i] would represent the number of l-hop nodes that could receive a message from <lb/>node i. Due to collisions, some of those l-hop nodes might not receive the message from <lb/>node i at all. However, Rate i] is an approximation of the number of l-hop nodes that <lb/>may eventually occur in the tree if node i is included. Note that nding an optimal tree <lb/>with the maximum number of l-hop nodes is too expensive because we would have to <lb/>consider all possible trees of height l. <lb/>Two nodes at level h are said to con ict (relative to the current topology) if they <lb/>have a common descendant at level h + 1. Our protocol uses the easily computed set, <lb/>Con ictNodes i], which consists of all nodes that are at the same level as i and con ict <lb/>with i. <lb/>Now we are ready to describe in detail the construction of a communication tree. <lb/>Initially, the tree includes only the source as its root. The nodes of level h, 1 h &lt; l, <lb/>are included as follows. All nodes of distance h that are neighbors of any node of level <lb/>h 1 in the tree are nodes that may possibly be included. Among them, we choose a <lb/>node with the maximum Rate, say node i. Ties are broken in favor of smaller ID. Node <lb/>i is added to the tree, while all nodes in Con ictNodes i] are excluded. We repeat this <lb/>selection process until the set of nodes at level h that have not already been included <lb/>is empty. For level l (the level of the leaves), all nodes that are neighbors of previously <lb/>included nodes at level l 1 are included in the tree. The algorithm to construct a <lb/>communication tree of height l is described in Figure 2. Assigning timeslots to the <lb/>nodes of the communication tree is discussed in the following subsection. <lb/>5.1.3 Computing Timeslot Assignments <lb/>Assume that a communication tree T of height l has been constructed. The Collect <lb/>message initiated by the source can be forwarded to all nodes on the tree without <lb/>collisions. However, deciding when nodes should send Reply messages up the tree is <lb/>more complicated. Because internal nodes send (aggregate) Reply messages only after <lb/>they receive Reply messages from their children, the timeslots to send their Reply <lb/>messages are assigned in a bottom-up fashion. <lb/>It is easy to assign timeslots to leaves of the tree. For each node i at level l 1, order <lb/>the children of node i in increasing order of their ID&apos;s and assign timeslots 0; 1; 2; . . . to <lb/>them in that order. Note that children of di erent nodes at level l 1 are scheduled in <lb/>the same timeslots, but no collisions occur since their parents do not con ict. <lb/>Let us consider the problem of assigning timeslots to internal nodes of the tree. Each <lb/>node has a rst timeslot in which it is ready to transmit its Reply message (this is the <lb/>next timeslot after receiving Reply messages from all of its children in T). For a node <lb/>x, we assign numwaitslot x] to be the number of timeslots a node must wait (possibly <lb/>0) after it is ready to send. Two types of collisions must be avoided: <lb/>Level con ict. Collisions between nodes x and y at the same level caused by x sending <lb/>to its parent at the same time y is receiving from a child. This type of con ict <lb/>only occurs if x and y are connected by an edge of the network. <lb/></body>

			<page>8 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>Compute Rate x], Con ictNodes x] for each node x in the current topology <lb/>dp := 1 <lb/>CurrentNodes := neighbors of the source <lb/>T := fsourceg <lb/>while dp &lt; l do <lb/>NextNodes := ;; <lb/>while CurrentNodes 6 = ; do <lb/>Let y be a node with maximum Rate over nodes in CurrentNodes; <lb/>T := T fyg; <lb/>CurrentNodes := CurrentNodes fyg fzjz 2 Con ictNodes y]g; <lb/>NextNodes := NextNodes fw 2 level(dp + 1)jw adjacent to yg <lb/>end <lb/>CurrentNodes := NextNodes; <lb/>dp := dp + 1 <lb/>end <lb/>T := T CurrentNodes <lb/>Figure 2: The Algorithm to Build a Communication Tree, T, of Height l <lb/>Sibling con ict. Collisions of Reply messages from siblings to their common parent <lb/>in T. <lb/>Level con icts are always resolved in favor of the node receiving a Reply message from a <lb/>deeper level. Sibling con icts are resolved in favor of nodes with lower ID&apos;s. We assign <lb/>numwaitslot x] to be the smallest value so that x has neither a level or sibling con ict <lb/>in the assigned timeslot. Details of the algorithm are given in Figure 3. <lb/>5.1.4 Example <lb/>In order to illustrate the protocol, we execute it on a sample network given in Figure 4. <lb/>The IDs of nodes are represented by numbers inside nodes and nodes connected by edges <lb/>can communicate. Node 0 is the source. Suppose that the source has already collected <lb/>responses from one-hop and two-hop nodes. The source wants to collect responses from <lb/>three-hop nodes. The execution of the protocol by non-source nodes is straightforward <lb/>and is omitted. The execution of the protocol by the source is as follows. <lb/>1. Before a tree is constructed, rates of one-hop and two-hop nodes are computed <lb/>with their con icting nodes. Rate 1] is 5 because node 8, 9, 10, 11, and 12 are <lb/>three-hop nodes and are descendants of node 1 in the DAG de ned above. Sim-<lb/>ilarly, Rate 2] = 3. Also, Rate 4] = 3, Rate 3] = Rate 6] = Rate 7] = 2, and <lb/>Rate 5] = 1. Con ictNodes 1] = Con ictNodes 2] = ; because node 1 and 2 have <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>9 <lb/></page>

			<body>(* sibling x] is a set of siblings of node x *) <lb/>(* children x] is a set of children of node x *) <lb/>for node x 2 T \ level(l) do <lb/>Let x be the j-th element in sibling x]; oldslotno x] := 1; numwaitslot x] := j 1 <lb/>for d := l 1 downto 1 do (* decide when internal nodes in T are to send Reply *) <lb/>NT := T \ level(d); <lb/>for node x 2 NT do <lb/>oldslotno x] := max(oldslotno y] + numwaitslot y]) + 1, where y 2 children x]; <lb/>newslotno x] := oldslotno x] <lb/>for node x 2 NT do <lb/>for node y 2 NT do <lb/>if y 6 = x and y adjacent to x then (* x may wait for y to nish collecting *) <lb/>if oldslotno x] oldslotno y] jchildren y]j then <lb/>newslotno x] := max (newslotno x]; oldslotno y]) <lb/>while NT 6 = ; do (* assign waiting timeslots *) <lb/>Let x be a node in NT; NT := NT sibling x]; <lb/>for node y 2 sibling x] do (* tie is broken in favor of smaller ID *) <lb/>Let newslotno y] be the j-th element in fnewslotno z] j z 2 sibling x]g; <lb/>index j] := y <lb/>cno := newslotno index 1]]; wno := 0; <lb/>numwaitslot index 1]] := wno + (cno oldslotno index 1]]); <lb/>for i := 2 to jsibling x]j do <lb/>if newslotno index i]] = cno then wno := wno + 1; <lb/>else cno := newslotno index i]]; <lb/>numwaitslot index i]] := wno + (newslotno index i]] oldslotno index i]]) <lb/>end <lb/>Figure 3: The Algorithm for Assigning Timeslots to the Nodes in T <lb/>no common neighbor of distance 2 and so can send simultaneously. Similarly, <lb/>Con ictNodes 5] = ;. However, Con ictNodes 3] = f4g and Con ictNodes 4] <lb/>= f3g because node 3 and 4 have a common neighbor (node 9) of distance <lb/>3 and their simultaneous transmissions will collide at the neighbor. Similarly, <lb/>Con ictNodes 6] = f7g and Con ictNodes 7] = f6g. <lb/>2. Now the source is ready to build a communication tree. The tree is built level-by-<lb/>level top-down. The source becomes the root. Then nodes of level 1 are included. <lb/>Node 1 is selected rst because Rate 1] = 5 &gt; 3 = Rate 2]. Since Con ictNodes 1] <lb/>is empty, node 2 is selected next. Now neighbors of node 1 and 2 of distance <lb/>2 (i.e., node 3, 4, 5, 6, and 7) become potential nodes that can be included as <lb/></body>

			<page>10 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>0 <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>8 <lb/>9 <lb/>10 11 12 <lb/>14 <lb/>15 <lb/>13 <lb/>Figure 4: The Sample Network <lb/>nodes of level 2. Node 4 is selected because it has the maximum rate. Now node <lb/>3 cannot be selected because Con ictNodes 4] = f3g. Then node 6 is selected <lb/>and so node 7 is excluded. Finally node 5 is selected. All neighbors of node 4, 5, <lb/>and 6 of distance 3 are included as leaves of the tree. The nal tree is shown in <lb/>Figure 5. The dotted lines represent non-tree edges. <lb/>3. The Collect message initiated by the source can be forwarded to all nodes on the <lb/>tree in 3 timeslots without collisions. Now consider assigning timeslots for nodes to <lb/>send Reply messages. This is done in a bottom-up fashion. Let numwaitslot x] be <lb/>the number of timeslots to wait after node x is ready to send its Reply message. <lb/>Node 9, 10, and 11 are siblings and so can send their Reply messages in the <lb/>ascending order of their ID&apos;s. Thus numwaitslot 9] = 0, numwaitslot 10] = 1, and <lb/>numwaitslot 11] = 2. Similarly, numwaitslot 13] = 0 and numwaitslot 14] = 1. <lb/>Also numwaitslot 12] = 0. Consider nodes of level 2. Node 5 is ready to send a <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>11 <lb/></page>

			<body>0 <lb/>1 <lb/>2 <lb/>4 <lb/>5 <lb/>6 <lb/>9 <lb/>10 11 12 <lb/>14 <lb/>13 <lb/>Figure 5: The Communication Tree <lb/>Reply message in timeslot 5 but must wait for node 4 to nish receiving all Reply <lb/>messages because a level con ict due to an edge (4,5) must be avoided (i.e., a <lb/>transmission without waiting would collide at node 4 with that of node 10). Then <lb/>it must wait for one more timeslot because a sibling con ict must be avoided and <lb/>its ID is greater than 4. Therefore numwaitslot 5] = 3. On the other hand, node <lb/>4 need not wait after it receives all Reply messages because its ID is less than 5. <lb/>Thus numwaitslot 4] = 0. Also numwaitslot 6] = 0 because node 6 has neither a <lb/>level nor a sibling con ict. Finally consider nodes of level 1. Node 2 must wait <lb/>for node 1 to receive all Reply messages because a level con ict due to an edge <lb/>(1,2) must be avoided (i.e., a transmission without waiting would collide at node <lb/>1 with that of node 4). Then it must wait for one more timeslot because a sibling <lb/>con ict must be avoided and its ID is greater than 1. Therefore numwaitslot 2] = <lb/>3. Finally, numwaitslot 1] = 0. <lb/></body>

			<page>12 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>4. The source sends Collect message with the communication tree (containing times-<lb/>lot assignments) down the tree. It will receive all Reply messages from leaves of <lb/>the tree in 10 timeslots. Then it updates new topology by inserting new edges, i.e., <lb/>(9,10) and (14,15). Also it updates current topology by deleting leaves and their <lb/>incident edges rst. Since nodes 4, 5, and 6 have no neighbors of distance 3, they <lb/>are deleted with their incident edges. The reduced network is shown in Figure 6. <lb/>The second tree built by the source is the reduced network, except for edge (1,2). <lb/>After the source collects responses from node 8 and 15 using the second tree, the <lb/>protocol terminates because responses have been received from all 3-hop nodes <lb/>(and, by assumption, K &lt; N). <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>7 <lb/>8 <lb/>15 <lb/>Figure 6: The Reduced Network <lb/>5.2 Correctness of the Deterministic Protocol <lb/>We now outline a proof that the deterministic protocol is correct. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>13 <lb/></page>

			<body>Lemma 1. For each phase l, the communication trees built in each round have at least <lb/>one leaf at level l. Furthermore, no communication trees in di erent rounds have any <lb/>leaves in common. This implies phase l terminates in at most jlevel(l)j rounds. <lb/>Proof: Before the source starts to collect responses from l-hop nodes, there is at least <lb/>one node at hop l in current topology. Otherwise the source would not start phase l. <lb/>At the beginning of each round, every node in the current topology has at least one <lb/>descendant at level l (otherwise, it would have been deleted by the recursive pruning <lb/>procedure). Since the rst node considered at each level is always included in the com-<lb/>munication tree, the tree has at least one node from each level through l, and hence has <lb/>a leaf at level l. At the end of each round, all leaves of the current communication tree <lb/>are deleted from the current topology, and so cannot occur in subsequent communica-<lb/>tion trees of the phase. This implies that communication trees in the same phase do <lb/>not have any leaves at level l in common. Since there are only level(l) nodes at level l, <lb/>this implies that there are at most level(l) rounds in phase l. <lb/>Lemma 2. No messages sent in any round of the protocol collide at their intended <lb/>recipients. In particular, no parent&apos;s transmission of Collect message will collide in its <lb/>child(ren) and no child&apos;s transmission of Reply message will collide in the child&apos;s parent. <lb/>Proof: During the execution of the protocol, a non-source node can transmit a message <lb/>only after the node receives the Collect message initiated by the source that shows that <lb/>the node is a part of the current communication tree. Assume that node i of level h 1 <lb/>has received a Collect message. If node i is an internal node of the tree, it forwards the <lb/>message in the following timeslot. The forwarded message will not collide at any child <lb/>of node i because the nodes in Con ictNodes i] are not included in the tree. Thus the <lb/>Collect message is forwarded to all nodes on the tree without collisions. <lb/>Consider the Reply message sent by node i of level h 1. Let node k be a parent <lb/>of node i. If node i is a leaf, its Reply message will not collide at node k because only <lb/>one child of node k sends a Reply message in any timeslot and any node of level h 1 <lb/>adjacent to node k, if any, delays sending Reply message until node k nishes collecting <lb/>all its Reply messages. If node i is an internal node, it sends an (aggregate) Reply <lb/>message only after it receives all Reply messages from its children. The transmission of <lb/>its Reply message could collide at node k only with the Reply messages from its siblings <lb/>or any node of level h 1 adjacent to node k. However, only one child of node k sends <lb/>a Reply message in a timeslot, and a node of level h 1 adjacent to node k will not <lb/>send a Reply message simultaneously if its transmission interferes with that of node i. <lb/>Therefore no collision occurs at node k. <lb/>Theorem 1. The deterministic collection protocol is correct. That is, the source col-<lb/>lects at least K responses in a nite time using the protocol. <lb/></body>

			<page>14 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>Proof: Since the protocol only terminates early if at least K responses are collected, we <lb/>can assume K = N 1 without loss of generality. We show by induction on phases that <lb/>if phase l begins with new topology = l-hop topology, then at the end of the phase the <lb/>source has collected responses from all l-hop nodes and ends the phase with new topology <lb/>= (l + 1)-hop topology. This implies the claim of the theorem. <lb/>For the base case, l = 1, the new topology is initialized to the 1-hop topology. The <lb/>source builds a communication tree of height 1 that includes all its neighbors. The nodes <lb/>are ordered in the ascending order of their ID&apos;s and are assigned timeslots 0; 1; 2; . . . to <lb/>send their Reply messages in that order. The messages are received without collisions <lb/>by Lemma 2. Thus, the source correctly receives responses from all 1-hop nodes. Also, <lb/>the information from the source&apos;s neighbors is incorporated into new topology, which is <lb/>then equal to the 2-hop topology, as required. <lb/>Now, consider phase l &gt; 1. By the inductive assumption, the phase begins with <lb/>new topology = l-hop topology. The source builds a communication tree of height l <lb/>level by level. All leaves of the communication tree are nodes of distance l, and the <lb/>tree has at least one node of distance l by Lemma 1. By Lemma 2, the source receives <lb/>Reply messages from all leaves in the tree without collisions. Thus the source collects <lb/>responses from all nodes of distance l. Since the ID&apos;s of the leaves&apos; neighbors are <lb/>carried along with the responses and incorporated into new topology, the phase ends <lb/>with new topology = (l + 1)-hop topology, as required. <lb/>We will discuss the performance of the deterministic protocol in Section 7, but rst <lb/>we will describe the randomized protocol. <lb/>6 The Randomized Collection Protocol <lb/>Bar-Yehuda et al. developed a randomized collection protocol as a subprotocol of <lb/>multiple broadcasts BII89]. The protocol sends the broadcast messages from multiple <lb/>sources to the root of a breadth rst search (BFS) tree that is constructed before <lb/>any broadcasts are performed. Unlike this protocol, our randomized protocol does <lb/>not construct a BFS tree, which is relatively costly. Thus the deterministic active <lb/>acknowledgement protocol in BII89] cannot be used. Instead, we use passive (or echo) <lb/>acknowledgements. In addition to assumptions in Section 2, we assume each node <lb/>knows , the maximum degree over all nodes in the network (actually, knowledge of <lb/>a reasonable upper bound on is su cient). We also make use of collision detection <lb/>(CD) in the initial phase of the protocol. Finally, we assume that each node is initially <lb/>quiet. <lb/>Two kinds of messages are used: A Collect message is sent by the source, and <lb/>Reply messages (containing at least one response) are sent by each node. Unlike the <lb/>deterministic protocol, topology information is not collected, and ID&apos;s are used only to <lb/>distinguish di erent Reply messages. As in the deterministic protocol, Reply messages <lb/>are aggregated together at intermediate nodes. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>15 <lb/></page>

			<body>6.1 Informal Description <lb/>The rst idea of the protocol is to divide all nodes into three groups in such a way that <lb/>nodes in di erent groups do not interfere with each other. (See Figure 7.) For i = 0; 1; 2, <lb/>group i is de ned to be the set of nodes at all distances d such that d = i mod 3 from <lb/>the source. Every timeslot is allocated to exactly one of the groups (each group gets <lb/>one-third of the timeslots). Nodes may send messages only in allocated timeslots. On <lb/>three succeeding timeslots, rst nodes in group 0 may send, then those in group 1, <lb/>and then those in group 2. Since simultaneously sending nodes (at di erent levels) <lb/>are distance two (or more) apart, collisions can only occur if two nodes from the same <lb/>level send to a common destination. All the nodes in a group know which timeslots are <lb/>allocated for their use. <lb/>1 <lb/>10 <lb/>1 <lb/>10 <lb/>8 <lb/>12 <lb/>8 <lb/>12 <lb/>2 <lb/>3 <lb/>2 <lb/>3 <lb/>5 <lb/>0 <lb/>5 <lb/>0 <lb/>17 <lb/>18 <lb/>17 <lb/>18 <lb/>16 <lb/>16 <lb/>14 <lb/>9 <lb/>14 <lb/>9 <lb/>7 <lb/>7 <lb/>6 <lb/>15 <lb/>6 <lb/>15 <lb/>Group 1 <lb/>Group 0 <lb/>Group 2 <lb/>Group 1 <lb/>Group 0 <lb/>Figure 7: Example of Groups in the Randomized Protocol <lb/>Group identity is established in the rst phase of the protocol. The source sends <lb/>a Collect message to its neighbors, and all other nodes forward this message to their <lb/>neighbors. Since we make use of CD, collisions can be treated identically to Collect <lb/>messages in this rst phase. This guarantees that <lb/></body>

			<page>16 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>1. All nodes begin the protocol within D timeslots from the time the source sends <lb/>its Collect message. <lb/>2. For any integer d, all nodes at distance d from the source begin their protocols at <lb/>the same time, and thus are synchronized. <lb/>3. All nodes in group i, for i = 0; 1; 2, are allocated to send in the same timeslots <lb/>and no nodes in distinct groups are allocated to send at the same time. <lb/>The second idea of the protocol is to pass response messages closer to the source in <lb/>\bucket brigade&quot; fashion. From the point of view of a non-source node, three successive <lb/>rounds can be considered as: (possibly) send known information, receive messages from <lb/>nodes further from the source, and receive messages from nodes closer to the source. <lb/>If new information is received from further away, this is added to the information <lb/>to be moved closer to the source. Messages from closer to the source are treated as <lb/>acknowledgements: information that has successfully been received at a node closer to <lb/>the source need not be sent again. Note that collision detection is not used in this part <lb/>of the protocol. <lb/>The nal idea of the protocol is to use a random backo procedure to avoid (with <lb/>non-zero probability) collisions and move information closer to the source and send <lb/>acknowledgements away from the source. For each node, a succession of dlog e + <lb/>1 allocated timeslots constitutes a response cycle. (Recall that all nodes at a given <lb/>distance from the source agree on when response cycles begin and end and that allocated <lb/>timeslots occur every third timeslot.) An active node is a node with at least one <lb/>unacknowledged response to send. An active node may send its information at most <lb/>twice in a response cycle. All active nodes send in the rst timeslot of the cycle. In <lb/>succeeding timeslots, each active node ips an unbiased random binary coin. The rst <lb/>time (if it occurs) in a response cycle that an active node ips a 1 (\heads&quot;), it sends its <lb/>information and becomes inactive. Thus, all nodes in a group send in the rst allocated <lb/>timeslot of a response cycle, about 1 <lb/>2 in the second allocated timeslot, about 1 <lb/>4 in the <lb/>third, etc. Since at most <lb/>2 nodes can con ict at nodes that are outside of the <lb/>sending group, collision-free transmission occurs with non-zero probability, as will be <lb/>shown. <lb/>The randomized protocol for non-source nodes is described in Figure 8. To guarantee <lb/>the termination of the protocol at non-source nodes, we limit the time that a non-source <lb/>node runs its protocol to a threshold value. Due to the random nature of the protocol, <lb/>only if the threshold value is in nite is the protocol guaranteed to collect the desired <lb/>number of responses before termination. The source, knowing the threshold value, will <lb/>need to rerun the protocol if it did not achieve its collection objective upon termination. <lb/>We envision the use of a threshold value that will make the likelihood of not achieving <lb/>a collection objective small. The protocol followed by the source is straightforward and <lb/>is omitted. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>17 <lb/></page>

			<body>wait until a message is received or a collision is detected for the rst time <lb/>Bu er := f(i; response i ; unmarked)g; Active := True; t := 0; ts := 0 <lb/>send a Reply message containing all unmarked responses in Bu er <lb/>repeat <lb/>At the next timeslot: (receiving from below) <lb/>if a Reply message is received <lb/>then add any new responses in the message to Bu er <lb/>else do nothing. <lb/>At the next timeslot: (receiving from above) <lb/>if a Reply message is received <lb/>then mark any corresponding messages in Bu er <lb/>else do nothing. <lb/>At the next timeslot: (allocated for sending) <lb/>if t dlog e then <lb/>Active := False; t := 0 <lb/>if there are any unmarked responses in Bu er, <lb/>send a Reply message containing unmarked responses in Bu er; <lb/>also, Active := True. <lb/>else (so, t &lt; dlog e) <lb/>if Active = True <lb/>then ip a binary coin <lb/>if coin = 1 <lb/>then send a Reply message containing all unmarked responses in Bu er; <lb/>also, Active := False. <lb/>t := t + 1; ts := ts + 1 <lb/>until ts &gt; threshold <lb/>Figure 8: Sketch of the Randomized Protocol at Non-source Node i <lb/>6.2 Correctness of the Randomized Protocol <lb/>We estimate how fast Reply messages move up one level towards the source (and ac-<lb/>knowledgments move one level down). We begin with a lemma to compute the proba-<lb/>bility for a related problem. <lb/>The following lemma follows from an argument similar to the rst theorem of Bar-<lb/>Yehuda, et al. BGI87] and using the observation that a response cycle has at least log <lb/>timeslots in which x in the lemma may receive from its neighbors, while x has at most <lb/>neighbors. <lb/>Lemma 3. Let x be a node in the network and n(x) be the neighbors of x at the level <lb/>one more (less) than x&apos;s level. In a given response cycle for the nodes in n(x), if there <lb/></body>

			<page>18 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>is at least one active node in n(x), then x receives a message (acknowledgement) from <lb/>some node in n(x) during the response cycle with a positive probability. <lb/>From the protocol, it is clear that any responses that have not been collected by <lb/>the source are necessarily unmarked in some active node. The following theorem thus <lb/>implies that the randomized protocol terminates because the distance of the furthest <lb/>uncollected response decreases with positive probability in nite time. <lb/>For any node x, at any point during the execution of the randomized protocol, let <lb/>lev(x) be the minimal level such that x&apos;s response has been received by some node at <lb/>that level. (When lev(x) = 0, x&apos;s response has been received by the source.) Also, let <lb/>maxlev = maxflev(x)g over all (non-source) nodes. <lb/>Theorem 2. In every response cycle that begins with maxlev &gt; 0 there is a positive <lb/>probability that either maxlev decreases or the number of nodes x such that lev(x) = <lb/>maxlev decreases by the end of the cycle. <lb/>Proof: At the beginning of some response cycle with maxlev &gt; 0, let x be a node such <lb/>that lev(x) = maxlev, y be a node at level lev(x) that holds x&apos;s response, and z be <lb/>a neighbor of y at level lev(x) 1. Since z has at most neighbors at level lev(x), <lb/>Lemma 3 implies that there is a positive probability, say , that some neighbor of z <lb/>transmits to z in the cycle without collision. By symmetry, all neighbors of z that are <lb/>active are equally likely to be successful. Since y is necessarily active (since x&apos;s response <lb/>cannot have been acknowledged), the probability is at least = that lev(x) decreases <lb/>in the cycle. This implies the theorem. <lb/>7 Performance of the Protocols <lb/>Analysis of our protocols is very di cult for arbitrary graphs, so we rst consider some <lb/>graphs with simple structure that lend themselves to analysis. We then consider more <lb/>arbitrary graphs and resort to performance analysis by simulation. Two families of <lb/>graphs are considered: complete binary trees whose diameter is O(log N) and geometric <lb/>graphs (to be described below) whose diameter is O( <lb/>q <lb/>N <lb/>log N ): <lb/>7.1 Complete Binary Trees <lb/>Complete binary tree networks are not very realistic for radio networks, but provide a <lb/>simple structure that lends itself to analysis. <lb/>Theorem 3. Assume that the graph corresponding to a network is a complete binary <lb/>tree with N nodes, where N = 2 j 1 and j &gt; 1, and that the source wants to collect at <lb/>least K responses, where 0 &lt; K &lt; N. Then the time complexity of the deterministic <lb/>protocol in the network is 1:5blog Kc(blog Kc + 1). <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>19 <lb/></page>

			<body>Proof: In order to collect at least K responses, the source needs to consider only nodes <lb/>whose distance from the source is at most blog Kc. The number of timeslots needed <lb/>to collect responses from all nodes of distance i, 1 i blog Kc, is calculated. Only <lb/>one tree of height i is constructed to collect responses from them. Forwarding a Collect <lb/>message to all nodes on the tree takes i timeslots. Consider how many timeslots are <lb/>needed for the source to receive Reply messages from leaves of the tree. It takes two <lb/>timeslots to move Reply messages one level up the tree. Therefore the total number <lb/>of timeslots for the source to receive Reply messages from all nodes of distance i is 2i <lb/>since the height of the tree is i. Thus the total number of timeslots to collect responses <lb/>from all nodes of distance i is i + 2i = 3i. Therefore the time complexity of collecting <lb/>at least K responses is <lb/>blogKc X <lb/>i=1 <lb/>3i = 1:5blog Kc(blog Kc + 1): <lb/>Note that if the source knows that the network topology is a complete binary tree <lb/>with N nodes, there is an optimal protocol that requires 3blog Kc timeslots to collect <lb/>at least K responses. <lb/>We now explore the performance of the randomized protocol for complete binary <lb/>trees. <lb/>Theorem 4. Assume that the graph corresponding to a network is a complete binary <lb/>tree with N nodes, where N = 2 j 1 and j &gt; 1, and the source wants to collect at <lb/>least K responses. Then the expected time complexity of the randomized protocol is <lb/>bounded above by 18:6blog Nc. <lb/>Proof: Let us count the expected number of response cycles needed for nodes of equal <lb/>distance to send successfully their Reply messages. Consider two sibling nodes of equal <lb/>distance whose response cycles start at the same timeslot. Let P 2;i , i = 0; 1; 2, be the <lb/>probability that only i node(s) transmits its Reply message(s) successfully during its <lb/>response cycle given that each node has at least one response at the beginning of the <lb/>cycle. At the rst timeslot of the response cycle both nodes send their Reply messages <lb/>that are collided at their common neighbor. Then P 2;2 is 2( 1 <lb/>2 ) 2 ( 1 <lb/>2 ) = 1 <lb/>4 because one node <lb/>should transmit at the fourth timeslot of the response cycle and the other transmit at <lb/>the seventh timeslot of the response cycle. P 2;1 is 2( 1 <lb/>2 ) 2 ( 1 <lb/>2 ) + ( 1 <lb/>2 ) 2 2( 1 <lb/>2 ) 2 = 3 <lb/>8 because <lb/>only one node transmits either at the fourth timeslot or at the seventh timeslot. Thus <lb/>P 2;0 is 1 P 2;1 P 2;2 = 3 <lb/>8 . Note that the probability that if only one node has a Reply <lb/>message at the beginning of the response cycle, the node sends the message successfully <lb/>during the cycle is 1. <lb/>The probability that two sibling nodes with Reply messages send their Reply mes-<lb/>sages successfully by the rst response cycle is equal to P 2;2 = 1 <lb/>4 . The probability that <lb/></body>

			<page>20 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>two sibling nodes send their Reply messages successfully by the kth response cycle, <lb/>k &gt; 1, is (P 2;0 ) k 2 (P 2;0 P 2;2 + P 2;1 ) = ( 3 <lb/>8 ) k 2 15 <lb/>32 . Thus the expected number of response <lb/>cycles is <lb/>1 <lb/>4 + <lb/>1 <lb/>X <lb/>k=2 <lb/>k( 15 <lb/>32 )( 3 <lb/>8 ) k 2 = 2:2: <lb/>The length of a response cycle is 3(dlog 3e + 1) = 9. However the response cycle of <lb/>two sibling nodes is overlapped with that of their common neighbor. That is, by the <lb/>eighth timeslot of the response cycle the neighbor receives Reply messages and starts its <lb/>response cycle at the last timeslot of the cycle. Therefore only 8 timeslots are needed for <lb/>the neighbor to receive Reply messages. Since the height of the tree network is blog Nc, <lb/>the expected number of timeslots is bounded above by (9 1)2:2blog Nc + blog Nc = <lb/>18:6blog Nc: <lb/>The performance of both protocols is shown to be exponentially better than that <lb/>of the simple DFS protocol in complete binary tree networks. The performance of the <lb/>randomized protocol is asymptotically better than that of the deterministic protocol in <lb/>complete binary tree networks. Because the time complexity of the randomized protocol <lb/>is not a tight upper bound, both the deterministic and the randomized protocol have <lb/>been simulated on complete binary tree networks. A value of threshold = 1 is used <lb/>for the randomized protocol. For the case when all responses are desired, in complete <lb/>binary tree networks with at most 1024 nodes the deterministic protocol performs as <lb/>good as the randomized protocol as shown in Figure 9. <lb/>7.2 Geometric Graphs <lb/>The class of geometric graphs was rst de ned by Johnson, et al. JAMS89, Ram91]. <lb/>These graphs are de ned in terms of two parameters, N and d. To randomly generate <lb/>a graph from the class, N points are chosen uniformly and independently from the <lb/>unit square. A pair of points are connected in the graph if and only if they are within <lb/>Euclidean distance d of each other. Geometric graphs are a good representation for <lb/>radio networks in that they simulate a random dispersement of radios of equal power <lb/>in open terrain (without shadowing objects such as mountains). <lb/>We want to choose d so that graphs tend to be connected, but is not too dense (as d <lb/>increases, we approach the complete graph case). By choosing d to be 1 <lb/>log N <lb/>N + q <lb/>2N , the <lb/>graph is empirically known to be connected with an expectation of about 1 <lb/>2 . For these <lb/>graphs, the expected diameter is approximately 2 q <lb/>N <lb/>log N and there are about N log N <lb/>edges. For points not too close to the boundary, the expected degree is approximately <lb/>log N. <lb/>Both the deterministic and the randomized protocol have been simulated on geomet-<lb/>ric graphs. If only 10% of responses are to be collected, the average time complexity of <lb/>the deterministic protocol is better than that of the randomized protocol in geometric <lb/>networks of up to 1024 nodes (See Figure 10). The performance of the deterministic <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>21 <lb/></page>

			<body>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>14 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . : Deterministic <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . : Randomized <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>12 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>: DFS <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>10 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>f <lb/>o <lb/>r <lb/>e <lb/>b <lb/>m <lb/>u <lb/>N <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>6 <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>s <lb/>t <lb/>o <lb/>l <lb/>s <lb/>e <lb/>m <lb/>i <lb/>T <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>2 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>O <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . <lb/>Number of Nodes (X; Y : logarithmic scales) <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>Figure 9: Number of Timeslots for Collecting N 1 Responses in Tree Networks <lb/>protocol outperforms that of the DFS protocol in geometric networks of at least 64 <lb/>nodes. <lb/>For the case when 50% responses are desired, in geometric networks of up to 128 <lb/>nodes the average time complexity of the deterministic protocol is better than that of <lb/>the randomized protocol as shown in Figure 11. However in geometric networks of 8192 <lb/>nodes, a big gap exists in (average) time complexity between the randomized and the <lb/>deterministic protocol. The performance of the deterministic protocol outperforms that <lb/>of the DFS protocol in geometric networks of at least 16 nodes. <lb/>We next consider cases where the number of responses is xed at 32 and 60 inde-<lb/>pendent of network size. The performance of all three protocols is shown in Figure 12 <lb/>and Figure 13. In both cases the deterministic protocol outperforms the other two for <lb/>large networks. <lb/>The results of comparing the time complexity of both the deterministic and the <lb/>randomized protocol with that of the simple DFS protocol to collect all responses are <lb/></body>

			<page>22 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>12 <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . : Deterministic <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . : Randomized <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>10 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>: DFS <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>f <lb/>o <lb/>r <lb/>e <lb/>b <lb/>m <lb/>u <lb/>N <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>6 <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>s <lb/>t <lb/>o <lb/>l <lb/>s <lb/>e <lb/>m <lb/>i <lb/>T <lb/>2 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>O <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . <lb/>Number of Nodes (X; Y : logarithmic scales) <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>Figure 10: Number of Timeslots for Collecting 10 % Responses in Geometric Networks <lb/>summarized in Table 1. The results for geometric graph networks are upper bounds <lb/>that are approximations obtained by simulation. <lb/>Topology <lb/>DFS Protocl Deterministic Protocol Randomized Protocol <lb/>complete binary tree 2N 2 <lb/>1:5blog Nc(blog Nc + 1) <lb/>&lt; 18:6blog Nc <lb/>geometric graph <lb/>2N 2 <lb/>1:7N <lb/>2:7 <lb/>p N log N <lb/>Table 1: Time Complexity of Protocols to Collect N 1 Responses <lb/>8 Conclusion <lb/>In this paper we have developed a deterministic and a randomized protocol for collect-<lb/>ing responses in multi-hop packet radio networks and compared them with the simple <lb/>depth rst search protocol in various network environments. Simulation shows that, in <lb/>the interesting geometric graph case, the time complexity of the randomized protocol <lb/>is asymptotically much better than that of the deterministic protocol. However the <lb/>deterministic protocol seems to be a reasonably good choice in any of the following <lb/>cases. <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>23 <lb/></page>

			<body>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>14 <lb/>. . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . : Deterministic <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . : Randomized <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>12 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>: DFS <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>10 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>f <lb/>o <lb/>r <lb/>e <lb/>b <lb/>m <lb/>u <lb/>N <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>6 <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>s <lb/>t <lb/>o <lb/>l <lb/>s <lb/>e <lb/>m <lb/>i <lb/>T <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>2 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>O <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . <lb/>Number of Nodes (X; Y : logarithmic scales) <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>Figure 11: Number of Timeslots for Collecting 50 % Responses in Geometric Networks <lb/>The network has a small number of nodes (say, &lt; 100). <lb/>The network has a hierarchical structure that is not necessarily a tree, and whose <lb/>diameter is O(log N). <lb/>K, the number of responses to be collected, is a small fraction of N, the total <lb/>number of nodes. <lb/>The deterministic protocol incorporates a broadcast (with the Collect message), and <lb/>so it could serve this function also, while the randomized protocol does not have this <lb/>feature. Two drawbacks of the deterministic protocol are that it uses large messages and <lb/>the computation costs at the source are high. Although the randomized protocol could <lb/>use large message (O(N) responses aggregated into one message), this happens only <lb/>with low probability. In these rare cases, the number of responses put into a message <lb/>could be limited without any major impediment to the protocol. <lb/></body>

			<page>24 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<body>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>10 <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . : Deterministic <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . : Randomized <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>: DFS <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>f <lb/>o <lb/>r <lb/>e <lb/>b <lb/>m <lb/>u <lb/>N <lb/>6 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>2 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>s <lb/>t <lb/>o <lb/>l <lb/>s <lb/>e <lb/>m <lb/>i <lb/>T <lb/>O <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . <lb/>Number of Nodes (X; Y : logarithmic scales) <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>Figure 12: Number of Timeslots for Collecting 32 Responses in Geometric Networks <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>10 <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . : Deterministic <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . : Randomized <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>: DFS <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>f <lb/>o <lb/>r <lb/>e <lb/>b <lb/>m <lb/>u <lb/>N <lb/>6 <lb/>. <lb/>. <lb/>. <lb/>. . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>2 <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>s <lb/>t <lb/>o <lb/>l <lb/>s <lb/>e <lb/>m <lb/>i <lb/>T <lb/>O <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>. . . . . <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. <lb/>. . . . . . . . . . <lb/>Number of Nodes (X; Y : logarithmic scales) <lb/>2 <lb/>4 <lb/>6 <lb/>8 <lb/>10 <lb/>12 <lb/>14 <lb/>Figure 13: Number of Timeslots for Collecting 60 Responses in Geometric Networks <lb/>While the randomized protocol is attractive, it has several limitations. One is that it <lb/>uses collision detection in the initial phase of the protocol for synchronization. However, <lb/></body>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>25 <lb/></page>

			<body>the only critical use of this information by the protocol is to determine the direction of <lb/>information ow (the time of arrival indicates whether messages are coming from above <lb/>or below). This problem can be remedied by ignoring acknowledgements and always <lb/>sending all responses that have been gathered so far. This increases the message size <lb/>to O(N) responses, but does provide for all responses to reach the source (and every <lb/>other node) with probability one. <lb/></body>

			<listBibl>References <lb/>AS87] Afek, Y., and Saks, M., \Detecting global termination conditions in the face <lb/>of uncertainty,&quot; In Proc. 6th ACM Symp. on Principles of Distributed Com-<lb/>puting, August 1987, pp. 109-124. <lb/>AR90] Ammar, M.H., and Rouskas, G., \On the performance of protocols for col-<lb/>lecting responses over a multiple-access channel,&quot; Tech. Rep. GIT-ICS-90/34, <lb/>August 1990, Georgia Institute of Technology, Atlanta, GA 30332. <lb/>BGI87] Bar-Yehuda, R., Goldreich, O., and Itai, A., \On the time-complexity of <lb/>broadcast in radio networks: an exponential gap between determinism and <lb/>randomization,&quot; In Proc. 6th ACM Symp. on Principles of Distributed Com-<lb/>puting, August 1987, pp. 98-108. <lb/>BII89] Bar-Yehuda, R., Israeli, A., and Itai, A., \Multiple communication in multi-<lb/>hop radio networks,&quot; In Proc. 8th ACM Symp. on Principles of Distributed <lb/>Computing, August 1989, pp. 329-338. <lb/>HS88] Humblet, P.A., and Soloway, S.R., \Topology broadcast algorithms,&quot; Com-<lb/>puter Networks and ISDN Systems 16 (1988/89), pp. 179-186. <lb/>JAMS89] Johnson, D.S., Aragon, C.R., McGeoch, L.A., and Schevon, C., \Optimiza-<lb/>tion by simulated annealing: an experimental evaluation; part I, graph parti-<lb/>tioning,&quot; Operations Research 37 (1989), No.6, pp. 865-892. <lb/>MV88] Mullender, S.J., and Vitanyi, P.M.B., \Distributed match-making,&quot; Algorith-<lb/>mica 3 (1988), pp. 367-391. <lb/>Nat85] Natarajan, K.S., \Query retrieval protocols in a broadcast environment,&quot; In <lb/>Proc. GLOBECOM, November 1985, pp. 8.1.1-8.1.6. <lb/>Ram91] Raman, R., \Generating random graphs e ciently,&quot; Tech. Rep. 369, January <lb/>1991, The University of Rochester, Rochester, New York 14627. <lb/>WS89] Wang, J.L., and Silvester, J.A., \Optimizing responses to broadcast messages <lb/>in radio networks,&quot; Algorithmica 4 (1989), pp. 395-416. <lb/></listBibl>

			<page>26 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">Appendix <lb/> We present here a pseudo code of the deterministic collection protocol. Sets are widely <lb/>used for storage structures. We assume the existence of set operations (union), \ <lb/>(intersection), (di erence), and 2 (membership). Two types of messages are used <lb/>by the protocol: Collect and Reply message. They are shown in the rst subsection. <lb/>The protocol followed by the source (node 0) is in the second subsection. The protocol <lb/>followed by non-source nodes is in the third subsection. <lb/>8.1 The Messages <lb/>1. Collect(sender; dests; Tree), where <lb/>sender : sender of Collect message <lb/>dests : intended receivers of Collect message <lb/>Tree : a tree constructed at the source with timeslot assignments <lb/>2. Reply(sender; dest; numresponses; responses; neighbors), where <lb/>sender : sender of Reply message <lb/>dest : intended receiver of Reply message <lb/>numresponses : the number of responses in Reply message <lb/>responses : a list of responses from (di erent) nodes <lb/>neighbors : a list of pairs of nodes and their neighbors <lb/>8.2 The Protocol at the Source <lb/>Global Variables at the source <lb/>N : the (known) number of nodes in the network <lb/>K : the (known) number of responses to be collected <lb/>source : the ID of the source in the network <lb/>NewNodes : a set of nodes in the network topology known up to the beginning <lb/>of the current phase <lb/>neighbor(i) : a set of node i&apos;s neighbors in the network topology known up to <lb/>the beginning of the current phase. Initially, neighbor(source) is a set of source&apos;s <lb/>neighbors and neighbor(i) = ; for i 6 = source. <lb/>distance(i) : the shortest distance of node i from the source. Initially, distance(i) <lb/>= 1 for i 6 = source. <lb/></div>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>27 <lb/></page>

			<div type="annex">NoResponses : the number of responses collected up to now <lb/>Responses : a list of responses collected up to now <lb/>SetNodes : the set of nodes that will be given a chance to respond in the following <lb/>phase <lb/>(* Main Program *) <lb/>ht := 0; <lb/>NoResponses := 0; <lb/>call Initialize(); (* initialize global variables *) <lb/>while NoResponses &lt; K do <lb/>ht := ht + 1; <lb/>call CollectResponses(ht); (* collect responses from all nodes of distance ht *) <lb/>end <lb/>procedure Initialize() <lb/>(* initialize network topology consisting of source and its neighbors *) <lb/>source := 0; (* node 0 is the source *) <lb/>Responses := null; <lb/>SetNodes := neighbor(source); <lb/>NewNodes := fsourceg; <lb/>distance(source) := 0; <lb/>for node x 2 SetNodes do <lb/>distance(x) := 1; <lb/>neighbor(x) := fsourceg; <lb/>NewNodes := NewNodes fxg; <lb/>procedure CollectResponses(ht) <lb/>(* collect responses from all nodes of distance ht *) <lb/>(* Description of Local Variables *) <lb/>(* 1. ht : distance of nodes whose responses are collected *) <lb/>(* 2. CurrentNodes : a set of nodes used in the current round of current phase *) <lb/>(* 3. curneighbor(i) : a set of node i&apos;s neighbors used in the current round *) <lb/>(* 4. Respondents : a set of all nodes of distance ht *) <lb/>(* 5. V isitNodes : a set of replied nodes of distance ht *) <lb/>(* 6. Tree : a tree built to collect responses from some nodes of distance ht *) <lb/>(* 7. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 8. dests : a set of destinations of a Collect message *) <lb/>CurrentNodes := NewNodes; <lb/>for node x 2 CurrentNodes do <lb/>curneighbor(x) := neighbor(x); <lb/></div>

			<page>28 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">Respondents := SetNodes; <lb/>SetNodes := ;; <lb/>V isitNodes := ;; <lb/>while V isitNodes 6 = Respondents do <lb/>call BuildTree(ht;Tree;NodesTree;CurrentNodes;curneighbor); <lb/>call FindReplySlot(ht;Tree; NodesTree;curneighbor); <lb/>dests := NodesTree(1); <lb/>send Collect(source; dests; Tree) to all neighbors; <lb/>call CollectReplies(ht; Tree; NodesTree); (* collect replies from all leaves of Tree *) <lb/>if NoResponses K then return; <lb/>V isitNodes := V isitNodes NodesTree(ht); <lb/>(* remove all leaves and internal nodes without ht-hop nodes as descendants *) <lb/>call RemoveNodes(ht;NodesTree;CurrentNodes;curneighbor); <lb/>end <lb/>procedure BuildTree(ht;Tree;NodesTree;CurrentNodes;curneighbor) <lb/> (* build a tree of height ht, a subgraph of current topology *) <lb/>(* Description of Local Variables *) <lb/>(* 1. ht : the height of the built tree *) <lb/>(* 2. Tree : a set of nodes in the built tree *) <lb/>(* 3. depth(x) : depth of node x 2 Tree *) <lb/>(* 4. parent(x) : parent of node x 2 Tree *) <lb/>(* 5. children(x) : a set of children of node x 2 Tree *) <lb/>(* 6. sibling(x) : a set of siblings of node x 2 Tree *) <lb/>(* 7. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 8. CurrentNodes : a set of nodes used in the current round of current phase *) <lb/>(* 9. curneighbor(i) : a set of node i&apos;s neighbors used in the current round *) <lb/>(* 10. CNodes : possible internal nodes in the same depth *) <lb/>(* 11. Rate(x) : rate of node x *) <lb/>(* 12. Con ictNodes(x) : a set of nodes interfering with x *) <lb/>(* initialize a tree, Tree *) <lb/>Tree := fsourceg; (* source is the root of Tree *) <lb/>NodesTree(0) := fsourceg; <lb/>depth(source) := 0; <lb/>children(source) := curneighbor(source); <lb/>parent(source) := null; <lb/>if ht 1 <lb/>then (* all current neighbors of source become a part of Tree *) <lb/>NodesTree(1) := ;; <lb/>for node x 2 curneighbor(source) do <lb/>Tree := Tree fxg; <lb/>NodesTree(1) := NodesTree(1) fxg; <lb/></div>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>29 <lb/></page>

			<div type="annex">depth(x) := 1; <lb/> parent(x) := source; <lb/>children(x) := ;; <lb/>sibling(x) := curneighbor(source); <lb/>else (* choose internal nodes of Tree, using rates of nodes *) <lb/>call ComputeRate(ht;CurrentNodes;curneighbor; Con ictNodes; children; Rate); <lb/>d := 1; <lb/>CNodes := curneighbor(source); (* possible internal nodes of depth 1 *) <lb/>while d &lt; ht do (* include internal nodes depth by depth *) <lb/>call SelectNodesTree(d; curneighbor; CNodes; NNodes; Con ictNodes, <lb/>children; Rate; Tree; NodesTree); <lb/>d := d + 1; (* increment depth *) <lb/>CNodes := NNodes; <lb/>end <lb/>(* include leaf nodes that are children of node x in NodesTree(ht 1) *) <lb/>NodesTree(ht) := ;; <lb/>for node x 2 NodesTree(ht 1) do <lb/>for node y 2 children(x) do <lb/>Tree := Tree fyg; <lb/>NodesTree(ht) := NodesTree(ht) fyg; <lb/>parent(y) := x; <lb/>sibling(y) := children(x); <lb/>depth(y) := ht; <lb/>children(y) := ;; <lb/>procedure ComputeRate(ht;CurrentNodes;curneighbor;Con ictNodes; children; Rate) <lb/>(* compute Rate(x); Con ictNodes(x); children(x) for x 2 CurrentNodes *) <lb/>(* Description of Local Variables *) <lb/>(* 1. ht : the height of the tree *) <lb/>(* 2. CurrentNodes : a set of nodes used in the current round of current phase *) <lb/>(* 3. curneighbor(i) : a set of node i&apos;s neighbors used in the current round *) <lb/>(* 4. Con ictNodes(x) : a set of nodes interfering with x *) <lb/>(* 5. children(x) : a set of potential children of node x *) <lb/>(* 6. Rate(x) : rate of node x *) <lb/>(* 7. Resps(x) : the set of descendants of node x at distance ht *) <lb/>(* 8. CNodes; CNodes2 : a subset of CurrentNodes *) <lb/>d := ht; <lb/>CNodes := ;; <lb/>for node x 2 CurrentNodes do <lb/>if distance(x) &gt; 0 and distance(x) &lt; ht <lb/>then CNodes := CNodes fxg; <lb/> CNodes2 := CNodes; <lb/></div>

			<page>30 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">while d &gt; 1 do <lb/>d := d 1; <lb/>for node x 2 CNodes do <lb/>if distance(x) = d <lb/>then <lb/>children(x) := ;; <lb/>Con ictNodes(x) := ;; <lb/>for node y 2 curneighbor(x) do <lb/>if (distance(y) = distance(x) + 1) <lb/>then (* y is a potential child of x *) <lb/>children(x) := children(x) fyg; <lb/>for node z 2 curneighbor(y) do <lb/>if z 6 = x and distance(z) = d <lb/>then (* z interferes with x *) <lb/>Con ictNodes(x) := Con ictNodes(x) fzg; <lb/>(* compute rate of x *) <lb/>Resps(x) := ;; <lb/>if d &lt; ht 1 <lb/>then <lb/>for node y 2 children(x) do <lb/>Resps(x) := Resps(x) Resps(y); <lb/>else <lb/>Resps(x) := Resps(x) children(x); <lb/>Rate(x) := jResps(x)j; <lb/>CNodes2 := CNodes2 fxg; <lb/>CNodes := CNodes2; <lb/>procedure SelectNodesTree(d; curneighbor;CNodes; NNodes; Con ictNodes; children; Rate, <lb/>Tree; NodesTree) <lb/>(* select internal nodes of depth d with maximum rate *) <lb/>(* Description of Variables *) <lb/>(* 1. curneighbor(i) : a set of node i&apos;s neighbors used in the current round *) <lb/>(* 2. CNodes : a set of potential nodes of depth d in Tree *) <lb/>(* 3. NNodes : a set of potential nodes of depth d + 1 in Tree *) <lb/>(* 4. Con ictNodes(x) : a set of nodes interfering with x *) <lb/>(* 5. children(x) : a set of potential children of node x *) <lb/>(* 6. Rate(x) : rate of node x *) <lb/>(* 7. Tree : a set of nodes in the built tree *) <lb/>(* 8. NodesTree : a set of nodes in the same depth in Tree *) <lb/>NNodes := ;; <lb/>NodesTree(d) := ;; (* a set of nodes of depth d in Tree *) <lb/>while CNodes 6 = ; do (* are nodes to choose left? *) <lb/></div>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>31 <lb/></page>

			<div type="annex">x := FindMaxRate(CNodes;Rate); (* nd node with max rate among CNodes *) <lb/> Tree := Tree fxg; <lb/>NodesTree(d) := NodesTree(d) fxg; <lb/>depth(x) := d; <lb/>for node y 2 NodesTree(d 1) do (* nd the parent of x *) <lb/>if y 2 curneighbor(x) <lb/>then <lb/>parent(x) := y; <lb/>sibling(x) := children(y); <lb/>exit; <lb/>CNodes := CNodes fxg Con ictNodes(x); (* remove nodes interfering with x *) <lb/>NNodes := NNodes children(x); (* add all children of x *) <lb/>end <lb/>for node x 2 NodesTree(d) do (* update sibling(x) for node x of depth d *) <lb/>sibling(x) := sibling(x) \ NodesTree(d); <lb/>for node x 2 NodesTree(d 1) do (* update children(x) for node x of depth d 1 *) <lb/>children(x) := children(x) \ NodesTree(d); <lb/>function FindMaxRate(Nodes;Rate) <lb/>(* nd a node with maximum rate *) <lb/>(* Description of Local Variables *) <lb/>(* 1. Nodes : a set of nodes *) <lb/>(* 2. Rate(x) : rate of node x 2 Nodes *) <lb/>(* 3. maxrate : current maximum rate *) <lb/>(* 4. maxid : ID of node with maxrate *) <lb/>maxrate := 1; <lb/>maxid := 1; <lb/>for node x 2 Nodes do <lb/>if Rate(x) &gt; maxrate <lb/>then <lb/>maxrate := Rate(x); <lb/>maxid := x; <lb/>else <lb/>if Rate(x) = maxrate <lb/>then (* tie is broken in favor of smaller ID *) <lb/>if maxid &gt; x <lb/>then maxid := x; <lb/>return maxid; <lb/></div>

			<page>32 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">procedure FindReplySlot(ht;Tree;NodesTree;curneighbor) <lb/>(* determine when nodes in Tree send Reply if ready *) <lb/>(* Description of Local Variables *) <lb/>(* 1. Tree : a tree of height ht *) <lb/>(* 2. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 3. curneighbor(i) : a set of node i&apos;s neighbors known up to now *) <lb/>(* 4. sibling(x) : a set of siblings of node x 2 Tree *) <lb/>(* 5. oldslotno(x) : initial slot number given to node x 2 Tree *) <lb/>(* 6. newslotno(x) : nal slot number given to node x *) <lb/>(* 7. numwaitslot(x) : number of timeslots for node x to wait before replying *) <lb/>(* Leaf nodes send Reply in the ascending order of IDs of their siblings *) <lb/>for node x 2 NodesTree(ht) do <lb/>Let x be the j-th element in sibling(x); <lb/>oldslotno(x) := 1; <lb/>numwaitslot(x) := j 1; <lb/>(* determine when internal nodes in Tree send Reply *) <lb/>for l := ht 1 downto 1 do <lb/>for node x 2 NodesTree(l) do <lb/>oldslotno(x) := max(oldslotno(y) + numwaitslot(y)) + 1, where y 2 children(x); <lb/>newslotno(x) := oldslotno(x); <lb/>for node x 2 NodesTree(l) do <lb/>for node y 2 NodesTree(l) do <lb/>if y 6 = x and y 2 curneighbor(x) <lb/>then (* x may wait for y to nish collecting *) <lb/>if oldslotno(x) oldslotno(y) -jchildren(y)j <lb/>then <lb/>newslotno(x) := max (newslotno(x); oldslotno(y)); <lb/>call AssignReplySlot(l; Tree; NodesTree); (* assign waiting timeslots *) <lb/>procedure AssignReplySlot(d; Tree; NodesTree) <lb/>(* assign number of timeslots to wait before sending Reply when ready *) <lb/>(* Description of Local Variables *) <lb/>(* 1. Tree : built tree *) <lb/>(* 2. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 3. NT : a set of nodes of depth d in Tree *) <lb/>(* 4. sibling(x) : a set of siblings of node x *) <lb/>(* 5. index(i) : pointer to the node with the i-th newslotno *) <lb/>(* 6. cno : current newslotno *) <lb/>(* 7. wno : current number of waiting timeslots *) <lb/>NT := NodesTree(d); <lb/>(* consider siblings of a node and determine waiting timeslots *) <lb/>while NT 6 = ; do <lb/></div>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>33 <lb/></page>

			<div type="annex">Let x be a node in NT; <lb/>NT := NT sibling(x); <lb/>for node y 2 sibling(x) do <lb/>(* tie is broken in favor of smaller ID *) <lb/>Let newslotno(y) be the j-th element in fnewslotno(z) j z 2 sibling(x)g <lb/>index(j) := y; <lb/>(* determine timeslots to wait before forwarding its Reply upwards,*) <lb/>(* after it receives the last Reply from one of its children. *) <lb/>cno := newslotno(index(1)); <lb/>wno := 0; <lb/>numwaitslot(index(1)) := wno + (cno oldslotno(index(1))); <lb/>for i := 2 to jsibling(x)j do <lb/>if newslotno(index(i)) = cno <lb/>then wno := wno + 1; <lb/>else cno := newslotno(index(i)); <lb/>numwaitslot(index(i)) := wno + (newslotno(index(i)) oldslotno(index(i))); <lb/>procedure CollectReplies(ht;Tree;NodesTree) <lb/>(* collect Reply messages from all leaves of Tree *) <lb/>(* Description of Local Variables *) <lb/>(* 1. Tree : tree of height ht *) <lb/>(* 2. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 3. NoReplies : no of replies received from leaves of Tree *) <lb/>(* 4. Resps : all leaves of Tree *) <lb/>(* 5. numresponses : the number of responses in Reply message *) <lb/>(* 6. responses : a list of responses sent by leaf nodes in Tree *) <lb/>(* 7. neighbors : a list of pairs of (i, neighbor i ) for leaf node i 2 Tree *) <lb/>NoReplies := 0; <lb/>Resps := NodesTree(ht); (* all leaves of Tree *) <lb/>while NoReplies &lt; jRespsj do (* are some leaves left? *) <lb/>receive a message; <lb/>if it received Reply(sender; dest; numresponses; responses; neighbors) <lb/>then <lb/>NoReplies := NoReplies + numresponses; <lb/>NoResponses := NoResponses + numresponses; <lb/>Append responses to Responses; <lb/>if NoResponses K then return; <lb/>(* update network topology using a list of new neighbors *) <lb/>call UpdateTopology(ht;neighbors); <lb/>end <lb/></div>

			<page>34 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">procedure UpdateTopology(ht;neighbors) <lb/>(* update network topology using a list of new neighbors, neighbors *) <lb/>(* Description of Local Variables *) <lb/>(* 1. neighbors : a list of pairs of (i, neighbor i ) for leaf node i 2 Tree *) <lb/>(* 2. neighbor i : a set of i&apos;s neighbors sent by node i *) <lb/>(* 3. tneighbor : a temporary set of new neighbors of some node *) <lb/>for (i; neighbor i ) 2 neighbors do <lb/>tneighbor := neighbor i -neighbor(i); <lb/>for node x 2 tneighbor do <lb/>neighbor(i) := neighbor(i) fxg; <lb/>if (i 6 2 neighbor(x)) <lb/>then (* newly found edge *) <lb/>neighbor(x) := neighbor(x) fig; <lb/>if distance(x) = 1 <lb/>then (* newly found node *) <lb/>distance(x) := ht + 1; <lb/>NewNodes := NewNodes fxg; (* add new node *) <lb/>SetNodes := SetNodes fxg; (* next respondent found *) <lb/>procedure RemoveNodes(ht;NodesTree; CurrentNodes; curneighbor) <lb/>(* remove leaves and internal nodes without ht-hop descendants from current topology *) <lb/>(* Description of Local Variables *) <lb/>(* 1. Tree : tree of height ht *) <lb/>(* 2. NodesTree(i) : a set of nodes of depth i in Tree *) <lb/>(* 3. CurrentNodes : a set of nodes used in the current round of current phase *) <lb/>(* 4. curneighbor(i) : a set of node i&apos;s neighbors used in the current round *) <lb/>(* 5. SNodes : a set of remaining nodes *) <lb/>(* 6. CNodes; CNodes2 : a subset of CurrentNodes *) <lb/>(* remove leaves and their incident edges from current topology *) <lb/>for node x 2 NodesTree(ht) do <lb/>CurrentNodes := CurrentNodes fxg; <lb/>for node y 2 curneighbor(x) do <lb/>curneighbor(y) := curneighbor(y) fxg; <lb/>curneighbor(x) := ;; <lb/>(* remove (non-root) nodes all of whose children have been removed and *) <lb/>(* their incident edges from current topology *) <lb/>CNodes := ;; <lb/>for node x 2 CurrentNodes do <lb/>if distance(x) &gt; 0 and distance(x) &lt; ht <lb/>then CNodes := CNodes fxg; <lb/> CNodes2 := CNodes; <lb/>d := ht; <lb/></div>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks <lb/></note>

			<page>35 <lb/></page>

			<div type="annex">while CNodes 6 = ; do (* Is there a change in topology? *) <lb/>d := d 1; <lb/>for node x 2 CNodes do <lb/>if distance(x) = d <lb/>then <lb/>SNodes := curneighbor(x); <lb/>CNodes2 := CNodes2 fxg; <lb/>if distance(y) distance(x) for all y 2 SNodes <lb/>then (* all remaining neighbors have at most its distance *) <lb/>CurrentNodes := CurrentNodes fxg; <lb/>for node y 2 SNodes do <lb/>curneighbor(y) := curneighbor(y) fxg; <lb/>curneighbor(x) := ;; <lb/>CNodes := CNodes2; <lb/>8.3 The Protocol at Non-source Node i <lb/>Variables at node i <lb/>neighbor i : a set of i&apos;s neighbors. neighbor i is known initially. <lb/>response i : i&apos;s response <lb/>parent i : parent of node i in the tree <lb/>children i : children of node i in the tree <lb/>numwaitslot i : number of timeslots to wait before sending Reply when ready. <lb/>Tree : a set of nodes in the tree. For node x 2 Tree, children(x) and numwaitslot(x) <lb/>are stored. <lb/>noresponses i : the number of responses received currently <lb/>Responses i : a list of responses from di erent nodes <lb/>Neighbors i : a list of neighbors of di erent nodes <lb/>NoReply i : number of Reply messages expected <lb/>1. On Receiving Collect(sender; dests; Tree) <lb/>if i 2 dests <lb/>then <lb/>children i := children(i); <lb/></div>

			<page>36 <lb/></page>

			<note place="headnote">Lee, Burns, and Ammar <lb/></note>

			<div type="annex">numwaitslot i := numwaitslot(i); <lb/>if children i = ; <lb/>then (* i is a leaf node *) <lb/>parent i := sender; <lb/>wait until the next numwaitslot i timeslots; <lb/>send Reply(i; parent i ; 1; response i ; (i; neighbor i )); <lb/>else (* i is an internal node *) <lb/>parent i := sender; <lb/>Neighbors i := null; <lb/>Responses i := null; <lb/>noresponses i := 0; <lb/>NoReply i := 0; <lb/>send Collect(i; children i ; Tree) in the following timeslot; <lb/>2. On receiving Reply(sender; dest; numresponses; responses; neighbors) <lb/>if i 2 dest <lb/>then (* i must process Reply message and forward it *) <lb/>NoReply i := NoReply i + 1; <lb/>noresponses i := noresponses i + numresponses; <lb/>Append responses to Responses i ; <lb/>Append neighbors to Neighbors i ; <lb/>if NoReply i = jchildren i j <lb/>then (* received Reply from all children *) <lb/>wait until the next numwaitslot i timeslots; <lb/>send Reply(i; parent i ; noresponses i ; Responses i ; Neighbors i ); </div>


	</text>
</tei>
