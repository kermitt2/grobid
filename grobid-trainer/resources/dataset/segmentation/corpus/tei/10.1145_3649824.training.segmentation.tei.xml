<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">Quantitative Bounds on Resource Usage of Probabilistic Programs</title>
        <author>
          <persName>
            <forename>Krishnendu</forename>
            <surname>Chatterjee</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Amir Kafshdar</forename>
            <surname>Goharshady</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Tobias</forename>
            <surname>Meggendorfer</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Đorđe</forename>
            <surname>Žikelić</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-30T11:03:52.989936Z">30.10.2025 11:03:52</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3649824</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3649824</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Krishnendu Chatterjee, Amir Kafshdar Goharshady, Tobias Meggendorfer, Đorđe Žikelić. (2024). Quantitative Bounds on Resource Usage of Probabilistic Programs. Proceedings of the ACM on Programming Languages, 8(OOPSLA1), 362-391. DOI: 10.1145/3649824</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-30T11:03:52.989936Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-30T11:03:52.989936Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
    <front>Fully Composable and Adequate Verified Compilation with <lb/>Direct Refinements between Open Modules <lb/>LING ZHANG, Shanghai Jiao Tong University, China <lb/>YUTING WANG * , Shanghai Jiao Tong University, China <lb/>JINHUA WU, Shanghai Jiao Tong University, China <lb/>JÉRÉMIE KOENIG, Yale University, USA <lb/>ZHONG SHAO, Yale University, USA <lb/>Verified compilation of open modules (i.e., modules whose functionality depends on other modules) provides <lb/>a foundation for end-to-end verification of modular programs ubiquitous in contemporary software. However, <lb/>despite intensive investigation in this topic for decades, the proposed approaches are still difficult to use in <lb/>practice as they rely on assumptions about the internal working of compilers which make it difficult for external <lb/>users to apply the verification results. We propose an approach to verified compositional compilation without <lb/>such assumptions in the setting of verifying compilation of heterogeneous modules written in first-order <lb/>languages supporting global memory and pointers. Our approach is based on the memory model of CompCert <lb/>and a new discovery that a Kripke relation with a notion of memory protection can serve as a uniform and <lb/>composable semantic interface for the compiler passes. By absorbing the rely-guarantee conditions on memory <lb/>evolution for all compiler passes into this Kripke Memory Relation and by piggybacking requirements on <lb/>compiler optimizations onto it, we get compositional correctness theorems for realistic optimizing compilers <lb/>as refinements that directly relate native semantics of open modules and that are ignorant of intermediate <lb/>compilation processes. Such direct refinements support all the compositionality and adequacy properties <lb/>essential for verified compilation of open modules. We have applied this approach to the full compilation chain <lb/>of CompCert with its Clight source language and demonstrated that our compiler correctness theorem is open <lb/>to composition and intuitive to use with reduced verification complexity through end-to-end verification of <lb/>non-trivial heterogeneous modules that may freely invoke each other (e.g., mutually recursively). <lb/>CCS Concepts: • Software and its engineering → Formal software verification; Compilers; • Theory <lb/>of computation → Program verification. <lb/>Additional Key Words and Phrases: Verified Compositional Compilation, Direct Refinements, Kripke Relations <lb/>ACM Reference Format: <lb/>Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao. 2024. Fully Composable and Adequate <lb/>Verified Compilation with Direct Refinements between Open Modules. Proc. ACM Program. Lang. 8, POPL, <lb/>Article 72 (January 2024), 31 pages. https://doi.org/10.1145/3632914 <lb/> * Corresponding author <lb/>Authors&apos; addresses: Ling Zhang, John Hopcroft Center for Computer Science, School of Electronic Information and Electrical <lb/>Engineering, Shanghai Jiao Tong University, China, ling.zhang@sjtu.edu.cn; Yuting Wang, John Hopcroft Center for <lb/>Computer Science, School of Electronic Information and Electrical Engineering, Shanghai Jiao Tong University, China, <lb/>yuting.wang@sjtu.edu.cn; Jinhua Wu, John Hopcroft Center for Computer Science, School of Electronic Information and <lb/>Electrical Engineering, Shanghai Jiao Tong University, China, jinhua.wu@sjtu.edu.cn; Jérémie Koenig, Yale University, USA, <lb/>jeremie.koenig@yale.edu; Zhong Shao, Yale University, USA, zhong.shao@yale.edu. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/1-ART72 <lb/>https://doi.org/10.1145/3632914 <lb/>Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/>72:2 <lb/>Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></front>
    
    <body>1 INTRODUCTION <lb/>Verified compilation ensures that behaviors of source programs are faithfully transported to target <lb/>code, a property desirable for end-to-end verification of software whose development involves <lb/>compilation. As software is usually composed of modules independently developed and compiled, <lb/>researchers have developed a wide range of techniques for verified compositional compilation or <lb/>VCC that support modules invoking each other (i.e., open), being written in different languages <lb/>(i.e., heterogeneous) and transformed by different compilers [Patterson and Ahmed 2019]. <lb/>We are concerned with VCC for first-order languages with global memory states and support of <lb/>pointers (e.g., see Gu et al. [2015]; Jiang et al. [2019]; Koenig and Shao [2021]; Song et al. [2020]; <lb/>Stewart et al. [2015]; Wang et al. [2019]). As it stands now, the proposed approaches are inherently <lb/>limited at supporting open modules (e.g. libraries) as they either deviate from the native semantics <lb/>of modules or expose the semantics of intermediate representations for compilation, resulting in <lb/>correctness theorems that are difficult to work with for external users. In this paper, we investigate <lb/>an approach that eliminates these limitations while retaining the full benefits of VCC, i.e., obtaining <lb/>correctness of compiling open modules that is fully composable, adequate, and extensional. <lb/>1.1 Full Compositionality and Adequacy in Verified Compilation <lb/>Correctness of compiling open modules is usually described as refinement between semantics of <lb/>source and target modules. We shall write (possibly with subscripts) to denote semantics of open <lb/>modules and write 1 ≼ 2 to denote that 1 is refined by 2 . Therefore, the compilation of any <lb/>module 2 into 1 is correct iff [[ 1 ]] ≼ [[ 2 ]] where [[ ]] denotes the semantics of . <lb/>To support the most general form of VCC, it is critical that the established refinements are fully <lb/>composable, i.e., both horizontally and vertically composable, and adequate for native semantics: <lb/>Vertical Compositionality: <lb/>1 ≼ 2 ⇒ 2 ≼ 3 ⇒ 1 ≼ 3 <lb/>Horizontal Compositionality: <lb/>1 ≼ ′ <lb/>1 ⇒ 2 ≼ ′ <lb/>2 ⇒ 1 ⊕ 2 ≼ ′ <lb/>1 ⊕ ′ <lb/>2 <lb/>Adequacy for Native Semantics: [[ 1 + 2 ]] ≼ [[ 1 ]] ⊕ [[ 2 ]] <lb/>[[a.c]] <lb/>[[a.i 1 ]] <lb/>[[a.i 2 ]] <lb/>[[a.s]] <lb/>≼ <lb/>≼ <lb/>≼ <lb/>[[b.s]] <lb/>≼ <lb/>⊕ <lb/>⊕ <lb/>[[a.s + b.s]] <lb/>≼ <lb/>Fig. 1. Motivating Example <lb/>The first property states that refinements are transitive. It is essential <lb/>for composing proofs for multi-pass compilers. The second property <lb/>guarantees that refinements are preserved by semantic linking (denoted <lb/>by ⊕). It is essential for composing correctness of compiling open mod-<lb/>ules (possibly through different compilers). The last one ensures that, <lb/>given any modules, their semantic linking coincides with their syntactic <lb/>linking (denoted by +). It ensures that linked semantics do not deviate <lb/>from native semantics and is essential to propagate verified properties <lb/>to final target programs. <lb/>We use the example in Fig. 1 to illustrate the importance of the above <lb/>properties in VCC where heterogeneous modules are compiled through <lb/>different compilation chains and linked into a final target module. In this <lb/>example, a source C module a.c is compiled into an assembly module <lb/>a.s through a multi-pass optimizing compiler like CompCert: it is first <lb/>compiled to a.i 1 in an intermediate representation (IR) for optimization (e.g., the RTL language <lb/>of CompCert) and then to a.i 2 in another IR for code generation (e.g., the Mach language of <lb/>CompCert). Finally, it is linked with a library module b.s which is not compiled at all (an extreme <lb/>case where the compilation chain is empty). The goal is to prove that the semantics of linked target <lb/>assembly a.s + b.s refines the combined source semantics [[a.c]] ⊕ where is the semantic <lb/>specification of b.s, i.e., [[a.s + b.s]] ≼ [[a.c]] ⊕ . The proof proceeds as follows: <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:3 <lb/></page>
    
    <body>[[a.c]] <lb/>[[a.i 1 ]] <lb/>[[a.i 2 ]] <lb/>[[a.s]] <lb/>≼ <lb/>C <lb/>≼ <lb/>C <lb/>≼ <lb/>C <lb/>[[b.s]] <lb/>≼ <lb/>C <lb/>⊕ <lb/>⊕ <lb/>[[a.s + b.s]] <lb/≯ ≼ <lb/>C <lb/>(a) CompComp <lb/>[[a.c]] <lb/>[[a.i 1 ]] <lb/>[[a.i 2 ]] <lb/>[[a.s]] <lb/>≼ <lb/>1 <lb/>≼ <lb/>2 <lb/>≼ <lb/>3 <lb/>[[b.s]] <lb/>≼ <lb/>4 <lb/>⊕ <lb/>⊕ <lb/>[[a.s + b.s]] <lb/>≼ <lb/>5 <lb/>≼ <lb/>1 + ≼ <lb/>2 + ≼ <lb/>3 + ≼ <lb/>4 + ≼ <lb/>5 <lb/>(b) CompCertM <lb/>[[a.c]] <lb/>[[a.i 1 ]] <lb/>[[a.i 2 ]] <lb/>[[a.s]] <lb/>≼ <lb/>1 <lb/>≼ <lb/>2 <lb/>≼ <lb/>3 <lb/>[[b.s]] <lb/>≼ <lb/>3 • ≼ <lb/>2 • ≼ <lb/>1 <lb/>⊕ <lb/>⊕ <lb/>[[a.s + b.s]] <lb/>≼ <lb/>4 <lb/>≼ <lb/>4 • ≼ <lb/>3 • ≼ <lb/>2 • ≼ <lb/>1 <lb/>(c) CompCertO <lb/>Fig. 2. Refinements in the Existing Approaches to VCC <lb/>(1) Prove every pass respects refinement, from which [[a.i 1 ]] ≼ [[a.c]], [[a.i 2 ]] ≼ [[a.i 1 ]] and <lb/>[[a.s]] ≼ [[a.i 2 ]]. Moreover, show b.s meets its specification, i.e., [[b.s]] ≼ ; <lb/>(2) By vertically composing the refinement relations for compiling a.c, we get [[a.s]] ≼ [[a.c]]; <lb/>(3) By further horizontally composing with [[b.s]] ≼ , we get [[a.s]] ⊕ [[b.s]] ≼ [[a.c]] ⊕ ; <lb/>(4) By adequacy for assembly and vertical composition, conclude [[a.s + b.s]] ≼ [[a.c]] ⊕ . <lb/>1.2 Problems with the Existing Approaches to Refinements <lb/>Despite the simplicity of VCC at an intuitive level, full compositionality and adequacy are sur-<lb/>prisingly difficult to prove for any non-trivial multi-pass compiler. First and foremost, the formal <lb/>definitions must take into account the facts that each intermediate representation has different <lb/>semantics and each pass may imply a different refinement relation. To facilitate the discussion <lb/>below, we classify different open semantics by language interfaces (or simply interfaces) which <lb/>formalize their interaction with environments. We write : I to denote that has a language <lb/>interface I. For instance, [[a.c]] : C denotes that the semantics of a.c has the interface C which <lb/>only allows for interaction with environments through function calls and returns in C. Similarly, <lb/>[[a.s]] : A denotes the semantics of a.s where A only allows for interaction at the assembly level. <lb/>Note that the interface for a module may not match its native semantics. For example, [[a.s]] : C <lb/>asserts that [[a.s]] actually converts assembly level calls/returns to C function calls/returns for <lb/>interacting with C environments (e.g., extracting arguments from registers and memory to form an <lb/>argument list for C function calls). In this case, [[a.s]] deviates from the native semantics of a.s. <lb/>When the interface of [[ ]] is not explicitly given, it is implicitly the native interface of . We write <lb/>≼: I 1 ⇔ I 2 to denote a refinement between two semantics with interfaces I 1 and I 2 . For instance, <lb/>given ≼ ac : A ⇔ C that relates open semantics at the C and assembly levels, [[b.s]] ≼ ac <lb/>asserts <lb/>that [[b.s]] is the native semantics of b.s and is refined by the C level specification . <lb/>For VCC, it is essential that variance of open semantics and refinements does not impede compo-<lb/>sitionality and adequacy. The existing approaches achieve this by imposing algebraic structures <lb/>on refinements. We categorize them by their algebraic structures below, and explain the problems <lb/>facing them via three well-known extensions of CompCert [Leroy 2023] (the state-of-the-art verified <lb/>C compiler) to support VCC, i.e., Compositional CompCert (CompComp) [Stewart et al. 2015], <lb/>CompCertM [Song et al. 2020] and CompCertO [Koenig and Shao 2021]. <lb/>Constant Refinement. An obvious way to account for different semantics in VCC is to force <lb/>every semantics to use the same language interface I and a constant refinement ≼ I : I ⇔ I. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:4 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>CompComp adopts this &quot;one-type-fits-all&quot; approach by having every language of CompCert to <lb/>use C function calls/returns for module-level interactions and using a uniform refinement relation <lb/>≼ C : C ⇔ C known as structured simulation [Stewart et al. 2015]. In this case, vertical and horizontal <lb/>compositionality is established by proving transitivity of ≼ C and symmetry of rely-guarantee <lb/>conditions of ≼ C . However, because the C interface is adopted for assembly semantics, adequacy at <lb/>the target level is lost, making end-to-end compiler correctness not provable as shown in Fig. 2a. <lb/>Sum of Refinements. A more relaxed approach allows users to choose language interfaces for <lb/>different IRs from a finite collection {I 1 , . . . , I } and refinements for different passes from a finite <lb/>set {≼ 1 , . . . , ≼ } relating these interfaces, i.e., ≼ : I 1 + . . . + I ⇔ I 1 + . . . + I . In essence, a <lb/>constant refinement is split into a sum of refinements s.t. ≼ 1 + . . . + ≼ ′ holds if ≼ ′ for <lb/>some 1 ≤ ≤ . Then, every compiler pass can use ≼ 1 + . . . + ≼ as the uniform refinement relation, <lb/>which is proven both composable and adequate under certain well-formedness constraints. Fig. 2b <lb/>depicts such an example where semantics have both C and assembly interfaces (e.g., [[a.s]] : A + C) <lb/>and the refinement relations ≼ : A + C ⇔ A + C(1 ≤ ≤ 5) are tailored for each pass. This <lb/>is the approach adopted by CompCertM [Song et al. 2020]. However, the top-level refinement <lb/>≼ 1 + . . . + ≼ is difficult to use by a third party without introducing complicated dependency on <lb/>intermediate results of compilation. For example, horizontal composition with ≼ 1 + . . . + ≼ only <lb/>works for modules self-related by all the refinements ≼ (1 ≤ ≤ ). Since ≼ s are tailored for <lb/>individual passes, they inevitably depend on the intermediate semantics used in compilation. Such <lb/>dependency is only exacerbated as new languages, compilers and optimizations are introduced. <lb/>Product of Refinements. The previous approach effectively &quot;flattens&quot; the refinements for indi-<lb/>vidual compiler passes into an end-to-end refinement. A different approach adopted by Comp-<lb/>CertO [Koenig and Shao 2021] is to &quot;concatenate&quot; the refinements for individual passes into a chain <lb/>of refinements by a product operation (_•_) such that ≼ 1 • ≼ 2 <lb/>′′ if ≼ 1 <lb/>′ and ′ ≼ 2 <lb/>′′ for some <lb/>′ . Fig. 2c illustrates how it works. Vertical composition is simply the concatenation of refinements. <lb/>For example, composing refinements for compiling a.c results in [[a.s]] ≼ 3 • ≼ 2 • ≼ 1 [[a.c]]. Ade-<lb/>quacy is trivially guaranteed with native interfaces. However, horizontal composition still depends <lb/>on the intermediate semantics of compilation because of the concatenation. For example, in Fig. 2c, <lb/>to horizontally compose with [[a.s]] ≼ 3 • ≼ 2 • ≼ 1 [[a.c]], it is necessary to show refines [[b.s]] <lb/>via the same product, i.e., to construct intermediate semantics bridging ≼ 1 , ≼ 2 and ≼ 3 . <lb/>Summary. The existing approaches for VCC either lack adequacy because they force non-native <lb/>language interfaces on semantics for open modules (e.g., CompComp) or lack compositionality <lb/>that is truly extensional because they depend on intermediate semantics used in compilation (e.g., <lb/>CompCertM and CompCertO). Such dependency makes their correctness theorems for compiling <lb/>open modules (e.g., libraries) difficult to further compose with and incurs a high cost in verification. <lb/>1.3 Challenges for Direct Refinement of Open Modules <lb/>The ideal approach to VCC should produce refinements that directly relate the native semantics <lb/>of source and target open modules without mentioning any intermediate semantics and support <lb/>both vertical and horizontal composition. We shall call them direct refinements of open modules. <lb/>For example, a direct refinement between a.c and a.s could be ≼ ac : A ⇔ C s.t. [[a.s]] ≼ ac <lb/>[[a.c]]. It relates assembly and C without mentioning intermediate semantics, and could be further <lb/>horizontally composed with [[b.s]] ≼ ac <lb/>and vertically composed by adequacy to get [[a.s + <lb/>b.s]] ≼ ac [[a.c]] ⊕ . Note that even the top-level refinement is still open to horizontal and <lb/>vertical composition, making direct refinements effective for supporting VCC for open modules. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:5 <lb/></page>
    
    <body>The main challenge in getting direct refinements is tied to their &quot;real&quot; vertical composition, i.e., <lb/>given any direct refinements ≼ 1 and ≼ 2 , how to show ≼ 1 • ≼ 2 is equivalent to a direct refinement ≼ 3 . <lb/>This is considered very technical and involved (see Hur et al. [2012b]; Neis et al. [2015]; Patterson <lb/>and Ahmed [2019]; Song et al. [2020]) because of the difficulty in constructing interpolating program <lb/>states for transitively relating evolving source and target states across external calls of open modules. <lb/>This problem also manifests in proving transitivity for logical relations where construction of <lb/>interpolating terms of higher-order types is not in general possible [Ahmed 2006]. In the setting of <lb/>compiling first-order languages with global memory, all previous work avoids proving real vertical <lb/>composition of direct refinements. Some produce refinement without adequacy by introducing <lb/>intrusive changes to semantics to make construction of interpolating states possible. For example, <lb/>CompComp instruments the semantics of languages with effect annotations to expose internal <lb/>effects for this purpose. Some essentially restrict vertical composition to closed programs (e.g., <lb/>CompCertM). Some leave the top-level refinement a combination of refinements that still exposes <lb/>the intermediate steps of compilation (e.g., CompCertO). Finally, even if the problem of vertical <lb/>composition was solved, it is not clear if the solution can support realistic optimizing compilers. <lb/>1.4 Our Contributions <lb/>In this paper, we propose an approach to direct refinements for VCC of imperative programs that <lb/>addresses all of the above challenges. Our approach is based on the memory model of CompCert <lb/>which supports first-order states and pointers. We show that in this memory model interpolating <lb/>states for proving vertical compositionality of refinements can be constructed by exploiting the <lb/>properties on memory invariants known as memory injections. The solution is based on a new <lb/>discovery that a Kripke relation with memory protection can serve as a uniform and composable <lb/>relation for characterizing the evolution of memory states across external calls. With this relation <lb/>we successfully combined the correctness theorems of CompCert&apos;s passes into a direct refinement <lb/>between C and assembly modules. We summarize our technical contributions below: <lb/>• We prove that injp-a Kripke Memory Relation with a notion of memory protection-is <lb/>both uniform (i.e., memory transformation in every compiler pass respects this relation) and <lb/>composable (i.e., transitive modulo an equivalence relation). The critical observation making <lb/>this proof possible is that interpolating memory states can be constructed by exploiting <lb/>memory protection inherent to memory injections and the functional nature of injections. <lb/>• Based on the above observation, we show that a direct refinement from C to assembly can be <lb/>derived by composing open refinements for all of CompCert&apos;s passes starting from Clight. <lb/>In particular, we show that compiler passes can use different Kripke relations sufficient for <lb/>their proofs (which may be weaker than injp) and these relations will later be absorbed <lb/>into injp via refinements of open semantics. Furthermore, we show that assumptions for <lb/>compiler optimizations can be formalized as semantic invariants and, when piggybacked onto <lb/>injp, can be transitively composed. Based on these techniques, we upgrade the proofs in <lb/>CompCertO to get a direct refinement from C to assembly for the full CompCert, including all <lb/>of its optimization passes. These experiments show that direct refinements can be obtained <lb/>without fundamental changes to the verification framework of CompCert. <lb/>• We demonstrate the simplicity and usefulness of direct refinements by applying it to end-to-<lb/>end verification of several non-trivial examples with heterogeneous modules that mutually <lb/>invoke each other. In particular, we observe that C level refinements can be absorbed into <lb/>the direct refinement of CompCert by transitivity of injp. Combining direct refinements <lb/>with full compositionality and adequacy, we derive end-to-end refinements from high-level <lb/>source specifications to syntactically linked assembly modules in a straightforward manner. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:6 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>/* client .c */ <lb/>int result ; <lb/>void encrypt ( int i , <lb/>void (* p)( int *) ); <lb/>void process ( int *r) <lb/>{ <lb/>result = *r; <lb/>10 } <lb/>11 <lb/>12 int request ( int i) <lb/>13 { <lb/>14 <lb/>encrypt (i , process ); <lb/>15 <lb/>return i; <lb/>16 } <lb/>(a) Client in C <lb/>1 /* server .s */ <lb/>2 key : <lb/>3 <lb/>. long 42 <lb/>4 encrypt : <lb/>5 <lb/>// allocate frame <lb/>6 <lb/>Pallocframe 24 16 0 <lb/>7 <lb/>// RSP [8] = i XOR key <lb/>8 <lb/>Pmov key RAX <lb/>9 <lb/>Pxor RAX RDI <lb/>10 <lb/>Pmov RDI 8( RSP ) <lb/>11 <lb/>// call p( RSP + 8) <lb/>12 <lb/>Plea 8( RSP ) RDI <lb/>13 <lb/>Pcall RSI <lb/>14 <lb/>// free frame <lb/>15 <lb/>Pfreeframe 24 16 0 <lb/>16 <lb/>Pret <lb/>(b) Server in Asm <lb/>1 /* server_opt .s <lb/>2 <lb/>* key is an constant <lb/>3 <lb/>* and inlined in code */ <lb/>4 encrypt : <lb/>5 <lb/>// allocate frame <lb/>6 <lb/>Pallocframe 24 16 0 <lb/>7 <lb/>// RSP [8] = i XOR 42 <lb/>8 <lb/>Pxori 42 RDI <lb/>9 <lb/>10 <lb/>Pmov RDI 8( RSP ) <lb/>11 <lb/>// call p( RSP + 8) <lb/>12 <lb/>Plea 8( RSP ) RDI <lb/>13 <lb/>Pcall RSI <lb/>14 <lb/>// free frame <lb/>15 <lb/>Pfreeframe 24 16 0 <lb/>16 <lb/>Pret <lb/>(c) Optimized Server <lb/>Fig. 3. An Example of Encryption Client and Server <lb/>The above developments are fully formalized in Coq based on the latest CompCertO which <lb/>is in turn built on top of CompCert v3.10 (see the data-availability statement at the end of the <lb/>paper for more details). While the formalisation of our approach is tied to CompCert&apos;s block-based <lb/>memory model [Leroy et al. 2012], and applied to its particular chain of compilation, we present <lb/>evidence in §7 that variants of injp could be adapted for alternate memory models for first-order <lb/>languages, and that it may be extended to support new optimizations. Therefore, this work provides <lb/>a promising direction for further evolving the techniques for VCC. <lb/>1.5 Structure of the Paper <lb/>Below we first introduce the key ideas supporting this work in §2. We then introduce necessary <lb/>background and discuss the technical challenges for building direct refinements in §3. We present <lb/>our technical contributions in §4, §5 and §6. We discuss the generality and limitations of our <lb/>approach in §7. We discuss evaluation and related work in §8 and finally conclude in §9. <lb/>2 KEY IDEAS <lb/>We introduce a running example with heterogeneous modules and callback functions to illustrate <lb/>the key ideas of our work. This example is representative of mutual dependency between modules <lb/>that often appears in practice and it shows how free-form invocation between modules can be <lb/>supported by our approach. As we shall see in §6, our approach also handles more complicated <lb/>programs with mutually recursive heterogeneity without any problem. <lb/>The example is given in Fig. 3. It consists of a client written in C (Fig. 3a) and an encryption <lb/>server hand-written in x86 assembly by using CompCert&apos;s assembly syntax where instruction <lb/>names begin with P (Fig. 3b). For now, let us ignore Fig. 3c which illustrates how optimizations <lb/>work in direct refinements. Users invoke request to initialize an encryption request. It is relayed to <lb/>the function encrypt in the server with the prototype void encrypt(int i, void (*p)(int*)) <lb/>which respects a calling convention placing the first and second arguments in registers RDI and <lb/>RSI, respectively. The main job of the server is to encrypt i (RDI) by XORing it with an encryption <lb/>key (stored in the global variable key) and invoke the callback function p (RSI). Finally, the client <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:7 <lb/></page>
    
    <body>1 <lb/>1 : <lb/>1 <lb/>2 <lb/>2 <lb/>Guarantee <lb/>′ <lb/>2 <lb/>2 : <lb/>′ <lb/>2 <lb/>′ <lb/>1 <lb/>′ <lb/>1 <lb/>Rely <lb/>≼ <lb/>(a) Rely-Guarantee Simulation <lb/>1 <lb/>1 : <lb/>′ <lb/>1 <lb/>′ <lb/>1 <lb/>1 <lb/>2 <lb/>2 : <lb/>′ <lb/>2 <lb/>′ <lb/>2 <lb/>2 <lb/>3 <lb/>3 : <lb/>′ <lb/>3 <lb/>′ <lb/>3 <lb/>3 <lb/>≼ <lb/>12 <lb/>≼ <lb/>23 <lb/>Rely <lb/>Rely <lb/>(b) Naive Vertical Composition <lb/>1 <lb/>1 : <lb/>′ <lb/>1 <lb/>′ <lb/>1 <lb/>1 <lb/>3 <lb/>3 : <lb/>′ <lb/>3 <lb/>′ <lb/>3 <lb/>3 <lb/>≼ <lb/>13 <lb/>Rely <lb/>(c) A Direct Refinement <lb/>Fig. 5. Basic Concepts of Open Simulations <lb/>takes over and stores the encrypted value in the global variable result. The pseudo instruction <lb/>Pallocframe m n o allocates a stack frame of m bytes and stores its address in register RSP. In <lb/>this frame, a pointer to the caller&apos;s stack frame is stored at the o-th byte and the return address is <lb/>stored at the n-th byte. Note that Pallocframe 24 16 0 in encrypt reserves 8 bytes on the stack <lb/>from RSP + 8 to RSP + 16 for storing the encrypted value whose address is passed to the callback <lb/>function p. Pfreeframe m n o frees the frame and restores RSP and the return address RA. <lb/>[[client.c]] <lb/>[[client.s]] <lb/>CompCert <lb/>≼ <lb/>ac <lb/>S <lb/>[[server.s]] <lb/>≼ <lb/>ac <lb/>⊕ <lb/>⊕ <lb/>[[client.s + server.s]] <lb/>≼ <lb/>id <lb/>CS <lb/>≼ <lb/>c <lb/>≼ <lb/>ac <lb/>Fig. 4. Verifying the Running Example <lb/>With the running example, our goal is to verify its <lb/>end-to-end correctness by exploiting the direct refine-<lb/>ment ≼ ac : A ⇔ C derived from CompCert&apos;s compi-<lb/>lation chain as shown in Fig. 4. The verification pro-<lb/>ceeds as follows. First, we establish [[client.s]] ≼ ac <lb/>[[client.c]] by the correctness of compilation. Then, <lb/>we prove [[server.s]] ≼ ac S manually by providing <lb/>a specification S for the server that respects the direct <lb/>refinement. At the source level, the combined semantics <lb/>is further refined to a single top-level specification CS . Fi-<lb/>nally, the source and target level refinements are absorbed <lb/>into the direct refinement by vertical composition and <lb/>adequacy, resulting in a single direct refinement between <lb/>the top-level specification and the target program: <lb/>[[client.s + server.s]] ≼ ac CS <lb/>The refinements of open modules discussed in our paper are based on forward simulations <lb/>between small-step operational semantics (often in the form of labeled transition systems or LTS) <lb/>which have been witnessed in a wide range of verification projects [Gu et al. 2015; Jiang et al. 2019; <lb/>Koenig and Shao 2021; Song et al. 2020; Stewart et al. 2015; Wang et al. 2019]. Fig. 5a depicts a <lb/>refinement 2 ≼ 1 between two open semantics (LTS) 1 and 2 . The source (target) semantics <lb/>1 ( 2 ) is initialized with a query (i.e., function call) 1 ( 2 ) and may invoke an external call ′ <lb/>1 <lb/>( ′ <lb/>2 ) as the execution goes. The execution continues when ′ <lb/>1 ( ′ <lb/>2 ) returns with a reply ′ <lb/>1 ( ′ <lb/>2 ) and <lb/>finishes with a reply 1 ( 2 ). For the refinement to hold, an invariant between the source and target <lb/>program states must hold throughout the execution which is denoted by the vertical double arrows <lb/>in Fig. 5a. Furthermore, this refinement relies on external calls satisfying certain well-behavedness <lb/>conditions (known as rely-conditions; e.g., external calls do not modify the private memory of <lb/>callers). In turn, it guarantees the entire source and target execution satisfy some well-behavedness <lb/>conditions (known as guarantee-conditions, e.g., they do not modify the private memory of their <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:8 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>calling environments). The rely-guarantee conditions are essential for horizontal composition: two <lb/>refinements 1 ≼ 2 and ′ <lb/>1 ≼ ′ <lb/>2 with complementary rely-guarantee conditions can be composed <lb/>into a single refinement 1 ⊕ 2 ≼ ′ <lb/>1 ⊕ ′ <lb/>2 . However, vertical composition of such refinements <lb/>is difficult. A naive vertical composition of two refinements (one between 1 and 2 and another <lb/>between 2 and 3 ) simply concatenates them together like Fig. 5b, instead of generating a single <lb/>refinement between 1 and 3 like Fig. 5c. 1 This exposes the intermediate semantics (i.e., 2 ) and <lb/>imposes serious limitations on VCC as discussed in §1.2. Therefore, to the best of our knowledge, <lb/>none of the existing approaches fully support the verification outlined in Fig. 4. <lb/>To address the above problem, we develop direct refinements with the following distinguishing <lb/>features: 1) they always relate the semantics of modules at their native interfaces, thereby supporting <lb/>adequacy; 2) they do not mention the intermediate process of compilation, thereby supporting <lb/>heterogeneous modules and compilers; 3) they provide direct memory protection for source and <lb/>target semantics via a Kripke relation, thereby enabling horizontal composition of refinements <lb/>for heterogeneous modules; 4) most importantly, they are vertically composable. The first three <lb/>features are manifested in the very definition of direct refinements, which we shall discuss in §2.1 <lb/>below. We then discuss the vertical composition of direct refinements in §2.2, which relies on the <lb/>discovery of the uniformity and transitivity of a Kripke relation for memory protection. <lb/>2.1 Refinement Supporting Adequacy, Heterogeneity and Horizontal Composition <lb/>To illustrate the key ideas, we use the top-level direct refinement ≼ ac in Fig. 4 as an example. In the <lb/>remaining discussions we adopt the block-based memory model of CompCert [Leroy et al. 2012] <lb/>where a memory state consists of a disjoint set of memory blocks. ≼ ac is a forward simulation that <lb/>directly relates C and assembly modules with their native language interfaces. By the definition of <lb/>these interfaces (See §3.1), a C query C = [sg] (ì )@ is a function call to with signature sg, <lb/>a list of arguments ì and a memory state ; a C reply C = ′ @ ′ carries a return value ′ and <lb/>an updated memory state ′ . An assembly query A = rs@ invokes a function with the current <lb/>register set rs and memory state . An assembly reply A = rs ′ @ ′ returns from a function with <lb/>the updated registers rs ′ and memory ′ . By definition, 2 ≼ ac 1 means that 1 and 2 behave like <lb/>C and assembly programs at the boundary of modules, respectively. However, there is no restriction <lb/>on how 1 and 2 are actually implemented internally, which enables source-level specifications <lb/>with C interfaces like S in Fig. 4. <lb/>The rely and guarantee conditions imposed by ≼ ac are symmetric and bundled with the simulation <lb/>invariants at the boundary of modules. They make assumptions about how C and assembly queries <lb/>should be related at the call sites and provide conclusions about how the replies should be related <lb/>after the calls return. Given any matching source and target queries C = [sg] (ì )@ 1 and <lb/>A = rs@ 2 , it is assumed that <lb/>(1) The memory states are related by an invariant known as a memory injection function [Leroy <lb/>et al. 2012], i.e., memory blocks in 1 are projected by into those in 2 ; <lb/>(2) The function pointer is related to the program counter register in rs; <lb/>(3) The source arguments ì are projected either to registers in rs or to outgoing argument slots <lb/>in the stack frame RSP in 2 according to the C calling convention; <lb/>(4) The outgoing arguments on the target stack frame are freeable and not in the image of . <lb/>The first three requirements ensure that C arguments and memory are related to assembly regis-<lb/>ters and memory according to CompCert&apos;s C calling convention. The last one ensures outgoing <lb/>arguments are protected, thereby preserving the invariant of open simulation across external calls. <lb/></body>
    
    <note place="footnote">1 To simplify the presentation, we often elide the guarantee conditions in figures for simulation. <lb/></note>

      <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:9 <lb/></page>
    
    <body>encrypt( , )@ 1 <lb/>([ , ], 1 ) <lb/>([ , ], ′ <lb/>1 ) <lb/>( 0 )@ ′ <lb/>1 <lb/>()@ ′′ <lb/>1 <lb/>. . . <lb/>@ 2 <lb/>@ 2 <lb/>′ @ ′<lb/>2 <lb/>′ @ ′ <lb/>2 <lb/>′′ @ ′′ <lb/>2 . . . <lb/>1 <lb/>1 <lb/>1 <lb/>2 <lb/>2 <lb/>2 <lb/>initial <lb/>query <lb/>external <lb/>query <lb/>external <lb/>reply <lb/>injp <lb/>S : <lb/>[[server.s]]: <lb/>≼ <lb/>ac <lb/>Fig. 6. Direct Refinement of the Hand-wri en Server <lb/>After the function calls return, the source and target queries C = res@ ′ <lb/>1 and A = rs ′ @ ′ <lb/>2 <lb/>must satisfy the following requirements: <lb/>(1) The updated memory states ′ <lb/>1 and ′ <lb/>2 are related by an updated memory injection ′ ; <lb/>(2) The C-level return value res is related to the value stored in the register for return value; <lb/>(3) For any callee-saved register r, rs ′ (r) = rs(r); <lb/>(4) The stack pointer register and program counter are restored. <lb/>(5) The access to memory during the function call is protected by a Kripke Memory Relation injp <lb/>such that the private stack data for other function calls are not modified. <lb/>The first two requirements ensure that return values and memories are related according to the <lb/>calling convention. The following two ensure that registers are correctly restored before returning. <lb/>The last requirement plays a critical role in rely-guarantee reasoning and enables horizontal <lb/>composition of direct refinements as we shall see soon. <lb/>2.1.1 Adequacy and Heterogeneity via Direct Refinement. By definition, ≼ ac is basically a formalized <lb/>C calling convention for CompCert with direct relations between C and assembly operational <lb/>semantics and with invariants for protecting register values and memory states. Adequacy is <lb/>automatically guaranteed as syntactic linking coincides with semantics linking at the assembly <lb/>level. That is, given any assembly modules a.s and b.s, [[a.s + b.s]] ≼ id [[a.s]] ⊕ [[b.s]]. <lb/>Moreover, ≼ ac does not mention anything about compilation. It works for any heterogeneous <lb/>module and compilation chain that meet its requirements, even for hand-written assembly. Take <lb/>the refinement of [[server.s]] ≼ ac S in Fig. 4 as an example. The first few steps of the simulation <lb/>are depicted in Fig. 6, where S is an LTS hand-written by us and [[server.s]] is derived from <lb/>the CompCert assembly semantics. Because S is only required to respect the C interface, we <lb/>choose a form easy to comprehend where its internal executions are in big steps. Now, suppose the <lb/>environment calls encrypt with source and target queries initially related by CompCert&apos;s calling <lb/>convention s.t. (RDI) = and (RSI) = . After the initialization 1 and 2 , the execution enters <lb/>internal states related by an invariant . Then, the target execution takes internal steps 2 until <lb/>reaching an external call. This corresponds to executing lines 5-13 in Fig. 3b, which allocates the <lb/>stack frame RSP, performs encryption by storing i XOR key at the address RSP+8, and calls back <lb/>with RSP+8. At the source level, these steps correspond to one big-step execution 1 which allocates <lb/>a memory block 0 , stores i XOR key at 0 , and prepares to call with 0 . Therefore, the memory <lb/>injection in maps 0 to RSP+8. The source and target execution continue with transitions 1 and <lb/>2 to the external calls to , return from and go on until they return from encrypt. <lb/>2.1.2 Horizontal Composition via Kripke Memory Relations. The Kripke Memory Relation (KMR) <lb/>injp provides essential protection for private values on the stack, which ensures that simulations <lb/>between heterogeneous modules can be established and their horizontal composition is feasible. <lb/>We illustrate these points via our running example. Assume that the environment calls request <lb/>in the client with 11 which in turn calls encrypt in the server to get the value 11 XOR 42 = 33 <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:10 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>Source Environment <lb/>[[client.c]] <lb/>S <lb/>[[client.c]] <lb/>request(11) <lb/>encrypt(11, <lb/>process) <lb/>process( 0 ) <lb/>result <lb/>C : <lb/>42 <lb/>key <lb/>. . . <lb/>11 <lb/>i <lb/>33 <lb/>0 <lb/>0 <lb/>r <lb/>′ <lb/>result <lb/>Asm : <lb/>42 <lb/>′ <lb/>key <lb/>. . . <lb/>RSP RBX RA <lb/>RSP 1 <lb/>RSP 1 33 RA 1 <lb/>RSP 2 <lb/>RSP 2 RA 2 <lb/>RSP 3 <lb/>Target Environment <lb/>[[client.s]] <lb/>[[server.s]] <lb/>[[client.s]] <lb/>request <lb/>encrypt <lb/>process <lb/>Fig. 7. Snapshot of the Memory State a er Call Back <lb/>whose address is passed back to the client by calling process. Fig. 7 depicts a snapshot of the <lb/>memory states and the injection right after process is entered (i.e., at line 8 in Fig. 3a), where boxes <lb/>denote allocated memory blocks, black arrows between blocks denote injections, and red arrows <lb/>denote pointers. The source semantics allocates one block for each local variable ( for i, 0 for <lb/>the encrypted value 33 and for r) while the target semantics stores their values in registers or <lb/>stacks (11 is stored in RDI while 33 on the stack because its address is taken and may be modified by <lb/>the callee). One stack frame is allocated for each function call which stores private data including <lb/>pointers to previous frames ( RSP ), return addresses (RA), and callee-saved registers (e.g., RBX). <lb/>injp is essential for proving simulation for open modules as it guarantees simulation can be <lb/>re-established after external calls return. Informally, at every external call site, injp marks all <lb/>memory regions outside the footprint (domain and image) of the current injection as private and <lb/>does not allow the external call to modify those memory regions. From the perspective of server.s, <lb/>when the snapshot in Fig. 7 is taken, the execution is inside the thick dashed line in Fig. 6 and <lb/>protected by injp. Therefore, all the shaded memory in Fig. 7 are marked as private and protected <lb/>against the callback to process. Indeed, they correspond to either memory values turned into <lb/>temporary variables (e.g., ) or private stack data (e.g., RSP , RBX and RA in block RSP 1 ) that should <lb/>not be touched by process. Such protection ensures that when process returns, all the private <lb/>values are still valid, thereby re-establishing the simulation invariant. <lb/>The role of injp is reversed for the incoming calls from the environment: it guarantees that the <lb/>entire execution from the initial query to the final reply will not touch any private memory of <lb/>the environment. Therefore, injp is used to impose a reliance on memory protection by external <lb/>calls and to provide a symmetric guarantee of memory protection for the environment callers. Any <lb/>simulations with compatible language interfaces that satisfy this rely-guarantee condition can be <lb/>horizontally composed. For example, we can horizontally compose [[client.s]] ≼ ac [[client.c]] <lb/>and [[server.s]] ≼ ac S into [[client.s]] ⊕ [[server.s]] ≼ ac [[client.c]] ⊕ S in Fig. 4. <lb/>2.2 Uniform and Transitive KMR for Vertical Composition of Direct Refinements <lb/>Direct refinements are only useful if they can be vertically composed, which is critical for composing <lb/>refinements obtained from individual compiler passes into a single top-level refinement such as <lb/>≼ ac and for further composition with source-level refinements as shown in Fig. 4. <lb/>We discuss our approach for addressing this problem by using CompCert and CompCertO as the <lb/>concrete platforms. It is based on the following two observations. First, injp in fact captures the <lb/>rely-guarantee conditions for memory protection needed by every compiler pass in CompCert. At <lb/>a high-level, it means that the rely-guarantee conditions as depicted in Fig. 5 can all be replaced <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:11 <lb/></page>
    
    <body>by injp (modulo the details on language interfaces). Second, injp is transitively composable, i.e., <lb/>any vertical pairing of injp can be proved equivalent to a single injp. It means that given two <lb/>refinements 2 ≼ 12 1 and 3 ≼ 23 2 as depicted in Fig. 5b, when their rely-guarantee conditions are <lb/>uniformly represented by injp, they can be merged into the direct refinement 3 ≼ 13 1 in Fig. 5c <lb/>with a single injp as the rely-guarantee condition. We shall present the technical challenges leading <lb/>to these observations in §3 and elaborate on the observations themselves in §4. <lb/>By the above observations, an obvious approach for applying direct refinements to realistic <lb/>optimizing compilers is to prove open simulation for every compiler pass using injp, and vertically <lb/>compose those simulations into a single simulation. However, for a non-trivial compiler like Comp-<lb/>Cert, it means we need to rewrite a significant part of its proofs. More importantly, optimization <lb/>passes in CompCert need additional rely-guarantee conditions as they are based on value analysis. <lb/>To address the first problem, we start from the refinement proofs with least restrictive KMRs for <lb/>individual passes in CompCertO [Koenig and Shao 2021], and exploit the properties that these KMRs <lb/>can eventually be &quot;absorbed&quot; into injp in vertical composition to generate a direct refinement <lb/>parameterized only by injp. To address the second problem, we propose a notion of semantic <lb/>invariant that captures the rely-guarantee conditions for value analysis. When piggybacked onto <lb/>injp, this semantic invariant can be transitively composed along with injp and eventually pushed <lb/>to the C level. It then becomes a condition for enabling optimizations at the source level, e.g., for <lb/>supporting the refinement of the optimized server in Fig. 3c. We discuss those solutions in §5. <lb/>Finally, we observe that source-level refinements can also be parameterized by injp, which <lb/>enables end-to-end program verification as depicted in Fig. 4 as we shall discuss in §6. <lb/>3 BACKGROUND AND CHALLENGES <lb/>3.1 Background <lb/>We introduce the memory model, open simulations, and injp which is critical for direct refinements. <lb/>3.1.1 Block-based Memory Model. By Leroy et al. [2012], a memory state (of type mem) consists <lb/>of a disjoint set of memory blocks. A memory address or pointer ( , ) points to the -th byte in the <lb/>block where has type block and has type Z (integers). The value at ( , ) is denoted by [ , ]. <lb/>Values (of type val) are either undefined (Vundef), 32-or 64-bit integers or floats, or pointers of the <lb/>form Vptr( , ). For simplicity, we often write for Vptr( , 0). The memory operations including <lb/>allocation, free, read and write are provided and governed by permissions. The permission of <lb/>a memory cell is ordered from high to low as Freeable ⩾ Writable ⩾ Readable ⩾ NA where <lb/>Freeable enables all operations, Writable enables all but free, Readable enables only read, and <lb/>NA enables none. If 1 ⩾ 2 then any cell with permission 1 also has permission 2 . perm( , ) <lb/>denotes the set of cells with at least permission . For example, ( , ) ∈ perm( , Readable) iff the <lb/>cell at ( , ) in is readable. An address with no permission at all is not in the footprint of memory. <lb/>Transformations of memory states are captured via partial functions : block → ⌊block × Z⌋ <lb/>called injection functions, s.t. ( ) = ∅ if is removed from memory and ( ) = ⌊( ′ , )⌋ if is shifted <lb/>(injected) to ( ′ , ) in the target memory. We define meminj = block → ⌊block × Z⌋. 1 and 2 are <lb/>related under (denoted by 1 ↩→ 2 ) if either 1 is Vundef, or they are both equal scalar values, <lb/>or pointers shifted according to , i.e., 1 = Vptr( , ), ( ) = ⌊( ′ , ′ )⌋ and 2 = Vptr( ′ , + ′ ). <lb/>Given this relation, there is a memory injection between the source memory state 1 and the <lb/>target state 2 under (denoted by 1 ↩→ <lb/>2 ) if the following properties are satisfied which <lb/>ensure preservation of permissions and values under injection: <lb/>∀ 1 2 <lb/>′ , ( 1 ) = ⌊( 2 , ′ )⌋ ⇒ ( 1 , ) ∈ perm( 1 , ) ⇒ ( 2 , + ′ ) ∈ perm( 2 , ). <lb/>∀ 1 2 <lb/>′ , ( 1 ) = ⌊( 2 , ′ )⌋ ⇒ ( 1 , ) ∈ perm( 1 , Readable) ⇒ 1 [ 1 , ] ↩→ 2 [ 2 , + ′ ]. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:12 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>Memory injections are transitive and necessary for verifying transformations of memory structures <lb/>(e.g., merging local variables into stack-allocated data and generating a concrete stack frame). For <lb/>the remaining passes, a simpler relation called memory extension is used instead, which employs an <lb/>identity injection. Reasoning about permissions under refinements is a major source of complexity. <lb/>3.1.2 A Framework for Open Simulations. In CompCertO [Koenig and Shao 2021], a language <lb/>interface = ⟨ , ⟩ is a pair of sets <lb/>and <lb/>denoting acceptable queries and replies for open <lb/>modules, respectively. Different interfaces may be used for different languages. The relevant ones <lb/>for our discussion have been introduced in §2.1 and formally defined as follows. The language <lb/>interface at the C level is C = ⟨val × sig × val * × mem, val × mem⟩ where its queries and replies <lb/>take the forms [sg] (ì )@ and ′ @ ′ , respectively. The language interface at the assembly level <lb/>is A = ⟨regset × mem, regset × mem⟩ where its queries and replies take the form rs@ . <lb/>Open labeled transition systems (LTS) represent semantics of modules that may accept queries <lb/>and provide replies at the incoming side and provide queries and accept replies at the outgoing side <lb/>(i.e., calling external functions). An open LTS : ↠ is a tuple ⟨ , , , →, , , ⟩ where ( ) <lb/>is the language interface for outgoing (incoming) queries and replies, ⊆ <lb/>a set of initial queries, <lb/>a set of internal states, ⊆ × ( ⊆ × ) transition relations for incoming queries (replies), <lb/>⊆ × <lb/>( ⊆ × × ) transitions for outgoing queries (replies), and →⊆ × E * × internal <lb/>transitions emitting events of type E. Note that ( , ) ∈ iff an outgoing query <lb/>happens at ; <lb/>( , , ′ ) ∈ iff after <lb/>returns with <lb/>the execution continues with an updated state ′ . <lb/>Kripke relations are used to describe evolution of program states in open simulations between <lb/>LTSs. A Kripke relation : <lb/>→ { | ⊆ × } is a family of relations indexed by a Kripke <lb/>world ; for simplicity, we define K ( , ) = <lb/>→ { | ⊆ × }. A simulation convention <lb/>relating two language interfaces 1 and 2 is a tuple R = ⟨ , R : K ( 1 , 2 ), R : K ( 1 , 2 )⟩ <lb/>which we write as R : 1 ⇔ 2 . Simulation conventions serve as interfaces of open simulations <lb/>by relating source and target language interfaces. For example, a C-level convention c : C ⇔ <lb/>C = ⟨meminj, R c , R c ⟩ relates C queries and replies as follows, where the Kripke world consists of <lb/>injections and, in a given world , the values and memory in queries and replies are related by . <lb/>( [ ] (ì )@ , ′ [ ] ( ì ′ )@ ′ ) ∈ R c ( ) ⇔ <lb/>↩→ ′ ∧ ì ↩→ ì ′ ∧ ↩→ <lb/>′ <lb/>( @ , ′ @ ′ ) ∈ R c ( ) <lb/>⇔ <lb/>↩→ ′ ∧ ↩→ <lb/>′ <lb/>Open forward simulations describe refinement between LTS. To establish an open (forward) <lb/>simulation between 1 : 1 ↠ 1 and 2 : 2 ↠ 2 , one needs to find two simulation conventions <lb/>R : 1 ⇔ 2 and R : 1 ⇔ 2 that connect queries and replies at the outgoing and incoming <lb/>sides, and show the internal execution steps and external interactions of open modules are related <lb/>by an invariant . This simulation is denoted by 1 ⩽ R ↠R 2 and formally defined as follows (for <lb/>simplicity, we shall write 1 ⩽ R 2 to denote 1 ⩽ R↠R 2 ): <lb/>Definition 3.1. Given 1 : 1 ↠ 1 , 2 : 2 ↠ 2 , R : 1 ⇔ 2 and R : 1 ⇔ 2 , <lb/>1 ⩽ R ↠R 2 holds if there is some Kripke relation ∈ K ( 1 , 2 ) that satisfies: <lb/>(1) ∀ 1 2 , ( 1 , 2 ) ∈ R ( ) ⇒ ( 1 ∈ 1 ⇔ 2 ∈ 2 ) <lb/>(2) ∀ <lb/>1 2 1 , ( 1 , 2 ) ∈ R ( ) ⇒ ( 1 , 1 ) ∈ 1 ⇒ ∃ 2 , ( 1 , 2 ) ∈ ( ) ∧ ( 2 , 2 ) ∈ 2 . <lb/>(3) ∀ <lb/>1 2 , ( 1 , 2 ) ∈ ( ) ⇒ 1 → ′ <lb/>1 ⇒ ∃ ′ <lb/>2 , ( ′ <lb/>1 , ′ <lb/>2 ) ∈ ( ) ∧ 2 → * ′ <lb/>2 . <lb/>(4) ∀ <lb/>1 2 1 , ( 1 , 2 ) ∈ ( ) ⇒ ( 1 , 1 ) ∈ 1 ⇒ <lb/>∃ <lb/>2 , ( 1 , 2 ) ∈ R ( ) ∧ ( 2 , 2 ) ∈ 2 ∧ <lb/>∀ 1 2 <lb/>′ <lb/>1 , ( 1 , 2 ) ∈ R ( ) ⇒ ( 1 , 1 , ′ <lb/>1 ) ∈ 1 ⇒ ∃ ′ <lb/>2 , ( ′ <lb/>1 , ′ <lb/>2 ) ∈ ( ) ∧ ( 2 , 2 , ′ <lb/>2 ) ∈ 2 . <lb/>(5) ∀ <lb/>1 2 1 , ( 1 , 2 ) ∈ ( ) ⇒ ( 1 , 1 ) ∈ 1 ⇒ ∃ 2 , ( 1 , 2 ) ∈ R ( ) ∧ ( 2 , 2 ) ∈ 2 . <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:13 <lb/></page>
    
    <body>1 <lb/>1 <lb/>′ <lb/>1 <lb/>′ <lb/>1 <lb/>′ <lb/>1 <lb/>′′ <lb/>1 <lb/>′′′ <lb/>1 <lb/>1 <lb/>2 <lb/>2 <lb/>′ <lb/>2 <lb/>′ <lb/>2 <lb/>′ <lb/>2 <lb/>′′ <lb/>2 <lb/>′′′ <lb/>2 <lb/>2 <lb/>1 <lb/>1 <lb/>1 ( ′ <lb/>1 ) <lb/>1 <lb/>2 <lb/>2 <lb/>2 ( ′ <lb/>2 ) <lb/>2 <lb/>R <lb/>R <lb/>R <lb/>R <lb/>′ <lb/>′ <lb/>Fig. 8. Open Simulation between LTS <lb/>Here, property (1) requires initial queries to match; (2) requires initial states to hold under the <lb/>invariant ; (3) requires internal execution to preserve ; (4) requires to be preserved across exter-<lb/>nal calls, and (5) requires final replies to match. According to these properties, a complete forward <lb/>simulation looks like Fig. 8. From the above definition, it is easy to prove the horizontal and vertical <lb/>compositionality of open simulations and adequacy for assembly modules, i.e., ∀ 1 2 <lb/>′ <lb/>1 <lb/>′ <lb/>2 , 1 ⩽ R <lb/>2 ⇒ ′ <lb/>1 ⩽ R <lb/>′ <lb/>2 ⇒ 1 ⊕ ′ <lb/>1 ⩽ R 2 ⊕ ′ <lb/>2 and ∀ ( 1 2 : Asm), [[ 1 ]] ⊕ [[ 2 ]] ⩽ id [[ 1 + 2 ]]. <lb/>The Kripke worlds (e.g., memory injections) may evolve as the execution goes on. Rely-guarantee <lb/>reasoning about such evolution is essential for horizontal composition of simulations. For illus-<lb/>tration, the Kripke worlds at the boundary of modules are displayed in Fig. 8. The evolution of <lb/>worlds across external calls is governed by an accessibility relation <lb/>′ for describing the <lb/>rely-condition. By assuming <lb/>′ , one needs to prove the guarantee condition <lb/>′ , <lb/>i.e., the evolution of worlds in the whole execution respects <lb/>. Simulations with symmetric <lb/>rely-guarantee conditions can be horizontally composed, even with mutual calls between modules. <lb/>Note that the accessibility relation and evolution of Kripke worlds are not explicit in the definition <lb/>of simulation conventions. Instead, they are implicit by assuming a modality operator is always <lb/>applied to R s.t. ∈ R ( ) ⇔ ∃ ′ , <lb/>′ ∧ ∈ R ( ′ ). We often ignore accessibility and <lb/>modality when talking purely about simulation conventions in the remaining discussion. <lb/>Accessibility relations are mainly for describing evolution of memory states across external calls. <lb/>For this, simulation conventions are parameterized by Kripke Memory Relations or KMR. <lb/>Definition 3.2. A Kripke Memory Relation is a tuple ⟨ , , , ⟩ where <lb/>is a set of worlds, <lb/>: <lb/>→ meminj a function for extracting injections from worlds, ⊆ <lb/>× an accessibility <lb/>relation between worlds and : K (mem, mem) a Kripke relation over memory states that is <lb/>compatible with the memory operations. We write <lb/>′ for ( , ′ ) ∈ . <lb/>We write R to emphasize that a simulation convention R is parameterized by the KMR , meaning <lb/>R shares the same type of worlds with and inherits its accessibility relation. <lb/>The most interesting KMR is injp as it provides protection on memory w.r.t. injections. <lb/>Definition 3.3 (Kripke Relation with Memory Protection). injp = ⟨ injp , injp , injp , injp ⟩ where <lb/>injp = (meminj × mem × mem), injp ( , _, _) = , ( 1 , 2 ) ∈ injp ( , 1 , 2 ) ⇔ 1 ↩→ <lb/>2 and <lb/>( , 1 , 2 ) injp ( ′ , ′ <lb/>1 , ′ <lb/>2 ) ⇔ ⊆ ′ ∧ unmapped( ) ⊆ unchanged-on( 1 , ′ <lb/>1 ) <lb/>∧ out-of-reach( , 1 ) ⊆ unchanged-on( 2 , ′ <lb/>2 ). <lb/>∧ mem-acc( 1 , ′ <lb/>1 ) ∧ mem-acc( 2 , ′ <lb/>2 ) <lb/>Here, mem-acc( , ′ ) denotes monotonicity of memory states such as valid blocks can only increase <lb/>and read-only data does not change in value. unchanged-on( , ′ ) denotes memory cells whose <lb/>permissions and values are not changed from to ′ and <lb/>( 1 , 1 ) ∈ unmapped( ) <lb/>⇔ ( 1 ) = ∅ <lb/>( 2 , 2 ) ∈ out-of-reach( , 1 ) ⇔ ∀ 1 <lb/>′ <lb/>2 , ( 1 ) = ⌊( 2 , ′ <lb/>2 )⌋ ⇒ ( 1 , 2 -′ <lb/>2 ) ∉ perm( 1 , NA). <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:14 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>1 <lb/>2 <lb/>′ <lb/>1 <lb/>′ <lb/>2 <lb/>′ <lb/>Fig. 9. Kripke Worlds Related by injp <lb/>By definition, a world ( , 1 , 2 ) evolves to <lb/>( ′ , ′ <lb/>1 , ′ <lb/>2 ) under injp only if ′ is strictly larger <lb/>than and any memory cells in 1 and 2 not in <lb/>the domain (i.e., unmapped by ) or image of (i.e., <lb/>out-of-reach by from 1 ) will be protected, mean-<lb/>ing their values and permissions are unchanged from <lb/>1 ( 2 ) to ′ <lb/>1 ( ′ <lb/>2 ). An example is shown in Fig. 9 <lb/>where the shaded regions in 1 are unmapped by and unchanged while those in 2 are out-<lb/>of-reach from and unchanged. ′ <lb/>1 and ′ <lb/>2 may contain newly allocated blocks which are not <lb/>protected by injp. When injp is used at the outgoing side, it denotes that the simulation relies on <lb/>knowing that the unmapped and out-of-reach regions at the call side are not modified by external <lb/>calls. When injp is used at the incoming side, it denotes that the simulation guarantees such <lb/>regions at initial queries are not modified by the simulation itself. <lb/>3.2 Challenges for Vertically Composing Open Simulations <lb/>As discussed in §2.2, the challenge for constructing direct refinements for multi-pass optimizing <lb/>compilers lies in their vertical composition. The most basic vertical composition for open simulations <lb/>is stated below which is easily proved by pairing of individual simulations [Koenig and Shao 2021]. <lb/>Theorem 3.4 (V. Comp). Given 1 : 1 ↠ 1 , 2 : 2 ↠ 2 and 3 : 3 ↠ 3 , and given <lb/>R 12 : 1 ⇔ 2 , S 12 : 1 ⇔ 2 , R 23 : 2 ⇔ 3 and S 23 : 2 ⇔ 3 , <lb/>1 ⩽ R 12 ↠S 12 2 ⇒ 2 ⩽ R 23 ↠S 23 3 ⇒ 1 ⩽ R 12 •R 23 ↠S 12 •S 23 3 . <lb/>Here, (_ • _) is a composed simulation convention s.t. R • S = ⟨ R × S , R • S , R • S ⟩ where for <lb/>any 1 and 3 , ( 1 , 3 ) ∈ R • S ( R , S ) ⇔ ∃ 2 , ( 1 , 2 ) ∈ R ( R ) ∧ ( 2 , 3 ) ∈ S ( S ) (similarly <lb/>for R • S ). Then, given any compiler with passes and their refinement relations 1 ⩽ R 12 ↠S 12 <lb/>2 , . . . , <lb/>⩽ R , +1 ↠S , +1 <lb/>+1 , we get their concatenation 1 ⩽ R 12 •...•R , +1 ↠S 12 •...•S , +1 <lb/>+1 , <lb/>which exposes internal compilation and weakens compositionality as we have discussed in §1.2. <lb/>The above problem may be solved if the composed simulation convention can be refined into <lb/>a single convention directly relating source and target queries and replies. Given two simulation <lb/>conventions R, S : 1 ⇔ 2 , R is refined by S if <lb/>∀ S 1 2 , ( 1 , 2 ) ∈ S ( S ) ⇒ ∃ R , ( 1 , 2 ) ∈ R ( R )∧ <lb/>∀ 1 2 , ( 1 , 2 ) ∈ R ( R ) ⇒ ( 1 , 2 ) ∈ S ( S ) <lb/>which we write as R ⊑ S. If both R ⊑ S and S ⊑ R, then R and S are equivalent and written as <lb/>R ≡ S. By definition, R ⊑ S indicates any query for S can be converted into a query for R and any <lb/>reply resulting from the converted query can be converted back to a reply for S. By wrapping the <lb/>incoming side of an open simulation with a more general convention and its outgoing side with a <lb/>more specialized convention, one gets another valid open simulation [Koenig and Shao 2021]: <lb/>Theorem 3.5. Given 1 : 1 ↠ 1 and 2 : 2 ↠ 2 , if R ′ ⊑ R : 1 ⇔ 2 , R ⊑ R ′ : 1 ⇔ 2 <lb/>and 1 ⩽ R ↠R 2 , then 1 ⩽ R ′ ↠R ′ 2 . <lb/>Now, we would like to prove the &quot;real&quot; vertical composition generating direct refinements <lb/>(simulations). Given any 1 ⩽ R 12 ↠R 12 2 and 2 ⩽ R 23 ↠R 23 3 , if we can show the existence of <lb/>simulation conventions R 13 directly relating source and target semantics s.t. R 13 ≡ R 12 • R 23 , then <lb/>1 ⩽ R 13 ↠R 13 3 holds by Theorem 3.4 and Theorem 3.5, which is the desired direct refinement. <lb/>This composition is illustrated in Fig. 10 where the parts enclosed by dashed boxes represent the <lb/>concatenation of 1 ⩽ R 12 ↠R 12 2 and 2 ⩽ R 23 ↠R 23 3 . The direct queries and replies are split and <lb/>merged for interaction with parallelly running simulations underlying the direct refinement. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:15 <lb/></page>
    
    <body>1 <lb/>3 <lb/>2 <lb/>1 <lb/>3 <lb/>1 : <lb/>3 : <lb/>2 : <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>2 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>2 <lb/>1 <lb/>3 <lb/>2 <lb/>1 <lb/>3 <lb/>R 13 <lb/>R 12 <lb/>R 23 <lb/>R 12 <lb/>R 23 <lb/>R 13 <lb/>R 13 <lb/>R 12 <lb/>R 23 <lb/>R 12 <lb/>R 23 <lb/>R 13 <lb/>⇒ <lb/>⇒ <lb/>⇒ <lb/>⇒ <lb/>Fig. 10. Vertical Composition of Open Simulations by Refinement of Simulation Conventions <lb/>1 <lb/>2 <lb/>3 <lb/>12 <lb/>23 <lb/>1 <lb/>3 <lb/>13 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>13 <lb/>′ <lb/>1 <lb/>′ <lb/>2 <lb/>′ <lb/>3 <lb/>′ <lb/>12 <lb/>′ <lb/>23 <lb/>⇒ <lb/>13 <lb/>⇒ <lb/>12 <lb/>23 <lb/>(a) 13 ⊑ 12 • 23 <lb/>1 <lb/>13 <lb/>3 <lb/>1 <lb/>2 <lb/>3 <lb/>12 <lb/>23 <lb/>′ <lb/>1 <lb/>′ <lb/>2 <lb/>′ <lb/>3 <lb/>′ <lb/>12 <lb/>′ <lb/>23 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>13 <lb/>⇒ <lb/>12 <lb/>23 <lb/>⇒ <lb/>13 <lb/>(b) 12 • 23 ⊑ 13 <lb/>Fig. 11. Composition of KMRs <lb/>Since simulation conventions are parameterized by KMRs, a major obstacle to the real vertical <lb/>composition of open simulations is to prove KMRs for individual simulations can be composed into <lb/>a single KMR. For this, one needs to define refinements between KMRs. Given any KMRs and , <lb/>⊑ (i.e., is refined by ) holds if the following is true: <lb/>∀ <lb/>1 2 , ( 1 , 2 ) ∈ ( ) ⇒ ∃ <lb/>, ( 1 , 2 ) ∈ <lb/>( ) ∧ ( ) ⊆ ( ) ∧ <lb/>∀ ′ ′ <lb/>1 <lb/>′ <lb/>2 , <lb/>′ ⇒ ( ′ <lb/>1 , ′ <lb/>2 ) ∈ <lb/>( ′ ) ⇒ <lb/>∃ ′ , <lb/>′ ∧ ( ′ <lb/>1 , ′ <lb/>2 ) ∈ ( ′ ) ∧ ( ′ ) ⊆ ( ′ ). <lb/>We write ≡ to denote that and are equivalent, i.e., ⊑ and ⊑ . <lb/>Continue with the proof of real vertical composition, i.e., proving R 13 ≡ R 12 • R 23 . Assume <lb/>R is parameterized by KMR , showing the existence of R 13 s.t. R 13 ⊑ R 12 • R 23 amounts to <lb/>proving a parallel refinement over the parameterizing KMRs, i.e., there exists 13 s.t. 13 ⊑ 12 • 23 <lb/>where 12 • 23 = ⟨ 12 × 23 , 12 × 23 , 12 × 23 , 12 × 23 ⟩. A more intuitive interpretation is <lb/>depicted in Fig. 11a where black symbols are ∀-quantified (assumptions we know) and red ones are <lb/>∃-quantified (conclusions we need to construct). Note that Fig. 11a exactly mirrors the refinement <lb/>on the outgoing side in Fig. 10. For simplicity, we use not only to represent worlds, but also to <lb/>denote ( ) (where is the Kripke relation given by KMR ) when it connects memory states <lb/>through vertical lines. A dual property we need to prove for the incoming side is shown in Fig. 11b. <lb/>In both cases in Fig. 11, we need to construct interpolating states for relating source and target <lb/>memory (i.e., ′ <lb/>2 in Fig. 11a and 2 in Fig. 11b). The construction of ′ <lb/>2 is especially challenging, for <lb/>which we need to decompose the evolved world ′ <lb/>13 into ′ <lb/>12 and ′ <lb/>23 s.t. they are accessible from the <lb/>original worlds 12 and 23 . It is not clear at all how this construction is possible because 1) ′ <lb/>2 may <lb/>have many forms since Kripke relations are in general non-deterministic and 2) KMRs (e.g., injp) <lb/>introduce memory protection for external calls which may not hold after the (de-)composition. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:16 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>( 1 , 1 ) <lb/>( 2 , 2 ) <lb/>. . . <lb/>read <lb/>read <lb/>( ′ <lb/>1 , ′ <lb/>1 ) <lb/>( ′ <lb/>2 , ′ <lb/>2 ) <lb/>. . . <lb/>read <lb/>read <lb/>Fig. 12. Closure of Public Memory <lb/>1 <lb/>void f () { <lb/>2 <lb/>int x , y; <lb/>3 <lb/>g (&amp; y); <lb/>4 <lb/>} <lb/>(a) Example <lb/>′ <lb/>. . . <lb/>. . . <lb/>g <lb/>(b) SimplLocals <lb/>. . . <lb/>. . . <lb/>g <lb/>(c) Stacking <lb/>Fig. 13. Protection of Private Memory by injp <lb/>Because of the above difficulties, existing approaches either make substantial changes to semantics <lb/>for constructing interpolating states, thereby destroying adequacy [Stewart et al. 2015], or do not <lb/>even try to merge Kripke memory relations, but instead leave them as separate entities [Koenig <lb/>and Shao 2021; Song et al. 2020]. As a result, direct refinements cannot be achieved. <lb/>4 A UNIFORM AND TRANSITIVE KRIPKE MEMORY RELATION <lb/>To overcome the challenge for vertically composing open simulations, we exploit the observation <lb/>that injp in fact can be viewed as a most general KMR. Then, the compositionality of KMRs <lb/>discussed in §3.2 is reduced to transitivity of injp, i.e., injp ≡ injp • injp. <lb/>4.1 Uniformity of injp <lb/>We show that injp is both a reasonable guarantee condition and a reasonable rely condition for all <lb/>the compiler passes in CompCert. It is based on the observation that a notion of private and public <lb/>memory can be derived from injections and coincides with the protection provided by injp. <lb/>4.1.1 Public and Private Memory via Memory Injections. <lb/>Definition 4.1. Given 1 ↩→ <lb/>2 , the public memory regions in 1 and 2 are defined as follows: <lb/>pub-src-mem( ) <lb/>= {( , ) | ( ) ≠ ∅}; <lb/>pub-tgt-mem( , 1 ) = {( , ) | ∃ ′ ′ , ( ′ ) = ⌊( , ′ )⌋ ∧ ( ′ , -′ ) ∈ perm( 1 , NA)}. <lb/>By definition, a cell ( , ) is public in the source memory if it is in the domain of , and ( , ) is <lb/>public in the target memory if it is mapped by from some valid public source memory. Any memory <lb/>not public with respect to is private. We can see that private memory corresponds exactly to un-<lb/>mapped and out-of-reach memory defined by injp, i.e., for any and , ( , ) ∈ pub-src-mem( ) ⇔ <lb/>( , ) ∉ unmapped( ) and ( , ) ∈ pub-tgt-mem( , ) ⇔ ( , ) ∉ out-of-reach( , ). <lb/>With Definition 4.1 and the properties of memory injection (see §3.1.1), we can easily prove <lb/>access of pointers in a readable and public source location gets back another public location. <lb/>Lemma 4.2. Given 1 ↩→ <lb/>2 , <lb/>∀ 1 1 , ( 1 , 1 ) ∈ pub-src-mem( ) ⇒ ( 1 , 1 ) ∈ perm( 1 , Readable) ⇒ <lb/>1 [ 1 , 1 ] = Vptr( ′ <lb/>1 , ′ <lb/>1 ) ⇒ ( ′ <lb/>1 , ′ <lb/>1 ) ∈ pub-src-mem( ). <lb/>It implies that readable public memory regions form a &quot;closure&quot; such that the sequences of reads <lb/>are bounded inside these regions, as shown in Fig. 12. The horizontal arrows indicates a pointer <lb/>value ( +1 , +1 ) is read from ( , ) with possible adjustment with pointer arithmetic. Note that <lb/>all memory cells at ( , )s and ( ′ , ′ )s have Readable permission. By Lemma 4.2, ( , )s are all <lb/>in public regions. By Definition 4.1, the mirroring reads ( ′ , ′ )s are also in public regions. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:17 <lb/></page>
    
    <body>4.1.2 injp as a Uniform Rely Condition. injp is adequate for preventing external calls from <lb/>interfering with internal execution for all the compiler passes of CompCert. 2 To illustrate this <lb/>point, we discuss the effect of injp on two of CompCert&apos;s passes using Fig. 13a as an example <lb/>where g is an external function. The first pass is SimplLocals which converts local variables whose <lb/>memory addresses are not taken into temporary ones. As shown in Fig. 13b, x is turned into a <lb/>temporary variable at the target level which is not visible to g. Therefore, x at the source level <lb/>becomes private data as its block is unmapped by , thereby protected by injp and cannot be <lb/>modified by g. The second pass is Stacking which expands the stack frames with private regions <lb/>for return addresses, spilled registers, arguments, etc. Continuing with our example, the only public <lb/>stack data in Fig. 13c is . All the private data is out-of-reach, thereby protected by injp. <lb/>4.1.3 injp as a Uniform Guarantee Condition. For injp to serve as a uniform guarantee condition, <lb/>it suffices to show the private memory of the environment is protected between initial calls and <lb/>final replies. During an open forward simulation, all incoming values and memories are related <lb/>by some initial injection (e.g., ì 1 ↩→ ì 2 and 1 ↩→ <lb/>2 ). In particular, the pointers in them are <lb/>related by . Therefore, any sequence of reads starting from pointers stored in the initial queries <lb/>only inspect public memories in the source and target, as already shown in Fig. 12. The private (i.e., <lb/>unmapped or out-of-reach) regions of the initial memories are not modified by internal execution. <lb/>Moreover, because injection functions only grow bigger during execution but never change in <lb/>value and the outgoing calls have injp as a rely-condition, the initially unmapped (out-of-reach) <lb/>regions will stay unmapped (out-of-reach) and be protected during external calls. As a result, we <lb/>conclude that injp is a reasonable guarantee condition for any open simulation. <lb/>4.2 Transitivity of injp <lb/>1 <lb/>2 <lb/>3 <lb/>12 <lb/>23 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>injp <lb/>′ <lb/>13 ⇒ <lb/>1 <lb/>2 <lb/>3 <lb/>12 <lb/>23 <lb/>′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>13 <lb/>′ <lb/>2 <lb/>′ <lb/>12 <lb/>′ <lb/>23 <lb/>injp <lb/>injp <lb/>Fig. 14. Construction of Interpolating States <lb/>The goal is to show the two refinements <lb/>in Fig. 11 hold when <lb/>= injp, i.e., injp ≡ <lb/>injp•injp. As discussed in §3.2, the critical step <lb/>is to construct interpolating memory states that <lb/>transitively relate source and target states. The <lb/>construction is based on two observations: 1) <lb/>the memory injections deterministically decide <lb/>the value and permissions of public memory <lb/>because they encode partial functional transfor-<lb/>mations on memory states, and 2) any memory <lb/>not in the domain or range of the partial functions is protected (private) and unchanged throughout <lb/>external calls. Although the proof is quite involved, the result can be reused for all compiler passes <lb/>thanks to injp&apos;s uniformity. <lb/>4.2.1 injp ⊑ injp • injp. By definition, we need to prove the following lemma: <lb/>Lemma 4.3. injp ⊑ injp • injp holds. That is, <lb/>∀ 12 23 1 2 3 , 1 ↩→ 12 <lb/>2 ⇒ 2 ↩→ 23 <lb/>3 ⇒ ∃ 13 , 1 ↩→ 13 <lb/>3 ∧ <lb/>∀ ′ <lb/>1 <lb/>′ <lb/>3 <lb/>′ <lb/>13 , ( 13 , 1 , 3 ) injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ) ⇒ ′ <lb/>1 ↩→ <lb/>′ <lb/>13 <lb/>′ <lb/>3 ⇒ <lb/>∃ ′ <lb/>2 <lb/>′ <lb/>12 <lb/>′ <lb/>23 , ( 12 , 1 , 2 ) injp ( ′ <lb/>12 , ′ <lb/>1 , ′ <lb/>2 ) ∧ ′ <lb/>1 ↩→ <lb/>′ <lb/>12 <lb/>′ <lb/>2 <lb/>∧( 23 , 2 , 3 ) injp ( ′ <lb/>23 , ′ <lb/>2 , ′ <lb/>3 ) ∧ ′ <lb/>2 ↩→ <lb/>′ <lb/>23 <lb/>′ <lb/>3 . <lb/>This lemma conforms to the graphic representation in Fig. 11a. To prove it, an obvious choice <lb/>is to pick 13 = 23 • 12 . Then, we are left to prove the existence of interpolating state ′ <lb/>2 and the <lb/></body>
    
    <note place="footnote">2 In fact, the properties in Definition 3.3 are exactly from CompCert&apos;s assumptions on external calls. <lb/></note>
	<note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:18 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>1 <lb/>1 <lb/>2 <lb/>1 <lb/>3 <lb/>1 <lb/>1 <lb/>2 <lb/>2 <lb/>2 <lb/>3 <lb/>2 <lb/>1 <lb/>3 <lb/>2 <lb/>3 <lb/>1 : <lb/>2 : <lb/>3 : <lb/>12 <lb/>23 <lb/>(a) At the External Call <lb/>1 <lb/>1 <lb/>2 <lb/>1 <lb/>3 <lb/>1 <lb/>1 <lb/>2 <lb/>2 <lb/>2 <lb/>3 <lb/>2 <lb/>1 <lb/>3 <lb/>2 <lb/>3 <lb/>4 <lb/>1 <lb/>4 <lb/>2 <lb/>3 <lb/>3 <lb/>4 <lb/>3 <lb/>′ <lb/>1 : <lb/>′ <lb/>2 : <lb/>′ <lb/>3 : <lb/>′ <lb/>12 <lb/>′ <lb/>23 <lb/>(b) A er the External Call <lb/>Fig. 15. Constructing of an Interpolating Memory State <lb/>memory and accessibility relations as shown in Fig. 14. By definition, ′ <lb/>2 consists of memory blocks <lb/>newly allocated with respect to 2 and blocks that already exist in 2 . The latter can be further <lb/>divided into public and private memory regions with respect to injections 12 and 23 . Then, ′ <lb/>2 is <lb/>constructed following the ideas that 1) the public and newly allocated memory should be projected <lb/>from the updated source memory ′ <lb/>1 by ′ <lb/>12 , and 2) the private memory is protected by injp and <lb/>should be copied over from 2 to ′ <lb/>2 . <lb/>We use the concrete example in Fig. 15 to motivate the construction of ′ <lb/>2 . Here, the white <lb/>and green areas correspond to locations in perm(_, NA) (with at least some permission) and in <lb/>perm(_, Readable) (with at least readable permission), respectively. Given 1 ↩→ 12 <lb/>2 , 2 ↩→ 23 <lb/>3 and ( 23 • 12 , 1 , 3 ) injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ), we need to define ′ <lb/>12 and ′ <lb/>23 and build ′ <lb/>2 satisfying <lb/>′ <lb/>1 ↩→ <lb/>′ <lb/>12 <lb/>′ <lb/>2 , ′ <lb/>2 ↩→ <lb/>′ <lb/>23 <lb/>′ <lb/>3 , ( 12 , 1 , 2 ) injp ( ′ <lb/>12 , ′ <lb/>1 , ′ <lb/>2 ), and ( 23 , 2 , 3 ) injp ( ′ <lb/>23 , ′ <lb/>2 , ′ <lb/>3 ). <lb/>′ <lb/>1 and ′ <lb/>3 are expansions of 1 and 3 with new blocks and possible modification to the public <lb/>regions of 1 and 3 . Here, ′ <lb/>1 has a new block 4 <lb/>1 and ′ <lb/>3 has two new block 3 <lb/>3 and 4 <lb/>3 . <lb/>We first fix ′ <lb/>12 , ′ <lb/>23 and the shape of blocks in ′ <lb/>2 . We begin with 2 and introduce a newly <lb/>allocated block 4 <lb/>2 whose shape matches 4 <lb/>1 in ′ <lb/>1 . Then, ′ <lb/>12 is obtained by expanding 12 with <lb/>identity mapping from 4 <lb/>1 to 4 <lb/>2 . Furthermore, ′ <lb/>23 is also expanded with a mapping from 4 <lb/>2 to a <lb/>block in ′ <lb/>3 ; this mapping is determined by ′ <lb/>13 . <lb/>We then set the values and permissions for memory cells in ′ <lb/>2 so that it satisfies injection and the <lb/>unchanged-on properties for readable memory regions implied by ( 12 , 1 , 2 ) injp ( ′ <lb/>12 , ′ <lb/>1 , ′ <lb/>2 ) <lb/>and ( 23 , 2 , 3 ) injp ( ′ <lb/>23 , ′ <lb/>2 , ′ <lb/>3 ). The values and permissions for newly allocated blocks are <lb/>obviously mapped from ′ <lb/>1 by ′ <lb/>12 . Those for old blocks are fixed as follows. By memory protection <lb/>provided in ( 23 • 12 , 1 , 3 ) injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ), the only memory cells in 1 that may have been <lb/>modified in ′ <lb/>1 are those mapped all the way to 3 by 23 • 12 , while the cells in 3 that may be <lb/>modified in ′ <lb/>3 must be in the image of 23 • 12 . To match this fact, the only old memory regions <lb/>in ′ <lb/>2 whose values and permissions may be modified are those both in the image of 12 and the <lb/>domain of 23 . Those are the public memory with respect to 12 and 23 and displayed as the gray <lb/>areas in Fig. 15b. Following idea 1) above, the values and permissions in those regions are projected <lb/>from ′ <lb/>1 by applying the injection function 12 . Note that there is an exception: values in read-only <lb/>public regions are copied over from 2 . Following idea 2) above, the remaining old memory regions <lb/>are private with respect to 12 and 23 and should have the same values and permissions as in 2 . <lb/>Note that the accessibility relations ( 12 , 1 , 2 ) <lb/>injp ( ′ <lb/>12 , ′ <lb/>1 , ′ <lb/>2 ) and ( 23 , 2 , 3 ) <lb/>injp <lb/>( ′ <lb/>23 , ′ <lb/>2 , ′ <lb/>3 ) can be derived from ( 23 • 12 , 1 , 3 ) injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ) because the latter enforces <lb/>stronger protection than the former. This is due to unmapped and out-of-reach regions getting <lb/>bigger as memory injections get composed. For example, in Fig. 15, 1 <lb/>1 is mapped by 12 but becomes <lb/>unmapped by 23 • 12 ; the image of 1 <lb/>2 in 1 <lb/>3 is in reach by 23 but becomes out-of-reach by 23 • 12 . <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:19 <lb/></page>
    
    <body>Table 1. Significant Passes of CompCert <lb/>Languages/Passes Outgoing ↠ Incoming <lb/>Clight <lb/>C ↠ C <lb/>Self-Sim <lb/>ro • c injp ↠ ro • c injp <lb/>SimplLocals <lb/>c injp ↠ c inj <lb/>Csharpminor <lb/>C ↠ C <lb/>Cminorgen <lb/>c injp ↠ c inj <lb/>Cminor <lb/>C ↠ C <lb/>Selection <lb/>wt • c ext ↠ wt • c ext <lb/>CminorSel <lb/>C ↠ C <lb/>RTLgen <lb/>c ext ↠ c ext <lb/>RTL <lb/>C ↠ C <lb/>Self-Sim <lb/>c inj ↠ c inj <lb/>Tailcall <lb/>c ext ↠ c ext <lb/>Inlining <lb/>c injp ↠ c inj <lb/>Self-Sim <lb/>c injp ↠ c injp <lb/>Language/Pass <lb/>Outgoing ↠ Incoming <lb/>Constprop <lb/>ro • c injp ↠ ro • c injp <lb/>CSE <lb/>ro • c injp ↠ ro • c injp <lb/>Deadcode <lb/>ro • c injp ↠ ro • c injp <lb/>Unusedglob <lb/>c inj ↠ c inj <lb/>Allocation <lb/>wt • c ext • CL ↠ wt • c ext • CL <lb/>LTL <lb/>L ↠ L <lb/>Tunneling <lb/>ltl ext ↠ ltl ext <lb/>Linear <lb/>L ↠ L <lb/>Stacking <lb/>ltl injp • LM ↠ LM • mach inj <lb/>Mach <lb/>M ↠ M <lb/>Asmgen <lb/>mach ext • MA ↠ mach ext • MA <lb/>Asm <lb/>A ↠ A <lb/>Self-Sim <lb/>asm inj ↠ asm inj <lb/>Self-Sim <lb/>asm injp ↠ asm injp <lb/>4.2.2 injp • injp ⊑ injp. By definition, we need to prove: <lb/>Lemma 4.4. injp • injp ⊑ injp holds. That is, <lb/>∀ 13 1 3 , 1 ↩→ 13 <lb/>3 ⇒ ∃ 12 23 2 , 1 ↩→ 12 <lb/>2 ∧ 2 ↩→ 23 <lb/>3 ∧ <lb/>∀ ′ <lb/>1 <lb/>′ <lb/>2 <lb/>′ <lb/>3 <lb/>′ <lb/>12 <lb/>′ <lb/>23 , ( 12 , 1 , 2 ) injp ( ′ <lb/>12 , ′ <lb/>1 , ′ <lb/>2 ) ⇒ ( 23 , 2 , 3 ) injp ( ′ <lb/>23 , ′ <lb/>2 , ′ <lb/>3 ) ⇒ <lb/>′ <lb/>1 ↩→ <lb/>′ <lb/>12 <lb/>′ <lb/>2 ⇒ ′ <lb/>2 ↩→ <lb/>′ <lb/>23 <lb/>′ <lb/>3 ⇒ ∃ ′ <lb/>13 , ( 13 , 1 , 3 ) injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ) ∧ ′ <lb/>1 ↩→ <lb/>′ <lb/>13 <lb/>′ <lb/>3 . <lb/>This lemma conforms to Fig. 11b. To prove it, we pick 12 to be an partial identity injection <lb/>( 12 ( ) = ⌊ , 0⌋ when 13 ( ) ≠ ∅) , 23 = 13 and 2 = 1 . Then the lemma is reduced to proving <lb/>the existence of ′ <lb/>13 that satisfies ( 13 , 1 , 3 ) <lb/>injp ( ′ <lb/>13 , ′ <lb/>1 , ′ <lb/>3 ) and ′ <lb/>1 ↩→ <lb/>′ <lb/>13 <lb/>′ <lb/>3 . By picking <lb/>′ <lb/>13 = ′ <lb/>12 • ′ <lb/>23 , we can easily prove these properties by exploiting the properties of injp. <lb/>5 DERIVATION OF THE DIRECT REFINEMENT FOR COMPCERT <lb/>In this section, we discuss the proofs and composition of open simulations for the compiler passes of <lb/>CompCert into the direct refinement ≼ ac following the ideas discussed in §2.2. CompCert compiles <lb/>Clight programs into Asm programs through 19 passes [Leroy 2023], including several optimization <lb/>passes working on the RTL intermediate language. First, we prove the open simulations for all <lb/>these passes with appropriate simulation conventions. In particular, we directly reuse the proofs of <lb/>non-optimizing passes in CompCertO and update the proofs of optimizing passes with semantic <lb/>invariants. Second, we prove a collection of properties for refining simulation conventions in <lb/>preparation for vertical composition. Those properties enable absorption of KMRs into injp and <lb/>composition of semantic invariants. They rely critically on transitivity of injp. Finally, we vertically <lb/>compose the simulations and refine the incoming and outgoing simulation conventions into a <lb/>single simulation convention C, thereby establishing ⩽ C as the top-level refinement ≼ ac . <lb/>5.1 Open Simulation of Individual Passes <lb/>We list the compiler passes and their simulation types in Table 1 (passes on the right follow the <lb/>passes on the left) together with their source and target languages and interfaces (in bold fonts). <lb/>The passes in black are reused from CompCertO, while those in red are reproved optimizing passes. <lb/>The passes in blue are self-simulating passes we inserted; they will be used in §5.3 for refining <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:20 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>composed simulation conventions. Note that we have omitted passes with the identity simulation <lb/>convention (i.e., simulations of the form 1 ⩽ id 2 ) in Table 1 as they do not affect the proofs. 3 <lb/>5.1.1 Simulation Conventions and Semantic Invariants. We first introduce relevant simulation <lb/>conventions and semantic invariants shown in Table 1. The simulation conventions c : C ⇔ C, <lb/>ltl : L ⇔ L, mach : M ⇔ M, and asm : A ⇔ A relate the same language interfaces with <lb/>queries and replies native to the associated intermediate languages. They are parameterized by <lb/>a KMR to allow different compiler passes to have different assumptions on memory evolution. <lb/>Conceptually, this parameterization is unnecessary as we can simply use injp for every pass <lb/>due to its uniformity (as discussed in §4.1). Nevertheless, it is useful because the compiler proofs <lb/>become simpler and more natural with the least restrictive KMRs which may be weaker than injp. <lb/>CompCertO defines several KMRs weaker than injp: id is used when memory is unchanged; ext <lb/>is used when the source and target memory share the same structure; inj is a simplified version of <lb/>injp without its memory protection. The simulation conventions CL : C ⇔ L, LM : L ⇔ M and <lb/>MA : M ⇔ A capture the calling convention of CompCert: CL relates C-level queries and replies to <lb/>those in the LTL language where the arguments are distributed to abstract stack slots; LM further <lb/>relates abstract stack slots with states on an architecture independent machine; MA relates this state <lb/>to registers and memory in the assembly language (X86 assembly in our case). As discussed before, <lb/>some refinements rely on invariants on the source semantics. The semantic invariant wt enforces <lb/>that arguments and return values of function calls respect function signatures. ro is critical for <lb/>ensuring the correctness of optimizations, which will be discussed next. <lb/>1 const int key = 42; <lb/>2 void foo ( int *) ; <lb/>3 int double_key () { <lb/>4 <lb/>int a = key ; <lb/>5 <lb/>foo (&amp; key ); <lb/>6 <lb/>return a + key ; <lb/>7 } <lb/>(a) Source Program <lb/>1 const int key = 42; <lb/>2 void foo ( int *) ; <lb/>3 int double_key () { <lb/>4 <lb/>int a = 42; <lb/>5 <lb/>foo (&amp; key ); <lb/>6 <lb/>return 84; <lb/>7 } <lb/>(b) Target Program <lb/>Fig. 16. An Example of Constant Propagation <lb/>5.1.2 Open Simulation of Optimizations. <lb/>The optimizing passes Constprop, CSE and <lb/>Deadcode perform constant propagation, com-<lb/>mon subexpression elimination and dead code <lb/>elimination, respectively. They make use of a <lb/>static value analysis algorithm for collecting <lb/>information of variables during the execution. <lb/>For each function, this algorithm starts with <lb/>the known initial values of read-only (con-<lb/>stant) global variables. It simulates the func-<lb/>tion execution to analyze the values of global <lb/>or local variables after executing each instruc-<lb/>tion. In particular, for global constant variables, <lb/>their references at any point should have the initial values of constants. For local variables stored <lb/>on the stack, their references may have initial values or may not if interfered by other function calls. <lb/>When the analysis encounters a call to another function, it checks whether the address of current <lb/>stack frame is leaked to the callee directly through arguments or indirectly through pointers in <lb/>memory. If not, then the stack frame is considered unreachable from its callee. Consequently, the <lb/>references to local variables on unreachable stack frames after function calls remain to be their <lb/>initial values. Based on this analysis, the three passes then identify and perform optimizations. <lb/>Most of the proofs of closed simulations for those passes can be adapted to open simulation <lb/>straightforwardly. The only and main difficulty is to prove that information derived from static <lb/>analysis is consistent with the dynamic memory states in incoming queries and after external calls <lb/>return. We introduce the semantic invariant ro and combine it with injp to ensure this consistency. <lb/>The above optimization passes all use ro • c injp as their simulation conventions (because RTL <lb/></body>
    
    <note place="footnote">3 The omitted passes are Cshmgen, Renumber, Linearize, CleanupLabels and Debugvar. <lb/></note>
	<note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:21 <lb/></page>
    
    <body>42 <lb/>key <lb/>42 <lb/>a <lb/>42 <lb/>42 <lb/>1 : <lb/>2 : <lb/>(a) Before foo <lb/>42 <lb/>key <lb/>42 <lb/>a <lb/>42 <lb/>42 <lb/>1 <lb/>1 : <lb/>2 : <lb/>(b) Start of foo <lb/>42 <lb/>key <lb/>42 <lb/>a <lb/>42 <lb/>42 <lb/>2 <lb/>′ <lb/>1 : <lb/>′ <lb/>2 : <lb/>(c) End of foo <lb/>42 <lb/>key <lb/>42 <lb/>a <lb/>42 <lb/>42 <lb/>3 <lb/>′ <lb/>1 : <lb/>′ <lb/>2 : <lb/>(d) A er foo <lb/>Fig. 17. Memory Injections from Call to Return of foo <lb/>conforms to the C interface). The adaptation of optimization proofs for those passes is similar. As <lb/>an example, we only discuss constant propagation whose correctness theorem is stated as follows: <lb/>Lemma 5.1. ∀( <lb/>′ : RTL), Constprop( ) = ′ ⇒ [[ ]] ⩽ ro•c injp [[ ′ ]]. <lb/>Instead of presenting its proof, we illustrate how ro and injp help establish the open simulation <lb/>for Constprop through a concrete example as depicted in Fig. 16. This example covers optimization <lb/>for both global constants (e.g., key) and local variables (e.g., a). By static analysis of Fig. 16a, 1) key <lb/>contains 42 at line 4 because key is a constant global variable and, 2) both key and a contain 42 <lb/>after the external call to foo returns to line 6. Here, the analysis confirms key has the value 42 <lb/>because foo (if well-behaved) will not modify a constant global variable. Furthermore, a has the <lb/>value 42 because it resides in the stack frame of double_key which is unreachable from foo (in <lb/>fact, a is the only variable in the frame). As a result, the source program is optimized into Fig. 16b. <lb/>We first show that ro guarantees the dynamic values of global constants are consistent with <lb/>static analysis. That is, global variables are correct in incoming memory and are protected during <lb/>external calls. ro is defined as follows: <lb/>Definition 5.2. ro : C ⇔ C = ⟨ ro , R ro , R ro ⟩ where ro = (symtbl × mem) and <lb/>R ro (se, ) = {( [sg] (ì )@ , [sg] (ì )@ ) | ro-valid( , )} <lb/>R ro (se, ) = {(res@ ′ , res@ ′ ) | mem-acc( , ′ )} <lb/>Note that although ro takes the form of a simulation convention, it only relates the same queries <lb/>and replies, i.e., it only enforces invariants on the source side. This kind of simulation conventions <lb/>are what we called semantic invariants. A symbol table (of type symtbl) is provided together <lb/>with memory, so that the semantics can locate the memory blocks and initial values of global <lb/>definitions. ro-valid( , ) states that the values of global constant variables in the incoming <lb/>memory are the same as their initial values. Therefore, the optimization of key into 42 at line 4 <lb/>of Fig. 16a is correct. For the call to foo, mem-acc( , ′ ) ensures that read-only values in memory <lb/>are unchanged, therefore ro-valid is preserved across external calls (i.e., ro-valid( , ) ⇒ <lb/>mem-acc( , ′ ) ⇒ ro-valid( , ′ )). As a result, replacing key with 42 at line 6 makes sense. <lb/>We then show that injp guarantees the dynamic values of unreachable local variables are <lb/>consistent with static analysis. That is, unreachable stack values are unchanged by external calls. <lb/>This protection is realized by injp with shrinking memory injections. Fig. 17 shows the protection <lb/>of a when calling foo. Before the external call to foo, the source blocks a and key are mapped to <lb/>target blocks by the current injection . The analysis determines that the argument and memory <lb/>passed to foo do not contain any pointer to a . Therefore, we can simply remove a from to get a <lb/>shrunk yet valid memory injection 1 . Then, a is protected during the call to foo. a is added back <lb/>to the injection after foo returns and the simulation continues. <lb/>Finally, Unusedglob which removes unused static global variables is verified by assuming that <lb/>global symbols remain the same throughout the compilation and with a weaker KMR inj. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:22 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>1 <lb/>2 <lb/>3 <lb/>( 1 , 1 ) <lb/>( 2 , 2 ) <lb/>1 <lb/>3 <lb/>( 1 , 1 ) <lb/>1 <lb/>3 <lb/>( 1 , 1 ) <lb/>1 <lb/>2 <lb/>3 <lb/>( 1 , 1 ) <lb/>( 2 , 2 ) <lb/>⇒ <lb/>⇒ <lb/>mem-acc <lb/>mem-acc <lb/>(a) ro • c injp ⊑ ro • c injp • ro • c injp <lb/>1 <lb/>( 1 , 1 ) <lb/>3 <lb/>1 <lb/>1 <lb/>3 <lb/>( 1 , 1 ) <lb/>( 1 , 1 ) <lb/>1 <lb/>2 <lb/>3 <lb/>( 1 , 1 ) <lb/>( 1 , 1 ) <lb/>1 <lb/>3 <lb/>( 1 , 1 ) <lb/>⇒ <lb/>⇒ <lb/>mem-acc <lb/>(b) ro • c injp • ro • c injp ⊑ ro • c injp <lb/>Fig. 18. Transitivity of ro • c injp <lb/>5.2 Properties for Refining Simulation Conventions <lb/>We present properties necessary for refining the composed simulation conventions in Table 1. <lb/>5.2.1 Commutativity of KMRs and Structural Conventions. <lb/>Lemma 5.3. For Z ∈ {CL, LM, MA} and ∈ {ext, inj, injp} we have X • Z ⊑ Z • Y . <lb/>This lemma is provided by CompCertO [Koenig and Shao 2021]. X and Y denote the simulation <lb/>conventions for the source and target languages of Z, respectively (e.g., X = c and Y = ltl when <lb/>Z = CL). If = injp we get c injp •CL ⊑ CL•ltl injp . This lemma indicates at the outgoing (incoming) <lb/>side a convention lower (higher) than CL, LM and MA may be lifted over them to a higher position <lb/>(pushed down to a lower position). <lb/>5.2.2 Absorption of KMRs into injp. The lemma below is needed for absorbing KMRs into injp: <lb/>Lemma 5.4. For any R, (1)R injp • R injp ≡ R injp (2)R injp ⊑ R inj (3)R injp • R inj • R injp ⊑ R injp <lb/>(4)R inj • R inj ⊑ R inj (5)R ext • R inj ≡ R inj (6)R inj • R ext ≡ R inj (7)R ext • R ext ≡ R ext . <lb/>The simulation convention R is parameterized over a KMR. Property (1) is a direct consequence <lb/>of injp • injp ≡ injp, which is critical for merging simulations using injp. The remaining ones <lb/>either depend on transitivity of injp, or trivially hold as shown by Koenig and Shao [2021]. <lb/>5.2.3 Composition of Semantic Invariants. Lastly, we also need to handle the two semantic invari-<lb/>ants ro and wt. They cannot be absorbed into injp because their assumptions are fundamentally <lb/>different. Therefore, our goal is to permute them to the top-level and merge any duplicated copies. <lb/>The following lemmas enable elimination and permutation of wt: <lb/>Lemma 5.5. For any R : C ⇔ C, we have (1)R • wt ≡ wt • R • wt and (2)R • wt ≡ wt • R . <lb/>ro is more difficult to handle as it does not commute with arbitrary simulation conventions. To <lb/>eliminate redundant ro, we piggyback ro onto injp and prove the following transitivity property: <lb/>Lemma 5.6. ro • c injp ≡ ro • c injp • ro • c injp <lb/>Its proof is similar to that for c injp ≡ c injp • c injp but with additional reasoning for establishing <lb/>ro. A graphic presentation of the proof is given in Fig. 18 which mirrors Fig. 11. We focus on the <lb/>additional reasoning and have omitted the injp relations and the worlds for injp in Fig. 18. Note <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:23 <lb/></page>
    
    <body>that by definition the worlds ( , ) for ro do not evolve like those for injp. A red circle around a <lb/>memory state indicates the necessity to prove that ro-valid in R ro holds for . The mem-acc <lb/>relations over dashed arrows are the properties over replies in R ro and must also be verified. <lb/>The above additional properties are proved based on two observations. First, the properties for <lb/>queries (i.e., ro-valid) are propagated in refinement along with copying of memory states. For <lb/>example, to prove the refinement in Fig. 18a, we are given ro-valid( 1 , 1 ) and ro-valid( 2 , 2 ) <lb/>according to the initial R ro relations. By choosing ( 1 , 1 ) to be the world for the composed R ro , <lb/>ro-valid( 1 , 1 ) holds trivially for 1 in the circle. To prove the refinement in Fig. 18b, we need to <lb/>prove that the interpolating memory state after the initial decomposition satisfies R ro . By choosing <lb/>1 to be this state (in the middle circle in Fig. 18b and according to the proof of Lemma 4.4), <lb/>ro-valid( 1 , 1 ) follows directly from the initial assumption. Second, the properties for replies <lb/>(i.e., mem-acc) have already been encoded into injp by Definition 3.3. For example, 2 in Fig. 18a <lb/>is constructed by following exactly Lemma 4.3. Therefore, mem-acc( 2 , 2 ) trivially holds. <lb/>Finally, at the top level, we need ro and wt to commute which is straightforward to prove: <lb/>Lemma 5.7. ro • wt ≡ wt • ro <lb/>5.3 Proving the Direct Open Simulation for CompCert <lb/>We first insert self-simulations into the compiler passes, as shown in Table 1. This is to supply extra <lb/>R inj , R injp , and ro for absorbing R ext (R inj ) into R inj (R injp ) by properties in Lemma 5.4 and for <lb/>transitive composition of ro. Self-simulations are obtained by the following lemma: <lb/>Theorem 5.8. If is a program written in Clight or RTL and R ∈ {ro, c ext , c inj , c injp }, or is <lb/>written in Asm and R ∈ {asm ext , asm inj , asm injp }, then [[ ]] ⩽ R↠R [[ ]] holds. <lb/>We unify the conventions at the incoming and outgoing sides. We start with the simulation <lb/>1 ⩽ R↠S 2 which is the transitive composition of compiler passes in Table 1 where <lb/>R = ro • c injp • c injp • c injp • wt • c ext • c ext • c inj • c ext • c injp • c injp • ro • c injp • ro • c injp <lb/>•ro • c injp • c inj • wt • c ext • CL • ltl ext • ltl injp • LM • mach ext • MA • asm inj • asm injp <lb/>S = ro • c injp • c inj • c inj • wt • c ext • c ext • c inj • c ext • c inj • c injp • ro • c injp • ro • c injp <lb/>•ro • c injp • c inj • wt • c ext • CL • ltl ext • LM • mach inj • mach ext • MA • asm inj • asm injp . <lb/>We then find two sequences of refinements C ⊑ R ⊑ . . . ⊑ R 1 ⊑ R and S ⊑ S 1 ⊑ . . . ⊑ S ⊑ C, <lb/>by which and Theorem 3.5 we get the simulation 1 ⩽ C↠C 2 . The direct simulation convention is <lb/>C = ro • wt • CAinjp • asm injp . ro enables optimizations at C level while wt ensures well-typedness. <lb/>The definition of CAinjp has already been discussed informally in §2.1; its formal definition is <lb/>given in the technical report [Zhang et al. 2023b]. The last asm injp is irrelevant as assembly code is <lb/>self-simulating by Theorem 5.8. The final correctness theorem is shown below: <lb/>Theorem 5.9. Compilation in CompCert is correct in terms of open simulations, <lb/>∀ ( : Clight) ( ′ : Asm), CompCert( ) = ′ ⇒ [[ ]] ⩽ C [[ ′ ]]. <lb/>We explain how the refinements are carried out at the outgoing side. Refinements at the incoming <lb/>side are similar. The following is the sequence of refined simulation conventions C ⊑ R ⊑ . . . ⊑ <lb/>R 1 ⊑ R. It begins with R and ends with C. <lb/>(1) ro • c injp • c injp • c injp • wt • c ext • c ext • c inj • c ext • c injp • ro • c injp • ro • c injp • ro • c injp <lb/>•c inj • wt • c ext • CL • ltl ext • ltl injp • LM • mach ext • MA • asm inj • asm injp <lb/>(2) ro • c injp • wt • c inj • c injp • ro • c injp <lb/>•c inj • wt • c ext • CL • ltl ext • ltl injp • LM • mach ext • MA • asm inj • asm injp <lb/>(3) ro • c injp • wt • c inj • wt • c injp • ro • c injp <lb/>•c inj • c ext • CL • ltl ext • ltl injp • LM • mach ext • MA • asm inj • asm injp <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:24 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>Calle <lb/>Callp <lb/>Retp <lb/>Rete <lb/>alloc <lb/>encrypt <lb/>free <lb/>external <lb/>(a) S <lb/>rs@ <lb/>A <lb/>A <lb/>A <lb/>A <lb/>external <lb/>(b) [[server_opt.s]] <lb/>Fig. 19. Specification and Open Semantics of server_opt.s <lb/>(4) wt • ro • c injp • c inj • c injp • ro • c injp <lb/>•c inj • c ext • CL • ltl ext • ltl injp • LM • mach ext • MA • asm inj • asm injp <lb/>(5) wt • ro • c injp • c inj • c injp • ro • c injp • c inj • c ext • c ext • c injp • c ext • c inj • CL • LM • MA • asm injp <lb/>(6) wt • ro • c injp • c injp • c injp • ro • c injp • c injp • c injp • c injp • CL • LM • MA • asm injp <lb/>(7) wt • ro • c injp • ro • c injp • CL • LM • MA • asm injp <lb/>(8) wt • ro • c injp • CL • LM • MA • asm injp <lb/>(9) ro • wt • c injp • CL • LM • MA • asm injp <lb/>(10) ro • wt • CAinjp • asm injp <lb/>In each line, the letters in red are simulation conventions transformed by the refinement operation <lb/>at that step. In step (1), we merge simulation conventions and semantic invariants by property (1) <lb/>and (5-7) in Lemma 5.4 and by Lemma 5.6. In steps (2-3), we move and eliminate wt by Lemmas 5.5 <lb/>and 5.7. In step (4), we lift conventions to higher positions by Lemma 5.3. In step (5), we absorb c ext <lb/>into c inj and turns c inj into c injp by property (2) in Lemma 5.4. In steps (6) and (7), we compose <lb/>c injp and ro by their transitivity. In step (8), we commute semantic invariants by Lemma 5.7. Finally, <lb/>we merge c injp and CL • LM • MA into CAinjp in step (9). <lb/>6 END-TO-END VERIFICATION OF HETEROGENEOUS MODULES <lb/>In this section, we give a formal account of end-to-end verification of heterogeneous modules based <lb/>on direct refinements. The discussion focuses on the running example in Fig. 4 and its variants. <lb/>Additional examples can be found in the technical report [Zhang et al. 2023b]. <lb/>6.1 Refinement for the Hand-wri en Server <lb/>We use server_opt.s instead of server.s to illustrate how optimizations are enabled by ro. The <lb/>proof for the unoptimized server is similar with only minor adjustments. A formal definition of <lb/>LTS for S is given below and its transition diagram is given in Fig. 19a. <lb/>Definition 6.1. LTS of S : <lb/>:= {Calle <lb/>, Callp sp <lb/>, Retp sp , Rete }; <lb/>:= {(Vptr( , 0) [int → ptr → void] ([ , ])@ , Calle <lb/>)}; <lb/>→ := {(Calle <lb/>, Callp sp <lb/>′′ ) | ( ′ , sp) = alloc 0 8 ∧ <lb/>′′ = ′ [sp ← ( XOR [ ])]} ∪ {(Retp sp , Rete ′ ) | ′ = free sp}; <lb/>:= {(Callp sp Vptr( , 0) , Vptr( , 0) [ptr → void] ([Vptr(sp, 0)])@ )}; <lb/>:= {(Callp sp <lb/>, @ ′ , Retp sp ′ )}; <lb/>:= {(Rete , Vundef@ )}. <lb/>The LTS has four internal states as depicted in Fig. 19a. Initialization is encoded in . If the incoming <lb/>query contains a function pointer Vptr( , 0) which points to encrypt, S enters Calle <lb/>where and <lb/>are its arguments. The first internal transition allocates the stack frame sp and <lb/>stores the result of encryption XOR [ ] in sp where <lb/>contains key. Then, it enters Callp <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:25 <lb/></page>
    
    <body>C <lb/>A <lb/>Calle <lb/>rs@tm <lb/>Callp sp <lb/>1 <lb/>rs 1 @tm 1 <lb/>C <lb/>A <lb/>C <lb/>A <lb/>Retp sp 2 <lb/>rs 2 @tm 2 <lb/>Rete 3 <lb/>rs 3 @tm 3 <lb/>C <lb/>A <lb/>S <lb/>S <lb/>S <lb/>S <lb/>alloc sp <lb/>store sp <lb/>free sp <lb/>A <lb/>Pallocframe <lb/>... Pcall <lb/>A <lb/>A <lb/>Pfreeframe <lb/>Pret <lb/>A <lb/>Fig. 20. Open Simulation between the Optimized Server and its Specification <lb/>which is the state before calling process. If the pointer <lb/>= Vptr( , 0) of the current state <lb/>points to an external function, S issues an outgoing C query <lb/>with a pointer to its stack frame <lb/>as its argument. After the external call, updates the memory with the reply and enters Retp. <lb/>The second internal transition frees and enters Rete and finally returns. Note that complete <lb/>semantics of S is accompanied by a local symbol table which determines the initial value of global <lb/>variables (key) and asserts that it is a constant. The only difference between the specifications for <lb/>server_opt.s and server.s is whether key is a constant in the symbol table. The semantics of <lb/>assembly module [[server_opt.s]] is given by CompCertO whose transition diagram is shown <lb/>in Fig. 19b. All the states, including queries and replies, are composed of register sets and memories. <lb/>Now, we need to prove the following forward simulation. The most important points of the proof <lb/>are how ro enables optimizations and how injp preserves memory across external calls. <lb/>Theorem 6.2. S ⩽ C [[server_opt.s]]. <lb/>At the top level, we expand C to ro • wt • CAinjp • asm injp and switch the order of ro and wt <lb/>by Lemma 5.7. By the vertical compositionality (Theorem 3.4), we first establish S ⩽ wt S with the <lb/>well-typed outgoing arguments and return value. [[server_opt.s]] ⩽ asm injp [[server_opt.s]] is <lb/>proved by Theorem 5.8. <lb/>We are left with proving S ⩽ ro•CAinjp [[server_opt.s]]. That is, we need to show the simulation <lb/>diagram in Fig. 20 holds where S = ro • CAinjp (which mirrors Fig. 6). Here, the given assumptions <lb/>and the conclusions to be proved are represented as black and red arrows, respectively. For the <lb/>proof, we need an invariant ∈ K ro•CAinjp ( , regset × mem). The most important point is that <lb/>ro and injp play essential roles in establishing the invariant. First, ro-valid is propagated from <lb/>the initial source query C to internal program states. This guarantees that the value of key read <lb/>from the source memory states is always 42, hence matching the constant in Pxori 42 RDI in <lb/>server_opt.s. Second, injp is essential for deriving that memory locations in the target stack <lb/>frame with offset ( &lt; 8 or 16 ≤ ) are unchanged since they are designated out-of-reach by . <lb/>Therefore, the private stack values of the server are protected. For the unoptimized server, the only <lb/>difference is that we decompose S ⩽ ro•CAinjp [[server.s]] into S ⩽ ro S which trivially holds <lb/>and S ⩽ CAinjp [[server.s]] which can be proved without the help of ro. <lb/>6.2 End-to-end Correctness Theorem <lb/>We first prove the following source-level refinement where CS is the top-level specification. Its <lb/>proof follows the same pattern as Theorem 6.2 but is considerably simpler because the source and <lb/>target semantics share the same C interface. <lb/>Lemma 6.3. CS ⩽ ro•wt•c injp [[client.c]] ⊕ S . <lb/>We then prove the following simulation, which is immediate from the full compositionality, the <lb/>adequacy for assembly described in §3.1.2, Theorem 5.9, and Theorem 6.2: <lb/>Lemma 6.4. [[client.c]] ⊕ S ⩽ C [[client.s + server_opt.s]]. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:26 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>/* client .c */ <lb/># define N 10 <lb/>int input [N] = {...}; <lb/>int result [N ]; <lb/>int i; <lb/>void encrypt ( int i , <lb/>void (* p)( int *) ); <lb/>1 <lb/>void request ( int *r) { <lb/>2 <lb/>if (i == 0) encrypt ( input [i ++] , request ); <lb/>3 <lb/>else if (0 &lt; i &amp;&amp; i &lt; N) { <lb/>4 <lb/>result [i -1] = *r; <lb/>5 <lb/>encrypt ( input [i ++] , request ); <lb/>6 <lb/>} else result [i -1] = *r; <lb/>7 <lb/>} <lb/>Fig. 21. Client with Multiple Encryption Requests <lb/>For end-to-end direct refinement, we need to absorb Lemma 6.3 into Lemma 6.4. The following <lb/>theorem is easily derived by applying Lemmas 5.5, 5.6 and 5.7. <lb/>Lemma 6.5. C ≡ ro • wt • c injp • C. <lb/>The final end-to-end simulation is immediate by vertically composing Lemma 6.3, Lemma 6.4 <lb/>and refining the simulation convention using Lemma 6.5. <lb/>Theorem 6.6. CS ⩽ C [[client.s + server_opt.s]]. <lb/>6.3 Verification of the Mutually Recursive Client and Server <lb/>We introduce a variant of the running example with mutual recursion in Fig. 21. The server <lb/>remains the same while the client is changed. request itself is passed as a callback function to <lb/>encrypt, resulting in recursive calls to encrypt for encrypting and storing an array of values. To <lb/>perform the same end-to-end verification for this example, we only need to define a new top-level <lb/>specification CS <lb/>′ and prove CS <lb/>′ ⩽ ro•wt•c injp [[client.c]] ⊕ S . Other proofs are either unchanged <lb/>(e.g., the refinement of the server) or can be derived from Theorem 5.9, full compositionality and <lb/>adequacy. The complete proofs can be found in the technical report [Zhang et al. 2023b]. <lb/>7 GENERALITY AND LIMITATIONS OF OUR APPROACH <lb/>We explain how our approach may be generalized to support other memory models, compilers and <lb/>optimizations for first-order languages. We also discuss the limitations of our approach. <lb/>7.1 Supporting Different Memory Models and Compilers <lb/>At a high level, injp is simply a general and transitive relation on evolving functional memory <lb/>invariants (represented as injections) enhanced with memory protection to guard against modifica-<lb/>tion to private memory by external calls. Many other first-order memory models can be viewed as <lb/>employing either a richer or a simplified version of injection as memory invariants and equipped <lb/>with a similar notion of memory protection. For example, the memory model of CompCertS [Besson <lb/>et al. 2015] extends injections to map symbolic values. The memory refinements in the <lb/>2 memory <lb/>model [Krebbers 2016] function like injections except that pointer offsets are represented as abstract <lb/>paths pointing into aggregated data structures. The memory model defined by Kang et al. [2015] <lb/>explicitly divides a memory state into public and private memory. Its memory invariant is an <lb/>equivalence relation between public source and target memory which is essentially an identity <lb/>injection. Therefore, uniform KMRs may be defined for those memory models as variants of injp. <lb/>To prove the transitivity of these KMRs, the key is the construction of interpolating memory <lb/>states after external calls as described in §4.2. This construction is based on the following general <lb/>ideas: 1) as KMRs are transitively composed, more memory gets protected, 2) the private memory <lb/>should be identical to the initial memory, and 3) the public memory should be projected from the <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:27 <lb/></page>
    
    <body>updated source memory via memory invariants. As we can see, these ideas are applicable to any <lb/>memory model with functional memory invariants and a notion of private memory. Therefore, our <lb/>approach should work for the aforementioned memory models and compilers based on them. <lb/>7.2 Supporting Additional Optimization Passes <lb/>Given any new optimization pass whose additional rely-guarantee condition can be represented as <lb/>a semantics invariant , we may piggyback onto an enriched injp to achieve direct refinement. <lb/>To see that, note that any consists of two parts: a condition for initial queries (e.g., ro-valid in <lb/>ro) and a condition for replies (e.g., mem-acc in ro). By extending injp to include the latter (just <lb/>like that Definition 3.3 includes mem-acc), if the enriched injp is still transitive, then we can easily <lb/>prove the following proposition which is generalized from Lemma 5.6. <lb/>Proposition 7.1. For any : C ⇔ C and enriched injp, • c injp ≡ • c injp • • c injp . <lb/>The proof follows exactly the steps for proving Lemma 5.6. It is based on the two observations we <lb/>made near the end of §5.2.3, i.e., 1) the properties for initial queries of hold along with copying of <lb/>memory states, and 2) the properties for replies trivially hold as they are part of the enriched injp. <lb/>7.3 Limitations <lb/>We discuss the limitations of our approach and possible solutions. First, it does not yet support <lb/>behavior refinements for whole programs in CompCert [Leroy 2023]. This is a technical limitation <lb/>and can be solved by reducing open simulations into closed simulations in CompCert. Second, <lb/>the proof for Unusedglob assumes that global symbols for removed definitions are preserved as <lb/>CompCertO&apos;s simulation framework requires the same set of global symbols throughout compilation. <lb/>We need to weaken this requirement to enable removal of global symbols by compilation. Third, <lb/>open simulations assume given any input injection , the execution outputs some injection ′ <lb/>related to by injp. This may not work for memory models with fixed injection functions [Wang <lb/>et al. 2022]. A possible solution is to enrich injp to account for this fixed definition. Finally, given <lb/>a new optimization, if its rely-guarantee condition cannot be described as a semantic invariant or <lb/>if injp enriched with becomes intransitive, then direct refinements may not be derivable. In this <lb/>case, we may need stronger restrictions on this optimization for our approach to work. <lb/>8 EVALUATION AND RELATED WORK <lb/>Our Coq development took about 7 person-months and 18.3k lines of code (LOC) on top of Comp-<lb/>CertO. We added 3.7k LOC to prove the transitivity of injp, 3k LOC to verify the compiler passes <lb/>as discussed in §5.1, 1.2k LOC for composing simulation conventions as described in the rest of §5 <lb/>and 7.3k LOC for the Client-Server examples. We also ported CompCertM&apos;s example on mutually <lb/>recursive summation [Song et al. 2020], which adds 3.1k LOC [Zhang et al. 2023b]. For now, the cost <lb/>of examples is relatively high. However, we observe that a lot of low-level proofs such as pointer <lb/>arithmetic can be automated by proof scripts, many proofs with predictable patterns can be directly <lb/>derived from the program structures, and a lot of duplicated lemmas in the examples can be elimi-<lb/>nated. We will carry out those exercises in the future which should simplify the proofs significantly. <lb/>Below we compare our work with other frameworks for VCC and program verification. <lb/>8.1 Verified Compositional Compilation for First-Order Languages <lb/>In this work, we are concerned with VCC of first-order imperative programs with global memory <lb/>states and support of pointers. A majority of the work in this setting is based on CompCert. We <lb/>compare them from the perspectives listed in the first column of Table 2. An answer that is not a <lb/>simple &quot;Yes&quot; or &quot;No&quot; denotes that special constraints are enforced to support the given feature. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:28 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <body>Table 2. Comparison between Work on VCC Based on CompCert <lb/>CompComp CompCertM CompCertO CompCertX This Work <lb/>Direct Refinement <lb/>No <lb/>No <lb/>No <lb/>No <lb/>Yes <lb/>Vertical Composition <lb/>Yes <lb/>RUSC <lb/>Trivial <lb/>CAL <lb/>Yes <lb/>Horizontal Composition <lb/>Yes <lb/>RUSC <lb/>Yes <lb/>CAL <lb/>Yes <lb/>Adequacy <lb/>No <lb/>Yes <lb/>Yes <lb/>Yes <lb/>Yes <lb/>End-to-end Verification <lb/>No <lb/>Yes <lb/>Unknown <lb/>CAL <lb/>Yes <lb/>Free-form Heterogeneity <lb/>Yes <lb/>Yes <lb/>Yes <lb/>No <lb/>Yes <lb/>Behavior Refinement <lb/>No <lb/>Yes <lb/>No <lb/>Yes <lb/>No <lb/>Compositional CompCert. CompComp supports VCC based on interaction semantics which is <lb/>a specialized version of open semantics with C interfaces [Stewart et al. 2015]. We have already <lb/>talked about its merits and limitations in §1.2. It is interesting to note that CompComp can also <lb/>be obtained based on our approach by adopting c injp for every compiler pass and exploiting the <lb/>transitivity of c injp , which does not require the instrumentation of semantics in CompComp. <lb/>CompCertM. CompCertM supports adequacy and end-to-end verification of mixed C and assem-<lb/>bly programs. A distinguishing feature of CompCertM is Refinement Under Self-related Contexts <lb/>or RUSC [Song et al. 2020]. A RUSC relation is a fixed collection of simulation relations. By exploit-<lb/>ing contexts that are self-relating under all of these simulation relations, horizontal and vertical <lb/>compositionality are achieved. However, refinements based on RUSC relations can be difficult <lb/>to use as they are not extensional. For example, the complete open refinement relation ⩽ 1 +...+ 9 <lb/>in CompCertM carries 9 RUSC relations 1 , . . . , 9 (6 for compiler passes and 3 for source-level <lb/>verification). To establish the refinement between a.s and its specification , one needs to prove <lb/>are self-simulating over all 9 simulation relations. This can quickly get out of hand as more modules <lb/>and more compiler passes are introduced. By contrast, we only need to prove direct refinement for <lb/>once and the refinement is open to further horizontal or vertical composition. On the other hand, <lb/>CompCertM supports behavior refinement of closed programs which we do not yet (See §7.3). <lb/>CompCertO. Vertical composition is a trivial pairing of simulations in CompCertO, which exposes <lb/>internal compilation steps. CompCertO tries to alleviate this problem via ad-hoc refinement of <lb/>simulation conventions. The resulting top-level convention is C CCO = R * • wt • CL • LM • MA • asm vainj <lb/>where R = c injp + c inj + c ext + c vainj + c vaext is a sum of conventions parameterized over KMRs. <lb/>In particular, c vaext is an ad-hoc combination of KMR and internal invariants for optimizations. R * <lb/>means that R may be repeated for an arbitrary number of times. Since the top-level summation <lb/>of KMRs is similar to that in CompCertM, we need to go through a reasoning process similar to <lb/>CompCertM, only more complicated because of the need to reason about internal invariants of <lb/>optimizations in c vaext and indefinitely repeated combination of all the KMRs by R * . Therefore, it <lb/>is unknown if the correctness theorem of CompCertO suffices for end-to-end program verification. <lb/>CompCertX. CompCertX [Gu et al. 2015; Wang et al. 2019] realizes a weaker form of VCC that <lb/>only allows assembly contexts to invoke C programs, but not the other way around. Therefore, it <lb/>does not support horizontal composition of modules with mutual recursions. The compositionality <lb/>and program verification are delegated to Certified Abstraction Layers (CAL) [Gu et al. 2015, <lb/>2018]. Furthermore, CompCertX does not support stack-allocated data (e.g., our server example). <lb/>However, its top-level semantic interface is similar to our interface, albeit not carrying a symmetric <lb/>rely-guarantee condition. This indicates that our work is a natural evolution of CompCertX. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:29 <lb/></page>
    
    <body>VCC for Concurrent Programs. VCC for concurrent programs needs to deal with multiple threads <lb/>and their linking. CASCompCert is an extension of CompComp that supports compositional <lb/>compilation of concurrency with no (or benign) data races [Jiang et al. 2019]. To make CompComp&apos;s <lb/>approach to VCC work in a concurrent setting, CASCompCert imposes some restrictions including <lb/>not supporting stack-allocated data and allowing only nondeterminism in scheduling threads. A <lb/>recent advancement based on CASCompCert is about verifying concurrent programs [Zha et al. <lb/>2022] running on weak memory models using the promising semantics [Kang et al. 2017; Lee et al. <lb/>2020]. We believe the ideas in CASCompCert are complementary to this work and can be combined <lb/>with our approach to achieve VCC for concurrency with cleaner interface and less restrictions. <lb/>8.2 Verified Compositional Compilation for Higher-Order Languages <lb/>Another class of work on VCC focuses on compilation of higher-order languages. In this setting, <lb/>the main difficulty comes from complex language features together with higher-order states. A <lb/>prominent example is the Pilsner compiler [Neis et al. 2015] that compiles a higher-order language <lb/>into some form of assembly programs. The technique Pilsner adopts is called parametric simulations <lb/>that evolves from earlier work on reasoning about program equivalence via bisimulation [Hur et al. <lb/>2012a]. Another line of work is multi-language semantics [Patterson and Ahmed 2019; Patterson <lb/>et al. 2017; Perconti and Ahmed 2014; Scherer et al. 2018] where a language combining all source, <lb/>intermediate and target languages is used to formalize semantics. Compiler correctness is stated as <lb/>contextual equivalence or logical relations. It seems that our techniques are not directly applicable <lb/>to those work because relations on higher-order states cannot deterministically fix the interpolating <lb/>states. A possible solution is to divide the higher-order memory into a first-order and a higher-order <lb/>part such that the former does not contain pointers to the latter (forming a closure). By encapsulating <lb/>higher-order programs inside first-order states, we may be able to apply our approach. <lb/>The high-level ideas for constructing interpolating states for proving transitivity of injp can <lb/>also be found in some of the work on program equivalence [Ahmed 2006; Hur et al. 2012b]. To the <lb/>best of our knowledge, our approach is the first concrete implementation of these ideas that works <lb/>for a realistic optimizing compiler for imperative languages with non-trivial memory models. <lb/>8.3 Frameworks for Compositional Program Verification <lb/>Researchers have proposed frameworks for compositional program verification based on novel <lb/>semantics, refinements and separation logics [Chappe et al. 2023; Gu et al. 2015, 2018; He et al. <lb/>2021; Sammler et al. 2023; Song et al. 2023; Xia et al. 2019]. These frameworks aim at broader <lb/>program verification and may be combined with our approach to generate more flexible end-to-end <lb/>verification techniques. For example, to support more flexible certified abstraction layers, we may <lb/>combine our approach with data abstraction in CAL and extend horizontal linking to work with <lb/>abstraction layers. More details can be found in the technical report [Zhang et al. 2023b]. <lb/>9 CONCLUSION AND FUTURE WORK <lb/>We have proposed an approach to compositional compiler correctness for first-order languages via <lb/>direct refinements between source and target semantics at their native interfaces, which overcomes <lb/>the limitations of the existing approaches on compositionality, adequacy and other important <lb/>criteria for VCC. In the future, we plan to support behavior (trace) refinement for closed programs <lb/>by reducing our open simulation into the whole-program correctness theorem for the original <lb/>CompCert. We also plan to combine our work with refinement-based program verification like <lb/>certified abstraction layers to support more substantial applications. Another research direction is <lb/>to apply our approach to different memory models and compilers for first-order and higher-order <lb/>languages, which will better test the limit of our approach and the usefulness of our discoveries. <lb/></body>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <page>72:30 <lb/></page>
    
    <note place="headnote">Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao <lb/></note>
    
    <div type="availability">DATA-AVAILABILITY STATEMENT <lb/>The Coq artifact containing the formal developments described in this paper is available on Zen-<lb/>odo [Zhang et al. 2023a]. A technical report of this work is available on arXiv [Zhang et al. 2023b]. <lb/></div>
    
    <div type="acknowledgement">ACKNOWLEDGMENTS <lb/>We would like to thank our shepherd Yannick Zakowski and the anonymous referees for their <lb/>helpful feedback which improved this paper significantly. This work is supported in part by the <lb/>National Natural Science Foundation of China (NSFC) under Grant No. 62002217 and 62372290, and <lb/>by the Natural Science Foundation of the United States (NSF) under Grant No. 1763399, 2019285, and <lb/>2313433. Any opinions, findings, and conclusions or recommendations expressed in this material <lb/>are those of the authors and do not necessarily reflect the views of the funding agencies. <lb/></div>
    
    <listBibl>REFERENCES <lb/>Amal J. Ahmed. 2006. Step-Indexed Syntactic Logical Relations for Recursive and Quantified Types. In Proc. 15th European <lb/>Symposium on Programming (ESOP&apos;06) (LNCS, Vol. 3924), Peter Sestoft (Ed.). Springer, Cham, 69-83. https://doi.org/10. <lb/>1007/11693024_6 <lb/>Frédéric Besson, Sandrine Blazy, and Pierre Wilke. 2015. A Concrete Memory Model for CompCert. In Proc. 6th Interactive <lb/>Theorem Proving (ITP&apos;15) (LNCS, Vol. 9236), Christian Urban and Xingyuan Zhang (Eds.). Springer, Cham, 67-83. https: <lb/>//doi.org/10.1007/978-3-319-22102-1_5 <lb/>Nicolas Chappe, Paul He, Ludovic Henrio, Yannick Zakowski, and Steve Zdancewic. 2023. Choice Trees: Representing <lb/>Nondeterministic, Recursive, and Impure Programs in Coq. Proc. ACM Program. Lang. 7, POPL, Article 61 (January 2023), <lb/>31 pages. https://doi.org/10.1145/3571254 <lb/>Ronghui Gu, Jérémie Koenig, Tahina Ramananandro, Zhong Shao, Xiongnan(Newman) Wu, Shu-Chun Weng, Haozhong <lb/>Zhang, and Yu Guo. 2015. Deep Specifications and Certified Abstraction Layers. In Proc. 42nd ACM Symposium on <lb/>Principles of Programming Languages (POPL&apos;15), Sriram K. Rajamani and David Walker (Eds.). ACM, New York, NY, USA, <lb/>595-608. https://doi.org/10.1145/2775051.2676975 <lb/>Ronghui Gu, Zhong Shao, Jieung Kim, Xiongnan (Newman) Wu, Jérémie Koenig, Vilhelm Sjober, Hao Chen, David Costanzo, <lb/>and Tahnia Ramananandro. 2018. Certified Concurrent Abstraction Layers. In Proc. 2018 ACM Conference on Programming <lb/>Language Design and Implementation (PLDI&apos;18), Jeffrey S. Foster and Dan Grossman (Eds.). ACM, New York, NY, USA, <lb/>646-661. https://doi.org/10.1145/3192366.3192381 <lb/>Paul He, Eddy Westbrook, Brent Carmer, Chris Phifer, Valentin Robert, Karl Smeltzer, Andrei Ştefănescu, Aaron Tomb, <lb/>Adam Wick, Matthew Yacavone, and Steve Zdancewic. 2021. A Type System for Extracting Functional Specifications <lb/>from Memory-Safe Imperative Programs. Proc. ACM Program. Lang. 5, OOPSLA, Article 135 (October 2021), 29 pages. <lb/>https://doi.org/10.1145/3485512 <lb/>Chung-Kil Hur, Derek Dreyer, Georg Neis, and Viktor Vafeiadis. 2012a. The Marriage of Bisimulations and Kripke Logical <lb/>Relations. In Proc. 39th ACM Symposium on Principles of Programming Languages (POPL&apos;12), John Field and Michael <lb/>Hicks (Eds.). ACM, New York, NY, USA, 59-72. https://doi.org/10.1145/2103656.2103666 <lb/>Chung-Kil Hur, Georg Neis, Derek Dreyer, and Viktor Vafeiadis. 2012b. The Transitive Composability of Relation Transition <lb/>Systems. Technical Report, MPI-SWS-2012-002. MPI-SWS. https://www.mpi-sws.org/tr/2012-002.pdf <lb/>Hanru Jiang, Hongjin Liang, Siyang Xiao, Junpeng Zha, and Xinyu Feng. 2019. Towards Certified Separate Compilation for <lb/>Concurrent Programs. In Proc. 2019 ACM Conference on Programming Language Design and Implementation (PLDI&apos;19), <lb/>Kathryn S. McKinley and Kathleen Fisher (Eds.). ACM, New York, NY, USA, 111-125. https://doi.org/10.1145/3314221. <lb/>3314595 <lb/>Jeehoon Kang, Chung-Kil Hur, Ori Lahav, Viktor Vafeiadis, and Derek Dreyer. 2017. A Promising Semantics for Relaxed-<lb/>memory Concurrency. In Proc. 44th ACM Symposium on Principles of Programming Languages (POPL&apos;17), Giuseppe <lb/>Castagna and Andrew D. Gordon (Eds.). ACM, New York, NY, USA, 175-189. https://doi.org/10.1145/3009837.3009850 <lb/>Jeehoon Kang, Chung-Kil Hur, William Mansky, Dmitri Garbuzov, Steve Zdancewic, and Viktor Vafeiadis. 2015. A Formal <lb/>C Memory Model Supporting Integer-Pointer Casts. In Proc. 2015 ACM Conference on Programming Language Design <lb/>and Implementation (PLDI&apos;15), David Grove and Stephen M. Blackburn (Eds.). ACM, New York, NY, USA, 326-335. <lb/>https://doi.org/10.1145/2737924.2738005 <lb/>Jérémie Koenig and Zhong Shao. 2021. CompCertO: Compiling Certified Open C Components. In Proc. 2021 ACM Conference <lb/>on Programming Language Design and Implementation (PLDI&apos;21). ACM, New York, NY, USA, 1095-1109. https://doi.org/ <lb/>10.1145/3453483.3454097 <lb/></listBibl>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. <lb/></note>
    
    <note place="headnote">Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules <lb/></note>
    
    <page>72:31 <lb/></page>
    
    <listBibl>Robbert Krebbers. 2016. A Formal C Memory Model for Separation Logic. J. Autom. Reason. 57 (2016), 319-387. https: <lb/>//doi.org/10.1007/s10817-016-9369-1 <lb/>Sung-Hwan Lee, Minki Cho, Anton Podkopaev, Soham Chakraborty, Chung-Kil Hur, Ori Lahav, and Viktor Vafeiadis. 2020. <lb/>Promising 2.0: Global Optimizations in Relaxed Memory Concurrency. In Proc. 2020 ACM Conference on Programming <lb/>Language Design and Implementation (PLDI&apos;20). ACM, New York, NY, USA, 362-376. https://doi.org/10.1145/3385412. <lb/>3386010 <lb/>Xavier Leroy. 2005-2023. The CompCert Verified Compiler. https://compcert.org/. <lb/>Xavier Leroy, Andrew W. Appel, Sandrine Blazy, and Gordon Stewart. 2012. The CompCert Memory Model, Version 2. <lb/>Research Report RR-7987. INRIA. 26 pages. https://hal.inria.fr/hal-00703441 <lb/>Georg Neis, Chung-Kil Hur, Jan-Oliver Kaiser, Craig McLaughlin, Derek Dreyer, and Viktor Vafeiadis. 2015. Pilsner: a <lb/>Compositionally Verified Compiler for a Higher-Order Imperative Language. In Proc. 2015 ACM SIGPLAN International <lb/>Conference on Functional Programming (ICFP&apos;15), Kathleen Fisher and John H. Reppy (Eds.). ACM, New York, NY, USA, <lb/>166-178. https://doi.org/10.1145/2784731.2784764 <lb/>Daniel Patterson and Amal Ahmed. 2019. The Next 700 Compiler Correctness Theorems (Functional Pearl). Proc. ACM <lb/>Program. Lang. 3, ICFP, Article 85 (August 2019), 29 pages. https://doi.org/10.1145/3341689 <lb/>Daniel Patterson, Jamie Perconti, Christos Dimoulas, and Amal Ahmed. 2017. FunTAL: Reasonably Mixing a Functional <lb/>Language with Assembly. SIGPLAN Not. 52, 6 (2017), 495-509. https://doi.org/10.1145/3140587.3062347 <lb/>James T. Perconti and Amal Ahmed. 2014. Verifying an Open Compiler Using Multi-language Semantics. In Proc. 23rd <lb/>European Symposium on Programming (ESOP&apos;14) (LNCS, Vol. 8410), Zhong Shao (Ed.). Springer, Cham, 128-148. https: <lb/>//doi.org/10.1007/978-3-642-54833-8_8 <lb/>Michael Sammler, Simon Spies, Youngju Song, Emanuele D&apos;Osualdo, Robbert Krebbers, Deepak Garg, and Derek Dreyer. <lb/>2023. DimSum: A Decentralized Approach to Multi-Language Semantics and Verification. Proc. ACM Program. Lang. 7, <lb/>POPL, Article 27 (January 2023), 31 pages. https://doi.org/10.1145/3571220 <lb/>Gabriel Scherer, Max New, Nick Rioux, and Amal Ahmed. 2018. Fabous Interoperability for ML and a Linear Language. In <lb/>Foundations of Software Science and Computation Structures, Christel Baier and Ugo Dal Lago (Eds.). Springer, Cham, <lb/>146-162. https://doi.org/10.1007/978-3-319-89366-2_8 <lb/>Youngju Song, Minki Cho, Dongjoo Kim, Yonghyun Kim, Jeehoon Kang, and Chung-Kil Hur. 2020. CompCertM: CompCert <lb/>with C-Assembly Linking and Lightweight Modular Verification. Proc. ACM Program. Lang. 4, POPL, Article 23 (January <lb/>2020), 31 pages. https://doi.org/10.1145/3371091 <lb/>Youngju Song, Minki Cho, Dongjae Lee, Chung-Kil Hur, Michael Sammler, and Derek Dreyer. 2023. Conditional Contextual <lb/>Refinement. Proc. ACM Program. Lang. 7, POPL, Article 39 (January 2023), 31 pages. https://doi.org/10.1145/3571232 <lb/>Gordon Stewart, Lennart Beringer, Santiago Cuellar, and Andrew W. Appel. 2015. Compositional CompCert. In Proc. <lb/>42nd ACM Symposium on Principles of Programming Languages (POPL&apos;15). ACM, New York, NY, USA, 275-287. https: <lb/>//doi.org/10.1145/2676726.2676985 <lb/>Yuting Wang, Pierre Wilke, and Zhong Shao. 2019. An Abstract Stack Based Approach to Verified Compositional Compilation <lb/>to Machine Code. Proc. ACM Program. Lang. 3, POPL, Article 62 (January 2019), 30 pages. https://doi.org/10.1145/3290375 <lb/>Yuting Wang, Ling Zhang, Zhong Shao, and Jérémie Koenig. 2022. Verified Compilation of C Programs with a Nominal <lb/>Memory Model. Proc. ACM Program. Lang. 6, POPL, Article 25 (January 2022), 31 pages. https://doi.org/10.1145/3498686 <lb/>Li-yao Xia, Yannick Zakowski, Paul He, Chung-Kil Hur, Gregory Malecha, Benjamin C. Pierce, and Steve Zdancewic. 2019. <lb/>Interaction Trees: Representing Recursive and Impure Programs in Coq. Proc. ACM Program. Lang. 4, POPL, Article 51 <lb/>(January 2019), 32 pages. https://doi.org/10.1145/3371119 <lb/>Junpeng Zha, Hongjin Liang, and Xinyu Feng. 2022. Verifying Optimizations of Concurrent Programs in the Promising <lb/>Semantics. In Proc. 2021 ACM Conference on Programming Language Design and Implementation (PLDI&apos;22). ACM, New <lb/>York, NY, USA, 903-917. https://doi.org/10.1145/3519939.3523734 <lb/>Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao. 2023a. Fully Composable and Adequate Verified <lb/>Compilation with Direct Refinements between Open Modules (Artifact). https://doi.org/10.5281/zenodo.10036618 <lb/>Ling Zhang, Yuting Wang, Jinhua Wu, Jérémie Koenig, and Zhong Shao. 2023b. Fully Composable and Adequate Verified <lb/>Compilation with Direct Refinements between Open Modules (Technical Report). https://doi.org/10.48550/arXiv.2302. <lb/>12990 <lb/></listBibl>
    
    <front>Received 2023-07-11; accepted 2023-11-07 <lb/></front>
    
    <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 72. Publication date: January 2024. </note>


	</text>

</TEI>