<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">Quarl: A Learning-Based Quantum Circuit Optimizer</title>
        <author>
          <persName>
            <forename>Zikun</forename>
            <surname>Li</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Jinjun</forename>
            <surname>Peng</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Yixuan</forename>
            <surname>Mei</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Sina</forename>
            <surname>Lin</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Yi</forename>
            <surname>Wu</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Oded</forename>
            <surname>Padon</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Zhihao</forename>
            <surname>Jia</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-30T11:19:32.271505Z">30.10.2025 11:19:32</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3649831</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3649831</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Zikun Li, Jinjun Peng, Yixuan Mei, Sina Lin, Yi Wu, Oded Padon, Zhihao Jia. (2024). Quarl: A Learning-Based Quantum Circuit Optimizer. Proceedings of the ACM on Programming Languages, 8(OOPSLA1), 555-582. DOI: 10.1145/3649831</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-30T11:19:32.271505Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-30T11:19:32.271505Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
        <front>Trillium: Higher-Order Concurrent and Distributed <lb/>Separation Logic for Intensional Refinement <lb/>AMIN TIMANY, Aarhus University, Denmark <lb/>SIMON ODDERSHEDE GREGERSEN, Aarhus University, Denmark <lb/>LÉO STEFANESCO, MPI-SWS, Germany <lb/>JONAS KASTBERG HINRICHSEN, Aarhus University, Denmark <lb/>LÉON GONDELMAN, Aarhus University, Denmark <lb/>ABEL NIETO, Aarhus University, Denmark <lb/>LARS BIRKEDAL, Aarhus University, Denmark <lb/>Expressive state-of-the-art separation logics rely on step-indexing to model semantically complex features <lb/>and to support modular reasoning about imperative higher-order concurrent and distributed programs. Step-<lb/>indexing comes, however, with an inherent cost: it restricts the adequacy theorem of program logics to a fairly <lb/>simple class of safety properties. <lb/>In this paper, we explore if and how intensional refinement is a viable methodology for strengthening <lb/>higher-order concurrent (and distributed) separation logic to prove non-trivial safety and liveness properties. <lb/>Specifically, we introduce Trillium, a language-agnostic separation logic framework for showing intensional <lb/>refinement relations between traces of a program and a model. We instantiate Trillium with a concurrent <lb/>language and develop Fairis, a concurrent separation logic, that we use to show liveness properties of concurrent <lb/>programs under fair scheduling assumptions through a fair liveness-preserving refinement of a model. We also <lb/>instantiate Trillium with a distributed language and obtain an extension of Aneris, a distributed separation <lb/>logic, which we use to show refinement relations between distributed systems and TLA + models. <lb/>CCS Concepts: • Theory of computation → Logic and verification; Higher order logic; Separation <lb/>logic; Hoare logic; Programming logic; Invariants; Program verification; Program specifications; Pre-and <lb/>post-conditions; Abstraction. <lb/>Additional Key Words and Phrases: Distributed systems, separation logic, refinement, higher-order logic, <lb/>concurrency, formal verification <lb/>ACM Reference Format: <lb/>Amin Timany, Simon Oddershede Gregersen, Léo Stefanesco, Jonas Kastberg Hinrichsen, Léon Gondelman, <lb/>Abel Nieto, and Lars Birkedal. 2024. Trillium: Higher-Order Concurrent and Distributed Separation Logic <lb/>for Intensional Refinement. Proc. ACM Program. Lang. 8, POPL, Article 9 (January 2024), 32 pages. https: <lb/>//doi.org/10.1145/3632851 <lb/></front>

        <body>1 INTRODUCTION <lb/>There is a tension between the expressivity of program logics and how much they say about the <lb/>semantics of the programs being verified, that is, the strength of their adequacy theorems. As program <lb/></body>

        <front>Authors&apos; addresses: Amin Timany, Aarhus University, Denmark, timany@cs.au.dk; Simon Oddershede Gregersen, Aarhus <lb/>University, Denmark, gregersen@cs.au.dk; Léo Stefanesco, MPI-SWS, Germany, lstefane@mpi-sws.org; Jonas Kast-<lb/>berg Hinrichsen, Aarhus University, Denmark, hinrichsen@cs.au.dk; Léon Gondelman, Aarhus University, Denmark, <lb/>gondelman@cs.au.dk; Abel Nieto, Aarhus University, Denmark, abeln@cs.au.dk; Lars Birkedal, Aarhus University, Denmark, <lb/>birkedal@cs.au.dk. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/1-ART9 <lb/>https://doi.org/10.1145/3632851 <lb/>Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/></front>

        <page>9:2 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>logics become more expressive-to handle sophisticated programming language features such as <lb/>higher-order functions and references, and to support modular and general library specifications-<lb/>they require increasingly complex semantic models to justify them. <lb/>In this work, we consider Iris [Jung et al. 2015], state of the art in terms of expressivity: in <lb/>particular, it supports higher-order quantification, nested Hoare triples, higher-order ghost state, and <lb/>impredicative invariants, i.e., invariants that can contain any Iris proposition, including invariants. <lb/>Through its adequacy theorem, the Iris program logic [Jung et al. 2018] is designed to prove <lb/>three kinds of properties about programs: (1) postconditions, i.e., properties of the final values <lb/>computed, (2) progress, i.e., the program never gets stuck, and (3) preservation of invariants, i.e., <lb/>all invariants stated by the user hold throughout execution. Note how these properties form a <lb/>particular class of safety properties. 1 That is-as trace properties-these are somewhat trivial, in <lb/>that they are all of the form: &quot;for any such that 0 → * , we have ( )&quot; for some property , where <lb/>→ * , is the reflexive-transitive closure of the operational semantics of the program. In particular, <lb/>this class of properties does not include liveness properties or non-trivial safety trace properties <lb/>like: &quot;the value of the counter must increase monotonically without skipping over any number.&quot; <lb/>While proving non-trivial safety trace properties is not a fundamental limitation of the Iris logic, 2 <lb/>the lack of support for liveness properties is. This inherent limitation is related to the fact that <lb/>Iris&apos;s semantic model relies on step-indexing, which is crucial for the soundness of impredicative <lb/>invariants. This fact is a compromise that the designers of Iris have made. On the one hand, making <lb/>the semantic model step-indexed, and thereby enabling impredicative invariants, allows many <lb/>important applications. Notably, it allows us to construct logical relations models for proving type <lb/>safety and contextual equivalences for expressive programming languages, e.g., System F with <lb/>recursive types, higher-order references, and concurrency [Krebbers et al. 2017]. On the other hand, <lb/>step-indexing inherently restricts program logics to only be able to express properties that concern <lb/>finite prefixes of program execution. This effectively dooms any program logic developed on top of <lb/>the Iris base logic from supporting liveness properties-at least directly. The thesis that we explore <lb/>in this work is that refinement is a viable methodology for strengthening higher-order concurrent (and <lb/>distributed) separation logic to prove non-trivial safety and liveness trace properties. <lb/>Focus and Methodology. In this paper, we use Iris to establish intensional refinements between <lb/>programs and labeled transition systems (LTSs), including the strong notion of liveness-preserving <lb/>refinements, for concurrent and distributed programs. We develop Trillium, a language-agnostic <lb/>generic program logic, whose adequacy theorem guarantees the existence of a refinement between <lb/>the program and an LTS chosen by the prover. This is in addition to the usual properties enjoyed <lb/>by program logics for safety reasoning as mentioned above, i.e., postconditions, progress, and <lb/>preservation of invariants. The key insight is that, by showing an intensional refinement between a <lb/>program and an LTS, we can-indirectly-establish non-trivial safety trace properties and liveness <lb/>properties such as fair termination of concurrent programs. By proving that the LTS enjoys the <lb/>property of interest (which is often, if not always, simpler than proving it for the program itself), <lb/>we can use the refinement relation to &quot;transport&quot; the property to the program. For this reason, we <lb/>will refer to the LTS as a model or specification of a program implementation. <lb/></body>

        <note place="footnote">1 Recall that a safety property is a property that expresses &quot;nothing bad ever happens throughout execution&quot;, as opposed to <lb/>liveness properties which express that &quot;something good will eventually happen&quot;. <lb/>2 For instance, Birkedal et al. [2021] do use an Iris program logic to prove some limited intensional safety trace properties, <lb/>e.g., &quot;a file can only be accessed if it has previously been opened and not subsequently closed. &quot; <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:3 <lb/></page>

        <body>Contributions. In summary, we make the following contributions: <lb/>• We introduce Trillium ( §3), a language-agnostic separation logic framework for establishing <lb/>intensional refinement relations between traces of program executions and models. <lb/>• We develop Fairis ( §4), a higher-order concurrent separation logic for showing liveness prop-<lb/>erties of concurrent programs under fair scheduling assumptions through a fair termination-<lb/>preserving refinement of a carefully chosen model (see discussion in §2). <lb/>• We showcase Fairis on a number of challenging but small concurrent examples ( §4.2). <lb/>• We instantiate Trillium with AnerisLang to get an extension of Aneris [Krogh-Jespersen et al. <lb/>2020] that can be used to show intensional refinements of distributed systems ( §5). <lb/>• We use the Aneris instantiation of Trillium to show that two distributed protocols, two-phase <lb/>commit and single-decree Paxos, refine their abstract TLA + [Lamport 1992] specifications. <lb/>To the best of our knowledge, this is the first foundationally verified proof that a concrete <lb/>implementation of a distributed protocol correctly implements an abstract TLA + specification. <lb/>• We further show functional correctness and strong eventual consistency of a concrete imple-<lb/>mentation of a Conflict-Free Replicated Data Type (CRDT). The challenging part is incorpo-<lb/>rating the notion of fairness of the inter-replica communication; if messages from one replica <lb/>are just ignored, then eventual consistency will never be reached. Moreover, the concurrent <lb/>interactions with the user-exposed operations makes it non-trivial to reason about eventual <lb/>consistency. To the best of our knowledge, this is the first such proof that takes into account <lb/>the inter-replica communication at the level of the implementation. For the sake of space, we <lb/>have relegated further details about this example to the accompanying appendix. <lb/>• All the results that appear in the paper have been formalized in the Coq proof assistant using <lb/>the Iris separation logic framework. <lb/>2 BACKGROUND AND KEY OBSERVATIONS <lb/>We will think of the operational semantics of a concurrent program as an LTS where the transition <lb/>labels are thread identifiers corresponding to the thread taking the step. That an LTS refines another <lb/>is a standard notion: two states are in a refinement relation if there exists a forward simulation <lb/>relation that relates them (see, e.g., Cleaveland and Sokolsky [2001]). 3 The goal in this paper <lb/>is to transport intensional safety and liveness properties of (possibly infinite) traces along such a <lb/>refinement relation, e.g., transporting the property &quot;the value of the counter increases (or stays the <lb/>same) monotonically without skipping over any number&quot; from the model Chain in Figure 1 to the <lb/>program count _ up in Figure 2. <lb/>To transport intensional properties, we will work with intensional refinement, which is a lockstep <lb/>relation where every step of the program is matched by a step of the model. This is, of course, too <lb/>strong if taken literally: for example, the step of computation corresponding to a recursive call of <lb/>count _ up does not increment the counter and hence does not correspond to a step in the model. For <lb/>now, we will ignore this issue; in the following section we will present constructions on LTSs that <lb/>will allow us to relax the correspondence between the program and the model, while still allowing <lb/>intensional properties to be transported. <lb/>We recall the precise definitions of forward simulation and refinement. The definitions are <lb/>relative to a parameter , a relation on traces, which provides for a bit of flexibility, by allowing <lb/>one to restrict attention to traces satisfying . <lb/></body>

        <note place="footnote">3 Cleaveland and Sokolsky [2001] work with relations on a single LTS whereas we work with two LTSs. Nonetheless, all the <lb/>results carry over straightforwardly by simply considering an LTS that is the disjoint union of the two LTSs we consider. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:4 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>0 <lb/>1 <lb/>2 <lb/>3 <lb/>. . . <lb/>(Chain) Chain of natural numbers <lb/>(∞, 0) <lb/>(1, 1) <lb/>(2, 1) <lb/>(2, 2) <lb/>(3, 1) <lb/>(3, 2) <lb/>(3, 3) <lb/>. . . <lb/>(FinChains) All finite chains of numbers; the first component is the length <lb/>Fig. 1. Two simple LTSs representing the infinite chain of natural numbers Chain, and all finite chains of <lb/>natural numbers FinChains. <lb/>let rec count _ up l = FAA l 1; count _ up l in count _ up l <lb/>Fig. 2. The program count _ up. Here FAA is the (atomic) fetch-and-add operation which increments the integer <lb/>stored in its first argument (a reference) by the given amount in the second argument. We assume that the <lb/>value of is zero at the beginning. <lb/>Definition 2.1 ( -forward simulation). Let be a binary relation on finite traces. A relation is a <lb/>-forward simulation, written ForSim ( ), if: <lb/>ForSim ( ) ≜ ∀ , ′ . ( , ′ ) =⇒ ( , ′ ) ∧ <lb/>∀ , ′ , , . ( , ′ ) ∧ last ( ) -<lb/>→ =⇒ ∃ ′ , ′ . ( -<lb/>→ , ′ ′ <lb/>-<lb/>→ ′ ) <lb/>where last maps a trace to its end state. <lb/>Definition 2.2 (Intensional refinement). Let be a binary relation on finite traces. A finite trace <lb/>is an intensional refinement of a finite trace ′ , with respect to parameter , written ≼ ′ , if there <lb/>exists a -forward simulation relation such that ( , ′ ). That is, <lb/>≼ ′ ≜ ∃ . ForSim ( ) ∧ ( , ′ ) <lb/>In our running example, the parameter is used to restrict our attention to traces where the <lb/>value of the counter and the model state agree at all times. <lb/>The Trillium program logic is designed to establish (cf. Theorem 3.2) an intensional refinement <lb/>≼ <lb/>between singleton traces consisting of a program state and a model state . From <lb/>Lemma 2.4 below it then follows directly that any possibly-infinite execution of the program can <lb/>be matched by a possibly-infinite trace of the model in such a way that all their corresponding <lb/>finite prefixes are in the intensional refinement relation. <lb/>Definition 2.3 (Trace Relation Extension). Given a relation on finite traces, we lift to possibly-<lb/>infinite traces, written ˆ , by considering all finite prefixes as follows: <lb/>ˆ ( 1 , 2 ) ≜ ∀ ′ <lb/>1 , ′ <lb/>2 . | ′ <lb/>1 | = | ′ <lb/>2 | ∧ prefix ( ′ <lb/>1 , 1 ) ∧ prefix ( ′ <lb/>2 , 2 ) =⇒ ( ′ <lb/>1 , ′ <lb/>2 ) <lb/>where prefix ( , ′ ) means is a prefix of ′ . <lb/>Lemma 2.4 (Intensional refinement, lifting). Let 1 and 2 be two LTSs, and a relation on <lb/>traces between these LTSs. Let 1 ∈ 1 and 2 ∈ 2 be two states such that 1 ≼ 2 (seen as singleton <lb/>traces). For all possibly-infinite traces 1 of 1 such that first ( 1 ) = 1 there exists a possibly-infinite <lb/>trace 2 where first ( 2 ) = 2 such that 1 ≼ 2 . Here, first maps traces to their initial state. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:5 <lb/></page>

        <body>2.1 Program Steps That Do Not Correspond to Steps in the Model <lb/>The core idea of the methodology we propose in this paper is that the model refined by the program <lb/>is more abstract, and hence simpler and easier to reason about, than the program. Thus, in general, <lb/>there will be steps in the program that do not correspond to any step in the model. One way to <lb/>reconcile this with our notion of refinement is to allow for stuttering. That is, allow the program <lb/>to take a step while the model stays in the same state. We will support stuttering by lifting the <lb/>model into an LTS that allows stuttering. We consider two kinds of lifting, one that is only sound <lb/>for intensional safety trace properties, and one that is sound for liveness trace properties as well. <lb/>For the former, we show that it is sound in the sense that, if a program refines the lifted model, and <lb/>the original model enjoys an intensional safety trace property, so does the program. Similarly, the <lb/>latter lifting is sound with respect to liveness trace properties. <lb/>We remark on a subtle point here, namely that Trillium is a framework, which means that <lb/>when we combine the base program logic of Trillium with one of the two aforementioned liftings, <lb/>we obtain two different program logics. The choice of lifting presents a compromise between <lb/>expressivity and simplicity of the derived logical principles of the program logic. In particular, <lb/>for the lifting that is sound for intensional safety properties, we obtain a program logic that is <lb/>conservative with respect to the ordinary program logic of Iris in that all the reasoning principles of <lb/>the Iris program logic are still sound, and in addition one obtains simple reasoning principles that <lb/>allow proving refinements (cf. §5). For the lifting that is sound with respect to liveness properties, <lb/>we obtain a program logic that is more involved but allows proving liveness properties (cf. §4). <lb/>Stutter-Lifting: Sound for Intensional Safety Trace Properties. This lifting is very simple: it essen-<lb/>tially amounts to adding self-loops, with a special label, to all states of the LTS. For example, the <lb/>LTS Chain from Figure 1 would result in the following LTS, where dotted arrows are added to <lb/>support stuttering: <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>. . . <lb/>(Chain-Loops) Stutter-Lifting of the LTS Chain in Figure 1 <lb/>The program count _ up in Figure 2 is an intensional refinement of the model Chain-Loops above <lb/>if we take the parameter to relate the value of memory location with the state of the model-the <lb/>recursive call then corresponds to taking the self-loop in the relevant state. As mentioned above, <lb/>this stutter-lifting is sound for intensional safety trace properties. Hence, to show that &quot;the value <lb/>of the counter increases (or stays the same) monotonically without skipping over any number&quot;, it <lb/>suffices to show that this property is enjoyed by Chain in Figure 1. <lb/>However, this lifting is not sound for liveness properties, because it is also refined by (using the <lb/>same parameter) the following program: <lb/>let rec loop () = loop () in FAA l 1; loop () <lb/>which only increments once and afterwards loops forever. To see this, take a very simple liveness <lb/>property like &quot;the value of the counter is eventually 3&quot; which is trivially true for the LTS Chain in <lb/>Figure 1, but not for the program above. The culprit here is unrestricted stuttering. <lb/>Fin-Stutter-Lifting: also Sound for Liveness Properties. To obtain soundness with respect to liveness <lb/>properties, we define a fin-stutter-lifting construction, which only allows for finite stuttering. That <lb/>is, instead of adding loops, it essentially adds finite unrollings of loops, by creating copies of each <lb/>state, each of which allows at most a certain, fixed number of stuttering steps. For instance, the <lb/>Fin-Stutter-Lifting of the LTS Chain in Figure 1 is given blow: <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:6 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>0 <lb/>00 <lb/>01 <lb/>02 <lb/>. . . <lb/>1 <lb/>10 <lb/>11 <lb/>12 <lb/>. . . <lb/>2 <lb/>20 <lb/>21 <lb/>22 <lb/>. . . <lb/>3 <lb/>30 <lb/>31 <lb/>32 <lb/>. . . <lb/>. . . <lb/>(Chain-Fin-Stutter) Fin-Stutter-Lifting of the LTS Chain in Figure 1 <lb/>The idea is to add states { | ∈ N} (for each state ), all of which intuitively correspond to state <lb/>. From a state , we can either go to the state + 1, or stutter to a state from where we can at <lb/>most stutter times before going to state + 1. The Fin-Stutter-Lifting construction is sound for <lb/>liveness properties. In fact, it is the core idea of the so-called fuel construction we present in §4.3. <lb/>Note that, as expected, the program above which increments the counter only once and then loops <lb/>forever does not refine the LTS Chain-Fin-Stutter. <lb/>2.2 Step-Indexing and Finite Approximability <lb/>As mentioned in §1, step-indexing prevents direct reasoning about liveness properties because it <lb/>restricts reasoning to finite prefixes of program execution. The same complication arises when <lb/>establishing refinement relations. In this work, this issue shows up in Theorem 3.2 as the relative <lb/>image-finiteness side-condition that we will discuss and formally define here. In order to see this <lb/>issue concretely, revisit the LTS FinChains from Figure 1. FinChains has no infinite paths and <lb/>hence any program that refines the fin-stutter-lifting of FinChains, regardless of the parameter, <lb/>must terminate. However, in a step-indexed logic, one can show a refinement relation between the <lb/>program count _ up in Figure 2 and the fin-stutter-lifting of FinChains. To see this, simply take the <lb/>parameter for this step-indexed refinement relation to require that the value of l corresponds <lb/>to the second component of the state in the fin-stutter-lifting of FinChains. In this case, for any <lb/>finite trace of the program, there is a trace in the fin-stutter-lifting of FinChains that matches it <lb/>according to this relation. The key point here is that when the value of l goes from 0 to 1 in the <lb/>program, on the model side we go from the state (∞, 0) to ( , 1), where is the number of steps of <lb/>execution being considered. Hence, it would not be sound, in this case, to conclude an intensional <lb/>refinement relation from the refinement relation established in the step-indexed logic. The crux of <lb/>the issue here is the unbounded choice of transitions going out of the state (∞, 0) which allows us <lb/>to pick a path based on the number of steps of execution that we are considering. Below we analyze <lb/>this problem more formally, and conclude that a so-called relative image-finiteness side-condition <lb/>suffices to circumvent the problem. (Note that the problem of unbounded branching is already <lb/>present in the fin-stutter-lifting construction; we will discuss this issue further when we explain <lb/>the fuel construction in §4.3.) <lb/>We first define a notion of finite approximation, which intuitively corresponds to what guarded <lb/>recursive predicates compute. Guarded recursive predicates are those defined as fixed points using <lb/>the step-indexing technique, e.g., the weakest preconditions underlying the program logic of both <lb/>Iris and Trillium. <lb/>Definition 2.5. Let be a function on the space of binary relations on traces of LTSs 1 and 2 , <lb/>i.e., : 2 tr ( 1 ) ×tr ( 2 ) → 2 tr ( 1 ) ×tr ( 2 ) , where 2 is the powerset of , and tr ( ) is the set of all traces <lb/>of the LTS . We define the finite approximation of , written FinApprox ( ), as <lb/>FinApprox ( ) ≜ <lb/>∞ <lb/>=0 <lb/>where 0 ≜ tr ( 1 ) × tr ( 2 ) and +1 ≜ ( ) <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:7 <lb/></page>

        <body>The upshot of the limitation of step-indexed logics is that the best we can hope to conclude from <lb/>a refinement relation defined in a step-indexed logic is a finite approximation of the refinement <lb/>relation. Specifically, in our case we can conclude FinApprox ( ≼ ), where ≼ is the function whose <lb/>greatest fixed point (by the Knaster-Tarski fixed point theorem) is the intensional refinement <lb/>relation in Definition 2.2: <lb/>≼ ( ) = {( , ′ )|∀ , . last ( ) -<lb/>→ =⇒ ∃ ′ , ′ . ( -<lb/>→ , ′ ′ <lb/>-<lb/>→ ′ )} ∩ <lb/>In other words, we can only conclude ≼ if ≼ is finitely approximable, i.e., if ≼ = FinApprox ( ≼ ), <lb/>which is well-known not to be the case in general for refinement relations. Indeed, one frequently <lb/>used condition for finite approximation is so-called image-finiteness [Cleaveland and Sokolsky <lb/>2001, Thm. 2.6]. An LTS is said to be image-finite if, for any state and label , there exists only <lb/>finitely many states ′ such that -<lb/>→ ′ . As we will discuss in §4.2.2, however, it is desirable to <lb/>consider LTSs with infinite branching. For this reason we relax the image-finiteness condition by <lb/>considering the weaker relative image-finiteness condition (a property of the relation, not the <lb/>LTS), defined below. For relative image-finiteness, it is sufficient that for any state of the program <lb/>and for any transition -<lb/>→ ′ , there are only finitely many LTS transitions that correspond to -<lb/>→ ′ <lb/>allowed by the relation. <lb/>Definition 2.6 (Relative image-finiteness). Let be a relation on traces of two LTSs. The relation <lb/>is relatively image-finite if, for any , ′ , and transition last ( ) -<lb/>→ , the following set is finite: <lb/>{( ′ , ′ ) | ( -<lb/>→ , ′ ′ <lb/>-<lb/>→ ′ )} <lb/>Theorem 2.7 (Finite Approximation). Let be a relatively image-finite relation on traces of two <lb/>LTSs. The intensional refinement relation ≼ is finitely approximable, i.e., ≼ = FinApprox ( ≼ ). <lb/>2.3 Further Discussions <lb/>Coming up with the Appropriate Model. One natural question regarding the methodology that <lb/>we present in this paper is &quot;how does one come up with the appropriate model and the parameter <lb/>for the verification task at hand?&quot; We argue that coming up with the appropriate model and <lb/>parameter is of the same nature, and indeed part of picking the appropriate specification, e.g., <lb/>relevant preconditions and postconditions. Hence, there is no obvious, one-size-fits-all answer. <lb/>Indeed, the model and the relation often need to be designed so as to facilitate establishing the <lb/>safety trace property or liveness property of the program we wish to prove, e.g., the relation <lb/>and the model Chain in Figure 1 that we chose for the program count _ up in Figure 2, in order to <lb/>establish that &quot;the value of the counter increases monotonically without skipping over any number&quot;. <lb/>Moreover, at a technical level, the limitation of relative-image-finiteness of the relation restricts <lb/>us in the choice of the model and the parameter. For these reasons, the chosen model may not <lb/>be arbitrarily abstract. It must reflect some of the core characteristics of the program, at least to <lb/>the extent necessary for the trace property in question, and for the to be relative image-finite. <lb/>It is our hypothesis that coming up with appropriate models and relations is feasible in most, <lb/>if not all, interesting examples. However, in the present paper we only present the foundation <lb/>and methodology of using intensional refinement to strengthen the expressivity of step-indexed <lb/>higher-order concurrent (and distributed) separation logics, and support it with simple examples. A <lb/>proper experimental evaluation of the hypothesis, using a wide range of more advanced examples, <lb/>is beyond the scope of the current work, and we leave it for future work. <lb/>What about Transfinite Iris? Transfinite Iris [Spies et al. 2021] is a variant of Iris whose model is <lb/>step-indexed over an arbitrary ordinal (as opposed to the natural numbers used in the model of <lb/>ordinary Iris). The upshot of this change is that Transfinite Iris satisfies the so-called &quot;existential <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:8 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>property&quot; [Spies et al. 2021] which in effect renders the (relative) image-finiteness side-condition <lb/>unnecessary. We believe that the work of this paper could also be carried out on top of Transfinite <lb/>Iris, dispensing with the relative image-finiteness side-condition, albeit at the cost of other possible <lb/>complications in proofs. 4 Spies et al. [2021] prove termination and termination-preserving refine-<lb/>ments of sequential programs but do not show any (preservation of) liveness properties beyond <lb/>termination nor do they treat concurrent programs. <lb/>What about the Approaches for Contextual Refinement? There have been several works on estab-<lb/>lishing contextual refinement in Iris for complex sequential and concurrent programming languages <lb/>[Frumin et al. 2018, 2020; Georges et al. 2022; Gregersen et al. 2023; Jacobs et al. 2022, 2021; Krebbers <lb/>et al. 2017; Krogh-Jespersen et al. 2017; Timany and Birkedal 2019; Timany et al. 2018]. In essence, <lb/>contextual refinement boils down to showing that if one program terminates, so should the other. <lb/>In these previous works, it is established by the use of invariants in Iris. This implies that the <lb/>approach only allows one to show that for any finite prefix of execution of the first program (the <lb/>implementation side) there exists a finite execution of the second program (the specification side) <lb/>and the final states correspond. This notion of refinement is too weak for our purposes: (1) it says <lb/>nothing about infinite executions and hence does not help us establish liveness properties, and (2) <lb/>it does not allow us to transfer non-trivial safety trace properties. In the Appendix we discuss an <lb/>illustrative example. <lb/>3 TRILLIUM: A TRACE PROGRAM LOGIC FRAMEWORK <lb/>In this section, we give a more detailed account of the general Trillium logic and a formal statement <lb/>of its adequacy theorem. We first detail how we instrument the operational semantics of the domain <lb/>programming language with &quot;locale&quot; transition identifiers (essentially thread id&apos;s), to facilitate <lb/>thread-level properties such as fair scheduling. Second, we present the fundamentals of the Trillium <lb/>logic, and its adequacy theorem (Theorem 3.2). We focus on the novelties of Trillium but will <lb/>recount necessary constructions of the Iris base logic briefly at a high level. <lb/>Language Agnostic Framework. The Trillium program logic is language agnostic and is defined <lb/>with respect to any programming language which comes with an operational semantics given <lb/>by a notion of expression ∈ Expr, value ∈ Val ⊆ Expr, evaluation context ∈ Ectx, program <lb/>state ∈ State (a model of, e.g., the heap and/or the network), and a primitive reduction relation <lb/>1 , 1 ⇝ 2 , 2 ; 1 , • • • , <lb/>that relates an expression 1 and a state 1 to an expression 2 , a state <lb/>2 , and a (possibly empty) list 1 , . . . , <lb/>of expressions, corresponding to the threads forked by <lb/>the reduction. A value denotes an expression that has reached its final form and will no longer <lb/>reduce. We write [ ] for the result of replacing the hole in evaluation context with . <lb/>The global state of the system is a configuration c = (tp, ), where the thread pool tp is a finite <lb/>mapping from locales 5 to expressions, each corresponding to an execution thread. We will write <lb/>tp( ) for the expression whose locale is in tp and use tp[ ↦ → ] for the corresponding update <lb/>(which adds a new thread if ∉ dom(tp)). We will write { ↦ → } for the singleton thread-pool <lb/>consisting of a single thread . For a language with shared-memory concurrency a locale would <lb/>simply be a thread identifier. For a distributed language, a natural definition would be a pair ( , tid) <lb/>of the name of the node and the thread identifier tid of the thread in that node. Having explicit <lb/>locales as part of the language definition will be beneficial when expressing, e.g., thread-level <lb/>properties such as fair scheduling. <lb/></body>

        <note place="footnote">4 The compromise that Transfinite Iris makes is that it no longer validates some of the basic reasoning principles regarding <lb/>step-indexing, i.e., rules regarding interaction of the later modality with other connectives of the logic. It is partly due to <lb/>this limitation that we opt to base our work on ordinary Iris at the cost of the relative image-finiteness side-condition. <lb/>5 The name is inspired by the Chapel programming language, where it denotes the abstract place where programs execute. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:9 <lb/></page>

        <body>The primitive reduction relation is lifted to an LTS by a relation between configurations labeled <lb/>by the step-taking locale as follows: <lb/>( 1 , 1 ) ⇝ ( 2 , 2 ; 1 , • • • , ) <lb/>fr ( , tp) = 1 , 2 , . . . <lb/>(tp[ ↦ → [ 1 ]], 1 ) -<lb/>→ (tp[ ↦ → [ 2 ], 1 ↦ → 1 , . . . , ↦ → ], 2 ) <lb/>where fr ( , tp) is an infinite sequence of fresh locales (not in dom(tp)) derived from , e.g., in case <lb/>of distributed systems it would consist of fresh thread identifiers on the same node as . <lb/>The Trillium Program Logic. The goal of the Trillium program logic is to establish an intensional <lb/>refinement c ≾ m between singleton traces consisting of the initial program configuration c and a <lb/>model state m. Proving this refinement is a matter of proving that always holds, throughout the <lb/>execution of the program starting in c, alongside a corresponding traversal of the model starting <lb/>from m. This can be achieved by ensuring that the program execution makes progress in tandem <lb/>with the model, in addition to the relation being preserved throughout any such execution. <lb/>Conventional Iris-style weakest precondition predicates wp E <lb/>guarantee postcondition <lb/>validity of terminated programs, progress of program executions, and preservation of the invariants <lb/>whose names are in the mask E. This can be seen explicitly in its definition; a guarded fixpoint of <lb/>the following equation [Jung et al. 2018] (which, unlike in Trillium, does not consider locales): <lb/>wp E Φ ≜ ∈ Val * ( ) ∨ <lb/>(post condition) <lb/>∉ Val * ∀ . ( ) - * | ⇛ <lb/>E ∅ reducible( , ) * <lb/>(progress) <lb/>⊲ ∀ ′ , ′ , 1 , • • • , <lb/>. ( , ) ⇝ ( ′ , ′ ; 1 , . . . , ) - * <lb/>| ⇛ <lb/>∅ E ( ′ ) * wp E <lb/>′ Φ *  * <lb/>1≤ ≤ <lb/>wp ⊤ <lb/>Ψ <lb/>(preservation) <lb/>The definition is by case distinction: either is a value, in which case the postcondition should <lb/>hold, or is not a value, in which case there are two requirements (ignoring | ⇛ <lb/>E 1 E 2 and ( ) <lb/>for now). First, for the current state (captured by ( )), the program should be reducible, i.e., it <lb/>can make progress. Second, for any program ′ and forked threads that might reduce to, the <lb/>weakest precondition must hold as well (with some post condition Ψ for the forked threads). The <lb/>later modality ⊲ guarantees that the fixpoint is well-defined (the recursive occurrence is guarded). <lb/>The update modality | ⇛ <lb/>E 1 E 2 enables a form of rely-guarantee reasoning regarding invariants: to <lb/>establish the prover can access the invariants in E 1 but they must also establish all the invariants <lb/>in E 2 alongside proving . Hence, the definition of the weakest precondition preserves invariants <lb/>in E by giving access to all of them (by going from E to ∅) but requires them to be preserved by <lb/>asking them to be closed immediately after each program step (by going back from ∅ to E). The <lb/>predicate : State → iProp is the state interpretation predicate that reflects the state (e.g., the heap) <lb/>of the program as resources in the logic and gives meaning to, e.g., the traditional separation logic <lb/>connective ℓ ↦ → for heap ownership. Note how the definition of weakest precondition enforces <lb/>that the state interpretation, just like invariants, is preserved throughout program execution. We <lb/>often write wp E <lb/>. <lb/>≜ wp E <lb/>. , and wp E <lb/>≜ wp E <lb/>. = () * . <lb/>Remark 3.1 (Invariants and ghost resources in Iris). That is invariant in Iris is represented <lb/>by the proposition <lb/>N which is annotated with a name N that identifies it. In order to work <lb/>with invariants formally in Iris, the update modality is annotated with two masks: | ⇛ <lb/>E 1 E 2 . <lb/>We write | ⇛ E when E 1 = E 2 = E and | ⇛ when E = ⊤, the set of all masks. The update <lb/>modality allows us to update ghost resources as described by Iris&apos;s ghost resource theory <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:10 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>[Jung et al. 2018] and to access invariants. Intuitively, the proposition | ⇛ <lb/>E 1 E 2 holds if we can <lb/>establish and all invariants in E 2 through ghost updates, without violating the environment&apos;s <lb/>resources (a &quot;frame preserving update&quot;), and all the invariants in E 1 . For weakest preconditions <lb/>(in both the Iris and Trillium program logic) we can manipulate resources and invariants <lb/>throughout the proof because weakest preconditions are closed under the update modality: <lb/>| ⇛ E wp <lb/>⊣⊢ wp <lb/>⊣⊢ wp <lb/>. | ⇛ E ( ) . The following rules allow us to create and <lb/>access invariants and to manipulate the update modality. Note how accessing an invariant <lb/>only makes its contents available one step later (under ⊲); similarly we only need to prove <lb/>it one step later to (re)establish the invariant. The inv-access rule-alongside providing the <lb/>contents of the invariant-also tells us how we can close/reestablish the invariant. <lb/>Inv-alloc <lb/>⊲ ⊢ | ⇛ E <lb/>inv-access <lb/>N ∈ E <lb/>N ⊢ | ⇛ <lb/>E E\N ⊲ * (⊲ - * <lb/>| ⇛ <lb/>E\N E True) <lb/>upd-mono <lb/>⊢ <lb/>| ⇛ <lb/>E 1 E 2 ⊢ | ⇛ <lb/>E 1 E 2 <lb/>upd-mask-trans <lb/>| ⇛ <lb/>E 1 E 2 <lb/>| ⇛ <lb/>E 2 E 3 <lb/>| ⇛ <lb/>E 1 E 3 <lb/>upd-mask-weaken <lb/>E 2 ⊆ E 1 <lb/>| ⇛ <lb/>E 1 E 3 <lb/>| ⇛ <lb/>E 1 E 2 <lb/>| ⇛ <lb/>E 2 E 3 <lb/>These rules, along with the definition of weakest preconditions above allow us to prove a rule <lb/>for accessing invariants during an &quot;atomic&quot; step of computation, i.e., a program that reduces <lb/>to a value in a single step of computation. <lb/>wp-atomic <lb/>N ∈ E <lb/>N <lb/>⊲ - * wp E\{ N } <lb/>. ⊲ * ( ) <lb/>atomic( ) <lb/>wp E <lb/>Note how wp-atomic might appear to consume the invariant. This is not an issue, though, as <lb/>invariants are persistent and hence freely duplicable and shareable [Jung et al. 2018]. <lb/>In the rest of this paper we will make heavy use of one kind of ghost resource, which we <lb/>explain in terms of abstract predicates. Given a set we define two predicates • ( ) and <lb/>• ( ), for any ∈ , respectively called the full part and the fragment of the resource; is <lb/>the name of the resource instance used for disambiguation. These predicates are defined in <lb/>terms of Iris ghost resources internally and satisfy the following rules, which essentially say <lb/>that the full part and the fragment must always agree: <lb/>auth-agree <lb/>• ( ) * • ( ) ⊢ = <lb/>auth-alloc <lb/>⊢ | ⇛ E ∃ . • ( ) * • ( ) <lb/>auth-update <lb/>• ( ) * • ( ) ⊢ | ⇛ E • ( ) * • ( ) <lb/>We refer to Jung et al. [2018] for a more thorough treatment of how invariants, the update <lb/>modality, the later modality, and ghost state is constructed in Iris. <lb/>To define the Trillium program logic, we enrich the Iris-style weakest precondition to consider <lb/>(1) program traces, (2) locales, and (3) a lock-step relation between the program trace and the model <lb/>trace. Formally, this is defined as a guarded fixpoint of the equation below: <lb/>wp E <lb/>≜ <lb/>∈ Val * ∀ , . ( , ) - * | ⇛ E ( , ) * ( ) ∨ <lb/>∉ Val * ∀ , , , , tp. last ( ) = (tp[ ↦ → [ ]], ) * ( , ) - * | ⇛ <lb/>E ∅ <lb/>reducible( , ) * ⊲ ∀ ′ , ′ , 1 , • • • , <lb/>. ( , ) ⇝ ( ′ , ′ ; 1 , • • • , <lb/>) - * | ⇛ <lb/>∅ E <lb/>∃m ∈ M, . last ( ) -<lb/>→ m * <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:11 <lb/></page>

        <body>( -<lb/>→ (tp[ ↦ → [ ′ ], fr ( , tp) 1 ↦ → 1 , . . . , fr ( , tp) ↦ → <lb/>], ′ ), -<lb/>→ m) * <lb/>wp E <lb/>′ <lb/> *  * <lb/>1≤ ≤ <lb/>wp <lb/>fr ( ,tp) <lb/>E <lb/>Ψ <lb/>Instead of just program configurations, the definition now considers all program traces where <lb/>the expression is about to make a step at the locale , under an evaluation context ; and for <lb/>all steps that may take, there must exist a model state m ∈ M that the last state of the model <lb/>trace can step to. Moreover, instead of a state interpretation, it tracks a trace interpretation of <lb/>the program and model traces, which will allow us not only to interpret the state of the language <lb/>and the current model state as resources. Note also that in the case where is a value, in order to <lb/>establish the postcondition, we can also access the trace interpretation. This change is required for <lb/>the soundness of some of our proof rules which apply even when the program is a value but whose <lb/>correctness relies on the resources in the trace interpretation-we will discuss this later on. <lb/>That the definition of the Trillium weakest precondition has the intended meaning is the content <lb/>of the following general adequacy theorem. <lb/>Theorem 3.2 (Adeqacy). Let be a program, a program state, the locale of in an otherwise <lb/>empty thread pool, and an Iris predicate on values. Let m ∈ M be a model state and a relative <lb/>image-finite relation on finite traces of the program and the model. Let = ({ ↦ → } , ) be the initial <lb/>configuration of the program. If ( , m) holds for the initial singleton traces, and furthermore we have <lb/>| ⇛ ⊤ ( , m) * wp ⊤ <lb/> * AlwaysHolds( , , m) <lb/>then ≾ m holds in the meta-logic. <lb/>In particular, we must show that the trace interpretation holds for the initial singleton traces, that <lb/>the weakest precondition holds, and that the predicate AlwaysHolds( , , m) holds. The predicate <lb/>AlwaysHolds( , , m) is an Iris predicate that states that (which is a relation on finite traces, not <lb/>mentioning resources of the logic) does in fact always hold, assuming that all invariants hold, that <lb/>postconditions hold (for any thread that has terminated up to that point in the trace), that the <lb/>trace interpretation holds, and that the program never gets stuck. We refer to our accompanying <lb/>Coq development for the precise definition of the AlwaysHolds predicate. In practice, designing <lb/>program logics on top of Trillium is thus a matter of carefully picking a trace interpretation that <lb/>admits user-friendly reasoning principles while allowing the user to conclude strong relations. 6 <lb/>The adequacy theorem of Trillium is much stronger than that of the ordinary Iris program <lb/>logic. Recall that the usual adequacy theorem only establishes postcondition validity, progress, and <lb/>invariant preservation. Trillium&apos;s adequacy theorem, on the other hand, establishes intensional <lb/>refinement for any relation which in turn can include all three aforementioned guarantees. In <lb/>addition, as per Lemma 2.4, it allows us to show that infinite traces of execution of the program <lb/>also have corresponding infinite model traces. Consequently, the adequacy theorem of Trillium is <lb/>much more complicated to establish. The proof is in two stages. We first show that the weakest <lb/>precondition implies a finite approximation of intensional refinement stated in terms of guarded <lb/>recursion of Iris&apos;s base logic. We then show that the aforementioned guarded recursive definition <lb/>implies intensional refinement-this is where we exploit relative image-finiteness. We refer to the <lb/>accompanying Coq development for the details of the proof. <lb/></body>

        <note place="footnote">6 In fact, Trillium is conservative in that one can always pick a trivial model LTS, , and yielding no further intricacies in <lb/>the program logic, and the regular safety guarantees of Iris. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:12 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>4 THE FAIRIS LOGIC <lb/>In this section we present the Fairis logic; an instantiation of Trillium for proving liveness proper-<lb/>ties under fairness assumptions, such as fair termination, of programs written in an OCaml-like <lb/>programming language. Most non-trivial concurrent programs only enjoy liveness properties, <lb/>including termination, under fair thread scheduling. To see this, consider the program in Figure 3. <lb/>In this example, the function yn _ start creates a new reference b initialized at 0, and starts two <lb/>threads: yes swaps the value of b from true to false in a loop k times, and the no swaps it from <lb/>false to true as many times. For thread yes to make progress, it has to wait for no to set the value <lb/>of b to true, and vice versa. Clearly, this program would not terminate with an unfair scheduler <lb/>which only gives execution time to, say, yes. But this program does terminate in practice, because <lb/>operating systems&apos; schedulers and processors do behave fairly. We discuss the details of the proof <lb/>of termination of the example in Figure 3 in §4.2.1. <lb/>Our approach to taking fairness into account when reasoning about liveness properties is to <lb/>incorporate it into the model LTS as follows. First, we use the labels of the model LTS M, which <lb/>we will henceforth call roles in this section, in order to be able to express fairness at the level <lb/>of the model. Intuitively, a role is the abstraction of the concept of a thread at the model level. <lb/>Bear in mind, though, that, as we will discuss, threads and roles are not always in one-to-one <lb/>correspondence. To this end, we introduce a construction Fuel(M) which augments the model M <lb/>to keep track of the correspondence between threads and roles in order to provide finite stuttering. <lb/>This construction also adapts the relation and lifts it to a relation Fuel( ) between traces of the <lb/>program and traces of Fuel(M). For brevity, we will write fuel instead of Fuel( ). <lb/>In order to show that the program enjoys a certain liveness property , i.e., that all fair execution <lb/>traces of the program satisfy ( ), we carry out the proof in the following steps: <lb/>(1) We choose a model M and a relation . <lb/>(2) We prove a specification for our program using the Fairis program logic whose adequacy <lb/>theorem ensures that all program traces (including unfair executions) refine some trace of <lb/>the instrumented model Fuel(M) for the relation fuel . <lb/>(3) We have proved (once and for all) that given two traces and ′ , if ˆ fuel ( , ′ ), and is fair, <lb/>then so is ′ . (Intuitively, this holds because we have constructed Fuel(M) and fuel such that <lb/>they only allow finite stuttering in each thread.) <lb/>(4) We prove that all fair traces of M satisfy the desired property . <lb/>(5) We prove that is preserved by fuel , in that ˆ fuel ( , ′ ) and ( ′ ) implies ( ). <lb/>(6) We prove that, if for a trace in Fuel(M) we have that the corresponding trace ′ satisfies , <lb/>then so does , this roughly corresponds to the fact that is invariant under finite stuttering. <lb/>(7) From all of the above, we conclude ( ) for any fair trace of the program. <lb/>This may seem like a lot of steps, but (7) is automatic, and given a fixed property , steps (5) and (6) <lb/>can be proved independently of the program and of the model M. Step (6) is trivial for the case <lb/>of termination and properties of the always-eventually form as these are preserved under finite <lb/>stuttering. Finally, in case of termination, we have formulated a simple criterion for step (4) which <lb/>is local in the sense that one does not need to consider traces but rather need to inspect individual <lb/>transitions in M. See our accompanying appendix and Coq formalization for this local criterion. <lb/>What the user obtains from the adequacy theorem of Fairis is ≼ fuel between the program and <lb/>the model LTS Fuel(M); fuel is relative image-finite by construction whenever is. Crucially, <lb/>all the liveness properties we are interested in-such as termination or &quot;always-eventually&quot; trace <lb/>properties-are stable under finite stuttering. Hence, if all fair traces of M satisfy our property <lb/>so do all fair traces of Fuel(M). Consequently, the user only has to prove that the property can <lb/>be transported along the ≼ fuel intensional refinement relation from Fuel(M) to the program. In <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:13 <lb/></page>

        <body>let rec yes b n = <lb/>if cas b true false then n := !n-1; <lb/>if !n &gt; 0 then yes b n <lb/>let rec no b m = <lb/>if cas b false true then m := !m-1; <lb/>if !m &gt; 0 then no b m <lb/>let yn _ start k = let b = ref true in <lb/>(yes b (ref k) || no b (ref k)) <lb/>Fig. 3. The Yes and No threads. <lb/>. . . <lb/>m, ⊥ <lb/>m, ⊤ <lb/>m+1, ⊥ <lb/>m+1, ⊤ <lb/>. . . <lb/>No <lb/>Yes <lb/>Yes <lb/>No <lb/>No <lb/>Yes <lb/>Yes <lb/>No <lb/>No <lb/>We write ⊤ for true and ⊥ for false. <lb/>Fig. 4. The model M yes_no . <lb/>some cases, e.g., §4.2.3, we may be interested in proving a liveness property under an assumption <lb/>stronger than fairness, i.e., that all fair traces that satisfy a certain property satisfy the desired <lb/>liveness property . In such cases the user of Fairis is responsible for proving that the property <lb/>can be transported from the program to Fuel(M) and from Fuel(M) to M-in case of the example <lb/>in §4.2.3, we are interested in infinite fair traces; infinitude, like finiteness, trivially transports as <lb/>it is preserved by intensional refinement and finite stuttering. The Fuel construction essentially <lb/>augments the model LTS to add two pieces of information: (1) for each thread id , the set of roles <lb/>that are associated to , and, (2) for each role , the value of its so-called fuel, i.e., a number which <lb/>measures how long the program can still postpone taking a step in that role in . This allows us <lb/>to assign obligations to threads, i.e., assign a set of live roles to a thread-a role is said to be live if <lb/>it can still take steps. A thread that has a set of roles assigned to it must eventually (restricted <lb/>by fuel) take a step in each of those roles. This is enforced by mandating that to take a step of <lb/>computation, a thread must have a non-empty set of live roles, and that after the step all fuels <lb/>in are decreased, except if this step was matched by a non-stuttering step corresponding to a <lb/>role ∈ (one of its live roles) in the underlying LTS M. In that case, the thread may increase <lb/>the fuel of role (but the fuel for all other roles in must decrease) as long as it remains under a <lb/>certain global cap which we will denote with F cap . 7 Alternatively, a thread can delegate some of <lb/>its obligations to a thread that it forks. The adequacy theorem of Fairis requires a proof in the <lb/>program logic that enforces that threads may only stop if there are no live roles assigned to them <lb/>anymore; this is encoded through threads&apos; postconditions. <lb/>The Fairis adequacy theorem is a special case of the Trillium adequacy theorem. The theorem is <lb/>shown below, and has differences from the Trillium adequacy theorem highlighted: <lb/>Theorem 4.1 (Fairis-Adeqacy). Let be a program, a program state, the locale of in an <lb/>otherwise empty thread pool. Let m ∈ M be a model state, and a relative image-finite relation on <lb/>program traces and model traces. Let = ({ ↦ → } , ) be the initial configuration of the program, <lb/>and m be the initial state of Fuel(M) corresponding to m, i.e., m together with assigned to a map <lb/>F init of all roles with F cap fuel. If ( , m) and <lb/>| ⇛ ⊤ (• M (m) * ⇒ F init *  * ℓ ; ∈ ℓ ↦ → ) - * <lb/>( , m) * wp ⊤ <lb/>. ⇒ ∅ * AlwaysHolds( , , m) <lb/>then ≾ fuel m holds in the meta-logic. <lb/>Here, • M (m) and tid ⇒ F init are initial resources used in the Fairis program logic rules. In <lb/>particular, • M (m) is an exclusive resource that tracks the current state of the user model, while <lb/></body>

        <note place="footnote">7 This global cap, fixed for each refinement proof, ensures relative image-finiteness (Definition 2.6) of Fuel( M ). <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:14 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>⇒ fs associates the locale with a partial map fs : Role(M) ⇀ N that associates model roles with <lb/>their fuels. The authoritative part • M (m) of the resource is kept as part of the trace interpretation; <lb/>the name M is a globally fixed name for the entire proof created as part of the proof of the adequacy <lb/>theorem. The resource • M (m) is available to the user of the Fairis program logic to be able to <lb/>relate the state of the program to the state of the model (which always agrees with the one tracked <lb/>in the trace interpretation as per resource rules), usually in an invariant. This relation in the logic <lb/>is then what the user will use to establish the relation as required-we will see this in examples <lb/>below. Initially, all roles are assigned to the single thread in the thread-pool with fuels all being <lb/>F cap . The last piece of resource the user acquires from the adequacy theorem is the full ownership <lb/>of the entire initial state (heap) in that we obtain points-to propositions for all locations in . <lb/>The adequacy theorem, and the rule for forking threads as we will see later, enforce that upon <lb/>termination (in the postcondition) the thread must own no live roles. Finally, note that even though <lb/>the adequacy theorem establishes a ≾ fuel relation, the user only needs to prove AlwaysHolds for <lb/>and not for fuel . <lb/>In the rest of this section we cover how we apply Fairis to prove various liveness properties. First, <lb/>we present the key ideas of the Fairis program logic, along with its reasoning rules, used for proving <lb/>the weakest precondition of programs §4.1. We then give a tour of how the Fairis program logic <lb/>can be used to prove liveness properties of programs §4.2, including fair termination of the yes-no <lb/>example discussed earlier. Finally, we outline some of the technical details involved in obtaining <lb/>the Fairis adequacy theorem §4.3. <lb/>The examples that we present in this section are simple examples designed to demonstrate <lb/>viability of the Trillium approach to liveness properties under fair scheduling assumptions. As such, <lb/>in all these examples the LTS model used includes the entire core functionality of the program; <lb/>only the administrative program steps, e.g., beta-reduction, are not included which are taken into <lb/>account via stuttering enabled by the fuel construction. Hence, in that sense, the LTS models of <lb/>these examples are not very abstract. For more involved examples, we expect that the level of <lb/>abstraction of the LTS model compared to the program should be similar to that of Aneris examples; <lb/>c.f. the Paxos example of §5 where the model abstracts away a substantial amount of implementation <lb/>details. However, to substantiate this claim one needs a proper experimental evaluation, using a <lb/>wide range of more advanced examples, which is beyond the scope of the current work, and thus <lb/>we leave it for future work. <lb/>4.1 The Fairis Program Logic <lb/>The Fairis program logic combines the reasoning principles of conventional Iris program logics <lb/>with reasoning principles involving fuel and model resources. To properly compartmentalize these <lb/>orthogonal reasoning principles, the program logic employs two layers of reasoning: an outer <lb/>(model) layer and an inner (program) layer. <lb/>The intuition is that at every program step, the program will either do a fuel step, corresponding <lb/>to stuttering, or a model step, corresponding to a step in the underlying model. Both of these are <lb/>handled by the outer model layer. Regardless of which kind of step the program takes, the inner <lb/>layer will then be used to reason about the actual program step. The rules of the inner program <lb/>logic only concern the program on its own and hence very closely resemble those of the ordinary <lb/>program logic of Iris. <lb/>The inner program logic layer is expressed in terms of a different weakest precondition wp E ⟨ ⟩ <lb/>(note the angle brackets instead of braces for the postcondition). This weakest precondition is a <lb/>(heavily) simplified version of Trillium&apos;s weakest precondition where the state interpretation (it <lb/>indeed only mentions the state and not the entire trace) only concerns the heap of the program. In <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:15 <lb/></page>

        <body>Fuel &amp; model rules (outer program logic) <lb/>wp-step-fuel <lb/>⇒ fs ++ <lb/>fs ≠ ∅ <lb/>wp E <lb/>′ . ⇒ fs - * wp E <lb/>′ <lb/>wp E <lb/>wp-role-dealloc <lb/>• M (m) <lb/>m -<lb/>→ / _ <lb/>⇒ { := _} ⊎ fs <lb/>(• M (m) * ⇒ fs) - * wp E <lb/>wp E <lb/>wp-step-model <lb/>• M (m) <lb/>m -<lb/>→ m ′ <lb/>⇒ { := _} ⊎ (fs ++ ) <lb/>wp E <lb/>′ . (• M (m ′ ) * ⇒ { := F cap } ⊎ fs) - * wp E <lb/>′ <lb/>wp E <lb/>wp-role-fork <lb/>⇒ (fs 1 ⊎ fs 2 ) ++ <lb/>fs 1 ⊎ fs 2 ≠ ∅ <lb/>∀ ′ . ′ ⇒ fs 2 - * wp <lb/>′ <lb/>E <lb/>′ ⇒ ∅ <lb/>wp E fork ( ) <lb/>⇒ fs 1 <lb/>Program rules (inner program logic; an excerpt) <lb/>wp-alloc <lb/>wp E ref ⟨ .∃ℓ. = ℓ * ↦ → ⟩ <lb/>wp-load <lb/>ℓ ↦ → <lb/>wp E ! ℓ ⟨ . = * ℓ ↦ → ⟩ <lb/>wp-store <lb/>ℓ ↦ → <lb/>wp E ℓ ← ⟨ℓ ↦ → ⟩ <lb/>wp-cas <lb/>ℓ ↦ → <lb/>wp E cas ℓ 1 2 <lb/>. ( = 1 * = true * ℓ ↦ → 2 ) ∨ <lb/>( ≠ 1 * = false * ℓ ↦ → ) <lb/>wp-beta <lb/>wp E ( . ) ⟨ ′ . ′ = [ / ]⟩ <lb/>Fig. 5. The rules of the Fairis program logic <lb/>particular, this inner program logic on its own would be useless. It is only useful, and extremely so, <lb/>because the outer program logic has already taken care of the details of the model including the fuel. <lb/>Additionally, the inner weakest precondition strictly captures a single step of reduction as for further <lb/>steps the outer program logic must intervene again to manage the model-side details. As a result, <lb/>the postcondition of the inner weakest preconditions are predicates over arbitrary expressions as <lb/>opposed to values, i.e., a predicate : Expr → iProp. Similar to the outer weakest precondition, we <lb/>often write wp E ⟨ ′ . ⟩ ≜ wp E ⟨ ′ . ⟩, and wp E ⟨ ⟩ ≜ wp E ⟨ ′ . ′ = () * ⟩. Additionally, <lb/>we often use instead of ′ for the return value binder, to denote that the returned expression is a <lb/>value. The definition of the inner weakest precondition is given in the accompanying appendix. <lb/>An overview of the layers and their rules can be found in Figure 5. The rules of the inner program <lb/>logic are entirely standard. We will thus not explain them in detail. The wp-step-fuel rule captures <lb/>that we can take a fuel step whenever the fuel of all the roles of the non-empty fuel map is non-zero <lb/>( ⇒ fs ++ and fs ≠ ∅, where fs ++ denotes the map fs where all fuels are incremented by 1). We must <lb/>then prove the inner weakest precondition, where the postcondition captures that we re-obtain the <lb/>fuel map ( ⇒ fs), where all fuel has been decremented, for the remaining proof obligation. <lb/>The wp-step-model rule captures that we can take a model step whenever the underlying model <lb/>can take a step over some role ; we have • M (m) indicating the current model state, and m -<lb/>→ m ′ <lb/>indicating we can take a step. We must then show that the role is associated with the current locale <lb/>, and that the fuel of all non-roles are non-zero ( ⇒ { := _} ⊎ fs ++ ). Just as in wp-step-fuel <lb/>we must show the inner weakest precondition, which in turn gives us back the model and fuel <lb/>resources. The model resource is updated to the new model state, • M (m ′ ), and the fuel map has the <lb/>fuel of replenished to the maximum fuel cap, F cap , while all non-fuels have been decremented, <lb/>⇒ { := F cap } ⊎ fs. The conjunction of these rules effectively enforce, that for any role for <lb/>which we can only take finitely many steps in the thread that is assigned to, we are forced to <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:16 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>take a step corresponding to . Otherwise, we would run out of fuel for the role and hence not <lb/>be able to take anymore steps, be it a stuttering step, or a step of any role other than . <lb/>The rules wp-role-dealloc and wp-role-fork allow us to discharge our obligations (roles we are <lb/>responsible for). The rule wp-role-dealloc removes a role from the fuel map of the locale when <lb/>all the obligations of that role are fulfilled, i.e., when the role &quot;terminates&quot; and cannot take any <lb/>more steps. The rule wp-role-fork, on the other hand, allows the thread to delegate some of its <lb/>obligations (roles) by forking a thread and passing those roles to the newly forked threads. Note <lb/>how the fuel is decremented for all roles, including those that are passed to the newly forked threads. <lb/>This restriction is necessary for the soundness of the logic as otherwise one could indefinitely <lb/>postpone taking a step in role by repeatedly forking new threads. Furthermore, note how the rule <lb/>wp-role-fork requires the postcondition of the forked thread to have a live role when it terminates, <lb/>effectively forcing it to discharge all its obligations before termination. <lb/>4.2 Examples <lb/>In this section we cover a suite of examples to demonstrate how Fairis can be used to prove fairness-<lb/>dependent liveness properties. In particular, we first prove fair termination of the yes-no example <lb/>(Figure 3) discussed earlier. We will then present an example in §4.2.2 where the model LTS is not <lb/>image-finite but still the relation is relative image-finite cf. Definition 2.6. Finally, we demonstrate <lb/>how Fairis can be used to show liveness properties beyond termination in §4.2.3. <lb/>4.2.1 Fair Termination: Yes-No. We initially consider the application of Fairis for proving fair <lb/>termination, which we formally state as follows over the initial configuration of the program: <lb/>fairly_terminating( ) ≜ ∀ . first( ) = =⇒ fair( ) =⇒ finite( ) <lb/>In particular, we prove fair termination for the yes-no program presented in Figure 3, using the <lb/>associated model shown in Figure 4. Proving fair termination of the model is relatively straight-<lb/>forward. In our Coq formalization we apply the local criterion mentioned earlier; this criterion <lb/>is explained in our accompanying appendix. Moreover, as discussed earlier, termination can be <lb/>trivially transported from M to Fuel(M). Hence, to prove fair termination of the yes-no program, <lb/>we just have to show that it is refined by the yes-no model using Fairis. <lb/>To do so, we apply the adequacy theorem of Fairis, using a trivial relation, and an empty initial <lb/>state for the program. This choice means that AlwaysHolds(Fuel( ), , m) holds trivially for any <lb/>and m. Since the yes-no model (Figure 4) is finitely branching, any relation on it is trivially <lb/>relative image-finite. What remains to prove is the weakest precondition of the yes-no program: <lb/>(• M (m) * ⇒ {Yes := F cap ; No := F cap }) - * wp ⊤ yn_start <lb/>⇒ ∅ <lb/>where is the state ( , ⊤) in Figure 4, and 0 &lt; is any positive natural number. As for applying <lb/>the rules updating the underlying model, the only steps in the program where this happens are the <lb/>two cas operations in the yes and no threads. These are precisely the horizontal steps in Figure 4 <lb/>when the cas operation succeeds and the loop when the cas operation fails-as cas is atomic, we <lb/>can access the invariant (see the rest of the proof argument) during a cas operation. All the other <lb/>steps in the program are stuttering steps. <lb/>The proof starts by using wp-alloc to resolve the allocation of the flag reference, obtaining <lb/>↦ → true. As per conventional Iris methodology for concurrent programs, the proof employs an <lb/>invariant to safely share the flag reference among the two threads. This invariant additionally <lb/>ensures that the program behaves according to the model LTS by incorporating the • M part of <lb/>the model resource. Recall that corresponds to how many times the model must cycle between <lb/>flipping the flag back and forth before termination. In order to tie the state of the model to the <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:17 <lb/></page>

        <body>let rec decr _ loop l = <lb/>if !l &gt; 0 then l := !l -1 else #() <lb/>let nondet _ start l = <lb/>l := (nondet () + 1);; decr _ loop l <lb/>Fig. 6. The non-deterministic nat example. <lb/>∞ <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>. . . <lb/>n on de t <lb/>n o n d e t <lb/>nondet <lb/>nondet <lb/>nondet <lb/>n o n d e t <lb/>nondet <lb/>no nd et <lb/>nondet <lb/>Fig. 7. The non-deterministic nat model. <lb/>references managed by the two threads, we incorporate two additional resource predicates • yes <lb/>and • no in the invariant, each tracking how many times each thread must still flip the flag -the <lb/>fragmental parts of these resources will be passed to the two threads. The invariant used to prove <lb/>the yes-no program, yesno_inv( yes , no , ), is as follows: <lb/>yesno_inv( yes , no ) ≜ ∃ , . • M ( , ) * ( , ) ≠ (0, false) * ↦ → * <lb/>= true * • yes ( ) * • no ( ) ∨ = false * • yes ( ) * • no ( -1) <lb/>Note how in the case the flag is false the value of the no thread may lag behind because it has not <lb/>yet had the chance to flip the flag in this &quot;round&quot; to be able to catch up. Furthermore, note how <lb/>this invariant asserts that the state (0, false) is not ever reached in the model when the program <lb/>is refining the model. This is crucially the case because we only ever call yn_start with a strictly <lb/>positive argument. It only remains to prove the following specifications of the two threads <lb/>( yesno_inv( yes , no , ) <lb/>N YN * ⇒ {Yes := 42} * • yes ( ) * 0 &lt; ) - * wp ⊤ yes <lb/>⇒ ∅ <lb/>( yesno_inv( yes , no , ) <lb/>N YN * ⇒ {No := 42} * • no ( ) * 0 &lt; ) - * wp ⊤ no <lb/>⇒ ∅ <lb/>Note that the fuel of 42 is picked somewhat arbitrarily; it only needs to be below F cap (which we <lb/>can arbitrarily pick) and large enough for the proof to go through. <lb/>We use these specifications along with wp-role-fork to delegate the role obligations to the two <lb/>threads, which completes the proof of the main thread which can (and must) now terminate as it <lb/>has no roles associated to it anymore. We use wp-step-fuel to resolve all the stuttering steps in <lb/>between model steps. The crux of the rest of the proof is the cas operations, where we update <lb/>the model using the rule wp-step-model, regardless of it succeeding or not. In particular, we open <lb/>the invariant around the operation using the rule inv-access, and then resolve the operation with <lb/>wp-cas. Based on whether the cas operation succeeds, we either take the decrementing or the <lb/>looping step in the model. In either case, the invariant is preserved. If we succeed, we update our <lb/>model resource • M ( ) accordingly to preserve the invariant. If we fail, we simply do nothing and <lb/>loop. In both cases, a model step has taken place in the underlying logic and hence the fuel for <lb/>thread&apos;s role can be replenished. The program loops until we eventually hit 0, in which case we can <lb/>use wp-role-dealloc to discharge the role obligation, as the role can no longer step in the model, <lb/>thus fulfilling the postcondition. <lb/>4.2.2 Sound Infinite Branching: Non-deterministic Nat. In §1 we remarked that the model should be <lb/>relatively image-finite for the Trillium (and thereby Fairis) adequacy theorem to be sound. In this <lb/>section we consider a model which is infinitely branching, while still being relative image-finite, by <lb/>virtue of the user picked relation . <lb/>The program we consider can be seen in Figure 6. This program works on a pre-allocated <lb/>reference ℓ as input. It then assigns a non-zero non-deterministically chosen natural number to <lb/>the reference, which it decrements until it hits zero, after which point it terminates. A specification <lb/>for the non-deterministic number operation is simply wp E nondet ⟨ .∃ . = ⟩. The model of the <lb/>program can be seen in Figure 7. It starts in an initial state ∞, from which it can go to any natural <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:18 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>let rec incr _ loop l n = <lb/>if cas l n (n+1) then incr _ loop l (n+2) else incr _ loop l n <lb/>let eo _ start l = <lb/>let x := !l in (incr _ loop l x || incr _ loop l (x+1)) <lb/>Fig. 8. The even-odd example. <lb/>0 <lb/>1 <lb/>2 <lb/>3 <lb/>. . . <lb/>even <lb/>odd <lb/>odd <lb/>even <lb/>even <lb/>odd <lb/>odd <lb/>even <lb/>Fig. 9. The even-odd model. <lb/>number . While the model is terminating (all traces are finite), it is also infinitely branching to <lb/>accommodate for the fact that the program may non-deterministically step to any natural number. <lb/>In order to prove relative image-finiteness we apply the Fairis adequacy theorem with the <lb/>following user relation: <lb/>ℓ <lb/>nondet ( , ) ≜ (last ( ) = ∞ ∧ heap(last ( ))(ℓ) = -1) ∨ (∃ . last ( ) = ∧ heap(last ( ))(ℓ) = ) <lb/>That is, the state of the model always correspond to the number stored in the location, once it has <lb/>been initialized-before that the location stores -1. This relation ensure relative image-finiteness, <lb/>as for every program step, there is only one valid model step. Intuitively, the model side number <lb/>we step to is uniquely (and hence finitely) determined by the program. <lb/>To be able to prove AlwaysHolds( nondet (ℓ), , m) we allocate a resource predicate, starting in the <lb/>initial model state • (∞) and • (∞), and use the former establish the following invariant at the <lb/>very beginning of our verification: <lb/>nondet_inv( , ℓ) ≜ ∃cn. • M (cn) * • (cn) * (cn = ∞ * ℓ ↦ → -1) ∨ (∃ . cn = * ℓ ↦ → ) <lb/>This invariant enforces that the location points to a natural number corresponding to the model. <lb/>Additionally, whenever the model is in the initial ∞ state, the location stores -1. Note that the <lb/>relation follows directly from the invariant. <lb/>To prove fair termination of the program, it only remains to prove the following specification: <lb/>( nondet_inv( , ℓ) <lb/>N nondet * • (∞) * ⇒ {nondet := F cap }) - * wp ⊤ nondet_start ℓ <lb/>⇒ ∅ <lb/>It is straightforward to prove that the invariant holds throughout the program, and that it implies <lb/>the user defined relation. The only non-stuttering step in the proof is the assignment step in the <lb/>then branch of decr _ loop which allows us to replenish the fuel in every loop iteration. An interesting <lb/>aspect of this proof is that we use an invariant in the proof despite the fact that program is not <lb/>concurrent. In this case, the invariant is not used to facilitate sharing between threads but rather <lb/>to enforce an invariant of the program, i.e., that the value of the reference must always, after <lb/>initialization, correspond to what is determined in the model LTS. <lb/>4.2.3 Liveness Properties Beyond Termination: Even-Odd. In this section we demonstrate how Fairis <lb/>can be used to prove liveness properties beyond termination. <lb/>Consider the program shown in Figure 8. The program works on a location ℓ assumed to store 0 <lb/>initially. It forks off two threads that each indefinitely increment the location whenever it is even <lb/>or odd, respectively. The property that we prove is that the counter ℓ visits all natural numbers in <lb/>order. This property only makes sense for maximal traces, i.e., traces that are either infinite or can <lb/>take no further step-as we will discuss, all maximal traces of this program are infinite. Formally, <lb/>the property we prove is the following: <lb/>evenodd_prop(ℓ, c) ≜ ∀ . first( ) = c ⇒ fair( ) ⇒ maximal( ) ⇒ <lb/>(∀ . ∃ . heap( ( ))(ℓ) = ) ∧ <lb/>(all numbers visited) <lb/>(∀ . ∃ . heap( ( ))(ℓ) = ∧ ∃ . ≤ ∧ ( + 1)(ℓ) = ) <lb/>(monotonicity) <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:19 <lb/></page>

        <body>We prove the property above by relating the program in Figure 8 with the model LTS Figure 9. To <lb/>this end, we prove the following property about the model Figure 9. <lb/>evenodd_prop_mdl(ℓ, m) ≜ ∀ . first( ) = m ⇒ fair( ) ⇒ infinite( ) ⇒ <lb/>(∀ . ∃ . ( ) = ) ∧ <lb/>(all number visited) <lb/>(∀ . ∃ . ( ) = ∧ ∃ . ≤ ∧ ( + 1) = ) <lb/>(monotonicity) <lb/>First, the property evenodd_prop_mdl(ℓ, m) is stable under finite stuttering-monotonicity is <lb/>expressed using ≤ which is preserved by stuttering. Second, notice the discrepancy between this <lb/>property and evenodd_prop(ℓ, c) where the latter only assumes maximality of the trace while the <lb/>former requires infinitude. This property is easy to prove under fairness assumptions. A fair infinite <lb/>trace cannot have a tail that just consists with one of the loops. Hence, it must visit all numbers. <lb/>Monotonicity follows rather trivially. <lb/>To finish the proof, we need to establish that (1) any maximal execution trace is infinite, and (2) <lb/>that the liveness property can be transported from the fuel-instrumented model to the execution <lb/>trace. To this end, we will pick relations as follows: <lb/>ℓ <lb/>even_odd ( , ) ≜ steps ( ) ∧ ℓ <lb/>match ( , ) <lb/>steps ( ) ≜ ∃ , c ′ . last ( ) -<lb/>→ c ′ <lb/>ℓ <lb/>match ( , ) ≜ ∀ &lt; length( ). ( )(ℓ) = ( ) <lb/>Note that, again, because the model in Figure 9 is finitely branching, the relation even_odd is trivially <lb/>relative image-finite. Moreover, if we have ≼ ℓ <lb/>even_odd <lb/>, given the steps ( ) part of ℓ <lb/>even_odd together <lb/>with maximality of , we can conclude that must be infinite. This established by (1) above. The <lb/>other part of the relation we pick, ℓ <lb/>match , simply expresses that the value stored in reference ℓ is <lb/>always the same as the number in the model trace. In order to prove AlwaysHolds( ℓ <lb/>even_odd , , m) <lb/>we must show that ℓ <lb/>steps is preserved throughout program execution. This, however, is a simple <lb/>consequence of post-condition validity and progress properties that we can assume as we prove <lb/>AlwaysHolds. On the one hand, we know that the program cannot be stuck, that is each thread is <lb/>either a value or it can take further steps. On the other hand, we cannot have that all threads are <lb/>values, as if they were, then their postconditions would all hold. This would allow us to conclude <lb/>that we have reached a state on the model side that has no live roles, which is in contradiction <lb/>with the definition of the model as given in Figure 9. Now, for establishing the other part of <lb/>AlwaysHolds( ℓ <lb/>even_odd , , m), we follow an approach similar to the two preceding examples. We use <lb/>resource predicates • e ( ), • e ( ), • o ( ), and • o ( ), and we will use the full parts in the invariant <lb/>below while the fragment parts are passed to the two threads. The invariant below immediately <lb/>allows us to establish that ℓ <lb/>match is preserved throughout program&apos;s execution. <lb/>EO_inv( e , o , ℓ) ≜ <lb/>∃ . • M ( ) * ℓ ↦ → * iseven( ) * • e ( ) * • o ( + 1) ∨ isodd ( ) * • e ( + 1) * • o ( ) <lb/>This invariant combines the ideas of the invariants of the preceding two examples. In particular, it <lb/>lets us modularly prove that the number stored in ℓ corresponds to the model state. Note how in <lb/>each case, whether is even or odd, the number tracked by the odd and even threads, respectively, <lb/>are out of sync by being one ahead of . This very closely reflects the behavior of the program; the <lb/>thread that is out of sync is waiting for the in-sync thread to perform its increment. <lb/>Finally, we need to prove the weakest precondition of the program. <lb/>( EO_inv( e , o , ℓ) <lb/>N eo * ⇒ {even := F cap ; odd := F cap } * • e (0) * • o (1) - * wp ⊤ eo_start ℓ <lb/>⇒ ∅ <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:20 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>f <lb/>tau <lb/>----→ f ′ <lb/>f <lb/>vis ( ) <lb/>------→ f ′ <lb/>st <lb/>f.m = f ′ .m <lb/>f.m --→ f ′ .m <lb/>th <lb/>∈ rng(th) <lb/>th( ) = <lb/>dom roles(f ′ ) ⊆ roles(f) <lb/>roles(f ′ ) \ roles(f) ⊆ lroles(f ′ ) \ lroles(f) <lb/>dec ∀ ∈ dom(f.map( )), fm ′ ( ) &lt; fm( ) <lb/>∀ ∈ dom(f.map( )) \ { }, fm ′ ( ) &lt; fm( ) <lb/>ch <lb/>∀ , th ′ ( ) ≠ th( ) ⇒ fm ′ ( ) &lt; fm( ) ∀ ≠ , th ′ ( ) ≠ th( ) ⇒ fm ′ ( ) &lt; fm( ) <lb/>ni <lb/>∀ ∉ dom(f.map( )), fm ′ ( ) ≤ fm( ) <lb/>∀ ∉ dom(f.map( )), fm ′ ( ) ≤ fm( ) <lb/>ref <lb/>∀ ∈ roles(f ′ ) \ roles(f) ∪ { }, fm ′ ( ) ≤ F cap <lb/>Fig. 10. Transitions between two states f and f ′ in Fuel(M) where th ≜ th f , th ′ ≜ th f ′ , etc. All conditions in <lb/>the column must be satisfied for the transition in the top row to be valid. <lb/>We prove the two threads satisfy the following specifications for any : <lb/>( EO_inv( e , o , ℓ) <lb/>N eo * ⇒ {even := 42} * • e ( ) - * wp ⊤ incr_loop ℓ <lb/>⇒ ∅ <lb/>( EO_inv( e , o , ℓ) <lb/>N eo * ⇒ {odd := 42} * • o ( ) - * wp ⊤ incr_loop ℓ <lb/>⇒ ∅ <lb/>The proof follows similarly to the one of §4.2.1. We similarly open the invariant around the cas <lb/>operation and in either case, whether it succeeds or fails, we take the appropriate model step. <lb/>4.3 Obtaining the Fairis Adequacy Theorem <lb/>This section describes in more detail how the Fairis logic and its adequacy theorem are obtained. In <lb/>particular, we describe the critical Fuel-construction which, given a model M, yields a Trillium <lb/>model Fuel(M) that handles fairness preservation and finite stuttering. The Fairis logic is then <lb/>obtained by instantiating Trillium with this model and a well-chosen trace interpretation predicate <lb/>and relation fuel . <lb/>The Fuel-construction. Recall that a state f of Fuel(M) has two components: a state f.m of the <lb/>fairness model M, and a partial function f.map : ThreadId ⇀ (Role(M) ⇀ N) associating roles to <lb/>thread ids and fuels (natural numbers) to roles. In actuality, not all such pairs are states of Fuel(M), <lb/>as states must satisfy certain conditions. Each role must be associated to at most one thread id: <lb/>∀ 1 ≠ 2 . dom(f.map( 1 )) ∩ dom(f.map( 2 )) = ∅ <lb/>and each live role must be associated to a thread id: <lb/>∀ ∈ lroles(f.m). ∃ ∈ ThreadId. ∈ dom(f.map( )) <lb/>where the live roles lroles(m) of a state m ∈ M are defined as the set { | ∃m ′ , m -<lb/>→ m ′ } of <lb/>roles that can take a step from m. Intuitively, to prove fairness of a model trace which refines a <lb/>fair program execution, we need to show that any live role eventually takes a step, so we need <lb/>to relate all live roles to locales. We write roles(f) for the set of roles allocated in f.map, formally, <lb/>⊎ ∈dom(f.map) dom(f.map( )). <lb/>Roles that are in roles(f) \ lroles(f.m) have a specific purpose: threads must be associated to a role <lb/>to be allowed to take steps. It is often the case that a thread has logically terminated (in that it took <lb/>all the steps corresponding to steps in the model) but has not actually terminated. This flexibility <lb/>allows the thread to terminate in a bounded number of steps without cluttering the model. <lb/>We now turn to the more delicate aspect of the Fuel-construction: the transitions. There are two <lb/>types of transitions: silent stuttering steps are labeled with tau , where is meant to be the locale <lb/>of the thread that takes the stuttering step, and visible steps, corresponding to the underlying model <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:21 <lb/></page>

        <body>steps which are labeled with vis ( ) annotated with the local taking the step, and the underlying <lb/>role in M. The locales in labels are necessary to relate Fuel(M) steps with the map f.th. <lb/>Figure 10 presents the list of conditions that define each type of transition. The conditions are <lb/>stated using two auxiliary maps fm f : Roles ⇀ N associating role with its fuel, and th f : Roles ⇀ <lb/>ThreadId associating each role to some thread id. These two maps are derived from f.map as follows: <lb/>fm f ( ) = f ⇐⇒ ∃ , fs. f.map( ) = fs ∧ fs( ) = f <lb/>th f ( ) = ⇐⇒ ∈ dom(f.map( )) <lb/>Condition st restricts the evolution of the underlying fairness model, th relates the thread with <lb/>the state; dom restricts the evolution of the domain: the only new roles are the roles which became <lb/>live in the new underlying state (if any); dec states that all threads associated to the thread that took <lb/>the step must decrease their fuel, except possibly for the role that took a step, ni states that roles <lb/>that changed theads must decrease their fuel; ni states that all other roles cannot increase their fuel, <lb/>and finally ref restricts the new fuel of the new roles and of the role that took the step to the global <lb/>bound F cap . This last condition is necessary to restrict the branching of the model Fuel(M), to be <lb/>able to use the adequacy theorem of Trillium. It may not be obvious why condition ch is necessary: <lb/>otherwise two threads could, at each step, take visible steps with roles 1 and 2 and, during that <lb/>step, and change ownership of 3 , whose fuel could remain constant according to condition nd. <lb/>Logical Resources and the Trace Interpretation. The logical predicate ⇒ fs reflects a coherent <lb/>view of the data in the Fuel(M) model, as explained below. <lb/>To define the ⇒ predicate we use Iris&apos;s support for custom ghost state. These predicates satisfy, <lb/>among other things, the following rules: <lb/>FuelMap-agree <lb/>FuelMap(FM) <lb/>⇒ <lb/>FM ( ) = <lb/>FuelMap-update <lb/>FuelMap(FM) <lb/>⇒ <lb/>| ⇛FuelMap(FM [ := ′ ]) * ⇒ ′ <lb/>The link between the state of the Fuel-model and these resources, as well as between locales <lb/>recorded in the Fuel-model and the program&apos;s locales, is specified in the trace interpretation ( , ). <lb/>First, and must have the same size, and their corresponding labels must match: the th label <lb/>of is equal to locale( ). Here is the th label of , and locale extracts the locale from a label <lb/>of Fuel(M), i.e., locale(tau ) = locale(vis ( )) = . Second, the respective last states (tp, ) and <lb/>(m, fm) of and satisfy the following Iris predicate: <lb/>∃FM. FuelMap(FM) * • M m * coherent (FM, m, fm) * dom(FM) ⊆ dom(tp) * ownHeap( ) <lb/>where ownHeap( ) is the usual state interpretation of the Iris program logic reflecting the program&apos;s <lb/>heap into Iris resources. Furthermore, coherent (FM, m, fm) is a predicate capturing that the ghost <lb/>fuel map is coherent with respect to the model state. In particular, coherence captures that the <lb/>ghost fuel map and model fuel map have the same locales, and that any role present in the former <lb/>is also present in the latter with a larger or equal fuel. Additionally, coherence captures that any <lb/>live role of the model exists in the ghost fuel map. <lb/>Adequacy. To use Trillium&apos;s adequacy theorem, the last missing piece is to choose the rela-<lb/>tion fuel = Fuel( ). It turns out that, for our purpose, this relation can be rather weak. Given a finite <lb/>program execution = (tp 1 , 1 ) <lb/>1 <lb/>-→ (tp 2 , 2 ) <lb/>2 <lb/>-→ • • • <lb/>-1 <lb/>---→ (tp , ), and a finite Fuel(M)-trace <lb/>= (m 1 , map 1 ) <lb/>1 <lb/>-→ (m 2 , map 2 ) <lb/>2 <lb/>-→ • • • <lb/>-1 <lb/>---→ (m , map ), we define fuel ( , ) as follows: <lb/>fuel ( , ) ≜ ( , ) ∧ <lb/>∀ , <lb/>= locale( ) ∧ <lb/>(1) <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:22 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>∀ , rng(th f ) ⊆ dom(tp ) ∧ ∀ , , th f ( ) = tp [ ] is a value ⇒ ∉ lroles(m ) (2) <lb/>We can now use Trillium&apos;s adequacy theorem (Theorem 3.2) to prove Fairis&apos;s adequacy theorem <lb/>(Theorem 4.1) given the following lemma. <lb/>Lemma 4.2. The following holds for the parameters we have chosen: <lb/>AlwaysHolds(Fuel( ), , ˜ ) =⇒ AlwaysHolds( , , ) <lb/>Proof sketch. Let us consider a program execution and a model trace . It suffices to consider <lb/>their last states, which we write respectively as (tp, ) and f. That rng(th f ) ⊆ dom(tp) follows from <lb/>coherent (FM, f.m, fm f ) and from the fact that dom(th f ) = dom(fm f ). We prove the contrapositive <lb/>of the second conjunct of (2) above. Assume a locale and a role such that th f ( ) = and <lb/>such that tp[ ] is a value. Since we know all the postconditions of terminated threads hold, we <lb/>know ⇒ ∅, which means, according to coherent (FM, f.m, fm f ), that cannot be live in f.m. The <lb/>condition (1) on labels follows directly from the trace interpretation. <lb/>□ <lb/>Fairness Preservation. The adequacy theorem of Fairis gives us that the intial states of the program <lb/>and of the Fuel(M) model are related: ( , ) ≾ fuel m. This refinement is useful because it has good <lb/>properties: preservation of fairness and preservation of termination. To make things precise, we <lb/>define some operations on traces: Any finite or infinite trace of Fuel(M) induces a trace in M <lb/>which we obtain by removing tau transitions and projecting out the m component. Since there can <lb/>only be finitely many tau transitions in a row (any such transition decreases the sum of all fuels), <lb/>is finite if and only if is finite. And since ˆ fuel relates traces of the same length, if is finite and <lb/>if ˆ fuel ( , ) holds, then is finite. <lb/>Let us now explain why fairness is preserved in the other direction: if ˆ fuel ( , ) and is fair, then <lb/>is fair. We endow traces of Fuel(M) with the natural notion of fairness where we only look at the <lb/>roles of the transitions, not the locales. It is obvious that if is fair then is fair, as tau-transitions <lb/>do not play any role in fairness. Therefore, preservation of fairness boils down to: <lb/>Lemma 4.3. If is fair and if ˆ fuel ( , ), then is fair. <lb/>Proof sketch. The proof is quite technical and consists of two nested inductions, but the idea <lb/>is the following: consider some state f of and which is live in that state, and call = th f ( ) <lb/>its associated locale. We need to prove there eventually exists a transition in . Since we have <lb/>a fixed fair program trace , there exists such that the next step of is in at most steps. We <lb/>proceed by induction over (fm f ( ), ), ordered lexicographically. <lb/>Without loss of generality, we can assume it is the first state of . Write for th f ( ). Consider <lb/>the first step of the program with locale ′ . There are two cases: (1) ≠ ′ . Then we apply the <lb/>induction hypothesis with the next state, the same fuel, and -1. (2) = ′ . If it is a -transition <lb/>we conclude. Otherwise, the fuel associated to decreases, and we apply the induction hypothesis <lb/>with the next state, a smaller fuel and some arbitrary ′ obtained as above. <lb/>□ <lb/>5 THE ANERIS LOGIC <lb/>To reason about distributed systems, we instantiate Trillium with AnerisLang, the programming <lb/>language accompanying Aneris, a higher-order distributed separation logic [Krogh-Jespersen <lb/>et al. 2020]. AnerisLang is an OCaml-like programming language with network primitives for <lb/>creating (socket) and binding (socketbind) network sockets as well as sending (sendto) and <lb/>receiving (receivefrom) messages. The operational semantics of AnerisLang is designed so that <lb/>the primitives closely model Unix sockets and UDP (unreliable) networking. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:23 <lb/></page>

        <body>The Aneris instantiation of Trillium is conceptually simple as we will target safety trace properties. <lb/>This means that we can &quot;bake-in&quot; the reflexive closure of the model and hence freely allow model <lb/>stuttering. The result is a program logic and reasoning principles that are virtually identical to the <lb/>original (non-relational) Aneris program logic, where the only difference is the addition of a single <lb/>rule (aneris-take-step) that allows us to relate an atomic step of the program to a corresponding <lb/>step in the LTS model. <lb/>aneris-take-step <lb/>wp E <lb/>. • M ( ′ ) - * ( ) <lb/>• M ( ) <lb/>⇀ M <lb/>′ <lb/>Atomic( ) <lb/>∉ Val <lb/>wp E <lb/>While fairly simple, this instantiation will still allow us to prove interesting properties. In what <lb/>follows, we will show how we use Aneris to transport safety (trace) properties of TLA + protocol <lb/>models to distributed programs that implement them. In the Appendix we also show how we, under <lb/>liveness assumptions, can prove eventual consistency [Vogels 2009] of a Conflict-Free <lb/>Replicated Data Type [Shapiro et al. 2011]. We leave a more principled approach to proving liveness <lb/>properties of distributed systems as future work. <lb/>We use the Aneris instantiation of Trillium to show an intensional refinement between imple-<lb/>mentations of two classical distributed algorithms, Two-Phase Commit (TPC) [Gray 1978] and <lb/>Single-Decree Paxos (SDP) [Lamport 1998, 2001], and their TLA + [Lamport 1992] models. As simple <lb/>corollaries of the refinement, we show using a single modular specification (1) that clients are safe, <lb/>i.e., they do not crash, (2) a formal proof that the implementation correctly implements a protocol, <lb/>and (3) correctness of the implementation by leveraging existing correctness properties of the <lb/>models. The TLA + specification of TPC and the TLA + specification of SDP can both be found in the <lb/>official TLA + -examples repository on GitHub. In our formalization, we have manually translated <lb/>the TLA + protocol specifications into STSs in Coq and proved their correctness properties. 8 <lb/>Note that correctness of the implementations can be established using regular Iris ghost resources <lb/>and invariants, but doing so through a refinement has the immediate benefit that the necessary <lb/>ghost theory is much simpler. The protocol logic is already encoded in the model and we &quot;just&quot; <lb/>need to map the state of the model to the physical state of the distributed system. The only place <lb/>we will need more sophisticated ghost theory is where the model is underspecified, e.g., in how <lb/>SDP distributes ballots among proposers. Additionally, by showing an intensional refinement, we <lb/>show that the implementation of, say, SDP actually implements the SDP protocol and not just any <lb/>other consensus protocol. While we do not show this explicitly, it also means that it is possible to <lb/>transfer other trace properties of the model to the implementation. <lb/>Both the implementation, the model, and the refinement proof for the TPC protocol can be found <lb/>in the Appendix. The development follows the same methodology as for SDP, which we describe <lb/>below; we omit network-and state-related Aneris resources and focus on the core parts relevant <lb/>for showing the refinement. <lb/>Single-Decree Paxos. The Paxos algorithm is a consensus protocol and its single-decree version <lb/>allows a set of distributed nodes to reach agreement on a single value by communicating through <lb/>message-passing over an unreliable network. <lb/>In SDP, each node in the system adopts one or more of the responsibilities of either proposer, <lb/>acceptor, or learner. A value is chosen when a learner learns that a quorum (e.g., a majority) of <lb/>acceptors have accepted a value proposed by some proposer. The algorithm works in two phases: <lb/>in the first phase, a proposer tries to convince a quorum of acceptors to promise that they will <lb/>later accept its value. If it succeeds, it continues to the second phase where it asks the acceptors to <lb/></body>

        <note place="footnote">8 A user who does not aim to be as foundational could, however, trust the translation and the existing TLA + proofs. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:24 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>fulfill their promise and accept its value. To satisfy the requirements of consensus, each attempt to <lb/>decide a value is distinguished with a unique totally-ordered round number or ballot. Each acceptor <lb/>stores its current ballot and the last value it might have accepted, if any. Acceptors will only give a <lb/>promise to proposers with a ballot greater than their current one, and in that case they switch to the <lb/>proposer&apos;s ballot; proposers only propose values that ensure consistency, if chosen. By observing <lb/>that a quorum of acceptors have accepted a value for the same ballot, learners will learn that a value <lb/>has been chosen. We refer to Lamport [2001] for an elaborate textual description of the protocol. <lb/>Model. The TLA + model of SDP is summarized in Figure 11. The model is parameterized over <lb/>a set of acceptors, Acceptor, and a type of values, Value, among which values are chosen. The <lb/>state of the model consists of a set of sent messages S ∈ P (PaxosMessage) and two maps <lb/>B : Acceptor → Option(Ballot) and V : Acceptor → Option(Ballot × Value) that for each <lb/>acceptor record the greatest ballot promise and the last accepted value together with its ballot, <lb/>respectively. The message type is defined using a datatype-like notation as <lb/>PaxosMessage ≜ msg1a( ) | msg1b( , , ) | msg2a( , ) | msg2b( , , ) <lb/>where ∈ Acceptor, ∈ Ballot, ∈ Value, and ∈ Option(Ballot × Value). <lb/>1 (S, , ) ≜ { ∈ S | ∃ , . = msg1b( , , Some( )) ∧ ∈ } <lb/>HavePromised (S, , ) ≜ ∀ ∈ . ∃ ∈ S, . = msg1b( , , ) <lb/>IsMaxVote(S, , , ) ≜ ∃ 0 ∈ 1 (S, , ), 0 , 0 . = msg1b( 0 , , Some( 0 , ))∧ <lb/>∀ ′ ∈ 1 (S, , ). <lb/>∃ ′ , ′ , ′ . ′ = msg1b( ′ , , Some( ′ , ′ )) ∧ 0 ≥ ′ <lb/>ShowsSafeAt (S, , , ) ≜ HavePromised (S, , ) ∧ ( 1 (S, , ) = ∅ ∨ IsMaxVote(S, , , )) <lb/>SDP-Phase1a <lb/>S, B, V ⇀ SDP S ∪ {msg1a( )} , B, V <lb/>SDP-Phase1b <lb/>msg1a( ) ∈ S <lb/>&gt; B ( ) <lb/>V ( ) = <lb/>S, B, V ⇀ SDP S ∪ {msg1b( , , )} , B [ ↦ → Some( )], V <lb/>SDP-Phase2a <lb/>′ . msg2a( , ′ ) ∈ S <lb/>orum( ) <lb/>ShowsSafeAt (S, , , ) <lb/>S, B, V ⇀ SDP S ∪ {msg2a( , )} , B, V <lb/>SDP-Phase2b <lb/>msg2a( , ) ∈ S <lb/>≥ B ( ) <lb/>S, B, V ⇀ SDP S ∪ {msg2b( , , )} , B [ ↦ → Some( )], V [ ↦ → Some( , )] <lb/>Fig. 11. TLA + specification of single-decree Paxos (SDP). <lb/>The SDP-Phase1a transition adds a msg1a( ) message to the set of sent messages; this corresponds <lb/>to the proposer asking the acceptors to not accept values for ballots smaller than . If a msg1a( ) <lb/>message has been sent and is greater than acceptor &apos;s current ballot B ( ) then the SDP-Phase1b <lb/>transition updates &apos;s state and sends a msg1b( , , ) message where is &apos;s last accepted value, if <lb/>any. This corresponds to an acceptor responding to a proposer&apos;s promise request. <lb/>The second phase is initiated using the SDP-Phase2a transition that corresponds to the proposer <lb/>proposing a value for ballot by sending a msg2a( , ) message. However, the transition can only <lb/>be made if no value has previously been proposed for ballot and if a quorum of acceptors exists <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:25 <lb/></page>

        <body>Listing 1. Acceptor implementation. <lb/>let acceptor learners addr = <lb/>let skt = socket () in <lb/>socketbind skt addr; <lb/>let maxBal = ref None in <lb/>let maxVal = ref None in <lb/>let rec loop () = <lb/>let (m, sndr) = receivefrom skt in <lb/>match acceptor _ deser m with <lb/>| inl bal =&gt; <lb/>if !maxBal = None || <lb/>Option.get !maxBal &lt; bal then <lb/>maxBal := Some bal; <lb/>sendto skt <lb/>(proposer _ ser (bal, !maxVal)) sndr <lb/>else () <lb/>| inr (bal, v) =&gt; <lb/>if !maxBal = None || <lb/>Option.get !maxBal &lt;= bal then <lb/>maxBal := Some bal; <lb/>maxVal := Some accept; <lb/>sendto _ all skt learners <lb/>(learner _ ser (bal, v)) <lb/>else () <lb/>end; loop () in loop () <lb/>Listing 2. Proposer implementation. <lb/>let proposer acceptors skt bal v = <lb/>sendto _ all skt acceptors <lb/>(acceptor _ ser (inl bal)); <lb/>let majority = <lb/>(Set.cardinal acceptors) / 2 + 1 in <lb/>let promises = <lb/>recv _ promises skt majority bal in <lb/>let max _ promise = <lb/>find _ max _ promise promises in <lb/>let av = Option.value max _ promise v in <lb/>sendto _ all skt acceptors <lb/>(acceptor _ ser (inr (bal, av))) <lb/>Listing 3. Client implementation. <lb/>let client addr = <lb/>let skt = socket () in <lb/>socketbind skt addr; <lb/>let (m1, sndr1) = receivefrom skt in <lb/>let ( _ , v1) = client _ deser m1 in <lb/>let (m2, _ ) = wait _ receivefrom skt <lb/>(fun ( _ , sndr2), sndr2 &lt;&gt; sndr1) in <lb/>let ( _ , v2) = client _ deser m2 in <lb/>assert (v1 = v2); v1. <lb/>such that the ShowsSafeAt (S, , , ) predicate holds; this predicate is at the heart of the Paxos <lb/>algorithm. Intuitively, the predicate holds if all acceptors in have promised not to accept values <lb/>for any ballot less than (HavePromised (S, , )) and either none of the acceptors have accepted <lb/>any value for all ballots less than or is the value of the largest ballot that acceptors from have <lb/>accepted. Following the SDP-Phase2b transition, acceptor may accept a proposal for value and <lb/>ballot by sending a msg2b( , , ) message and updating its state to reflect this fact. A value has <lb/>been chosen when a quorum of acceptors have sent a msg2b( , , ) message for some ballot : <lb/>Chosen(S, ) ≜ ∃ , . orum( ) ∧ ∀ ∈ . msg2b( , , ) ∈ S <lb/>As follows from the theorem below, it is not possible for the protocol to choose two different values <lb/>at the same time and hence SDP solves the consensus problem. <lb/>Theorem 5.1 (Consistency, SDP model). Let SDP = (∅, _. None, _. None). If SDP ⇀ * <lb/>SDP <lb/>(S, B, V) and both Chosen(S, 1 ) and Chosen(S, 2 ) hold then 1 = 2 . <lb/>Implementation. Listing 1 and Listing 2 show implementations of the acceptor and proposer <lb/>roles, respectively. The learner implementation and utility functions such as recv _ promises and <lb/>find _ max _ promise are found in the Appendix. <lb/>The acceptor implementation receives as input a set of learner socket addresses and an address to <lb/>communicate on. It creates a fresh socket, binds it to the address, and allocates two local references <lb/>to keep track of its current ballot and last accepted value. In a loop, it listens for the two different <lb/>kinds of messages that it may receive from the proposers. Given a phase one message, it only <lb/>considers the message if the ballot is greater than its current ballot in which case it responds with <lb/>its last accepted value. Given a phase two message, it only considers the message if the ballot is <lb/>greater than or equal to its current ballot in which case it accepts the value and broadcasts the fact <lb/>to all the learners. The learner implementation (included in the Appendix) simply waits for such a <lb/>message for the same ballot from a majority of acceptors. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:26 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>The proposer implementation receives as input a set of acceptor socket addresses, a bound socket, <lb/>a ballot number and a value to (possibly) propose in the ballot. First phase is initiated by sending <lb/>a message to all the acceptors and after receiving a response from a majority of the acceptors it <lb/>continues to the second phase. In the second phase it picks the value of the maximum ballot among <lb/>the responses; if no such value exist, it picks its own. The candidate is finally sent to all acceptors. <lb/>Note that this proposer implementation only proposes a value for a single ballot; typically, <lb/>proposers will issue new ballots when learning that no decision has been reached due to messages <lb/>being dropped or nodes crashing. Moreover, it is crucial that proposers do not issue proposals for <lb/>the same ballot. In our Coq formalization, proposer repeatedly issues new ballots of the form <lb/>• |Proposer| + for N by keeping track of the last issued in a local reference. <lb/>Consensus by Refinement. To show that the SDP implementation refines the SDP model we <lb/>instantiate the Aneris logic with the model; the key part of the proof is to keep the • M ( ) resource <lb/>in a global invariant that ties together the model state and the physical state with enough information <lb/>to verify the implementation and for the refinement relation established through the adequacy <lb/>theorem to be strong enough for proving our final correctness theorem (Corollary 5.2). Under this <lb/>invariant we will modularly verify each Paxos role and each component in isolation. <lb/>To state the invariant, we use three kinds of resources corresponding to: <lb/>(1) sets of messages with predicates Msgs • (S) and Msgs • ( ) such that <lb/>Msgs • (S) * Msgs • ( ) ⊢ ∈ S <lb/>Msgs • (S) ⊢ | ⇛ Msgs • (S ∪ ) * Msgs • ( ) <lb/>(2) maps, e.g., with predicates MaxBal • (B) and MaxBal • ( , ) such that <lb/>MaxBal • (B) * MaxBal • ( , ) ⊢ B ( ) = <lb/>MaxBal • (B) * MaxBal • ( , ) ⊢ | ⇛ (MaxBal • (B [ ↦ → ′ ]) * MaxBal • ( , ′ )) <lb/>(3) ballots with predicates pending( ) and shot( , ) such that <lb/>pending( ) * shot( , ) ⊢ False <lb/>pending( ) * pending( ) ⊢ False <lb/>pending( ) ⊢ | ⇛shot( , ) <lb/>shot( , 1 ) * shot( , 2 ) ⊢ 1 = 2 <lb/>Equipped with these resource we can state the invariant: <lb/>SDP ≜ ∃S, B, V. • M (S, B, V) * Msgs • (S) * MaxBal • (B) * <lb/>MaxVal • (V) * BalCoh(S) * MsgCoh(S) <lb/>The first part of the invariant ties the current state of the model (S, B, V) to its logical au-<lb/>thoritative counterparts which means that by owning a fragmental part you own a piece of the <lb/>model: e.g., by owning MaxBal • ( , ) you may open the invariant and conclude B ( ) = where <lb/>B is the current map of ballots. Intuitively, we will give acceptor exclusive ownership of the <lb/>parts of the model that should correspond to its local state (through resources MaxBal • ( , ) and <lb/>MaxVal • ( , )). Similarly, by owning Msgs • ( ) one may conclude that the message has in fact <lb/>been added to the set of messages in the model; this predicate we will transfer when sending <lb/>physical messages corresponding to . <lb/>In the last part of the invariant, the BalCoh(S) predicate simply requires that if msg2a( , ) ∈ S <lb/>then shot( , ) holds. This implies that by owning pending( ) you are the only entity that may <lb/>propose a value for ballot and it may never change. The MsgCoh(S) predicate ties the physical <lb/>state of the program to the model using Aneris-specific predicates for tracking the state of the <lb/>network. This, for instance, forces acceptors and proposers to also add to the model state S any <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:27 <lb/></page>

        <body>message they send over the network. Hence, to verify a proposer or an acceptor that sends a <lb/>message, the proof must open the invariant, use aneris-take-step to take a step in the model, and <lb/>update the corresponding logical resources to close the invariant. Following this methodology, we <lb/>give specifications of the following shape to the proposer and acceptor components: <lb/>SDP * MaxBal • ( , None) * MaxVal • ( , None) * . . . - * wp ⊤ acceptor <lb/>False <lb/>SDP * pending( ) * . . . - * wp ⊤ proposer <lb/>True <lb/>omitting Aneris-specific network connectives in the precondition; the postcondition for acceptor <lb/>may be False as it does not terminate. We give a similar specification to the learner. Working in <lb/>a modular program logic, we can compose these specifications to get a single specification for a <lb/>distributed system with both proposers, acceptors, and learners. By applying the adequacy theorem <lb/>to this specification we get that the implementation indeed refines the TLA + model of SDP. 9 <lb/>Consensus for the Implementation. Given the specification has been established for the implemen-<lb/>tation, we can state and prove that the consistency property holds for all executions by transporting <lb/>the consistency property of the model. Let <lb/>ChosenI ( , ) ≜ ∃ , . orum( ) ∧ ∀ ∈ . ∃ ∈ . ∼ msg2b( , , ) <lb/>where M is a set of physical messages and ∼ holds when is the serialization of the model <lb/>message . By picking a trace relation SDP that requires messages in the model to correspond to <lb/>messages in the program state (as implied by MsgCoh(S)): <lb/>SDP ( , ) ≜ ∃S. last ( ) = (S, _, _) ∧ messages(last ( )) ∼ S ∧ stu ering( ) <lb/>we combine the adequacy theorem (Theorem 3.2) with our model correctness theorem (Theorem 5.1) <lb/>to obtain the following corollary that only talks about the execution of the SDP implementation. <lb/>Corollary 5.2. Let be a distributed system obtained by composing proposers, <lb/>accep-<lb/>tors, and learners. For any and , if ( ; ∅) → * ( ; ) and both ChosenI (messages( ), 1 ) and <lb/>ChosenI (messages( ), 2 ) hold then 1 = 2 . <lb/>Functional Correctness. Corollary 5.2 is a meta-logic theorem (e.g., in Coq) that only talks about <lb/>the program execution and it follows from the adequacy theorem and the model correctness <lb/>theorem. However, it is not only in the meta-logic that we can exploit properties of the model to <lb/>prove properties about programs as the model is also embedded as a resource in the logic. <lb/>Listing 3 shows a client application that receives a message from two different Paxos learners <lb/>and asserts that the two values are equal; if the two values do not agree, the program crashes. <lb/>We can prove a specification for the client of the shape SDP * . . . - * wp client <lb/>. . . . From <lb/>the adequacy theorem it follows that the program is safe, i.e., it does not crash, which means the <lb/>asserted statement must always hold. In the proof of this specification, the client will receive ghost <lb/>resources from the learners conveying that 1 and 2 have been chosen (i.e., that a quorum of <lb/>acceptors have accepted ). By opening the invariant SDP and hence obtaining the model resource <lb/>• M (S, B, V), we can combine this knowledge with Theorem 5.1-a property exclusively of the <lb/>model-and conclude that 1 = 2 . Naturally, we may still compose a distributed system containing <lb/>the client together with proposers, acceptors, and learner nodes and derive a specification for the <lb/>full system. This single specification for the full distributed system entails both the refinement of <lb/>the TLA + model and the safety of the programs running on all nodes. <lb/></body>

        <note place="footnote">9 The full Coq proof amounts to about 1100 lines of proof scripts. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:28 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <body>6 RELATED WORK <lb/>Refinement-based Verification of Distributed Systems. We focus on works that, as ours, aim at <lb/>proving that concrete implementations refine models. The most closely related works are IronFleet <lb/>[Hawblitzel et al. 2017] and Igloo [Sprenger et al. 2020]. In contrast to both, our approach is <lb/>foundational: the operational semantics of the languages, the models, and the program logics are <lb/>all formally defined in Coq, and through adequacy theorems of the program logic, the end result <lb/>of a verification is a formal theorem expressed only in terms of the operational semantics of the <lb/>programming language and the model. <lb/>IronFleet uses the Dafny verifier to verify implementations and encodes the refinement of an <lb/>STS in preconditions and postconditions of programs but does not support node-local concurrency. <lb/>IronFleet uses a pen-and-paper argument for proving liveness of simple programs (programs that <lb/>consist of a simple event loop which calls terminating event handlers). <lb/>Igloo proves a particular kind of extensional safety properties. Igloo refines a high-level STS to <lb/>a more low-level STS for each node of the system. STSs are annotated with IO operations which <lb/>are used to generate IO specifications for network communications of the node in the style of <lb/>Penninckx et al. [2015]. Programs are subsequently verified against this generated specification. The <lb/>relationship between the implementation and the model considered in Igloo is a fixed relation, i.e. <lb/>producing the same IO behavior. In contrast, our work allows an arbitrary intensional refinement <lb/>relation to be specified and established between the program and the model. <lb/>Refinement in Iris. There has been earlier work on proving contextual refinements using Iris as <lb/>discussed in the introduction. Additionally, Perennial [Chajed et al. 2019] defines correctness of a <lb/>system using concurrent recovery refinement, requiring that the (possibly crashing) implementation <lb/>and specification STS has the same external I/O. This notion of refinement is much coarser and <lb/>does not allow you to prove, e.g., fair termination. Tassarotti and Harper [2019] relates concur-<lb/>rent probabilistic programs to abstract specifications denoting indexed valuations, exhibiting a <lb/>probabilistic coupling when assuming that the implementation terminates. <lb/>Our approach to termination-preserving refinement is similar in spirit to the one of Tassarotti <lb/>et al. [2017] but applies to reasoning about refinement of general concurrent programs with respect <lb/>to abstract models, not just compilation of session-typed programs. To the best of our knowledge, <lb/>the expressiveness of the logics is roughly similar. The main difference is that Tassarotti et al. [2017] <lb/>augments the Iris base logic with linear propositions, which requires modifying the definition of <lb/>resource algebra to add a transition relation. We achieve similar results without heavy modifications, <lb/>using that the authoritative state of the model is threaded through the weakest precondition, and <lb/>by putting an exclusive structure on the set of roles owned by a thread, which prevents arbitrary <lb/>weakening of the role resource, a limited form of linearity. <lb/>Besides efforts in Iris, Liang and Feng [2016, 2018] have also used refinement to show a wider <lb/>range of liveness properties of concurrent programs, including programs with partial methods, <lb/>but focusing on first-order logic and first-order programs. It would be interesting to investigate if <lb/>Trillium could serve as a basis for generalizing the verification methods of Liang and Feng [2016, <lb/>2018] to higher-order logic and higher-order programs. <lb/>Simuliris [Gäher et al. 2022] is a separation logic for fair termination-preserving contextual <lb/>refinements for concurrent program transformations that can exploit undefined behavior. In contrast <lb/>to both Iris and Trillium, Simuliris is not step-indexed, and thus does not support impredicative <lb/>invariants or higher-order ghost state, which we crucially target and rely on. 10 <lb/></body>

        <note place="footnote">10 For example, higher-order ghost state is used to define Aneris&apos;s socket protocols. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:29 <lb/></page>

        <body>Certified Abstraction Layers. A related approach to verification is certified abstraction layers [Gu <lb/>et al. 2015], in particular their concurrent variant [Gu et al. 2018], which are used to verify the <lb/>CertiKOS verified kernel [Gu et al. 2016]. Our approach is similar to that of CertiKOS in that <lb/>both approaches use models to help verify programs. The main difference is that, in the CertiKOS <lb/>approach, the person proving a refinement needs to work directly using the semantics of the <lb/>program and of the model, which are both sets of traces. Our approach, on the other hand, is to use <lb/>a program logic to do the heavy lifting of the refinement proof, which, we believe, lowers the proof <lb/>burden dramatically. Another difference is that their notion of concurrent certified abstraction <lb/>layers is more complex than our models, which are plain LTSs; but their models can be composed <lb/>together. <lb/>Paxos Verification Efforts. Paxos and its multiple variants have been considered by many ver-<lb/>ification efforts using, e.g., automated theorem provers and model checkers [Chand et al. 2016; <lb/>Jaskelioff and Merz 2005; Kellomäki 2004; Maric et al. 2017; Padon et al. 2017]. These efforts all <lb/>consider abstract models or specifications in high-level domain-specific languages of Paxos(-like) <lb/>protocols and not actual implementations in a realistic and expressive programming language. <lb/>Kragl et al. [2020] work in the Boogie verifier and programming language where they express <lb/>their high-level model, their low-level (non-distributed) imperative implementation, and the layers <lb/>in between, all in Boogie. By contrast, our effort is foundational (in the technical sense of being <lb/>formalized in Coq as mentioned above) and the implementation is carried out in the OCaml-like <lb/>programming language AnerisLang with UDP network primitives. <lb/>García-Pérez et al. [2018] devise composable specifications for a pseudo-code implementation of <lb/>Single-Decree Paxos and semantics-preserving optimizations to the protocol on pen-and-paper but <lb/>without a formal connection to their implementation in Scala; it would be interesting future work <lb/>to implement and verify the same optimizations in our setting. <lb/>7 CONCLUSION AND FUTURE WORK <lb/>In this paper, we explored how intensional refinement is indeed a viable methodology for strength-<lb/>ening higher-order concurrent and distributed separation logics to non-trivial safety and liveness <lb/>properties using Trillium and its instantiations. We have developed Fairis, a higher-order concurrent <lb/>separation logic, and we have shown how the logic gives us a methodology for proving liveness of <lb/>concurrent programs under fair scheduling assumptions. Moreover, we instantiated Trillium with a <lb/>distributed language and obtained an extension of Aneris, a distributed separation logic, that we <lb/>have used to show refinement relations between distributed systems and their TLA + models. <lb/>Future work includes extending Trillium&apos;s support for modular reasoning to also allow specifica-<lb/>tions of library functions to be modular with respect to the model, such that a library function can <lb/>be specified with respect to one model and client code can be specified with respect to another <lb/>model in isolation. Currently, library functions can be reasoned about modularly in Trillium using <lb/>higher-order specifications. For example, our Paxos implementation makes a call to the sendto all <lb/>function, whose specification quantifies over arbitrary socket protocols (themselves higher-order <lb/>predicates), and in turn the sendto all function internally makes a call to a function set iter, whose <lb/>specification uses impredicative quantification to support arbitrary callback functions. An impor-<lb/>tant point here, however, is that these library specifications do not interact with the model, i.e., <lb/>execution corresponds to stuttering steps on the model side. A concrete goal would be to give a <lb/>modular specification of a fair lock and then verify termination of a client that uses the lock, but <lb/>only by relying on its specification. <lb/></body>

        <div type="availability">Data availability statement. The Coq formalization accompanying this work is available on <lb/>Zenodo [Timany et al. 2023] and on GitHub at https://github.com/logsem/trillium. <lb/></div>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:30 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <div type="acknowledgement">ACKNOWLEDGMENTS <lb/>We would like to thank the anonymous reviewers for their valuable remarks and insightful com-<lb/>ments which have improved the presentation of this work. <lb/>This work was supported in part by a Villum Investigator grant (no. 25804), Center for Basic <lb/>Research in Program Verification (CPV), from the VILLUM Foundation. This work has received <lb/>funding from the European Research Council (ERC) under the European Union&apos;s Horizon 2020 <lb/>research and innovation program (grant agreement No. 101003349). <lb/></div>

        <listBibl>REFERENCES <lb/>Lars Birkedal, Thomas Dinsdale-Young, Armaël Guéneau, Guilhem Jaber, Kasper Svendsen, and Nikos Tzevelekos. 2021. <lb/>Theorems for Free from Separation Logic Specifications. Proc. ACM Program. Lang. 5, ICFP, Article 81 (aug 2021), 29 pages. <lb/>https://doi.org/10.1145/3473586 <lb/>Tej Chajed, Joseph Tassarotti, M. Frans Kaashoek, and Nickolai Zeldovich. 2019. Verifying concurrent, crash-safe systems <lb/>with Perennial. In Proceedings of the 27th ACM Symposium on Operating Systems Principles, SOSP 2019, Huntsville, ON, <lb/>Canada, October 27-30, 2019. 243-258. https://doi.org/10.1145/3341301.3359632 <lb/>Saksham Chand, Yanhong A. Liu, and Scott D. Stoller. 2016. Formal Verification of Multi-Paxos for Distributed Consensus. <lb/>In FM 2016: Formal Methods -21st International Symposium, Limassol, Cyprus, November 9-11, 2016, Proceedings (Lecture <lb/>Notes in Computer Science, Vol. 9995), John S. Fitzgerald, Constance L. Heitmeyer, Stefania Gnesi, and Anna Philippou <lb/>(Eds.). 119-136. https://doi.org/10.1007/978-3-319-48989-6_8 <lb/>Rance Cleaveland and Oleg Sokolsky. 2001. CHAPTER 6 -Equivalence and Preorder Checking for Finite-State Systems. <lb/>In Handbook of Process Algebra, J.A. Bergstra, A. Ponse, and S.A. Smolka (Eds.). Elsevier Science, Amsterdam, 391-424. <lb/>https://doi.org/10.1016/B978-044482830-9/50024-2 <lb/>Dan Frumin, Robbert Krebbers, and Lars Birkedal. 2018. ReLoC: A Mechanised Relational Logic for Fine-Grained Concurrency. <lb/>In Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, <lb/>2018. 442-451. https://doi.org/10.1145/3209108.3209174 <lb/>Dan Frumin, Robbert Krebbers, and Lars Birkedal. 2020. ReLoC Reloaded: A Mechanized Relational Logic for Fine-Grained <lb/>Concurrency and Logical Atomicity. Log. Methods Comput. Sci. 17 (2020). <lb/>Lennard Gäher, Michael Sammler, Simon Spies, Ralf Jung, Hoang-Hai Dang, Robbert Krebbers, Jeehoon Kang, and Derek <lb/>Dreyer. 2022. Simuliris: a separation logic framework for verifying concurrent program optimizations. Proc. ACM <lb/>Program. Lang. 6, POPL (2022), 1-31. https://doi.org/10.1145/3498689 <lb/>Álvaro García-Pérez, Alexey Gotsman, Yuri Meshman, and Ilya Sergey. 2018. Paxos Consensus, Deconstructed and <lb/>Abstracted. In Programming Languages and Systems -27th European Symposium on Programming, ESOP 2018, Held <lb/>as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2018, Thessaloniki, Greece, April <lb/>14-20, 2018, Proceedings (Lecture Notes in Computer Science, Vol. 10801), Amal Ahmed (Ed.). Springer, 912-939. https: <lb/>//doi.org/10.1007/978-3-319-89884-1_32 <lb/>Aïna Linn Georges, Alix Trieu, and Lars Birkedal. 2022. Le Temps Des Cerises: Efficient Temporal Stack Safety on <lb/>Capability Machines Using Directed Capabilities. Proc. ACM Program. Lang. 6, OOPSLA1, Article 74 (apr 2022), 30 pages. <lb/>https://doi.org/10.1145/3527318 <lb/>Jim Gray. 1978. Notes on Data Base Operating Systems. In Operating Systems, An Advanced Course, Michael J. Flynn, Jim Gray, <lb/>Anita K. Jones, Klaus Lagally, Holger Opderbeck, Gerald J. Popek, Brian Randell, Jerome H. Saltzer, and Hans-Rüdiger <lb/>Wiehle (Eds.). Lecture Notes in Computer Science, Vol. 60. Springer, 393-481. https://doi.org/10.1007/3-540-08755-9_9 <lb/>Simon Oddershede Gregersen, Alejandro Aguirre, Philipp G. Haselwarter, Joseph Tassarotti, and Lars Birkedal. 2023. <lb/>Asynchronous Probabilistic Couplings in Higher-Order Separation Logic. CoRR abs/2301.10061 (2023). https://doi.org/ <lb/>10.48550/arXiv.2301.10061 arXiv:2301.10061 <lb/>Ronghui Gu, Jérémie Koenig, Tahina Ramananandro, Zhong Shao, Xiongnan (Newman) Wu, Shu-Chun Weng, Haozhong <lb/>Zhang, and Yu Guo. 2015. Deep Specifications and Certified Abstraction Layers. In POPL. ACM. <lb/>Ronghui Gu, Zhong Shao, Hao Chen, Xiongnan Wu, Jieung Kim, Vilhelm Sjöberg, and David Costanzo. 2016. CertiKOS: An <lb/>Extensible Architecture for Building Certified Concurrent OS Kernels. In Proceedings of the 12th USENIX Conference on <lb/>Operating Systems Design and Implementation (Savannah, GA, USA) (OSDI&apos;16). USENIX Association, USA, 653-669. <lb/>Ronghui Gu, Zhong Shao, Jieung Kim, Xiongnan (Newman) Wu, Jérémie Koenig, Vilhelm Sjöberg, Hao Chen, David <lb/>Costanzo, and Tahina Ramananandro. 2018. Certified concurrent abstraction layers. In PLDI. ACM, 646-661. <lb/>Chris Hawblitzel, Jon Howell, Manos Kapritsos, Jacob R. Lorch, Bryan Parno, Michael L. Roberts, Srinath Setty, and Brian <lb/>Zill. 2017. IronFleet: Proving Safety and Liveness of Practical Distributed Systems. Commun. ACM 60, 7 (June 2017), <lb/>83-92. https://doi.org/10.1145/3068608 <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <note place="headnote">Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement <lb/></note>

        <page>9:31 <lb/></page>

        <listBibl>Koen Jacobs, Dominique Devriese, and Amin Timany. 2022. Purity of an ST Monad: Full Abstraction by Semantically Typed <lb/>Back-Translation. Proc. ACM Program. Lang. 6, OOPSLA1, Article 82 (apr 2022), 27 pages. https://doi.org/10.1145/3527326 <lb/>Koen Jacobs, Amin Timany, and Dominique Devriese. 2021. Fully Abstract from Static to Gradual. Proc. ACM Program. <lb/>Lang. 5, POPL, Article 7 (jan 2021), 30 pages. https://doi.org/10.1145/3434288 <lb/>Mauro Jaskelioff and Stephan Merz. 2005. Proving the Correctness of Disk Paxos. Arch. Formal Proofs 2005 (2005). <lb/>https://www.isa-afp.org/entries/DiskPaxos.shtml <lb/>Ralf Jung, Robbert Krebbers, Jacques-Henri Jourdan, Ales Bizjak, Lars Birkedal, and Derek Dreyer. 2018. Iris from the <lb/>ground up: A modular foundation for higher-order concurrent separation logic. J. Funct. Program. 28 (2018), e20. <lb/>https://doi.org/10.1017/S0956796818000151 <lb/>Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal, and Derek Dreyer. 2015. Iris: <lb/>Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning. In Proceedings of the 42nd Annual ACM <lb/>SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015. <lb/>637-650. https://doi.org/10.1145/2676726.2676980 <lb/>Pertti Kellomäki. 2004. An Annotated Specification of the Consensus Protocol of Paxos Using Superposition in PVS. Technical <lb/>Report. Tampere University of Technology. Institute of Software Systems. <lb/>Bernhard Kragl, Constantin Enea, Thomas A. Henzinger, Suha Orhun Mutluergil, and Shaz Qadeer. 2020. Inductive <lb/>sequentialization of asynchronous programs. In Proceedings of the 41st ACM SIGPLAN International Conference on <lb/>Programming Language Design and Implementation, PLDI 2020, London, UK, June 15-20, 2020. 227-242. https://doi.org/10. <lb/>1145/3385412.3385980 <lb/>Robbert Krebbers, Amin Timany, and Lars Birkedal. 2017. Interactive proofs in higher-order concurrent separation logic. <lb/>In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, <lb/>January 18-20, 2017. 205-217. https://doi.org/10.1145/3009837.3009855 <lb/>Morten Krogh-Jespersen, Kasper Svendsen, and Lars Birkedal. 2017. A Relational Model of Types-and-Effects in Higher-<lb/>Order Concurrent Separation Logic. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming <lb/>Languages (Paris, France) (POPL &apos;17). Association for Computing Machinery, New York, NY, USA, 218-231. https: <lb/>//doi.org/10.1145/3009837.3009877 <lb/>Morten Krogh-Jespersen, Amin Timany, Marit Edna Ohlenbusch, Simon Oddershede Gregersen, and Lars Birkedal. 2020. <lb/>Aneris: A Mechanised Logic for Modular Reasoning about Distributed Systems. In Programming Languages and Systems -<lb/>29th European Symposium on Programming, ESOP 2020, Held as Part of the European Joint Conferences on Theory and <lb/>Practice of Software, ETAPS 2020, Dublin, Ireland, April 25-30, 2020, Proceedings. 336-365. https://doi.org/10.1007/978-3-<lb/>030-44914-8_13 <lb/>Leslie Lamport. 1992. Hybrid Systems in TLA + . In Hybrid Systems, Robert L. Grossman, Anil Nerode, Anders P. Ravn, and <lb/>Hans Rischel (Eds.). Lecture Notes in Computer Science, Vol. 736. Springer, 77-102. https://doi.org/10.1007/3-540-57318-<lb/>6_25 <lb/>Leslie Lamport. 1998. The Part-Time Parliament. ACM Trans. Comput. Syst. 16, 2 (1998), 133-169. https://doi.org/10.1145/ <lb/>279227.279229 <lb/>Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, <lb/>December 2001) (December 2001), 51-58. <lb/>Hongjin Liang and Xinyu Feng. 2016. A program logic for concurrent objects under fair scheduling. In Proceedings of the 43rd <lb/>Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2016, St. Petersburg, FL, USA, <lb/>January 20 -22, 2016, Rastislav Bodík and Rupak Majumdar (Eds.). ACM, 385-399. https://doi.org/10.1145/2837614.2837635 <lb/>Hongjin Liang and Xinyu Feng. 2018. Progress of concurrent objects with partial methods. Proc. ACM Program. Lang. 2, <lb/>POPL (2018), 20:1-20:31. https://doi.org/10.1145/3158108 <lb/>Ognjen Maric, Christoph Sprenger, and David A. Basin. 2017. Cutoff Bounds for Consensus Algorithms. In Computer <lb/>Aided Verification -29th International Conference, CAV 2017, Heidelberg, Germany, July 24-28, 2017, Proceedings, Part II <lb/>(Lecture Notes in Computer Science, Vol. 10427), Rupak Majumdar and Viktor Kuncak (Eds.). Springer, 217-237. https: <lb/>//doi.org/10.1007/978-3-319-63390-9_12 <lb/>Oded Padon, Giuliano Losa, Mooly Sagiv, and Sharon Shoham. 2017. Paxos made EPR: decidable reasoning about distributed <lb/>protocols. Proc. ACM Program. Lang. 1, OOPSLA (2017), 108:1-108:31. https://doi.org/10.1145/3140568 <lb/>Willem Penninckx, Bart Jacobs, and Frank Piessens. 2015. Sound, Modular and Compositional Verification of the Input/Output <lb/>Behavior of Programs. In Programming Languages and Systems -24th European Symposium on Programming, ESOP 2015, <lb/>Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2015, London, UK, April 11-18, 2015. <lb/>Proceedings (Lecture Notes in Computer Science, Vol. 9032), Jan Vitek (Ed.). Springer, 158-182. https://doi.org/10.1007/978-<lb/>3-662-46669-8_7 <lb/>Marc Shapiro, Nuno M. Preguiça, Carlos Baquero, and Marek Zawirski. 2011. Convergent and Commutative Replicated <lb/>Data Types. Bull. EATCS 104 (2011), 67-88. http://eatcs.org/beatcs/index.php/beatcs/article/view/120 <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. <lb/></note>

        <page>9:32 <lb/></page>

        <note place="headnote">Timany, Gregersen, Stefanesco, Hinrichsen, Gondelman, Nieto, Birkedal <lb/></note>

        <listBibl>Simon Spies, Lennard Gäher, Daniel Gratzer, Joseph Tassarotti, Robbert Krebbers, Derek Dreyer, and Lars Birkedal. 2021. <lb/>Transfinite Iris: resolving an existential dilemma of step-indexed separation logic. In PLDI &apos;21: 42nd ACM SIGPLAN <lb/>International Conference on Programming Language Design and Implementation, Virtual Event, Canada, June 20-25, 20211. <lb/>80-95. https://doi.org/10.1145/3453483.3454031 <lb/>Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter Müller, Martin Clochard, and David Basin. 2020. <lb/>Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification. Proc. ACM <lb/>Program. Lang. 4, OOPSLA, Article 152 (Nov. 2020), 31 pages. https://doi.org/10.1145/3428220 <lb/>Joseph Tassarotti and Robert Harper. 2019. A separation logic for concurrent randomized programs. Proc. ACM Program. <lb/>Lang. 3, POPL (2019), 64:1-64:30. https://doi.org/10.1145/3290377 <lb/>Joseph Tassarotti, Ralf Jung, and Robert Harper. 2017. A Higher-Order Logic for Concurrent Termination-Preserving <lb/>Refinement. In Programming Languages and Systems -26th European Symposium on Programming, ESOP 2017, Held <lb/>as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-<lb/>29, 2017, Proceedings (Lecture Notes in Computer Science, Vol. 10201), Hongseok Yang (Ed.). Springer, 909-936. https: <lb/>//doi.org/10.1007/978-3-662-54434-1_34 <lb/>Amin Timany and Lars Birkedal. 2019. Mechanized Relational Verification of Concurrent Programs with Continuations. <lb/>Proc. ACM Program. Lang. 3, ICFP, Article 105 (July 2019), 28 pages. https://doi.org/10.1145/3341709 <lb/>Amin Timany, Simon Oddershede Gregersen, Léo Stefanesco, Jonas Kastberg Hinrichsen, Léon Gondelman, Abel Nieto, and <lb/>Lars Birkedal. 2023. Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement -Coq <lb/>Artifact. https://doi.org/10.5281/zenodo.10100892 <lb/>Amin Timany, Léo Stefanesco, Morten Krogh-Jespersen, and Lars Birkedal. 2018. A logical relation for monadic encapsulation <lb/>of state: proving contextual equivalences in the presence of runST. PACMPL 2, POPL (2018), 64:1-64:28. https: <lb/>//doi.org/10.1145/3158152 <lb/>Werner Vogels. 2009. Eventually consistent. Commun. ACM 52, 1 (2009), 40-44. https://doi.org/10.1145/1435417.1435432 <lb/></listBibl>

        <front>Received 2023-07-11; accepted 2023-11-07 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. POPL, Article 9. Publication date: January 2024. </note>


	</text>

</TEI>