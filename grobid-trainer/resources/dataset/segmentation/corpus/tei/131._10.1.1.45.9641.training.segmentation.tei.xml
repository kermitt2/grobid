<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>Strange Bedfellows: Issues in Object Naming Under Unix <lb/>Douglas B. Orr, Robert W. Mecklenburg and Ravindra Kuramkote <lb/>Department of Computer Science <lb/>University of Utah <lb/>Salt Lake City, UT 84112 USA <lb/>E-mail: dbo@cs.utah.edu, mecklen@cs.utah.edu, kuramkot@cs.utah.edu <lb/>Abstract <lb/>Naming plays a key role in the design of any sys-<lb/>tem that exports services or resources. Object systems <lb/>may export many di erent categories of names: in-<lb/>stances, components of records, types, etc. Operating <lb/>systems export the names of les, devices, and ser-<lb/>vices. Integrating an object base with existing oper-<lb/>ating system facilities can improve accessibility of the <lb/>object base resources. We consider the bene ts and <lb/>pitfalls of integrating an object base namespace with <lb/>the Unix namespace. 1 <lb/></front>

			<body>1 Introduction <lb/>Naming plays an important role in modern systems <lb/>design. Uniform naming of les and devices, long rec-<lb/>ognized as an important innovation, was rst made <lb/>widely available by the Unix 2 RT78] operating sys-<lb/>tem. Newer systems such as Plan 9 PPT + 93] extend <lb/>uniform naming to most system resources, including <lb/>network connections, processes, etc. Object bases ex-<lb/>port names for a wide variety of smaller grain entities, <lb/>such as instances, components of types, types, etc. <lb/>Object bases share the same need as operating sys-<lb/>tems for contextual naming (e.g., \current directory&quot;) <lb/>and hierarchical or relational organization of the enti-<lb/>ties they export. <lb/></body>

            <front>1 This research was sponsored by Hewlett-Packard&apos;s Re-<lb/>search Grants Program and by the Advanced Research Projects <lb/>Agency (DOD), monitored by the Department of the Navy, <lb/>O ce of the Chief of Naval Research, under Grant number <lb/>N00014{91{J{4046. The opinions and conclusions contained in <lb/>this document are those of the authors and should not be inter-<lb/>preted as representing o cial views or policies, either expressed <lb/>or implied, of the Advanced Research Projects Agency, the U.S. <lb/>Government, or Hewlett-Packard. <lb/></front>

            <note place="footnote">2 Unix is a trademark of Unix System Laboratories. <lb/></note>

            <body>The Mach Shared Objects project (MSO) is part <lb/>of an ARPA initiative focusing on persistent object <lb/>bases (POB) LK92]. In the MSO project, we nd <lb/>ourselves faced with the questions not only of how to <lb/>manage names within this object base, but how these <lb/>names relate to the \real world&quot; of the operating sys-<lb/>tem within which the MSO Object Manager exists. <lb/>The marriage of an object base namespace with <lb/>a traditional Unix namespace produces bene ts and <lb/>problems. The Unix naming framework has evolved <lb/>over time to support a particular semantics. The <lb/>framework includes facilities for hierarchical organi-<lb/>zation and protection, and supports a ( xed) set of <lb/>operations that can be invoked on the objects found <lb/>within the namespace. While this model is too lim-<lb/>ited to allow seamless incorporation of an object base <lb/>into the Unix world, there are many advantages gained <lb/>from using a single, uniform namespace. At the same <lb/>time, integration within the Unix namespace places <lb/>burdens on objects intended to be viewable as rst-<lb/>class Unix entities. <lb/>In this paper we discuss the issues involved with <lb/>such a marriage. We begin by exploring the pros and <lb/>cons of mandating a single namespace. We review the <lb/>naming facilities required by a modern object base. <lb/>We discuss features and restrictions of the framework <lb/>for objects provided by Unix. Finally, we describe <lb/>a strategy for merging the two namespaces and the <lb/>power and limitations of the resulting combined facil-<lb/>ities. <lb/>2 One Namespace or Many? <lb/>Early in the MSO project we encountered a ubiq-<lb/>uity of names. The instances of objects maintained <lb/>within our POB are externally accessible, and thus <lb/>require names. Object instances are uniquely named <lb/>by object identi ers (OIDs). String names (sym-<lb/>bolic labels) are mapped onto objects represented by <lb/>OIDs. Those objects are instances of classes, de-<lb/>scribed by named dossier objects. Dossiers describe <lb/>object instance layout and specify, by name, a class <lb/>implementation. Class implementations reside within <lb/>modules BL92], which group and provide a naming <lb/>scope for methods and static data elements. Finally, <lb/>the MSO Object Manager is implemented under Unix, <lb/>which maintains a namespace of les and devices of <lb/>which the Object Manager implementation makes use. <lb/>Within this paper we concern ourselves primarily <lb/>with the resolution and use of symbolic names. Given <lb/>that so many of these namespaces exist, there exists <lb/>the opportunity for gross duplication of e ort in those <lb/>areas common to all. Browsing, collection, protec-<lb/>tion, and simple I/O are facilities common to most or <lb/>all objects contained within these namespaces. Im-<lb/>plementation of a separate, similar facility for each <lb/>di erent namespace would be a waste of e ort, would <lb/>tend to have inconsistent and non-uniform implemen-<lb/>tations, and is contrary to the standard OO doctrine <lb/>concerning abstraction. <lb/>An analogous situation exists with a number of In-<lb/>ternet namespaces, such as that de ned by most im-<lb/>plementations of the File Transfer Protocol (ftp). Ob-<lb/>jects in this namespace must be transferred to the local <lb/>host via a manual mechanism before applications may <lb/>use them. When Sun Microsystems added the Yel-<lb/>low Pages (later NIS) distributed database Wei85] to <lb/>complement their network le system, it was not inte-<lb/>grated into the namespace. Sun was forced to provide <lb/>alternate naming facilities (e.g., yp bind, yp match) <lb/>and reimplement familiar utilities to work speci -<lb/>cally within the domain of the Yellow Pages (e.g., <lb/>ypcat, ypmatch). The Object Store system incorpo-<lb/>rates the Unix namespace into its namespace and pro-<lb/>vides its own mechanisms to access operating system <lb/>facilities LLOW91]. <lb/>Clearly, it is desirable, to the greatest extent pos-<lb/>sible, to avoid this sort of duplication of e ort. While <lb/>working within a single namespace largely achieves <lb/>that goal. Using a single namespace is not without <lb/>
            its limitations, of course. Choosing to adopt a sin-<lb/>gle convention means applying a single style of orga-<lb/>nization to all names, a single protection paradigm, <lb/>etc. These restrictions may not be acceptable to some <lb/>name providers but do not pose excessive problems <lb/>within the MSO context. Therefore the MSO project <lb/>has chosen to consolidate all its namespaces into one. <lb/>Given that one namespace is to be created, and <lb/>that the existing Unix namespace is one component, <lb/>the question arises as to whether it is better to adapt <lb/>the Unix namespace to support that of the object base, <lb/>or vice versa. The existence of a large number of use-<lb/>ful utilities that manipulate the Unix namespace leads <lb/>us to incorporate the MSO namespaces into the Unix <lb/>namespace. <lb/>3 Naming and Invocation Facilities <lb/>In a complete POB, names are used in at least two <lb/>contexts: naming persistent data and naming persis-<lb/>tent class implementations. Each context imposes re-<lb/>quirements on naming facilities. Persistent data re-<lb/>quires that users be allowed to retrieve instances by <lb/>name. The storage and retrieval of instances requires <lb/>dossiers, as described earlier. Our view of persis-<lb/>tent code is based on the Object/Meta-Object Server <lb/>(OMOS) OM92]. This server constructs class imple-<lb/>mentations from meta-object descriptions. These im-<lb/>plementations and meta-objects must also be named. <lb/>We discuss requirements for each of these contexts in <lb/>turn. <lb/>In our POB persistent objects are considered to be <lb/>rooted graphs of objects where each object may be <lb/>provided with an OID. Any object with an OID can <lb/>be bound to an externally visible name. The object <lb/>namespace is inherently hierarchical. Users can ex-<lb/>plicitly create hierarchies of names for organizational <lb/>purposes (e.g., directories). Object graphs form hier-<lb/>archies of names when more than one object in a single <lb/>graph is named. There is a syntactically seamless two-<lb/>way mapping between the organizational namespace <lb/>and the object name space. <lb/>Each object graph is actually the most recent view <lb/>on a versioning hierarchy which records the modi ca-<lb/>tion history of the graph. This versioning is controlled <lb/>by a set of library function calls which manage con-<lb/>currency. In general, the version of an object is not <lb/>considered part of its name, but as an attribute of <lb/>the persistent entity. Thus, a simple ls of an object <lb/>directory will reveal an entry for each unique named <lb/>object, where a named object may have an arbitrary <lb/>number of versions which are not immediately visi-<lb/>ble. Access to these versions must be speci able by a <lb/>speci c version number or date. <lb/>It is highly desireable that location information not <lb/>be encoded within the symbolic name. It should be <lb/>possible to recon gure an existing database without <lb/>a ecting the names of persistent objects. Protection <lb/>must be incorporated into the naming scheme. Fi-<lb/>nally, use of this naming scheme should not impose <lb/>undue burdens on application programs wishing to <lb/>manipulate named objects. In the extreme case, it <lb/>would be advantageous if applications which did not <lb/>interpret the contents of les (e.g., ls, cat) could be <lb/>used unchanged to manipulate named objects. <lb/>As noted above, persistent objects must include not <lb/>only the data members of the object but also the im-<lb/>plementations of function members. In MSO, this as-<lb/>pect of persistence is handled by the OMOS server. <lb/>Executable objects are described in OMOS by meta-<lb/>objects which contain a blueprint for constructing the <lb/>method implementations from modules. The meta-<lb/>object must be named, as must the component parts. <lb/>To support type evolution, the names found within <lb/>OMOS require a notion of \version&quot; as well. <lb/>Through the names found in these two contexts, <lb/>the MSO POB provides a rich facility for management <lb/>of classes, access to arbitrary instances of objects, and <lb/>the ability to invoke a wide variety of methods on those <lb/>instances. These are the object base facilities we wish <lb/>to access via the Unix namespace; any implementation <lb/>must support the indicated requirements. <lb/>4 Unix Object Semantics <lb/>Merging namespaces implies the potential of uni-<lb/>form operations on objects found in the namespaces <lb/>being merged. Since we have chosen to work within <lb/>the Unix context, we need to examine the implica-<lb/>tions of this decision with respect to an object base <lb/>composed of arbitrary object instances. <lb/>Fitting within the Unix framework implies a restric-<lb/>tion of functionality. The two mechanisms provided <lb/>for integrating a client name provider into the Unix <lb/>framework, the VFS le system switch Kle86] and the <lb/>NFS protocol ea85], support a xed set of operations. <lb/>The VFS switch operations are linked into the kernel <lb/>and accessed through a virtual function table. The <lb/>NFS operations (largely a subset of the VFS opera-<lb/>tions) are de ned by a network protocol. <lb/>The Unix open operation resolves a string name, <lb/>returning a handle to the object represented by that <lb/>name in the form of a Unix le descriptor. The Unix <lb/>le system operations de ned by its provider are ac-<lb/>cessible via this handle. File systems providing a di-<lb/>rectory service support an acyclic graph structure ac-<lb/>cessed by name, through operations such as lookup, <lb/>remove, rename, etc. Various kinds of attributes are <lb/>set and reported by the attr operations. The Unix <lb/>permission model is supported by chown and chmod <lb/>operations. Operations on non-directory objects are <lb/>mostly limited to simple byte stream and page I/O. <lb/>In addition to restrictions on available functionality <lb/>within the Unix framework, Unix applications require <lb/>that certain methods be implemented by an object if <lb/>it is to be usable in an expected fashion. For exam-<lb/>ple, make will only work properly if an update time <lb/>is maintained for an object. As a result, if objects <lb/>exported to the Unix namespace are to be treated as <lb/>rst-class Unix entities, it may not be su cient to <lb/>only implement a small number of I/O primitives to <lb/>meaningfully export objects into Unix. <lb/>5 The Unholy Union <lb/>Interoperation with Unix applications and objects <lb/>is highly desirable, but far from the full functional-<lb/>ity desired for an object base. The methods available <lb/>
            to objects within the POB cannot be limited to the <lb/>small, xed set available under Unix. As noted in the <lb/>previous section, Unix provides us with a mechanism <lb/>to resolve an object name to a object handle (the le <lb/>descriptor) in a protected fashion. From this, we must <lb/>develop mechanisms to invoke arbitrary operations on <lb/>the underlying object. <lb/>Since the OID represents an absolute name for an <lb/>object instance, independent of heterogeneous names-<lb/>paces, it is a convenient and appropriate handle with <lb/>which an application can perform operations on the <lb/>instance. Use of this handle requires some additional <lb/>form of authentication for security. <lb/>We propose a framework whereby string names are <lb/>resolved to protected Unix handles. The protected <lb/>Unix handle can then be used to derive an OID and <lb/>a ticket with which authenticated access to the ob-<lb/>ject can be veri ed. The OID and ticket can be used <lb/>to invoke arbitrary methods on the underlying object. <lb/>Applications wishing only to perform Unix operations <lb/>(such as standard Unix programs) need not go through <lb/>the process of dereferencing the protected Unix han-<lb/>dle. Applications performing more sophisticated oper-<lb/>ations retain the bene ts of a single namespace with-<lb/>out losing the power of the wide range of methods <lb/>available within an object base. <lb/>The interface between the POB and traditional <lb/>Unix tools can be further enhanced by allowing <lb/>\views&quot; of objects to be obtained through extensions <lb/>to the naming convention. We implement version-<lb/>ing as an extention to the standard Unix naming <lb/>scheme, where /&lt;version&gt; is appended to the ob-<lb/>ject name. This scheme has been implemented suc-<lb/>cessfully in Apollo&apos;s Domain System Engineering En-<lb/>vironment and PPT + 93]. Other extensions might <lb/>include appending an operation name, /&lt;op&gt; (e.g., <lb/>/bytestream). These operations could be mapped to <lb/>member function operations, to allow an object to ex-<lb/>port arbitrary operations via the namespace. <lb/>6 Issues and Limitations <lb/>Adopting the Unix model is not without its prob-<lb/>lems. One problem involves basic object architecture. <lb/>Objects typically contain state; a traditional role of <lb/>object methods is to manipulate that state. Object <lb/>access via a le descriptor is implicitly remote | the <lb/>object state is typically maintained in a server and not <lb/>in the application. Generalized method invocation not <lb/>involving le descriptors, however, does not imply this <lb/>restriction. As a result, we are left with the question <lb/>of where to maintain the object state, and the prob-<lb/>lems of synchronization and consistency if the state <lb/>resides in more than one place. <lb/>Access via le descriptor has the restriction that <lb/>there is a system-imposed limit to the number of open <lb/>le descriptors a process may hold at any given time. <lb/>This limit tends to be small (20-256). As a result, le <lb/>descriptors unacceptable for use in applications that <lb/>use a large number of objects simultaneously. When <lb/>used exclusively to establish a protected \backdoor&quot; <lb/>connection, however, the problem of restrictions on <lb/>the number of open le descriptors is manageable. <lb/>Use of generalized objects via Unix is complicated <lb/>by the expectations underlying many Unix applica-<lb/>tions. Standard utilities make assumptions that may <lb/>no longer be valid in the face of the additional capabil-<lb/>ities of generalized objects. For example, cp assumes <lb/>that it can duplicate the structure of an object with <lb/>the open operation and the contents using successive <lb/>reads and writes. When using objects from a POB, <lb/>the open operation may fail to reproduce the type in-<lb/>formation now implicit in their structure, and read <lb/>and write may not be su cient to reproduce their <lb/>state. As a result, either standard Unix commands <lb/>must be modi ed to work within the new, more so-<lb/>phisticated world, or their users must be made to un-<lb/>derstand the related changes in their operation. <lb/>Finally, Implementation of a name provider under <lb/>Unix has its own set of challenges. The world of Unix <lb/>namespaces is not the friendly and easily extensible <lb/>place the existence of the VFS le system switch might <lb/>lead one to believe. The VFS le system switch was <lb/>introduced by Sun as an abstraction of the le sys-<lb/>tem designed to allow constructing a single namespace <lb/>from multiple le system types. <lb/>Unfortunately, the realities of VFS are less elegant <lb/>than the concept. In reality, there are a number of <lb/>VFS interfaces, since most manufacturers have cho-<lb/>sen to make their own extensions from the base VFS <lb/>developed by Sun. In addition, since the manufac-<lb/>turers are the primary clients of VFS, the VFS API <lb/>and implementation tend to change subtly without <lb/>notice Web93]. And, since not all manufacturers sup-<lb/>port dynamic linking of kernel modules it is sometimes <lb/>necessary to specially con gure and statically link new <lb/>le system support into the kernel. <lb/>An alternative option is extend the Unix namespace <lb/>via servers implementing the NFS protocol. Using the <lb/>NFS protocol has the distinct advantage that the NFS <lb/>protocols are much more rigidly xed and uniform <lb/>than the speci cations for VFS. An NFS framework <lb/>has the disadvantage that the semantics of NFS are <lb/>stateless, implying inherent di culty when used in a <lb/>stateful context. In addition, the set of methods sup-<lb/>ported under NFS is a subset of those supported un-<lb/>der VFS, further restricting the possible derived Unix <lb/>functionality. <lb/>7 Conclusion <lb/>Maintaining a single namespace for operating sys-<lb/>tem and object base objects gives the advantage of <lb/>uniformity and avoids duplication of functionality of <lb/>common applications. While it is not possible to sup-<lb/>port arbitrary object operations within the existing <lb/>Unix context, using it as the basis for naming pro-<lb/>vides enough functionality to be very useful. We have <lb/>proposed a simple model to allow access to the addi-<lb/>tional functionality not provided for by Unix. <lb/></body>

			<div type="acknowledgement">Acknowledgements <lb/>We would like to thank Gary Lindstrom and <lb/>Charles Clark for much help in reviewing this doc-<lb/>ument. <lb/></div>

			<listBibl>References <lb/>BL92] Gilad Bracha and Gary Lindstrom. Mod-<lb/>ularity meets inheritance. In Proc. In-<lb/>ternational Conference on Computer Lan-<lb/>guages, pages 282{290, San Francisco, CA, <lb/>April 20-23 1992. IEEE Computer Society. <lb/>Also available as Technical Report UUCS-<lb/>91-017. <lb/>ea85] <lb/>R. Sandberg et al. Design and im-<lb/>plementation of the sun network lesys-<lb/>tem. In Proceedings of the Summer <lb/>1985 USENIX Conference, pages 119{130, <lb/>Portland, 1985. Usenix Association. <lb/>Kle86] Steven R. Kleiman. Vnodes: An architec-<lb/>ture for multiple le system types in Sun <lb/>UNIX. In Proceedings of the Summer 1986 <lb/>USENIX Conference, pages 238{247, At-<lb/>lanta, Georgia, 1986. Usenix Association. <lb/>LK92] Gary Lindstrom and Robert R. Kessler. <lb/>Mach Shared Objects. In Proceedings Soft-<lb/>ware Technology Conference, pages 279{ <lb/>280, Los Angeles, CA, April 1992. DARPA <lb/>SISTO. <lb/>LLOW91] Charles Lamb, Gordon Landis, Jack Oren-<lb/>stein, and Dan Weinreb. The ObjectStore <lb/>database system. Communications of the <lb/>ACM, 34(10):50{63, October 1991. <lb/>OM92] Douglas B. Orr and Robert W. Mecklen-<lb/>burg. OMOS | an object server for pro-<lb/>gram execution. In Proc. International <lb/>Workshop on Object Oriented Operating <lb/>Systems, pages 200{209, Paris, September <lb/>1992. IEEE Computer Society. Also avail-<lb/>able as technical report UUCS-92-033. <lb/>PPT + 93] Rob Pike, Dave Presotto, Ken Thompson, <lb/>Howard Trickey, and Phil Winterbottom. <lb/>The use of name spaces in plan 9. ACM <lb/>Operating Systems Review, 27(2):72{75, <lb/>April 1993. <lb/>RT78] D. M. Ritchie and K. Thompson. The <lb/>UNIX time-sharing system. The Bell Sys-<lb/>tem Technical Journal, 57(6):1905{1930, <lb/>July/August 1978. <lb/>Web93] Neil Webber. Operating system support <lb/>for portable lesystem extensions. In Pro-<lb/>ceedings of the Winter 1993 USENIX Con-<lb/>ference, pages 219{228, San Diego, Cali-<lb/>fornia, January 25-29, 1993. Usenix Asso-<lb/>ciation. <lb/>Wei85] P. Weiss. Yellow Pages protocol speci ca-<lb/>tion. Technical report, Sun Microsystems, <lb/>Inc., 1985. </listBibl>


	</text>
</tei>
