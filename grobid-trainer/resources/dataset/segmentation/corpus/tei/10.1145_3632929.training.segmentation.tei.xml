<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">On Model-Checking Higher-Order Effectful Programs</title>
        <author>
          <persName>
            <forename>Ugo</forename>
            <surname>Dal Lago</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Alexis</forename>
            <surname>Ghyselen</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-30T10:27:19.360294Z">30.10.2025 10:27:19</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3632929</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3632929</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Ugo Dal Lago, Alexis Ghyselen. (2024). On Model-Checking Higher-Order Effectful Programs. Proceedings of the ACM on Programming Languages, 8(POPL), 2610-2638. DOI: 10.1145/3632929</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-30T10:27:19.360294Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-30T10:27:19.360294Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
        <front>Taypsi: Static Enforcement of Privacy Policies for <lb/>Policy-Agnostic Oblivious Computation <lb/>QIANCHUAN YE, Purdue University, USA <lb/>BENJAMIN DELAWARE, Purdue University, USA <lb/>Secure multiparty computation (MPC) techniques enable multiple parties to compute joint functions over <lb/>their private data without sharing that data with other parties, typically by employing powerful cryptographic <lb/>protocols to protect individual&apos;s data. One challenge when writing such functions is that most MPC languages <lb/>force users to intermix programmatic and privacy concerns in a single application, making it difficult to <lb/>change or audit a program&apos;s underlying privacy policy. Prior policy-agnostic MPC languages relied on <lb/>dynamic enforcement to decouple privacy requirements from program logic. Unfortunately, the resulting <lb/>overhead makes it difficult to scale MPC applications that manipulate structured data. This work proposes to <lb/>eliminate this overhead by instead transforming programs into semantically equivalent versions that statically <lb/>enforce user-provided privacy policies. We have implemented this approach in a new MPC language, called <lb/>Taypsi; our experimental evaluation demonstrates that the resulting system features considerable performance <lb/>improvements on a variety of MPC applications involving structured data and complex privacy policies. <lb/>CCS Concepts: • Software and its engineering → Functional languages; Data types and structures; <lb/>Compilers; • Security and privacy → Cryptography. <lb/>Additional Key Words and Phrases: Oblivious Computation, Dependent Types, Algebraic Data Types <lb/>ACM Reference Format: <lb/>Qianchuan Ye and Benjamin Delaware. 2024. Taypsi: Static Enforcement of Privacy Policies for Policy-<lb/>Agnostic Oblivious Computation. Proc. ACM Program. Lang. 8, OOPSLA1, Article 144 (April 2024), 30 pages. <lb/>https://doi.org/10.1145/3649861 <lb/></front>

        <body>1 INTRODUCTION <lb/>Secure multiparty computation (MPC) techniques allow multiple parties to jointly compute a function <lb/>over their private data while keeping that data secure. A variety of privacy-focused applications <lb/>can be formulated as MPC problems, including secure auctions, voting, and privacy-preserving <lb/>machine learning [Evans et al. 2018; Hastings et al. 2019; Laud and Kamm 2015]. MPC solutions <lb/>typically depend on powerful cryptographic techniques, e.g., Yao&apos;s Garbled Circuits [Yao 1982] or <lb/>secret sharing [Beimel 2011], to provide strong privacy guarantees. These cryptographic techniques <lb/>can be difficult for non-experts to use, leading to the creation of several high-level languages that <lb/>help programmers write MPC applications [Acay et al. 2021; Darais et al. 2020; Hastings et al. 2019; <lb/>Liu et al. 2015; Malkhi et al. 2004; Rastogi et al. 2014, 2019; Sweet et al. 2023; Ye and Delaware 2022; <lb/>Zahur and Evans 2015; Zhang et al. 2013]. While raising the level of abstraction, almost all of these <lb/>languages intermix privacy and programmatic concerns, requiring the programmers to explicitly <lb/>enforce the high-level privacy policies within the logic of the application itself, using the secure <lb/>operations provided by the language. As a consequence, the entire application must be examined <lb/></body>

        <front>Authors&apos; addresses: Qianchuan Ye, Purdue University, West Lafayette, USA, ye202@purdue.edu; Benjamin Delaware, Purdue <lb/>University, West Lafayette, USA, bendy@purdue.edu. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/4-ART144 <lb/>https://doi.org/10.1145/3649861 <lb/>Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/></front>

        <page>144:2 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>in order to audit its privacy policy, and an application must be rewritten in order to change its <lb/>privacy guarantees. This intermixing of policy enforcement and application logic thus makes it <lb/>difficult to read, write, and reason about MPC applications. <lb/>This is particularly true for applications with the sorts of complex requirements that can occur in <lb/>practice. Within the United States, for example, the Health Insurance Portability and Accountability <lb/>Act (HIPAA) governs how patient data may be used. HIPAA allows either the personally identifiable <lb/>information (PII) or medical data to be shared, but not both. Notably, this policy does not simply <lb/>specify whether some particular field of a patient&apos;s medical record is private or public; rather <lb/>it is a relation that dictates how a program can access and manipulate different parts of every <lb/>individual record. To conform to this policy, an MPC application must either pay the (considerable) <lb/>cryptographic overhead of conservatively securing all accesses to the fields of a record, or adopt a <lb/>more sophisticated strategy for monitoring how data is accessed. These challenges become more <lb/>acute when dealing with structured data, e.g., lists or trees, whose policies are necessarily more <lb/>complex. Consider a classifier that takes as input a decision tree and a medical record, each of which <lb/>is owned by a different party: if the owner of the tree stipulates that its depth may be disclosed, <lb/>the classification function must use secure operations to ensure that no other information about <lb/>the tree is leaked, e.g., its spine or the attributes it uses. If the owner of this tree is willing to share <lb/>such information, however, this function must either be rewritten to take advantage of the new, <lb/>more permissive policy, or continue to pay the cost of providing stricter privacy guarantees. Thus, <lb/>most existing MPC languages require users to write different implementations of essentially the <lb/>same program for each distinct privacy policy. <lb/>A notable exception is Taype [Ye and Delaware 2023], a recently proposed language that decouples <lb/>privacy policies from programmatic concerns, allowing users to write applications over structured <lb/>data that are agnostic to any particular privacy policy. To do so, Taype implements a novel form of <lb/>the tape semantics proposed by Ye and Delaware [2022]. This semantics allows insecure operations <lb/>whose evaluation could violate a policy to appear in a program, as long as the results of these <lb/>operations are eventually protected. Under tape semantics, such operations are lazily deferred <lb/>until it is safe to execute them, effectively dynamically &quot;repairing&quot; potential leaks at runtime. Using <lb/>Taype, programmers can thus build a privacy-preserving version of a standard functional program <lb/>by composing it with a policy, specified as a dependent type equipped with security labels, relying <lb/>on tape semantics to enforce the policy during execution. Unfortunately, while this enforcement <lb/>strategy disentangles privacy concerns from program logic, it also introduces considerable overhead <lb/>for applications that construct or manipulate structured data with complex privacy requirements. <lb/>Thus, this strategy does not scale to the sorts of complex applications that could greatly benefit <lb/>from this separation of concerns. <lb/>This work presents Taypsi, a policy-agnostic language for writing MPC applications that elimi-<lb/>nates this overhead by instead transforming a non-secure function into a version that statically <lb/>enforces a user-provided privacy policy. Taypsi extends Taype with a form of dependent sums, <lb/>which we call Ψ-types, that package together the public and private components of an algebraic <lb/>data type (ADT). Each Ψ-type is equipped with a set of Ψ-structures which play an important role <lb/>in our translation, enabling it to, e.g., efficiently combine subcomputations that produce ADTs <lb/>with different privacy policies. Our experimental evaluation demonstrates that this strategy yields <lb/>considerable performance improvements over the enforcement strategy used by Taype, yielding <lb/>exponential improvements on the most complex benchmarks in our evaluation suite. <lb/>To summarize, the contributions of this paper are as follows: <lb/>• We present Taypsi, a version of Taype extended with Ψ-types, a form of dependent sums <lb/>that enables modular translation of non-secure programs into efficient, secure versions. This <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:3 <lb/></page>

        <body>language is equipped with a security type system that offers the same guarantees as Taype: <lb/>after jointly computing a well-typed function, neither party can learn more about the other&apos;s <lb/>private data than what can be gleaned from their own data and the output of the function. <lb/>• We develop an algorithm that combines a program written in the non-secure fragment of <lb/>Taypsi with a privacy policy to produce a secure private version that statically enforces the <lb/>desired policy. We prove that this algorithm generates well-typed (and hence secure) target <lb/>programs that are additionally guaranteed to preserve the semantics of the source programs. <lb/>• We evaluate our approach on a range of case studies and microbenchmarks. Our experimental <lb/>results demonstrate exponential performance improvements over the previous state-of-the-art <lb/>(Taype) on several complicated benchmarks, while simultaneously showing no performance <lb/>regression on the remaining benchmarks. <lb/>2 OVERVIEW <lb/>data list = Nil | Cons Z list <lb/>fn filter : list → Z → list = xs y ⇒ <lb/>match xs with Nil ⇒ Nil <lb/>| Cons x xs ′ ⇒ <lb/>if x ≤ y then Cons x (filter xs ′ y) <lb/>else filter xs ′ y <lb/>Fig. 1. Filtering a list <lb/>Before presenting the full details of our approach, <lb/>we begin with an overview of Taypsi&apos;s strategy for <lb/>building privacy-preserving applications. Consider the <lb/>simple filter function in Figure 1, which drops all the <lb/>elements in a list above a certain bound. 1 Suppose Alice <lb/>owns some integers, and wants to know which of those <lb/>integers are less than some threshold integer belonging <lb/>to Bob, but neither party wants to share their data with <lb/>the other. MPC protocols allow Alice and Bob to encrypt <lb/>their data and then jointly compute filter using secure <lb/>operations, without leaking information about the encrypted data beyond what they can infer from <lb/>the final disclosed output. One (insecure) implementation strategy is to simply encrypt everyone&apos;s <lb/>integers and use a secure version of the ≤ operation to compute the resulting list. Under a standard <lb/>semi-honest threat model, 2 however, this naive strategy can reveal private information, via the <lb/>shape of the input and the intermediate program states. <lb/>As an example, assume Alice&apos;s input list is Cons [2] (Cons [7] (Cons [3] Nil)), and Bob&apos;s input is <lb/>[5], where square brackets denote secure (encrypted) numbers, i.e., only the owner of the integer <lb/>can observe its value. By observing that Alice&apos;s private data is built from three Conss, Bob can already <lb/>tell Alice owns exactly 3 integers, information that Alice may want to keep secret. In addition, <lb/>both parties can learn information from the control flow of the execution of filter: by observing <lb/>which branch of if is executed, for example, Bob can infer that the second element of Alice&apos;s list is <lb/>greater than 5. Thus, even if the integers are secure, both parties can still glean information about <lb/>the other&apos;s private data. <lb/>The particular policy that a secure application enforces can greatly impact the performance of <lb/>that application, since the control flow of an application cannot depend on private data. In the <lb/>case of our example, this means that the number of recursive calls to filter depends on the public <lb/>information Alice is willing to share. If Alice only wants to share the maximum length of her list, <lb/>for example, its encrypted version must be padded with dummy encrypted values, and a secure <lb/>version of filter must recurse over these dummy elements, in order to avoid leaking information <lb/>to Bob through its control flow. On the other hand, if Alice does not mind sharing the exact number <lb/>of integers she owns, the joint computation will not have to go over these values, allowing a secure <lb/>version of filter to be computed more efficiently. <lb/></body>

        <note place="footnote">1 Taypsi supports higher-order functions, but our overview will use this specialized version for presentation purposes. <lb/>2 In this threat model, all parties can see the execution traces produced by a small-step semantics [Ye and Delaware 2022]. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:4 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>2.1 Encoding Private Data and Policies <lb/>obliv list ≤ (k : N) = <lb/>if k = 0 then <lb/>else <lb/>+ Z × list ≤ (k-1) <lb/>obliv list = (k : N) = <lb/>if k = 0 then <lb/>else Z × list = (k-1) <lb/>Fig. 2. Oblivious lists with maxi-<lb/>mum and exact length public views <lb/>Taypsi allows Alice and Bob to use types to describe what <lb/>public information can be shared about their private data (i.e., the <lb/>policy governing that data), and its type system guarantees that <lb/>these policies are not violated when jointly computing a function <lb/>over that data. At a high-level, a privacy policy for a structured <lb/>(i.e., algebraic) datatype specifies which of its components are pri-<lb/>vate and which can be freely shared. We call this publicly shared <lb/>information a public view, reflecting that it is some projection of <lb/>the full data. Formally, policies in Taypsi are encoded as oblivious <lb/>algebraic data types (OADTs) [Ye and Delaware 2022], dependent <lb/>types that take a public view as a parameter. The body of an OADT is the type of the private <lb/>components of a data type, which are built using oblivious (i.e., secure) type formers, e.g., oblivious <lb/>fixed-width integer ( Z) and oblivious sum ( +). 3 An oblivious sum is similar to a standard sum, but <lb/>both its tag and &quot;payload&quot; (i.e., component) are obfuscated, so that an attacker cannot distinguish <lb/>between a left and right injection. Essentially, an OADT is a type-level function that maps the <lb/>public view of a value to its private representation, i.e., the shape of its private component. <lb/>Figure 2 shows two OADTs for the type list: list ≤ , whose public view is the maximum length of <lb/>a list, and list = , whose public view is the exact length. A public view can be any public data type. <lb/>We say list is the public type or public counterpart of the OADTs list ≤ and list = . The key invariant <lb/>of OADTs is that private values with the same public view are indistinguishable to an attacker, as <lb/>their private representation is completely determined by the public view. For example, all private <lb/>lists of type list ≤ 2 have the same private representation, regardless of the actual length of the list: <lb/>list ≤ 2 ≡ + Z × ( + Z × ). Thus, an attacker cannot learn anything about the structure of an <lb/>OADT, outside of what is entailed by its public view: an empty list, singleton list, or a list with two <lb/>elements of type list ≤ 2 all appear the same to an attacker. <lb/>Z <lb/>Z <lb/>Z#s <lb/>Z#r <lb/>{ l : list | length l ≤ k } <lb/>list ≤ k <lb/>list≤ #s <lb/>list≤ #r <lb/>Fig. 3. Public and oblivious types <lb/>Conceptually, OADTs generalize the notion of secure <lb/>fixed-width integers to secure structured data, as illus-<lb/>trated in Figure 3. Every fixed-width integer (of type Z) <lb/>can be sent to its secure value in Z by &quot;encryption&quot;, and a <lb/>secure integer can be converted back to Z by &quot;decryption&quot;. <lb/>In Taypsi, these conversion functions are called section <lb/>(e.g., Z#s) and retraction (e.g., Z#r). The names reflect their <lb/>expected semantics: applying retraction to the section <lb/>of a value should produce the same value. Importantly, while the oblivious integer type Z does <lb/>not appear to have much structure, it nonetheless has an implicit policy: the public view of an <lb/>integer is its bit width. If we use 32-bit integers, for example, Z is the set of all integers whose bit <lb/>width is 32, and Z is the set of their &quot;encrypted&quot; values, related by a pair of conversion functions. <lb/>Similarly, list ≤ k consists of the secure encodings of lists that have at most k elements. Like Z, list ≤ <lb/>is equipped with a section function, list ≤ #s, and a retraction function, list ≤ #r, which convert public <lb/>values of list to their oblivious counterparts and back. Crucially, just as the oblivious integers in Z <lb/>are indistinguishable, the elements of list ≤ k are also indistinguishable. <lb/>In the implementation of Taypsi, oblivious values are represented using arrays of secure values. <lb/>To ensure that attackers cannot learn anything from the &quot;memory layout&quot; of an OADT value, the <lb/>size of this array is the same for all values of a particular OADT. As an example, the encoding of the <lb/>list Cons 10 (Cons 20 Nil) as an oblivious list of type list ≤ 2 is inr ([10], inr ([20], ())), where inr <lb/></body>

        <note place="footnote">3 By convention, we use ˆ to denote the oblivious version of something. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:5 <lb/></page>

        <body>( inl) is the oblivious counterpart of standard sum injection inr (inl). &quot;Under the hood&quot; this oblivious <lb/>value is represented as an array holding four secure values; in the remainder of this section, we <lb/>will informally write this value as [Cons,10,Cons,20], where [Cons] is a synonym of the tag [inr] for <lb/>readability. As another example, the empty list Nil is encoded as inl (); it is also represented using <lb/>an array with four elements, [Nil,-,-,-], where the last three elements are dummy encrypted <lb/>values (denoted by -). Our compiler uses the type of inl to automatically pad this array with these <lb/>values, in order to ensure that it is indistinguishable from other private values of list ≤ 2. <lb/>2.2 Enforcing Policies <lb/>Although using OADTs ensures that the representation of private information does not leak <lb/>anything, both parties can still learn information by observing the control flow of a program. In <lb/>order to protect private data from control flow channels, Taypsi provides oblivious operations <lb/>to manipulate private data safely. One such operation is the atomic conditional mux, 4 a version <lb/>of if that fully evaluates both branches before producing its final result. To understand why this <lb/>evaluation strategy is necessary, consider the following example of what would happen if we were <lb/>to evaluate mux like a standard if expression: <lb/>mux [true] ([2] + [3]) [4] -→ [2] + [3] -→ [5] <lb/>Even when all the private data (i.e., the integers in square brackets) is hidden, an attacker can <lb/>infer that the private condition is true by observing that mux evaluates to the expression in its then <lb/>branch. <lb/>With the secure semantics of mux, however, the following execution trace does not reveal any <lb/>private information: <lb/>mux ([0] ≤ [1]) ([2] + [3]) ([4] + [5]) -→ mux [true] ([2] + [3]) ([4] + [5]) -→ <lb/>mux [true] [5] ([4] + [5]) -→ mux [true] [5] [9] -→ [5] <lb/>Since both branches are evaluated regardless of the private condition, an attacker cannot infer that <lb/>condition from this execution trace (again, all secure values are indistinguishable to an attacker). <lb/>Thus, falsifying the condition produces an equivalent trace, modulo the encrypted data: <lb/>mux ([6] ≤ [1]) ([2] + [3]) ([4] + [5]) -→ mux [false] ([2] + [3]) ([4] + [5]) -→ <lb/>mux [false] [5] ([4] + [5]) -→ mux [false] [5] [9] -→ [9] <lb/>The security-type system of Taypsi ensures all operations on private data are done in a way that <lb/>does not reveal any private information, outside the public information specified by the policies. <lb/>2.3 Automatically Enforcing Policies <lb/>Users can directly implement privacy-preserving applications in Taypsi using OADTs and secure <lb/>operations, but this requires manually instrumenting programs so that their control flow only <lb/>depends on public information. Under this discipline, the implementation of a secure function <lb/>intertwines program logic and privacy policies: the secure version of filter requires a different <lb/>implementation depending on whether Alice is willing to share the exact length of her list, or an <lb/>upper bound on that length. Taype [Ye and Delaware 2023] decouples these concerns by allowing <lb/>programs to include unsafe computations and repairing unsafe computations at runtime, using a <lb/>novel form of semantics called tape semantics. As an example of this approach, in Taype, a secure <lb/>implementation of filter that allows Alice to only share an upper bound on the size of her list can <lb/>be written as: <lb/>fn filter ≤ : (k : N) → list ≤ k → Z → list ≤ k = <lb/>k xs y ⇒ list ≤ #s k (filter ( list ≤ #r k xs) ( Z#r y)) <lb/></body>

        <note place="footnote">4 The oblivious version of if in Taypsi is called mux, not if, in order to be consistent with the MPC literature. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:6 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>The type signature of filter ≤ specifies the policy it must follow. Intuitively, its implementation <lb/>first &quot;decrypts&quot; the private inputs, applying the standard filter function to those values, and then <lb/>&quot;re-encrypts&quot; the filtered list. In this example, the retractions of the private inputs xs and y are unsafe <lb/>computations that would violate the desired policy if they were computed naively. Fortunately, <lb/>using the tape semantics prevents this from occurring by deferring these computations until it is <lb/>safe to do so. Less fortunately, the runtime overhead of dynamic policy enforcement makes it hard <lb/>to scale private applications manipulating structured data. As one data point, the secure version of <lb/>filter produced by Taype takes more than 5 seconds to run with an oblivious list list ≤ with sixteen <lb/>elements, and its performance grows exponentially worse as the number of elements increases. <lb/>To understand the source of this slowdown, consider a computation that filters a private list <lb/>containing 10 and 20 with integer 15: filter ≤ 2 [Cons,10,Cons,20] [15]. The first step in evaluating <lb/>this function is to compute list ≤ #r 2 [Cons,10,Cons,20]. Completely reducing this expression leaks <lb/>information, so tape semantics instead stops evaluation after producing the following computation: 5 <lb/>mux [false] Nil (Cons ( Z#r [10]) (mux [false] Nil (Cons ( Z#r [20]) Nil))) <lb/>The two [false]s are the results of securely checking if the two constructors in the input list are <lb/>Nil. Observe that evaluating either mux or Z#r would reveal private information, so the evaluation <lb/>of these operations is deferred. This delayed computation can be thought of as an &quot;if-tree&quot; whose <lb/>internal nodes are the private conditions needed to compute the final results, and whose leaves <lb/>hold the result of the computation along each corresponding control flow path. To make progress, <lb/>tape semantics distributes the context surrounding a delayed computation, filter and then list ≤ #s <lb/>in this example, into each of its leaves; having done so, those leaves can be further evaluated. <lb/>Importantly, in our example, the leaves of this if-tree are eventually re-encrypted using list ≤ #s. <lb/>The tape semantics does so in a secure way, so that Z#r [10] becomes [10] again, and each result <lb/>list is converted to a secure value of the expected OADT. Once the branches of a mux node have <lb/>been reduced to oblivious values of the same type, the node itself can be securely reduced using <lb/>the secure semantics of mux. Unfortunately, the if-tree produced by the tape semantics can grow <lb/>exponentially large before its mux nodes can be reduced. For example, after applying filter to the <lb/>if-tree produced by list ≤ #r, the resulting if-tree has a leaf corresponding to every possible list that <lb/>filter could produce; the number of these leaves is exponential in the maximum length of the input <lb/>list. As any surrounding computation, i.e., list ≤ #s in our example, can be distributed to each of <lb/>these leaves, an exponential number of computations may need to be performed before the if-tree <lb/>can be collapsed. <lb/>To remedy these limitations, this paper proposes to instead compile an insecure program into <lb/>a secure version that statically enforces a specified policy. To do so, we extend Taype, the secure <lb/>language of Ye and Delaware [2023] with Ψ-types, a form of dependent sums (or dependent pairs) <lb/>that packs public views and the oblivious data into a uniform representation. For example, Ψ list ≤ <lb/>is the oblivious list list ≤ with its public view: ⟨2, inr ([10], inr ([20], ()))⟩ and ⟨2, inl ()⟩ are <lb/>elements of type Ψ list ≤ , corresponding to the examples in the previous section. The first component <lb/>of this pair-like syntax is a public view and the second component is an OADT whose public view <lb/>is exactly the first component. This allows users to again derive a private filter function from its <lb/>type signature: <lb/>fn filter ≤ : Ψ list ≤ → Z → Ψ list ≤ = %lift filter <lb/>Users no longer need to explicitly provide the public views for either the output or any intermediate <lb/>subroutines: both are automatically inferred. As a result, the policy specification of filter ≤ more <lb/>directly corresponds to the type signature of filter. In addition, specifying policies using Ψ-types <lb/></body>

        <note place="footnote">5 We refer interested readers to Ye and Delaware [2022, 2023] for a complete accounting of tape semantics. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:7 <lb/></page>

        <body>avoids mistakes in the supplied public views: using Taype, if the programmer mistakenly specifies <lb/>the return type list ≤ (k-1) for a secure version of filter, for example, the resulting implementation <lb/>may truncate the last element of the result list. A keyword %lift is used to translate the standard <lb/>non-secure function filter to a private version that respects the policy specification. <lb/>To understand how this translation works, consider a naive approach where each algebraic data <lb/>type (ADT) is thought of as an abstract interface, whose operations correspond to the introduction <lb/>and elimination forms of the algebraic data type 6 . An ADT, e.g., list, as well as any corresponding <lb/>Ψ-type, e.g., Ψ list ≤ and Ψ list = , are implementations or instances of this interface. For example, an <lb/>interface for list operations is: <lb/>ListLike t = {Nil : <lb/>→ t; Cons : Z × t → t; match : t → ( → α) → ( Z × t → α) → α} <lb/>As long as Ψ list ≤ and Ψ list = implement this interface, we could straightforwardly translate <lb/>filter to a secure version: <lb/>fn filter ≤ : Ψ list ≤ → Z → Ψ list ≤ = xs y ⇒ <lb/>list ≤ #match xs ( _ ⇒ list ≤ #Nil ()) <lb/>( (x, xs ′ ) ⇒ <lb/>mux (x ≤ y) ( list ≤ #Cons x ( filter ≤ xs ′ y)) <lb/>( filter ≤ xs ′ y)) <lb/>fn filter = : Ψ list = → Z → Ψ list = = xs y ⇒ <lb/>list = #match xs ( _ ⇒ list = #Nil ()) <lb/>( (x, xs ′ ) ⇒ <lb/>mux (x ≤ y) ( list = #Cons x ( filter = xs ′ y)) <lb/>( filter = xs ′ y)) <lb/>This strategy does not rely on unsafe retractions like list ≤ #r, as private data always remains <lb/>in its secure form, eliminating the need to defer unsafe computations, which is the source of <lb/>exponential slowdowns in Taype. Unfortunately, there are several obstacles to directly implementing <lb/>this strategy. First, an ADT and an OADT may not agree on the type signatures of the abstract <lb/>interface. ListLike fixes the argument types of operations like Cons and match, meaning that list <lb/>is not an instance of this abstract interface, despite list being a very reasonable (albeit very <lb/>permissive) policy! In general, different OADTs may only be able to implement operations with <lb/>specific signatures. Second, a private function may involve a mixture of oblivious types. Thus, some <lb/>functions may need to coerce from one type to a &quot;more&quot; secure version. For example, if the policy <lb/>of filter ≤ is Ψ list ≤ → Z → Ψ list ≤ , its second argument y will need to be converted to Z in order to <lb/>evaluate x ≤ y. A secure list that discloses its exact length may similarly need to be converted to one <lb/>disclosing its maximum length. Third, this naive translation results in ill-typed programs, because <lb/>the branches of a mux may have mismatched public views. In filter ≤ , for example, the branches of <lb/>mux may evaluate to ⟨2, [Cons,10,Cons,20]⟩ and ⟨1, [Cons,20]⟩, respectively. Thus, Taypsi&apos;s secure <lb/>type system will (rightly) reject filter ≤ as leaky. Lastly, the signatures that should be ascribed to <lb/>any subsidiary function calls may not be obvious. Consider the following client of filter: <lb/>fn filter5 : list → list = xs ⇒ filter xs 5 <lb/>If filter5 is given a signature Ψ list ≤ → Ψ list ≤ , we would like to use a secure version of the filter <lb/>function with the type Ψ list ≤ → Z → Ψ list ≤ , as the threshold argument is publicly known. In <lb/>general, a function may have many private versions, and we should infer which version to use at <lb/>each callsite: a recursive function may even recursively call a different &quot;version&quot; of itself. <lb/>To solve these challenges, we generalize the abstract interface described above into a set of <lb/>more flexible structures, which we collectively refer to as Ψ-structures (Section 4). Intuitively, each <lb/>category of Ψ-structures solves one of the challenges described above. Our translation algorithm <lb/>(Section 5) generates a set of typing constraints for the intermediate expressions in a program. These <lb/>constraints are then solved using the set of available Ψ-structures, resulting in multiple private <lb/>versions of the necessary functions and ruling out the infeasible ones, e.g., filter = . <lb/></body>

        <note place="footnote">6 As Taypsi already supports general recursion, we use pattern matching instead of recursion schemes as our elimination <lb/>forms. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:8 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>OADT-structure <lb/>fn list ≤ #s : (k : N) → list → list ≤ k = <lb/>k xs ⇒ <lb/>if k = 0 then () <lb/>else match xs with Nil ⇒ inl () <lb/>| Cons x xs ′ ⇒ <lb/>inr ( Z#s x, list ≤ #s (k-1) xs ′ ) <lb/>fn list ≤ #view : list → N = length <lb/>unsafe fn list ≤ #r : (k : N) → list ≤ k → list = <lb/>k ⇒ <lb/>if k = 0 then _ ⇒ Nil <lb/>else xs ⇒ <lb/>match xs with inl _ ⇒ Nil <lb/>| inr (x, xs ′ ) ⇒ <lb/>Cons ( Z#r x) ( list ≤ #r (k-1) xs ′ ) <lb/>Intro/elim-structure <lb/>fn list ≤ #Nil : <lb/>→ Ψ list ≤ = _ ⇒ ⟨0, ()⟩ <lb/>fn list ≤ #Cons : Z × Ψ list ≤ → Ψ list ≤ = <lb/>(x, ⟨k, xs⟩) ⇒ <lb/>⟨k+1, inr (x, xs)⟩ <lb/>fn list ≤ #match : <lb/>Ψ list ≤ → ( → α) → ( Z × Ψ list ≤ → α) → α = <lb/>⟨k, xs⟩ f1 f2 ⇒ <lb/>(if k = 0 then _ ⇒ f1 () <lb/>else xs ⇒ <lb/>match xs with inl _ ⇒ f1 () <lb/>| inr (x, xs ′ ) ⇒ f2 (x, ⟨k-1, xs ′ ⟩) <lb/>: list ≤ k → α) xs <lb/>Join-structure <lb/>fn list ≤ #join : N → N → N = max <lb/>fn list ≤ #reshape : (k : N) → (k ′ : N) → list ≤ k → list ≤ k ′ = k k ′ ⇒ <lb/>if k ′ = 0 then _ ⇒ () <lb/>else if k = 0 then _ ⇒ inl () <lb/>else xs ⇒ match xs with inl _ ⇒ inl () <lb/>| inr (x, xs ′ ) ⇒ inr (x, list ≤ #reshape (k-1) (k ′ -1) xs ′ ) <lb/>Fig. 4. Ψ-structures of list ≤ <lb/>Figure 4 presents the methods of each category of Ψ-structures of list ≤ . The first two methods, <lb/>list ≤ #s and list ≤ #r, are its section and retraction functions, belonging to the OADT-structure <lb/>category. Unlike Taype, these two functions are not directly used to derive secure implementations <lb/>of functions. In fact, our type system guarantees that retraction functions are never used in a secure <lb/>computation, because Taypsi does not rely on tape semantics to repair unsafe computation (the <lb/>unsafe fn keyword tells our type checker that list ≤ #r is potentially leaky). Our implementation of <lb/>Taypsi exposes section and retraction functions as part of the API of the secure library it generates, <lb/>however, so that client programs can conceal their private input and reveal the output of secure <lb/>computations. This structure also includes a view method, which our translation uses to select the <lb/>public view needed to safely convert a list into a Ψ list ≤ . Figure 4 does not show coercion methods, <lb/>but the programmers can define a coercion from Ψ list = to Ψ list ≤ , for example. <lb/>The next set of methods belong to the intro-structure and elim-structure category. These intro-<lb/>duction ( list ≤ #Nil and list ≤ #Cons) and elimination ( list ≤ #match) methods construct and destruct <lb/>private list, respectively. As we construct and manipulate data, these methods build the private <lb/>version, calculate its public view, and record that view in Ψ-types. Their type signatures are specified <lb/>by the programmers, as long as the signatures are compatible with Z × list (Section 4). <lb/>The join and reshape methods in the join-structure category enable translated programs to <lb/>include private conditionals whose branches return OADT values with different public views. As <lb/>an example, consider the following private conditional whose branches have Ψ-types: <lb/>mux [true] ⟨2, [Cons,10,Cons,20]⟩ ⟨1, [Cons,20]⟩ <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:9 <lb/></page>

        <body>To build a version of this program that does not reveal [true], Taypsi uses join to calculate a common <lb/>public view that &quot;covers&quot; both branches. In this example, list ≤ #join chooses a public view of 2, as a <lb/>list with at most one element also has at most two elements. Our translation then uses the reshape <lb/>method to convert both branches to use this common public view. In our example, [Cons,20], an <lb/>oblivious list of maximum length 1, is converted into the list [Cons,20,Nil,-], which has maximum <lb/>length 2. Since both branches in the resulting program have the same public view, it is safe to <lb/>evaluate mux: the resulting list is equivalent to ⟨2, mux [true] [Cons,10,Cons,20] [Cons,20,Nil,-]⟩. As <lb/>we will see later, not all OADTs admit join structures, e.g., list = , but our translation generates <lb/>constraints that take advantage of any that are available, failing when these constraints cannot <lb/>be resolved in a way that guarantees security. Note that these two methods are key to avoiding <lb/>the slowdown exhibited by Taype&apos;s enforcement strategy: they allow functions that may return <lb/>different private representations to be eagerly evaluated, instead of being lazily deferred in a way <lb/>that requires an exponential number of subcomputations to resolve. <lb/>In summary, to develop a secure application in Taypsi, programmers first implement its desired <lb/>functionality, e.g., filter, in the public fragment of Taypsi, independently of any particular privacy <lb/>policy. Policies are separately defined as oblivious algebraic data types, e.g., list ≤ , and their Ψ-<lb/>structures. Users can then automatically derive a secure version of their application by providing <lb/>the desired policy in the form of a type signature involving Ψ-types, relying on Taypsi&apos;s compiler to <lb/>produce a privacy-preserving implementation. The type system of Taypsi, like Taype&apos;s, provides a <lb/>strong security guarantee in the form of an obliviousness theorem (Theorem 3.1). This obliviousness <lb/>theorem is a variant of noninterference [Goguen and Meseguer 1982], and ensures that well-typed <lb/>programs in Taypsi are secure by construction: no private information can be inferred even by an <lb/>attacker capable of observing every state of a program&apos;s execution. Our compilation algorithm is <lb/>further guaranteed to generate a secure implementation that preserves the behavior of the original <lb/>program (Theorem 4.8). 7 <lb/>The following three sections formally develop the language Taypsi, the Ψ-structures, and our <lb/>translation algorithm. <lb/>3 TAYPSI, FORMALLY <lb/>This section presents OADTΨ , the core calculus for secure computation that we will use to explain <lb/>our translation. This calculus extends the existing OADT [Ye and Delaware 2022] calculus with <lb/>Ψ-types, and uses ML-style ADTs in lieu of explicit fold and unfold operations. 8 <lb/>3.1 Syntax <lb/>Figure 5 presents the syntax of OADTΨ . Types and expressions are in the same syntax class, as OADTΨ <lb/>is dependently typed, but we use e for expressions and τ for types when possible. A OADTΨ program <lb/>consists of a set of global definitions of data types, functions and oblivious types. Definitions in each <lb/>of these classes are allowed to refer to themselves, permitting recursive types and general recursion <lb/>in both function and oblivious type definitions. We use x for variable names, C for constructor <lb/>names, T for type names, and T for oblivious type names. Each constructor of an ADT definition <lb/>takes exactly one argument, but this does not harm expressivity: this argument is for constructors <lb/>that take no arguments, e.g., Nil, and a tuple of types for constructors that have more than one <lb/>argument, e.g., Cons takes an argument of type Z × list. <lb/></body>

        <note place="footnote">7 Taypsi&apos;s formal guarantees (Section 4.7) do not cover equi-termination of the source and target programs: when the public <lb/>view lacks sufficient information to bound the computation of the original program, the secure version will not terminate, <lb/>in order to avoid leaking information through its termination behavior. <lb/>8 For simplicity, OADTΨ does not include public sums and oblivious integers, which are straightforward to add. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:10 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>e,τ <lb/>Expressions <lb/>| | B | B | τ×τ | τ +τ public &amp; oblivious types | Ψ T <lb/>Ψ-type <lb/>| Πx:τ,τ | x:τ⇒e <lb/>dependent function <lb/>| (e,e) | ⟨e,e⟩ <lb/>pair &amp; Ψ-pair <lb/>| () | b | x | T <lb/>literals &amp; variables <lb/>| π 1 e | π 2 e <lb/>product and Ψ-type projection <lb/>| let x = e in e <lb/>let binding <lb/>| inl&lt;τ&gt; e | inr&lt;τ&gt; e <lb/>oblivious sum injection <lb/>| e e | C e | T e <lb/>applications <lb/>| match e with x⇒e|x⇒e oblivious sum elimination <lb/>| if e then e else e conditional <lb/>| match e with C x⇒e <lb/>ADT elimination <lb/>| mux e e e <lb/>oblivious conditional <lb/>| B#s e <lb/>boolean section <lb/>D <lb/>Global Definitions ω <lb/>| B | ω× ω | ω + ω <lb/>Obliv. Type Values <lb/>| data T = C τ <lb/>algebraic data type <lb/>v <lb/>() | [b] | ( v, v) <lb/>Obliv. Values <lb/>| fn x:τ = e <lb/>(recursive) function <lb/>| [inl&lt; ω&gt; v] | [inr&lt; ω&gt; v] <lb/>| obliv T (x:τ) = τ (recursive) obliv. type <lb/>v <lb/>v | b | (v,v) | ⟨v,v⟩ | x:τ⇒e | C v Values <lb/>Fig. 5. OADTΨ syntax with extensions to OADT highlighted <lb/>In addition to standard types and dependent function types (Π), OADTΨ includes oblivious booleans <lb/>( B) and oblivious sum types ( +). The elimination forms of these types are oblivious conditionals mux <lb/>and oblivious case analysis match, respectively. The branches of both expressions must be private and <lb/>each branch has to be fully evaluated before the expression can take an atomic step to a final result. <lb/>Boolean section B#s is a primitive operation that &quot;encrypts&quot; a boolean expression to an oblivious <lb/>version. Oblivious injection inl and inr are the oblivious counterparts of the standard constructors <lb/>for sums. Other terms are mostly standard, although let bindings (let), conditionals (if) and pattern <lb/>matching (match) are allowed to return a type, as OADTΨ supports type-level computation. <lb/>The key addition over OADT is the Ψ-type, Ψ T. It is constructed from a pair expression ⟨•,•⟩ that <lb/>packs the public view and the oblivious data together, and has the same eliminators π 1 and π 2 as <lb/>normal products. As an example, ⟨3, list ≤ #s 3 (Cons 1 Nil)⟩ creates a Ψ-pair of type Ψ list ≤ with <lb/>public view 3, using the section function from Figure 4. Projecting out the second component of <lb/>a pair using π 2 produces a value of type list ≤ 3. A Ψ-type is essentially a dependent sum type <lb/>(Σx:τ, T x), with the restriction that τ is the public view of T, and that T x is an oblivious type. <lb/>Since OADTΨ has type-level computation, oblivious types have normal forms; oblivious type <lb/>values ( ω) are essentially polynomials formed by primitive oblivious types. We also have the <lb/>oblivious values of oblivious boolean and sum type. Note that these &quot;boxed&quot; values only appear at <lb/>runtime, our semantics use these to model encrypted booleans and tagged sums. <lb/>3.2 Semantics <lb/>Figure 6 shows a selection of the small-step semantics rules of OADTΨ (the full rules are included in <lb/>the appendix), with judgment Σ ⊢ e -→ e ′ . The global context Σ is a map from names to a global <lb/>definition, which is elided for brevity as it is fixed in these rules. The semantics of OADTΨ is similar <lb/>to OADT , with the addition of S-PsiProj 1 (and S-PsiProj 2 ) to handle the projection of dependent <lb/>pairs, which is simply the same as normal projection. S-Ctx reduces subterms according to the <lb/>evaluation contexts defined in Figure 6. The first few contexts take care of the type-level reduction <lb/>of product and oblivious sum type. The type annotation of oblivious injection inl and inr is reduced <lb/>to a type value first, before reducing the payload. The evaluation contexts for mux capture the <lb/>intuition that all components of a private conditional have to be normalized to values first to avoid <lb/>leaking the private condition through control flow channels. <lb/>S-OMatchL (and S-OMatchR) evaluates a pattern matching expression for oblivious sums. <lb/>Similar to mux, oblivious pattern matching needs to ensure the reduction does not reveal private <lb/>information about the discriminee, e.g., whether it is the left injection or right injection. To do <lb/>so, we reduce a match to an oblivious conditional that uses the private tag. The pattern variable in <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:11 <lb/></page>

        <body>e -→ e ′ <lb/>S-Ctx <lb/>e -→ e ′ <lb/>E[e] -→ E[e ′ ] <lb/>S-Fun <lb/>fn x:τ = e ∈ Σ <lb/>x -→ e <lb/>S-OADT <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>T v -→ [v/x]τ ′ <lb/>S-App <lb/>( x:τ⇒e) v -→ [v/x]e <lb/>S-IfTrue <lb/>if true then e 1 else e 2 -→ e 1 <lb/>S-MuxTrue <lb/>mux [true] v 1 v 2 -→ v 1 <lb/>S-Match <lb/>match C v with C x⇒e -→ [v/x]e <lb/>S-Proj 1 <lb/>π 1 (v 1 ,v 2 ) -→ v 1 <lb/>S-Sec <lb/>B#s b -→ [b] <lb/>S-OInl <lb/>inl&lt; ω&gt; v -→ [inl&lt; ω&gt; v] <lb/>S-PsiProj 1 <lb/>π 1 ⟨v 1 ,v 2 ⟩ -→ v 1 <lb/>S-OMatchL <lb/>v 2 ⇐ ω 2 <lb/>match [inl&lt; ω 1 + ω 2 &gt; v] with x⇒e 1 |x⇒e 2 -→ mux [true] ([ v/x]e 1 ) ([ v 2 /x]e 2 ) <lb/>E <lb/>Evaluation Context <lb/>| <lb/>□×τ | ω×□ | □ +τ | ω +□ | e □ | □ v | C □ | T □ | if □ then e else e <lb/>| <lb/>mux □ e e | mux v □ e | mux v v □ <lb/>| <lb/>(□,e) | (v,□) | ⟨□,e⟩ | ⟨v,□⟩ | π 1 □ | match □ with C x ⇒ e <lb/>| <lb/>inl&lt;□&gt; e | inl&lt; ω&gt; □ | match □ with x⇒e|x⇒e | B#s □ | . . . <lb/>Fig. 6. Selected small-step semantics rules of OADTΨ <lb/>the &quot;correct&quot; branch is of course instantiated by the payload in the discriminee, while the pattern <lb/>variable in the &quot;wrong&quot; branch is an arbitrary value of the corresponding type, synthesized from <lb/>the judgment v ⇐ ω, whose definition is in appendix. When evaluating a match statement whose <lb/>discriminee is [inl&lt; B + B× B&gt; [true]], the pattern variable in the second branch can be substituted by <lb/>([true],[true]), ([false],[true]), or any other pair of oblivious booleans. <lb/>3.3 Type System <lb/>Similar to OADT , types in OADTΨ are classified by kinds which specify how protected a type is, in <lb/>addition to ensuring the types are well-formed. For example, an oblivious type, e.g., B, kinded by <lb/> * O , can be used as branches of an oblivious conditional, but not as a public view, which can only <lb/>be kinded by * P . A mixed kind * M is used to classify function types and types that consist of both <lb/>public and oblivious components, e.g., B× B. A type with a mixed kind cannot be used as a public <lb/>view or in private context. <lb/>The type system of OADTΨ is defined by a pair of typing and kinding judgments, Σ; Γ ⊢ e : τ and <lb/>Σ; Γ ⊢ τ :: κ, with global context Σ (which is again elided for brevity) and the standard typing context <lb/>Γ. Figure 7 presents a subset of our typing and kinding rules; the full rules are in appendix. <lb/>The security type system [Sabelfeld and Myers 2003] of OADTΨ enforces a few key invariants. <lb/>First, oblivious types can only be constructed from oblivious types, which is enforced by the kinding <lb/>rules, such as K-OSum. Otherwise, the attacker could infer the private tag of an oblivious sum, e.g., <lb/>B + , by observing its public payload. Second, oblivious operations, e.g., mux, require their subterms <lb/>to be oblivious, to avoid leaking private information via control flow channels. T-Mux, for example, <lb/>requires both branches to be typed by an oblivious type, otherwise an attacker may infer the private <lb/>condition by observing the result, as in mux [true] true false. Third, type-level computation is only <lb/>defined for oblivious types and cannot depend on private information. Thus, K-If requires both <lb/>branches to have oblivious kinds, and the condition to be a public boolean. The type mux [true] B <lb/>is ill-typed, since the &quot;shape&quot; of the data reveals the private condition. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:12 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>Γ ⊢ e : τ <lb/>T-Conv <lb/>Γ ⊢ e : τ <lb/>τ ≡ τ ′ <lb/>Γ ⊢ τ ′ :: * <lb/>Γ ⊢ e : τ ′ <lb/>T-Abs <lb/>x : τ 1 , Γ ⊢ e : τ 2 <lb/>Γ ⊢ τ 1 :: * <lb/>Γ ⊢ x:τ 1 ⇒e : Πx:τ 1 ,τ 2 <lb/>T-App <lb/>Γ ⊢ e 2 : Πx:τ 1 ,τ 2 <lb/>Γ ⊢ e 1 : τ 1 <lb/>Γ ⊢ e 2 e 1 : [e 1 /x]τ 2 <lb/>T-If <lb/>Γ ⊢ e 0 : B <lb/>Γ ⊢ e 1 : [true/y]τ <lb/>Γ ⊢ e 2 : [false/y]τ <lb/>Γ ⊢ if e 0 then e 1 else e 2 : [e 0 /y]τ <lb/>T-Mux <lb/>Γ ⊢ e 0 : B <lb/>Γ ⊢ τ :: * O <lb/>Γ ⊢ e 1 : τ <lb/>Γ ⊢ e 2 : τ <lb/>Γ ⊢ mux e 0 e 1 e 2 : τ <lb/>T-PsiPair <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>Γ ⊢ e 1 : τ <lb/>Γ ⊢ e 2 : T e 1 <lb/>Γ ⊢ ⟨e 1 ,e 2 ⟩ : Ψ T <lb/>T-PsiProj 1 <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>Γ ⊢ e : Ψ T <lb/>Γ ⊢ π 1 e : τ <lb/>T-PsiProj 2 <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>Γ ⊢ e : Ψ T <lb/>Γ ⊢ π 2 e : T (π 1 e) <lb/>Γ ⊢ τ :: κ <lb/>K-Sub <lb/>Γ ⊢ τ :: κ <lb/>κ ⊑ κ ′ <lb/>Γ ⊢ τ :: κ ′ <lb/>K-OADT <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>Γ ⊢ e : τ <lb/>Γ ⊢ T e :: * O <lb/>K-Pi <lb/>Γ ⊢ τ 1 :: * <lb/>x : τ 1 , Γ ⊢ τ 2 :: * <lb/>Γ ⊢ Πx:τ 1 ,τ 2 :: * M <lb/>K-OSum <lb/>Γ ⊢ τ 1 :: * O <lb/>Γ ⊢ τ 2 :: * O <lb/>Γ ⊢ τ 1 +τ 2 :: * O <lb/>K-Psi <lb/>obliv T (x:τ) = τ ′ ∈ Σ <lb/>Γ ⊢ Ψ T :: * M <lb/>K-If <lb/>Γ ⊢ e 0 : B <lb/>Γ ⊢ τ 1 :: * O <lb/>Γ ⊢ τ 2 :: * O <lb/>Γ ⊢ if e 0 then τ 1 else τ 2 :: * O <lb/>Fig. 7. Selected typing and kinding rules of OADTΨ <lb/>Σ ⊢ D <lb/>DT-Fun <lb/>• ⊢ τ :: * <lb/>• ⊢ e : τ <lb/>Σ ⊢ fn x:τ = e <lb/>DT-ADT <lb/>∀ . • ⊢ τ :: * P <lb/>Σ ⊢ data T = C τ <lb/>DT-OADT <lb/>• ⊢ τ :: * P <lb/>x : τ ⊢ τ ′ :: * O <lb/>Σ ⊢ obliv T (x:τ) = τ ′ <lb/>Fig. 8. OADTΨ global definitions typing <lb/>The typing rules for Ψ-types are defined similarly to the rules of standard dependent sums. <lb/>T-PsiPair introduces a dependent pair, where the type of the second component depends on the <lb/>first component. In contrast to standard dependent sum type, Ψ-type has the restriction that the <lb/>first component must be public, and the second component must be oblivious. This condition <lb/>is implicitly enforced by the side condition that T is an OADT with public view type τ. Figure 8 <lb/>shows the typing rules for global definitions; DT-OADT prescribes exactly this restriction. The <lb/>rules for the first and second projection of Ψ-type, T-PsiProj 1 and T-PsiProj 2 , are very similar <lb/>to the corresponding rules for standard dependent sum types. Observe that a Ψ-type always has <lb/>mixed kind, as in K-Psi, because it consists of both public and oblivious components. <lb/>T-Conv allows conversion between equivalent types, such as if true then B else and B. The <lb/>equivalence judgment τ ≡ τ ′ is defined by a set of parallel reduction rules, which we elide here. The <lb/>converted type is nonetheless required to be well-kinded. <lb/>Note that these rules cannot be used to type check retraction functions, e.g., list ≤ #r from Figure 4, <lb/>and for good reason: these functions reveal private information. Nevertheless, we still want to <lb/>check that these sorts of &quot;leaky&quot; functions have standard type safety properties, i.e., progress and <lb/>preservation. To do so, we use a version of these rules that simply omit some security-related <lb/>side-conditions about oblivious kinding: removing Γ ⊢ τ :: * O from T-Mux allows the branches of a <lb/>mux to disclose the private condition, for example. The implementation of Taypsi&apos;s type checker <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:13 <lb/></page>

        <body>uses a &quot;mode&quot; flag to indicate whether security-related side-conditions should be checked. Our <lb/>implementation ensures that secure functions never use any leaky functions. <lb/>3.4 Metatheory <lb/>With our addition of Ψ-types, OADTΨ enjoys the standard type safety properties (i.e., progress and <lb/>preservation), and, more importantly, the same security guarantees as OADT : <lb/>Theorem 3.1 (Obliviousness). If e 1 ≈ e 2 and • ⊢ e 1 : τ 1 and • ⊢ e 2 : τ 2 , then <lb/>(1) e 1 -→ e ′ <lb/>1 if and only if e 2 -→ e ′ <lb/>2 for some e ′ <lb/>2 . <lb/>(2) if e 1 -→ e ′ <lb/>1 and e 2 -→ e ′ <lb/>2 , then e ′ <lb/>1 ≈ e ′ <lb/>2 . <lb/>Here, e ≈ e ′ means the two expressions are indistinguishable, i.e., they only differ in their unob-<lb/>servable oblivious values, and e -→ e ′ means e reduces to e ′ in exactly steps. This obliviousness <lb/>theorem provides a strong security guarantee: well-typed programs that are indistinguishable <lb/>produce traces that are pairwise indistinguishable. In other words, an attacker cannot infer any <lb/>private information even by observing the execution trace of a program. All these results are <lb/>mechanized in the Coq theorem prover, including the formalization of the core calculus and the <lb/>proofs of soundness and obliviousness theorems. <lb/>4 Ψ-STRUCTURES AND DECLARATIVE LIFTING <lb/>While our secure language makes it possible to encode structured data and privacy policies, and use <lb/>them in a secure way, it does not quite achieve our main goal yet, i.e., to decouple privacy policies <lb/>and programmatic concerns. To do so, we allow the programmers to implement the functionality <lb/>of their secure application in a conventional way, that is using only the public, nondependent <lb/>fragment of Taypsi. We make this fragment explicit by requiring such programs to have simple types, <lb/>denoted by η, defined in Figure 9. For example, filter has simple type list → Z → list. Programs <lb/>of simple types are the source programs to our lifting process that translates them to a private <lb/>version against a policy, which stipulates the public information allowed to disclose in the program <lb/>input and output. This policy on private functionality is specified by a specification type, denoted <lb/>by θ, defined also in Figure 9. For example, filter ≤ has specification type Ψ list ≤ → Z → Ψ list ≤ . <lb/>Note that dependent types are not directly allowed in specifications, they are instead encapsulated <lb/>in Ψ-types. Simple types and specification types are additionally required to be well-kinded under <lb/>empty local context, i.e., all ADTs and OADTs appear in them are defined. <lb/>However, not all specification types are valid with respect to a simple type. It is nonsensical to <lb/>give filter the specification type Z → B, for example. The specification types should still correspond <lb/>to the simple types in some way: the specification type corresponding to list should at least be <lb/>&quot;list-like&quot;. This correspondence is formally captured in the erasure function in Figure 9, which <lb/>maps a specification type to the &quot;underlying&quot; simple type. For example, Ψ list ≤ is erased to list. <lb/>This function clearly induces an equivalence relation: the erasure ⌊θ⌋ is the representative of <lb/>the equivalence class. We call this equivalence class a compatibility class, and say two types are <lb/>compatible if they belong to the same compatibility class. For example, list, Ψ list ≤ and Ψ list = <lb/>are in the same compatibility class [list]. This erasure operation is straightforwardly extended to <lb/>typing contexts, ⌊Γ ⌋, by erasing every specification type in Γ and leaving other types untouched. <lb/>Our translation transforms source programs with simple types into target programs with the <lb/>desired (compatible) specification types. As mentioned in Section 2, this lifting process depends on <lb/>a set of -structures which explain how to translate certain operations associated with an OADT. <lb/>4.1 OADT Structures <lb/>Every global OADT definition T must be equipped with an OADT-structure, defined below. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:14 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>Simple types <lb/>η <lb/>| B | T | η×η | η→η <lb/>specification types <lb/>θ <lb/>| B | B | T | Ψ T | θ×θ | θ→θ <lb/>⌊θ⌋ <lb/>⌊ ⌋ = <lb/>⌊B⌋ = ⌊ B⌋ = B <lb/>⌊T⌋ = T where T is an ADT <lb/>⌊Ψ T⌋ = T where T is an OADT for T <lb/>⌊θ×θ⌋ = ⌊θ⌋× ⌊θ⌋ <lb/>⌊θ→θ⌋ = ⌊θ⌋→⌊θ⌋ <lb/>Fig. 9. Simple types, specification types and erasure <lb/>Definition 4.1 (OADT-structure). An OADT-structure of an OADT T, with public view type τ, <lb/>consists of the following (Taypsi) type and functions: <lb/>• A public type T :: * P , which is the public counterpart of T. We say T is an OADT for T. <lb/>• A section function s : Πk:τ,T→ T k, which converts a public type to its oblivious counterpart. <lb/>• A retraction function r : Πk:τ, T k→T, which converts an oblivious type to its public version. <lb/>• A public view function : T→τ, which creates a valid view of the public type. <lb/>• A binary relation ≼ over values of types T and τ; v ≼ k reads as v has public view k, or k is a <lb/>valid public view of v. <lb/>These operations are required to satisfy the following axioms: <lb/>• (A-O 1 ) s and r are a valid section and retraction, i.e., r is a left-inverse for s, given a valid <lb/>public view: for any values v : T, k : τ and v : T k, if v ≼ k and s k v -→ * v, then r k v -→ * v. <lb/>• (A-O 2 ) the result of r always has valid public view: r k v -→ * v implies v ≼ k for all values <lb/>k : τ, v : T k and v : T. <lb/>• (A-O 3 ) produces a valid public view: v -→ * k implies v ≼ k, given any values v : T and k : τ. <lb/>For example, list ≤ is equipped with the OADT-structure with the public type list, section <lb/>function list ≤ #s, retraction function list ≤ #r and view function list ≤ #view, all of which are shown <lb/>in Figure 4. Taypsi users do not need to explicitly give the public type of an OADT-structure, as it <lb/>can be inferred from the types of the other functions. The binary relation ≼ is only used in the proof <lb/>of correctness of our translation, so Taypsi users can also elide it. In the case of list ≤ , ≼ simply <lb/>states the length of the list is no larger than the public view. <lb/>4.2 Join Structures <lb/>In order for Ψ-types to be flexibly used in the branches of secure control flow structures, our <lb/>translation must be able to find a common public view for both branches, and to convert an OADT <lb/>to use this view. To do so, an OADT can optionally be equipped with a join-structure. <lb/>Definition 4.2 (join-structure). A join-structure of an OADT T for T, with public view type τ, <lb/>consists of the following operations: <lb/>• A binary relation ⊑ on τ, used to compare two public views. <lb/>• A join function ⊔ : τ→τ→τ, which computes an upper bound of two public views 9 . <lb/>• A reshape function <lb/>↩→ <lb/>: Πk:τ,Πk ′ :τ, T k→ T k ′ , which converts an OADT to one with a different <lb/>public view. <lb/>such that: <lb/>• (A-R 1 ) ⊑ is a partial order on τ. <lb/>• (A-R 2 ) the join function produces an upper bound: given values k 1 , k 2 and k of type τ, if <lb/>k 1 ⊔k 2 -→ * k, then k 1 ⊑ k and k 2 ⊑ k. <lb/></body>

        <note place="footnote">9 It is a bit misleading to call the operation ⊔ &quot;join&quot;, as it only computes an upper bound, not necessarily the lowest one. <lb/>However, it should compute a supremum for performance reasons: intuitively, larger public view means more padding. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:15 <lb/></page>

        <body>θ ▷ ite <lb/>θ ∈ { , B } <lb/>θ ▷ b x y⇒mux b x y <lb/>θ 1 ▷ ite 1 <lb/>θ 2 ▷ ite 2 <lb/>θ 1 ×θ 2 ▷ b x y⇒( ite 1 b (π 1 x) (π 1 y), ite 2 b (π 2 x) (π 2 y)) <lb/>θ 2 ▷ ite 2 <lb/>θ 1 →θ 2 ▷ b x y⇒ z⇒ ite 2 b (x z) (y z) <lb/>( T, ⊔, <lb/>↩→ <lb/>) ∈ S ⊔ <lb/>Ψ T ▷ <lb/>b x y⇒let k = π 1 x ⊔ π 1 y in <lb/>⟨k,mux b ( <lb/>↩→ <lb/>(π 1 x) k (π 2 x)) <lb/>( <lb/>↩→ <lb/>(π 1 y) k (π 2 y))⟩ <lb/>Fig. 10. Mergeability <lb/>• (A-R 3 ) the validity of public views is monotone with respect to the binary relation ⊑: for any <lb/>values v : T, k : τ and k ′ : τ, if v ≼ k and k ⊑ k ′ , then v ≼ k ′ . <lb/>• (A-R 4 ) the reshape function produces equivalent value, as long as the new public view is valid: <lb/>for any values v : T, k : τ, k ′ : τ, v : T k and v ′ : T k ′ , if r k v -→ * v and v ≼ k ′ and <lb/>↩→ <lb/>k k ′ v -→ * v ′ , <lb/>then r k ′ v ′ -→ * v. <lb/>Figure 4 defines the join and reshape functions list ≤ #join and list ≤ #reshape. The partial order for <lb/>this join structure is simply the total order on integers, and the join is simply the maximum of the <lb/>two numbers. Not all OADTs have a sensible join-structure: oblivious lists using their exact length <lb/>as a public view cannot be combined if they have different lengths. If such lists are the branches of <lb/>an oblivious conditional, lifting will either fail or coerce both to an OADT with a join-structure. <lb/>Join structures induce a mergeability relation, defined in Figure 10, that can be used to decide if <lb/>a specification type can be used in oblivious conditionals. We say θ is mergeable if θ ▷ ite, with <lb/>witness ite of type B→θ→θ→θ. We will write θ when we do not care about the witness. This <lb/>witness can be thought of as a generalized, drop-in replacement of mux: we simply translate mux to <lb/>the derived ite if the result type is mergeable. The case of Ψ-type captures this intuition: we first <lb/>join the public views, and reshape all branches to this common public view, before we select the <lb/>correct one privately using mux. This rule looks up the necessary methods from the context of join <lb/>structures S ⊔ . Other cases are straightforward: we simply fall back to mux for primitive types, and <lb/>the derivation for product and function types are done congruently. <lb/>4.3 Introduction and Elimination Structures <lb/>An ADT is manipulated by its introduction and elimination forms. To successfully lift a public <lb/>program using ADTs, we need structures to explain how the primitive operations of its ADTs <lb/>are handled in their OADT counterparts. Thus, an OADT T can optionally be equipped with an <lb/>introduction-structure (intro-structure) and an elimination-structure (elim-structure), defined below. <lb/>These structures are optional because some programs only consume ADTs, without constructing <lb/>any new ADT values (and vice versa): a function that checks membership in a list only requires <lb/>an elim-structure on lists, for example. Intuitively, the axioms of these structures require the <lb/>introduction and elimination methods of an OADT to behave like those of the corresponding ADT. <lb/>This is formalized using a pair of logical refinement relations on values (V • ) and expressions <lb/>(E • ); these relations are formally defined in Section 4.6. <lb/>Definition 4.3 (intro-structure). An intro-structure of an OADT T for ADT T, with global definition <lb/>data T = C η, consists of a set of functions C , each corresponding to a constructor C . The type of C <lb/>is θ →Ψ T, where ⌊θ ⌋ = η (note that DT-ADT guarantees that η is a simple type). The particular θ <lb/>an intro-structure uses is determined by the author of that structure. Each C is required to logically <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:16 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>θ ↣ θ ′ ▷ ↑ <lb/>θ ↣ θ ▷ x⇒x <lb/>B ↣ B ▷ x⇒ B#s x <lb/>( T, T, s, r, , ≼) ∈ S ω <lb/>T ↣ Ψ T ▷ x⇒⟨ x,s ( x) x⟩ <lb/>↑ : Ψ T→Ψ T ′ ∈ S ↑ <lb/>Ψ T ↣ Ψ T ′ ▷ ↑ <lb/>θ 1 ↣ θ ′ <lb/>1 ▷ ↑ 1 <lb/>θ 2 ↣ θ ′ <lb/>2 ▷ ↑ 2 <lb/>θ 1 ×θ 2 ↣ θ ′ <lb/>1 ×θ ′ <lb/>2 ▷ x⇒(↑ 1 (π 1 x),↑ 2 (π 2 x)) <lb/>θ ′ <lb/>1 ↣ θ 1 ▷ ↑ 1 <lb/>θ 2 ↣ θ ′ <lb/>2 ▷ ↑ 2 <lb/>θ 1 →θ 2 ↣ θ ′ <lb/>1 →θ ′ <lb/>2 ▷ x⇒ y⇒↑ 2 (x (↑ 1 y)) <lb/>Fig. 11. Coercion <lb/>refine the corresponding constructor (A-I 1 ): given any values v : ⌊θ⌋ and v ′ : θ, if (v, v ′ ) ∈ V θ , then <lb/>(C v, C v ′ ) ∈ E Ψ T . <lb/>Definition 4.4 (elim-structure). An elim-structure of an OADT T for ADT T, with global definition <lb/>data T = C η, consists of a family of functions match α , indexed by the possible return types. The type <lb/>of match α is Ψ T→(θ→α)→α, where ⌊θ ⌋ = η for each θ in the function arguments corresponding to <lb/>alternatives. Each match α is required to logically refine the pattern matching expression, specialized <lb/>with ADT T and return type α. The sole axiom of this structure (A-E 1 ) only considers return type <lb/>α being a specification type: given values v : η , ⟨k, v⟩ : T k, x⇒e : ⌊θ ⌋→⌊α⌋ and x⇒e ′ : θ →α, if <lb/>r k v -→ * C v and ( x⇒e , x⇒e ′ ) ∈ V θ →α then ([v /x]e , match ⟨k, v⟩ ( x⇒e ′ ) ) ∈ E α . <lb/>The types of the oblivious introduction and elimination forms in these structures are only <lb/>required to be compatible with the public counterparts. The programmers can choose which <lb/>specific OADTs to use according to their desired privacy policy. Figure 4 shows the constructors <lb/>and pattern matching functions for list ≤ . <lb/>The elim-structure of an OADT consists of a family of destructors, whose return type α does not <lb/>necessarily range over all types. For example, match α of list ≤ , list ≤ #match in Figure 4, requires α <lb/>to be a mergeable type, due to the use of match, which imposes a restriction similarly to mux. Such <lb/>constraints on α are automatically inferred and enforced. <lb/>4.4 Coercion Structures <lb/>As discussed in Section 2, we may need to convert an oblivious type to another, either due to a <lb/>mismatch from input to output, or due to its lack of certain structures. For example, list = does not <lb/>have join structure, so if the branches of an oblivious conditional has type Ψ list = , they should be <lb/>coerced to Ψ list ≤ , when such a coercion is available. <lb/>Two compatible OADTs may form a coercion-structure, shown below. <lb/>Definition 4.5 (coercion-structure). A coercion-structure of a pair of compatible OADTs T and T ′ <lb/>for T, with public view type τ and τ ′ respectively, consists of a coercion function ↑ of type Ψ T→Ψ T ′ . <lb/>The coercion should produce an equivalent value (A-C 1 ): given values v : T, ⟨k, v⟩ : Ψ T and ⟨k ′ , v ′ ⟩ : Ψ T ′ , <lb/>if r k v -→ * v and ↑⟨k, v⟩ -→ * ⟨k ′ , v ′ ⟩, then r k ′ v ′ -→ * v. <lb/>This structure only defines the coercion between two Ψ-types. Figure 11 generalizes the coercion <lb/>relation to any (compatible) specification types. We say θ is coercible to θ ′ if θ ↣ θ ′ ▷ ↑, with witness ↑ <lb/>of type θ→θ ′ . We may write θ ↣ θ ′ when we do not care about the witness. The rules of this relation <lb/>are straightforward. The context of coercion structures S ↑ and the context of OADT structures <lb/>S ω are used to look up the necessary methods in the corresponding rules. The rule for coercing <lb/>a function type is contravariant. Note that we can always coerce a public type to an OADT by <lb/>running the section function, and the public view can be selected by the view function in the OADT <lb/>structure. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:17 <lb/></page>

        <body>Γ ⊢ e : θ ▷ e <lb/>L-Lit <lb/>Γ ⊢ b : B ▷ b <lb/>L-Var <lb/>x : θ ∈ Γ <lb/>Γ ⊢ x : θ ▷ x <lb/>L-Fun <lb/>x : θ ▷ x ∈ L <lb/>Γ ⊢ x : θ ▷ x <lb/>L-Abs <lb/>x : θ 1 , Γ ⊢ e : θ 2 ▷ e <lb/>Γ ⊢ x:⌊θ 1 ⌋⇒e : θ 1 →θ 2 ▷ x:θ 1 ⇒ e <lb/>L-App <lb/>Γ ⊢ e 2 : θ 1 →θ 2 ▷ e 2 <lb/>Γ ⊢ e 1 : θ 1 ▷ e 1 <lb/>Γ ⊢ e 2 e 1 : θ 2 ▷ e 2 e 1 <lb/>L-Let <lb/>Γ ⊢ e 1 : θ 1 ▷ e 1 <lb/>x : θ 1 , Γ ⊢ e 2 : θ 2 ▷ e 2 <lb/>Γ ⊢ let x = e 1 in e 2 : θ 2 ▷ let x = e 1 in e 2 <lb/>L-If 1 <lb/>Γ ⊢ e 0 : B ▷ e 0 <lb/>Γ ⊢ e 1 : θ ▷ e 1 <lb/>Γ ⊢ e 2 : θ ▷ e 2 <lb/>Γ ⊢ if e 0 then e 1 else e 2 : θ ▷ if e 0 then e 1 else e 2 <lb/>L-If 2 <lb/>Γ ⊢ e 0 : B ▷ e 0 <lb/>θ ▷ ite <lb/>Γ ⊢ e 1 : θ ▷ e 1 <lb/>Γ ⊢ e 2 : θ ▷ e 2 <lb/>Γ ⊢ if e 0 then e 1 else e 2 : θ ▷ ite e 0 e 1 e 2 <lb/>L-Ctor 1 <lb/>data T = C η ∈ Σ <lb/>Γ ⊢ e : η ▷ e <lb/>Γ ⊢ C e : T ▷ C e <lb/>L-Ctor 2 <lb/>C : θ →Ψ T ∈ S <lb/>Γ ⊢ e : θ ▷ e <lb/>Γ ⊢ C e : Ψ T ▷ C e <lb/>L-Match 1 <lb/>data T = C η ∈ Σ <lb/>Γ ⊢ e 0 : T ▷ e 0 <lb/>∀ . x : η , Γ ⊢ e : θ ′ ▷ e <lb/>Γ ⊢ match e 0 with C x⇒e : θ ′ ▷ match e 0 with C x⇒ e <lb/>L-Match 2 <lb/>match : Ψ T→(θ→θ ′ )→θ ′ ∈ S <lb/>Γ ⊢ e 0 : Ψ T ▷ e 0 <lb/>∀ . x : θ , Γ ⊢ e : θ ′ ▷ e <lb/>Γ ⊢ match e 0 with C x⇒e : θ ′ ▷ match e 0 ( x:θ⇒ e) <lb/>L-Coerce <lb/>Γ ⊢ e : θ ▷ e <lb/>θ ↣ θ ′ ▷ ↑ <lb/>Γ ⊢ e : θ ′ ▷ ↑ e <lb/>Fig. 12. Selected declarative li ing rules <lb/>4.5 Declarative Li ing <lb/>With these Ψ-structures, we define a declarative lifting relation, which describes what the lifting <lb/>procedure is allowed to derive at a high level. This lifting relation is given by the judgment <lb/>S; L; Σ; Γ ⊢ e : θ ▷ e. It is read as the expression e of type ⌊θ⌋ is lifted to the expression e of target type θ, <lb/>under various contexts. The Ψ-structure context S consists of the set of OADT-structures (S ω ), join-<lb/>structures (S ⊔ ), intro-structures (S ), elim-structures (S ) and coercion-structures (S ↑ ), respectively. <lb/>The global definition context Σ is the same as the one used in the typing relation. The local context <lb/>Γ is also similar to the one in the typing relation, but it keeps track of the target types of local <lb/>variables instead of source types. Finally, the lifting context L consists of entries of the form x : θ ▷ x, <lb/>which associates the global function x of type ⌊θ⌋ with a generated function x of the target type θ. A <lb/>single global function may have multiple target types, i.e., multiple private versions, either specified <lb/>by the users or by the callsites. For example, L may contain filter : Ψ list ≤ → Z → Ψ list ≤ ▷ filter 1 <lb/>and filter : Ψ list = → Z → Ψ list ≤ ▷ filter 2 . <lb/>Figure 12 shows a selection of rules of the declarative lifting relation (the full rules are in <lb/>appendix). We elide most contexts as they are fixed, and simply write Γ ⊢ e : θ ▷ e for brevity. Most <lb/>rules are simply congruences and similar to typing rules. L-Fun outsources the lifting of a function <lb/>call to the lifting context. L-If 2 handles the case when the condition is lifted to an oblivious boolean <lb/>by delegating the translation to the mergeability relation. Similarly, L-Ctor 2 and L-Match 2 query <lb/>the contexts of the intro-structures and elim-structures, and use the corresponding instances as the <lb/>drop-in replacement, when we are constructing or destructing Ψ-types. Lastly, L-Coerce coerces <lb/>an expression nondeterministically using the coercion relation. <lb/>This lifting relation in Figure 12 only considers one expression. In practice, the users specify a set <lb/>of functions and their target types to lift. The result of our lifting procedure is a lifting context L <lb/>which maps these functions and target types to the corresponding generated functions, as well as <lb/>any other functions and the inferred target types that these functions depend on. The global context <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:18 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>V θ <lb/>V <lb/>= V B = V T = { (v, v ′ ) | 0 &lt; =⇒ v = v ′ } <lb/>V B = { (b, [b ′ ]) | 0 &lt; =⇒ b = b ′ } <lb/>V Ψ T = (v, ⟨k, v⟩ ) 0 &lt; =⇒ r k v -→ * v <lb/>V θ 1 ×θ 2 = ((v 1 ,v 2 ),(v ′ <lb/>1 ,v ′ <lb/>2 ) ) (v 1 , v ′ <lb/>1 ) ∈ V θ 1 ∧ (v 2 , v ′ <lb/>2 ) ∈ V θ 2 <lb/>V θ 1 →θ 2 = ( x:⌊θ 1 ⌋⇒e, x:θ 1 ⇒e ′ ) ∀ &lt; .∀ (v, v ′ ) ∈ V θ 1 .([v/x]e, [v ′ /x]e ′ ) ∈ E θ 2 <lb/>E θ <lb/>E θ = (e, e ′ ) ∀ &lt; .∀v ′ . e ′ -→ v ′ =⇒ ∃v. e -→ * v ∧ (v, v ′ ) ∈ V -θ <lb/>Fig. 13. A logical relation for refinement <lb/>Σ is also extended with the definitions of the generated functions. To make this more clear, we say <lb/>a lifting context is derivable, denoted by ⊢ L, if and only if, for any x : θ ▷ x ∈ L, fn x:⌊θ⌋ = e ∈ Σ and <lb/>fn x:θ = e ∈ Σ for some e and e, such that S; L; Σ; • ⊢ e : θ ▷ e. In other words, any definitions of the <lb/>lifted functions in L can be derived from the lifting relation in Figure 12. Note that the derivation <lb/>of a function definition is under a lifting context with possibly an entry of this function itself. This <lb/>is similar to the role of global context in type checking, as Taypsi supports mutually recursive <lb/>functions. The goal of our algorithm (Section 5) is then to find such a derivable lifting context that <lb/>includes the user-specified liftings. <lb/>4.6 Logical Refinement <lb/>The correctness of the lifting procedure is framed as a logical refinement between expressions <lb/>of specification types and those of simple types; this relationship is defined as a step-indexed <lb/>logical relation [Ahmed 2006]. As is common, this relation is defined via a pair of set-valued <lb/>type denotations: a value interpretation V θ and an expression interpretation E θ . We say an <lb/>expression e ′ of type θ refines e of type ⌊θ⌋ (within steps) if (e, e ′ ) ∈ E θ . In other words, e ′ <lb/>preserves the behavior of e, in that if e ′ terminates at a value, e must terminate at an equivalent <lb/>value. The equivalence between values is dictated by V θ . <lb/>Figure 13 shows the complete definition of the logical relation. All pairs in the relations must be <lb/>closed and well-typed, i.e., their interpretations have the forms: <lb/>V θ = { (v, v ′ ) | • ⊢ v : ⌊θ⌋ ∧ • ⊢ v ′ : θ ∧ . . . } <lb/>E θ = { (e, e ′ ) | • ⊢ e : ⌊θ⌋ ∧ • ⊢ e ′ : θ ∧ . . . } <lb/>For brevity, we leave this requirement implicit in Figure 13. <lb/>The definitions are mostly standard. The most interesting case is the value interpretation of <lb/>Ψ-type: we say the pair of a public view and an oblivious value of an OADT is equivalent to a <lb/>public value of the corresponding ADT when the oblivious value can be retracted to the public <lb/>value. Intuitively, an encrypted value is equivalent to the value it decrypts to. The base cases of <lb/>the value interpretation are also guarded by the condition that we still have steps left, i.e., greater <lb/>than 0. This requirement maintains the pleasant property that the interpretations V 0 θ and E 0 θ <lb/>are total relations on closed values and expressions, respectively, of type θ. The proof also uses a <lb/>straightforward interpretation of typing context, G Γ , whose definition is in appendix. <lb/>This relation also gives rise to a semantic characterization of the lifting context. We say a lifting <lb/>context is -valid, denoted by ⊨ L, if and only if, for any x : θ ▷ x ∈ L, (x, x) ∈ E θ . If ⊨ L for any <lb/>, we say L is valid, denoted by ⊨ L. The validity is essentially a semantic correctness of L. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:19 <lb/></page>

        <body>4.7 Metatheory of Li ing <lb/>The first key property of the lifting relation is well-typedness, which guarantees the security of <lb/>translated programs, thanks to Theorem 3.1. <lb/>Theorem 4.6 (Regularity of declarative lifting). Suppose L is well-typed and S; L; Σ; Γ ⊢ e : <lb/>θ ▷ e. We have Σ; ⌊Γ ⌋ ⊢ e : ⌊θ⌋ and Σ; Γ ⊢ e : θ. <lb/>Our lifting relation ensures that lifted expressions refine source expressions in fewer than <lb/>steps, as long as every lifted program in L is also semantically correct in fewer than steps. As is <lb/>common in logical relation proofs, this proof requires a more general theorem about open terms. <lb/>Theorem 4.7 (Correctness of declarative lifting of closed terms). Suppose S; L; Σ; • ⊢ e : θ▷ e <lb/>and ⊨ L. We have (e, e) ∈ E θ . <lb/>Finally, Theorem 4.8 provides a strong result of the correctness of our translation. Any lifting <lb/>context that is derived using the rules of Figure 12 is semantically correct. In other words, if every <lb/>pair of source program and lifted program in L are in our lifting relation, they also satisfy our <lb/>refinement criteria. <lb/>Theorem 4.8 (Correctness of declarative lifting). ⊢ L implies ⊨ L. <lb/>Our notion of logical refinement only provides partial correctness guarantees, as can be seen in <lb/>the definition of E • . As a result, the lifting relation does not guarantee equi-termination: it is <lb/>possible that a lifted program will diverge when the source program terminates. This can occur <lb/>when an if is replaced by a mux: since the latter fully executes both branches, this effectively changes <lb/>the semantics of a conditional from a lazy evaluation strategy to an eager strategy. Using a public <lb/>value to bound the recursion depth in order to guarantee termination is a common practice in <lb/>data-oblivious computation, for the reasons discussed in Section 2. While the public view of an <lb/>OADT naturally serves as a measure in many cases, including all of the case studies and benchmarks <lb/>in our evaluation, in theory it is possible for a user to provide a policy to a function that results in <lb/>a nonterminating lifted version. In this situation, users must either specify a different policy, or <lb/>rewrite the functions to recurse on a different argument, e.g., a fuel value. <lb/>5 ALGORITHMIC LIFTING <lb/>Figure 14 presents the overall workflow of our lifting algorithm. This algorithm starts with a set of <lb/>goals, i.e., pairs of source functions tagged with the %lift keywords and their desired specification <lb/>types. We then run our lifting algorithm on all the functions in these goals, as well as any functions <lb/>they depend on, transforming each of these functions to an oblivious version parameterized by <lb/>typed macros and type variables, along with a set of constraints over these type variables. After <lb/>solving the constraints, we obtain a set of type assignments for each function. Note that a single <lb/>function may have multiple type assignments, one for each occurence in a goal and callsite. For <lb/>example, filter may have the type assignment for the goal Ψ list ≤ → Z → Ψ list ≤ generated by <lb/>%lift, and the assignment for Ψ list ≤ → Z → Ψ list ≤ generated by the call in filter5 from Section 2. <lb/>Finally, we generate the private versions of all the lifted functions by instantiating their type <lb/>variables and expanding away any macros. The lifting context from the last section is simply these <lb/>lifted functions and their generated private versions. <lb/>The lifting algorithm is defined using the judgment Σ; Γ ⊢ e : η ∼ X ▷ e | C. It reads as the source <lb/>expression e of type η is lifted to the target expression e whose type is a type variable X as a <lb/>placeholder for the specification type, and generates constraints C. The source expression e is <lb/>required to be in administrative normal form (ANF) [Flanagan et al. 1993], which is guaranteed by <lb/>our type checker. In particular, type annotations are added to let-bindings, and the body of every <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:20 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>let is either another let or a variable. Importantly, this means the last expression of a sequence of <lb/>let must be a variable. The output of this algorithm is an expression e containing macros (which <lb/>will be discussed shortly), and the constraints C. Unlike the declarative rules, this algorithm keeps <lb/>track of the source type η, which is used to restrict the range of the type variables. Consequently, <lb/>every entry of the typing context Γ has the form x : η ∼ X, meaning that local variable x has type η <lb/>in the source program and type X in the target program. For example, after the lifting algorithm <lb/>has processed the function arguments of filter in Figure 1, the typing context contains entries <lb/>xs : list ∼ X 1 and y : Z ∼ X 2 , with freshly generated type variables X 1 and X 2 . <lb/>goals from %lift <lb/>functions to lift <lb/>lifted functions with <lb/>macros &amp; type var. <lb/>constraints over <lb/>type var. <lb/>type assignments <lb/>lifted functions <lb/>with macros <lb/>well-typed &amp; correct <lb/>lifted functions <lb/>dependency analysis <lb/>lifting <lb/>constraint solving <lb/>instantiation <lb/>elaboration <lb/>Fig. 14. Translation pipeline <lb/>The typed macros, defined in Figure 15, are an essential <lb/>part of the output of the lifting algorithm, and permit a form <lb/>of ad-hoc polymorphism, that allows the algorithm to cleanly <lb/>separate constraint solving from program generation. These <lb/>macros take types as parameters and elaborate to expres-<lb/>sions, under the contexts S, L and Σ implicitly. These macros <lb/>are effectively thin &quot;wrappers&quot; of their corresponding lan-<lb/>guage constructs and the previously defined relations. The <lb/>conditional macro %ite, for example, corresponds to the if <lb/>expression, but the condition may be oblivious. The construc-<lb/>tor macro %C is a &quot;smart&quot; constructor that may construct a <lb/>Ψ-type. The pattern matching macro %match is similar to %C <lb/>but for eliminating a type compatible with an ADT. Lastly, <lb/>%↑ and %x is simply a direct wrapper of the mergeable relation <lb/>and the lifting context L, respectively. Note that the deriva-<lb/>tion of these macro are completely determined by the type <lb/>parameters. <lb/>Figure 16 defines the constraints used in the algorithm, <lb/>where θ + is the specification types extended with type vari-<lb/>ables. The constraint X ∈ [η] means type variable X belongs to <lb/>the compatibility class of η. In other words, ⌊X⌋ = η. Each macro is accompanied by a constraint on <lb/>its type parameters. These constraints mean that the corresponding macros are resolvable. More <lb/>formally, this means they can elaborate to some expressions according to the rules in Figure 15 <lb/>for any expression arguments. As a result, after solving all constraints and concretizing the type <lb/>variables, all macros in the lifted expression e can be fully elaborated away. <lb/>Figure 17 shows a selection of lifting algorithm rules. Coercions only happen when we lift <lb/>variables, as in A-Var. This works because the source program is in ANF, so each expression is <lb/>bound to a variable which has the opportunity to get coerced. For example, the argument to a <lb/>function or constructor, in A-App and A-Ctor, is always a variable in ANF, and recursively lifting it <lb/>allows the application of A-Var. On the other hand, the top-level program is always in let-binding <lb/>form, whose last expression is always a variable too, allowing coercion of the whole program. <lb/>However, not all variables are subject to coercions: the function x 2 in A-App, the condition x 0 in <lb/>A-If and the discriminee x 0 in A-Match are kept as they are, for example. Coercing these variables <lb/>would be unnecessary and undesirable. For example, coercing the condition in a conditional only <lb/>makes the generated program more expensive: there is no reason to coerce from B to B, and use mux <lb/>instead of if. Another key invariant we enforce in our algorithmic rules is that every fresh variable <lb/>is &quot;guarded&quot; by a compatibility class constraint. For example, in A-Abs, the freshly generated <lb/>variables X 1 and X 2 belong to the classes η 1 and η 2 , respectively. This constraint ensures that every <lb/>type variable can be finitely enumerated, as every compatibility class is a finite set, bounded by the <lb/>number of available OADTs. As a result, constraint solving in our context is decidable. Finally, if an <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:21 <lb/></page>

        <body>%ite(θ 0 ,θ;e 0 ,e 1 ,e 2 ) ▷ e <lb/>%ite(B,θ;e 0 ,e 1 ,e 2 ) ▷ if e 0 then e 1 else e 2 <lb/>θ ▷ ite <lb/>%ite( B,θ;e 0 ,e 1 ,e 2 ) ▷ ite e 0 e 1 e 2 <lb/>%C(θ,θ ′ ;e) ▷ e <lb/>data T = C η ∈ Σ <lb/>%C (η ,T;e) ▷ C e <lb/>C : θ →Ψ T ∈ S <lb/>%C (θ ,Ψ T;e) ▷ C e <lb/>%match(θ 0 ,θ,θ ′ ;e 0 ,e) ▷ e <lb/>data T = C η ∈ Σ <lb/>%match(T,η,θ ′ ;e 0 ,e) ▷ match e 0 with C x⇒e <lb/>match : Ψ T→(θ→θ ′ )→θ ′ ∈ S <lb/>%match(Ψ T,θ,θ ′ ;e 0 ,e) ▷ match e 0 ( x:θ⇒e) <lb/>%↑(θ,θ ′ ;e) ▷ e <lb/>θ ↣ θ ′ ▷ ↑ <lb/>%↑(θ,θ ′ ;e) ▷ ↑e <lb/>%x(θ) ▷ e <lb/>x : θ ▷ x ∈ L <lb/>%x(θ) ▷ x <lb/>Fig. 15. Typed macros <lb/>Constraints <lb/>X ∈ [η] | θ + = θ + | %ite(θ + ,θ + ) | %C(θ + ,θ + ) | %match(θ + ,θ + ,θ + ) | %↑(θ + ,θ + ) | %x(θ + ) <lb/>Fig. 16. Constraints <lb/>expression is translated to a macro, a corresponding constraint is added to ensure this macro is <lb/>resolvable. <lb/>We use the judgment S; L; Σ; ⊨ C to mean the assignment satisfies a set of constraints C, under <lb/>the context of Ψ-structure, lifting context and global definition context. The constraints generated <lb/>by our lifting algorithm use type variables X as placeholders for the target type of the function <lb/>being lifted. To solve a goal with a particular target type θ, we add a constraint to C that equates <lb/>the placeholder with the stipulated type, i.e., X = θ. Our constraint solver then attempts to find type <lb/>assignments that satisfy the constraints in C; the resulting assignment is used to generate private <lb/>versions of all the functions in the set of goals, as well as the accompanying lifting context. <lb/>At a high level, 10 our solver reduces all constraints, except for function call constraints (%x), to <lb/>quantifier-free formulas in a finite domain theory, which can be efficiently solved using an off-the-<lb/>shelf solver. Function call constraints are recursively solved once their type arguments have been <lb/>concretized by discharging the other constraints. When a function call constraint is unsatisfiable, <lb/>we add a new refutation constraint and invoke the solver again to find a new instantiation of type <lb/>parameters. As an example of this process, in order to ascribe filter the type Ψ list = → Z → Ψ list ≤ , <lb/>we first add the constraint X = Ψ list = → Z → Ψ list ≤ to the constraints generated by the lifting <lb/>algorithm • ⊢ . . . : list → Z → list ∼ X ▷ e | C. Solving the other constraints may concretize the <lb/>type variable of function call constraint %filter(X), i.e., the type of the recursive call to filter, <lb/>to %filter(Ψ list = → Z → Ψ list ≤ ). Recursively solving this subgoal assuming the original goal is <lb/>solved, i.e., extending the lifting context with the original goal, results in immediate success, as <lb/>the subgoal is simply in the lifting context. On the other hand, if the type of the recursive call is <lb/>instantiated as %filter(Ψ list = → Z → Ψ list = ), the same constraints generated by lifting filter are <lb/>solved, with an additional constraint X = Ψ list = → Z → Ψ list = . However, this set of constraints <lb/>is unsatisfiable, as list = has no join structure, so we add a refutation constraint to the context <lb/></body>

        <note place="footnote">10 The full details of our constraint solver are given in the appendix. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:22 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>Γ ⊢ e : η ∼ X ▷ e | C <lb/>A-Lit <lb/>Γ ⊢ b : B ∼ X ▷ b | X = B <lb/>A-Var <lb/>x : η ∼ X ∈ Γ <lb/>Γ ⊢ x : η ∼ X ′ ▷ %↑(X,X ′ ;x) | %↑(X,X ′ ) <lb/>A-Fun <lb/>fn x:η = e ∈ Σ <lb/>Γ ⊢ x : η ∼ X ▷ %x(X) | %x(X) <lb/>A-Abs <lb/>X 1 , X 2 fresh <lb/>x : η 1 ∼ X 1 , Γ ⊢ e : η 2 ∼ X 2 ▷ e | C <lb/>Γ ⊢ x:η 1 ⇒e : η 1 →η 2 ∼ X ▷ x:X 1 ⇒ e | X 1 ∈ [η 1 ], X 2 ∈ [η 2 ], X = X 1 →X 2 , C <lb/>A-App <lb/>X 1 fresh <lb/>x 2 : η 1 →η 2 ∼ X ∈ Γ <lb/>Γ ⊢ x 1 : η 1 ∼ X 1 ▷ e 1 | C <lb/>Γ ⊢ x 2 x 1 : η 2 ∼ X 2 ▷ x 2 e 1 | X 1 ∈ [η 1 ], X = X 1 →X 2 , C <lb/>A-Let <lb/>X 1 fresh <lb/>Γ ⊢ e 1 : η 1 ∼ X 1 ▷ e 1 | C 1 <lb/>x : η 1 ∼ X 1 , Γ ⊢ e 2 : η 2 ∼ X 2 ▷ e 2 | C 2 <lb/>Γ ⊢ let x:η 1 = e 1 in e 2 : η 2 ∼ X 2 ▷ let x:X 1 = e 1 in e 2 | X 1 ∈ [η 1 ], C 1 , C 2 <lb/>A-If <lb/>x 0 : B ∼ X 0 ∈ Γ <lb/>Γ ⊢ e 1 : η ∼ X ▷ e 1 | C 1 <lb/>Γ ⊢ e 2 : η ∼ X ▷ e 2 | C 2 <lb/>Γ ⊢ if x 0 then e 1 else e 2 : η ∼ X ▷ %ite(X 0 ,X;x 0 , e 1 , e 2 ) | %ite(X 0 ,X), C 1 , C 2 <lb/>A-Ctor <lb/>data T = C η ∈ Σ <lb/>X fresh <lb/>Γ ⊢ x : η ∼ X ▷ e | C <lb/>Γ ⊢ C x : T ∼ X ▷ %C (X ,X; e) | X ∈ [η ], %C (X ,X), C <lb/>A-Match <lb/>data T = C η ∈ Σ <lb/>X fresh <lb/>x 0 : T ∼ X 0 ∈ Γ <lb/>∀ . x : η ∼ X , Γ ⊢ e : η ′ ∼ X ′ ▷ e | C <lb/>Γ ⊢ match x 0 with C x⇒e : η ′ ∼ X ′ ▷ %match(X 0 ,X,X ′ ;x 0 , e) | X ∈ [η], %match(X 0 ,X,X ′ ), C <lb/>Fig. 17. Selected algorithmic li ing rules <lb/>that forces the solver to not generate this assignment again. In general, the type of the recursive <lb/>call to filter may be concretized to any types compatible with list → Z → list. The number of <lb/>such compatible types is bounded, as the number of arguments of this function and the number of <lb/>OADTs are themselves bounded. The function filter has 3 × 2 × 3 = 18 possible type assignments. In <lb/>the worst case scenario, the algorithm eventually terminates after exhausting all 18 combinations. <lb/>The lifting algorithm enjoys a soundness theorem with respect to the declarative lifting relation. <lb/>As a result, our algorithm inherits the well-typedness and correctness properties of the declara-<lb/>tive version. The statement of this theorem follows how the algorithm is used: if the generated <lb/>constraints, equating the function type variable with the specification type, are satisfiable by the <lb/>type assignment , instantiating the lifted expression with and elaborating the macros results in <lb/>a target expression that is valid under the declarative lifting relation: <lb/>Theorem 5.1 (Soundness of algorithmic lifting). Suppose Σ; • ⊢ e : η ∼ X ▷ e | C. Given <lb/>a specification type θ, if S; L; Σ; ⊨ X = θ, C, then ( e) elaborates to an expression e ′ , such that <lb/>S; L; Σ; • ⊢ e : θ ▷ e ′ . <lb/>The proof of this theorem is available in the appendix. <lb/>6 IMPLEMENTATION AND EVALUATION <lb/>Our compilation pipeline takes as input a source program, including any OADTs, Ψ-structures, <lb/>and macros (e.g., %lift), in the public fragment of Taypsi and privacy policies (i.e., security-type <lb/>signatures) for all target functions. After typing the source program using a bidirectional type <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:23 <lb/></page>

        <body>checker, our lifting pass generates secure versions of the specified functions and their dependencies, <lb/>using Z3 [de Moura and Bjørner 2008] as its constraint solver. The resulting Taypsi functions are <lb/>translated into Oil [Ye and Delaware 2023], an ML-style functional language equipped with oblivious <lb/>arrays and secure array operations: OADTs are converted to serialized versions which are stored in <lb/>secure arrays, and all oblivious operations are translated into secure array operations. After applying <lb/>some optimizations, our pipeline outputs an OCaml library providing secure implementations of all <lb/>the specified functions, including section and retraction functions for encrypting private data and <lb/>decrypting the results of a joint computation. After linking this library to a driver that provides the <lb/>necessary cryptographic primitives (i.e., secure integer arithmetic), programmers can build secure <lb/>MPC applications on top of this API. The following evaluation uses a driver implemented using the <lb/>popular open-source EMP toolkit [Wang et al. 2016]. <lb/>Optimizations. Our implementation of Taypsi implements three optimizations which further im-<lb/>prove the performance of the programs it generates. 11 The reshape guard optimization instruments <lb/>reshape instances to first check if the public views of two private values are identical, omitting the <lb/>reshape operation if so. The memoization optimization caches the sizes of the private representation <lb/>of data in order to avoid recalculating this information, which is needed to create and slice oblivious <lb/>arrays. The final, smart array optimization supports zero-cost array slicing and concatenation, <lb/>and eliminates redundant operations over the serialized representation of oblivious data. One <lb/>observation underlying this optimization is that evaluating a mux whose branches are encrypted <lb/>versions of publicly-known values is unnecessary: mux [b] ( B#s true) ( B#s false) is equivalent to <lb/>[b], for example. This situation frequently occurs in map-like functions, where the constructor <lb/>used in each branch of a function is publicly known. Under the hood, the serialized encoding of the <lb/>result of map uses a boolean tag to indicate which constructor was used to build it, i.e., Nil or Cons; <lb/>this boolean is determined by the tag of the input list, e.g., mux [tag] [true] [false]. Of course, the <lb/>tag used in each branch is publicly known: map always returns Nil if the input list is empty, and <lb/>returns a Cons otherwise. Thus, we can safely reuse the [tag] of the input list to label the result <lb/>of map, for similar reasons as the previous example. The smart array optimization exploits this <lb/>observation by marking when section functions are applied to public values instead of, for example, <lb/>immediately evaluating B#s true to the encrypted value [true]. Then, when performing a mux, the <lb/>smart array first checks if both branches are &quot;fake&quot; private values, safely reducing the mux to its <lb/>private condition if so, without actually performing any cryptographic operations. <lb/>Our evaluation considers the following research questions: <lb/>RQ1 How does the performance of Taypsi&apos;s transformation-based approach compare to the dy-<lb/>namic enforcement strategy of Taype? <lb/>RQ2 What is the compilation overhead of Taypsi&apos;s translation strategy? <lb/>6.1 Microbenchmark Performance <lb/>To answer RQ1, we have evaluated the performance of a set of microbenchmarks compiled with <lb/>both Taypsi and Taype. Both approaches are equipped with optimizations that are unique to their <lb/>enforcement strategies: Taypsi&apos;s reshape guard optimization is not applicable to Taype, and Taype <lb/>features an early tape optimization that does not make sense for Taypsi. 12 Our evaluation also <lb/>includes a version of Taype that implements Taypsi&apos;s smart array optimization (Taype-SA), in order <lb/>to provide a comparison of the two approaches at their full potential. <lb/></body>

        <note place="footnote">11 Our appendix describes each of these optimizations in more detail. <lb/>12 Taype also implements a tupling optimization, but this is analogous to Taypsi&apos;s memoization optimization. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:24 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>Benchmark <lb/>Taype (ms) Taype-SA (ms) Taypsi (ms) <lb/>elem_1000 † <lb/>8.15 <lb/>8.11 <lb/>8.02 <lb/>(98.47%, 98.89%) <lb/>hamming_1000 † <lb/>15.09 <lb/>15.21 <lb/>14.46 <lb/>(95.79%, 95.04%) <lb/>euclidean_1000 † 67.43 <lb/>67.55 <lb/>67.32 <lb/>(99.84%, 99.66%) <lb/>dot_prod_1000 † <lb/>66.12 <lb/>66.19 <lb/>66.41 (100.43%, 100.33%) <lb/>nth_1000 † <lb/>11.98 <lb/>12.05 <lb/>12.04 (100.54%, 99.93%) <lb/>map_1000 <lb/>2139.55 <lb/>5.07 <lb/>5.14 <lb/>(0.24%, 101.44%) <lb/>filter_200 <lb/>failed <lb/>failed <lb/>86.86 <lb/>(N/A, N/A) <lb/>insert_200 <lb/>5796.69 <lb/>88.92 <lb/>88.07 <lb/>(1.52%, 99.04%) <lb/>insert_list_100 failed <lb/>failed <lb/>4667.66 <lb/>(N/A, N/A) <lb/>append_100 <lb/>4274.7 <lb/>45.09 <lb/>44.18 <lb/>(1.03%, 97.99%) <lb/>take_200 <lb/>169.07 <lb/>3.05 <lb/>3.09 <lb/>(1.83%, 101.15%) <lb/>flat_map_200 <lb/>failed <lb/>failed <lb/>7.3 <lb/>(N/A, N/A) <lb/>span_200 <lb/>13529.34 <lb/>124.79 <lb/>91.22 <lb/>(0.67%, 73.09%) <lb/>partition_200 <lb/>failed <lb/>failed <lb/>176.49 <lb/>(N/A, N/A) <lb/>elem_16 † <lb/>446.81 <lb/>459.1 <lb/>404.9 <lb/>(90.62%, 88.19%) <lb/>prob_16 † <lb/>13082.52 <lb/>12761.7 <lb/>12735.16 (97.34%, 99.79%) <lb/>map_16 <lb/>4414.69 <lb/>262.14 <lb/>215.67 <lb/>(4.89%, 82.27%) <lb/>filter_16 <lb/>8644.14 <lb/>452.04 <lb/>433.7 <lb/>(5.02%, 95.94%) <lb/>swap_16 <lb/>failed <lb/>failed <lb/>4251.36 <lb/>(N/A, N/A) <lb/>path_16 <lb/>failed <lb/>6657.07 <lb/>894.88 <lb/>(N/A, 13.44%) <lb/>insert_16 <lb/>83135.81 <lb/>8093.81 <lb/>1438.87 (1.73%, 17.78%) <lb/>bind_8 <lb/>21885.65 <lb/>494.98 <lb/>532.86 (2.43%, 107.65%) <lb/>collect_8 <lb/>failed <lb/>failed <lb/>143.38 <lb/>(N/A, N/A) <lb/>Fig. 18. Running times for each benchmark in milliseconds. The Taypsi column also reports the percentage of <lb/>running time relative to Taype and Taype-SA. A failed entry indicates the benchmark either timed out a er <lb/>5 minutes or exceeded the memory bound of 8 GB. List and tree benchmarks appear above and below the <lb/>double line, respectively. <lb/>Our benchmarks are a superset of the benchmarks from Ye and Delaware [2023]. Figure 18 <lb/>presents the experimental results. 13 These experiments fix the public views of private lists and trees <lb/>to be their maximum length and maximum depth, respectively; the suffix of each benchmark name <lb/>indicates the public view used. The benchmarks annotated with † simply traverse the data type in <lb/>order to produce a primitive value, e.g., an integer; these include membership (elem), hamming <lb/>distance (hamming), minimum euclidean distance (euclidean), dot product (dot_prod), secure <lb/>index look up (nth) and computing the probability of an event given a probability tree diagram <lb/>(prob). The programs generated by Taype, Taype-SA and Taypsi all exhibit similar performance <lb/>on these benchmarks. The remaining benchmarks all construct structured data values, i.e., the <lb/>sort of application on which Taypsi is expected to shine. In addition to standard list operations, <lb/>the list benchmarks include insertion into a sorted list (insert) and insertion of a list of elements <lb/>into a sorted list (insert_list) (both lists have public view 100). The tree examples include a <lb/>filter function that removes all nodes (including any subtrees) greater than a given private integer <lb/>(filter), swapping subtrees if the node matches a private integer (swap), computing a subtree <lb/>reached following a list of &quot;going left&quot; and &quot;going right&quot; directions (path), insertion into a binary <lb/>search tree (insert), replacing the leaves of a tree with a given tree (bind), and collecting all nodes <lb/>smaller than a private integer into a list (collect). <lb/></body>

        <note place="footnote">13 All results are averaged across 5 runs, on an M1 MacBook Pro with 16 GB memory. All parties run on the same host with <lb/>local network communication. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:25 <lb/></page>

        <body>Benchmark <lb/>No Smart Array (ms) No Reshape Guard (ms) No Memoization (ms) <lb/>elem_1000 <lb/>18.37 <lb/>(2.29x) 8.06 <lb/>(1.0x) 17.76 <lb/>(2.21x) <lb/>hamming_1000 <lb/>51.73 <lb/>(3.58x) 14.53 <lb/>(1.01x) 35.5 <lb/>(2.46x) <lb/>euclidean_1000 <lb/>79.07 <lb/>(1.17x) 67.31 <lb/>(1.0x) 76.36 <lb/>(1.13x) <lb/>dot_prod_1000 <lb/>87.77 <lb/>(1.32x) 66.15 <lb/>(1.0x) 77.33 <lb/>(1.16x) <lb/>nth_1000 <lb/>22.69 <lb/>(1.88x) 12.18 <lb/>(1.01x) 20.53 <lb/>(1.7x) <lb/>map_1000 <lb/>2106.43 <lb/>(409.89x) 139.91 <lb/>(27.23x) 37.71 <lb/>(7.34x) <lb/>filter_200 <lb/>5757.28 <lb/>(66.29x) 93.93 <lb/>(1.08x) 114.7 <lb/>(1.32x) <lb/>insert_200 <lb/>255.43 <lb/>(2.9x) 94.61 <lb/>(1.07x) 89.32 <lb/>(1.01x) <lb/>insert_list_100 22806.87 <lb/>(4.89x) 5186.07 <lb/>(1.11x) 4771.28 <lb/>(1.02x) <lb/>append_100 <lb/>4226.32 <lb/>(95.66x) 50.79 <lb/>(1.15x) 61.77 <lb/>(1.4x) <lb/>take_200 <lb/>169.45 <lb/>(54.91x) 12.92 <lb/>(4.19x) 4.68 <lb/>(1.52x) <lb/>flat_map_200 <lb/>5762.63 <lb/>(789.08x) 16.99 <lb/>(2.33x) 60.03 <lb/>(8.22x) <lb/>span_200 <lb/>5924.1 <lb/>(64.95x) 99.83 <lb/>(1.09x) 120.09 <lb/>(1.32x) <lb/>partition_200 <lb/>11528.0 <lb/>(65.32x) 185.16 <lb/>(1.05x) 231.06 <lb/>(1.31x) <lb/>elem_16 <lb/>433.73 <lb/>(1.07x) 404.05 <lb/>(1.0x) 402.15 <lb/>(0.99x) <lb/>prob_16 <lb/>13019.56 <lb/>(1.02x) 12746.24 <lb/>(1.0x) 12731.89 <lb/>(1.0x) <lb/>map_16 <lb/>4410.84 <lb/>(20.45x) 635.18 <lb/>(2.95x) 213.96 <lb/>(0.99x) <lb/>filter_16 <lb/>8674.71 <lb/>(20.0x) 1131.02 <lb/>(2.61x) 440.16 <lb/>(1.01x) <lb/>swap_16 <lb/>8671.52 <lb/>(2.04x) 5471.4 <lb/>(1.29x) 4246.39 <lb/>(1.0x) <lb/>path_16 <lb/>9108.54 <lb/>(10.18x) 1083.21 <lb/>(1.21x) 888.95 <lb/>(0.99x) <lb/>insert_16 <lb/>19101.36 <lb/>(13.28x) 2151.83 <lb/>(1.5x) 1432.92 <lb/>(1.0x) <lb/>bind_8 <lb/>19647.83 <lb/>(36.87x) 870.93 <lb/>(1.63x) 534.3 <lb/>(1.0x) <lb/>collect_8 <lb/>11830.6 <lb/>(82.51x) 152.29 <lb/>(1.06x) 186.92 <lb/>(1.3x) <lb/>Fig. 19. Impact of turning off the smart array (No Smart Array), reshape guard (No Reshape Guard), and <lb/>public view memoization (No Memoization) optimizations. Each column presents running time in milliseconds <lb/>and the slowdown relative to that of the fully optimized version reported in Figure 18. <lb/>Dynamic policy enforcement either fails to finish within 5 minutes or exceeds an 8 GB memory <lb/>bound on almost half of the last set of benchmarks, due to the exponential blowup discussed in <lb/>Section 2. For those benchmarks that do finish, Taypsi&apos;s enforcement strategy results in a fraction of <lb/>the total execution time compared to Taype. Compared to the version of Taype using smart arrays, <lb/>Taypsi still performs comparably or better, although the gap is somewhat narrowed: functions like <lb/>map do not suffer from exponential blowup, so these benchmarks benefit mostly from the smart array <lb/>optimization. In summary, these results demonstrate that a static enforcement strategy performs <lb/>considerably better than a dynamic one on many benchmarks, and works roughly as well on the <lb/>remainder. <lb/>6.2 Impact of Optimization <lb/>To evaluate the performance impact of Taypsi&apos;s three optimizations, we conducted an ablation <lb/>study on their effect. The results, shown in Figure 19, indicate that our smart array optimization is <lb/>the most important, providing up to almost 800x speedup in the best case. As suggested by Figure 18, <lb/>this optimization also helps significantly with the performance of Taype, although not enough to <lb/>outweigh the exponential blowup innate in its dynamic approach. The other optimizations also <lb/>improve performance, albeit not as significantly. As our memoization pass caches public views of <lb/>arbitrary type, we have also conducted an ablation study for these list and tree examples using <lb/>ADT public views instead, e.g., using Peano number to encode the maximum length of a list. In <lb/>this study, we observe up to 9 times speed up in list examples, with minimal regression in tree <lb/>examples. The full results of this study are included in the appendix. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:26 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <body>6.3 Compilation Overhead <lb/>To measure the overhead of Taypsi&apos;s use of an external solver to resolve constraints, we have <lb/>profiled the compilation of a set of larger programs drawn from Taype&apos;s benchmark suite, plus an <lb/>additional secure dating application. 14 The first two benchmark suites (List and Tree) in Figure 20 <lb/>include all the microbenchmarks from previous section. The next benchmark, List (stress), consists <lb/>of the same microbenchmarks as List with 5 additional list OADTs. The purpose of this synthetic <lb/>suite is to examine the impact of the number of OADTs on the search space. The remaining <lb/>benchmarks represent larger, more realistic applications which demonstrate the expressivity and <lb/>usability of Taypsi. <lb/>Suite <lb/>#Fn #Ty #At #Qu Tot (s) Slv (s) <lb/>List <lb/>20 <lb/>7 <lb/>70 <lb/>84 <lb/>0.47 <lb/>0.081 <lb/>Tree <lb/>14 <lb/>9 <lb/>44 <lb/>31 <lb/>0.47 <lb/>0.024 <lb/>List (stress) <lb/>20 <lb/>12 <lb/>70 <lb/>295 <lb/>3.45 <lb/>2.8 <lb/>Dating <lb/>4 <lb/>13 <lb/>16 <lb/>10 <lb/>0.58 <lb/>0.019 <lb/>Medical Records <lb/>20 <lb/>19 <lb/>58 <lb/>51 <lb/>0.48 <lb/>0.072 <lb/>Secure Calculator <lb/>2 <lb/>9 <lb/>6 <lb/>5 <lb/>1.34 <lb/>0.013 <lb/>Decision Tree <lb/>2 <lb/>13 <lb/>6 <lb/>16 <lb/>0.28 <lb/>0.016 <lb/>K-means <lb/>16 <lb/>11 <lb/>68 <lb/>86 <lb/>1.62 <lb/>0.95 <lb/>Miscellaneous <lb/>11 <lb/>7 <lb/>42 <lb/>47 <lb/>0.26 <lb/>0.065 <lb/>Fig. 20. Impact of constraint solving on compilation. <lb/>The last three columns of Figure 20 <lb/>report the results of these experiments: <lb/>total compilation time (Tot), time spent <lb/>on constraint solving (Slv) and the num-<lb/>ber of solver queries (#Qu). The group <lb/>of columns in the middle of the table <lb/>describes features that can impact the <lb/>performance of our constraint-based ap-<lb/>proach: the number of functions (#Fn) <lb/>being translated, the number of atomic <lb/>types (#Ty), and the total number of <lb/>atomic types used in function types (#At). <lb/>For example, the List benchmark features <lb/>7 atomic types: public and oblivious booleans, integers and lists, as well as an unsigned integer type <lb/>(i.e. natural numbers). The number of atomic types in the function filter : list → Z → list is 3. <lb/>In the worst case scenario, our constraint solving algorithm will explore every combination of types <lb/>that are compatible with this signature, resulting in the constraints associated with filter being <lb/>solved 2 * 2 * 2 = 8 times. Exactly how many compatible types the constraint solving algorithm <lb/>explores depends on many factors: the user-specified policies, the complexity of the functions, <lb/>the calls to other functions and so on. We chose these 3 metrics as a coarse approximation of the <lb/>solution space. Our results show that the solver overhead is quite minimal for most benchmarks, <lb/>and in general solving time per query is low thanks to our encoding of constraints in an efficiently <lb/>decidable logic. <lb/>7 RELATED WORK <lb/>The problem of secure computation was first formally introduced by Yao [1982], who simultane-<lb/>ously proposed garbled circuits as a solution. Subsequently, a number of other solutions have been <lb/>proposed [Evans et al. 2018; Hazay and Lindell 2010]. Solutions categorized as multiparty computa-<lb/>tion are usually based on cryptographic protocols, e.g., secret-sharing [Beimel 2011; Goldreich et al. <lb/>1987; Maurer 2006]. Outsourced computation is another type of secure computation that includes <lb/>both cryptographic solutions, e.g., fully homomorphic encryption [Acar et al. 2018; Gentry 2009], <lb/>and solutions based on virtualization [Barthe et al. 2014, 2019] or secure processors [Hoekstra <lb/>2015]. <lb/>Taypsi features a security-type system [Sabelfeld and Myers 2003; Zdancewic 2002] based on <lb/>the type system of OADT . While most security-type systems tag types with labels classifying the <lb/>sensitivity of data, our dependent type system tags kinds instead. The obliviousness guarantee <lb/>provided by Theorem 3.1 is a form of noninterference [Goguen and Meseguer 1982] that generalizes <lb/></body>

        <page>14 The full details of the additional case study can be found in the appendix. <lb/></page>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:27 <lb/></page>

        <body>memory trace obliviousness (MTO) [Liu et al. 2013]. MTO considers traces of memory accesses, while <lb/>the traces in Theorem 3.1 include every intermediate program state under a small-step operational <lb/>semantics. This reflects MPC&apos;s stronger threat model, in which all parties can observe the complete <lb/>execution of a program, including each instruction executed. As a consequence, our type system <lb/>also protects against timing channels, similar to other constant-time languages [Cauligi et al. 2019]. <lb/>Numerous high-level programming languages for writing secure multiparty computation ap-<lb/>plications have been proposed [Hastings et al. 2019]. Most prior languages either do not support <lb/>structured data, or require all structural information to be public, e.g., Obliv-C [Zahur and Evans <lb/>2015] and ObliVM [Liu et al. 2015]. To the best of our knowledge Taype is the only existing language <lb/>for MPC applications that natively supports decoupling privacy policies from program logic. On <lb/>the other hand, there are many aspects of MPC tackled by prior languages that we do not consider <lb/>here. Wysteria and Wys * [Rastogi et al. 2014, 2019], for example, focus on mixed-mode computation <lb/>which allows certain computation to be executed locally. Symphony [Sweet et al. 2023], a successor <lb/>of Wysteria, supports first-class shares and first-class party sets for coordinating many parties, <lb/>enabling more reactive applications. Darais et al. [2020] developed obliv , a probabilistic functional <lb/>language for oblivious computations that can be used to safely implement a variety of cryptography <lb/>algorithms, including Oblivious RAM. <lb/>Several prior works have considered how to compile secure programs into more efficient secure <lb/>versions. Viaduct [Acay et al. 2024, 2021] is a compiler that transforms high-level programs into <lb/>secure distributed versions by intelligently selecting an efficient combination of protocols for <lb/>subcomputations. The HyCC toolchain [Büscher et al. 2018] similarly transforms a C program <lb/>into a version that combines different MPC protocols to optimize performance. The HACCLE <lb/>toolchain [Bao et al. 2021] uses staging to generate efficient garbled circuits from a high-level <lb/>language. Compiler techniques, e.g., vectorization, have been studied for optimizing fully homo-<lb/>morphic encryption (FHE) applications [Cowan et al. 2021; Dathathri et al. 2020; Malik et al. 2023, <lb/>2021; Viand et al. 2023]. <lb/>Jeeves [Yang et al. 2012] and Taypsi have a shared goal of decoupling security policies from <lb/>program logic. While they both employ a similar high-level strategy of relying on the language <lb/>to automatically enforce policies, their different settings result in very different solutions. In <lb/>Jeeves&apos; programming model, each piece of data is equipped with a pair of high-and low-level <lb/>views: a username, for example, may have a high confidentiality view of &quot;Alice&quot;, but a low view <lb/>of &quot;Anonymous&quot;. The language then uses the view stipulated by the privacy policy and current <lb/>execution context, ensuring that information is only visible to observers with the proper authority. <lb/>In the MPC setting, however, no party is allowed to observe the private data of other parties. Thus, <lb/>no party can view all the data necessary for the computation, making it impossible to compute a <lb/>correct result by simply replacing data with some predetermined value, like &quot;Anonymous&quot;. <lb/>8 CONCLUSION <lb/>Secure multiparty computation allows joint computation over private data from multiple parties, <lb/>while keeping that data secure. Previous work has considered how to make languages for MPC <lb/>more accessible by allowing privacy requirements to be decoupled from functionality, relying on <lb/>dynamic enforcement of polices. Unfortunately, the resulting overhead of this strategy made it <lb/>difficult to scale applications manipulating structured data. This work presents Taypsi, a policy-<lb/>agnostic language for oblivious computation that transforms programs to instead statically enforce <lb/>a user-provided privacy policy. The resulting programs are guaranteed to be both well-typed, and <lb/>hence secure, and equivalent to the source program. Our experimental results show this strategy <lb/>yields considerable performance improvements over prior approaches, while maintaining a clean <lb/>separation between privacy and programmatic concerns. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:28 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <div type="availability">DATA-AVAILABILITY STATEMENT <lb/>An artifact containing our implementation of Taypsi, its source code, and the source for all the <lb/>benchmarks in our experiments with instructions is publicly available [Ye and Delaware 2024]. The <lb/>appendix is included in the auxiliary material. <lb/></div>

        <div type="acknowledgement">ACKNOWLEDGMENTS <lb/>We thank Raghav Malik, Prasita Mukherjee, Tarindu Jayatilaka, Patrick LaFontaine, and the anony-<lb/>mous reviewers for their detailed comments and suggestions. We also thank Milind Kulkarni and <lb/>Ashish Kundu for many stimulating discussions about this work. The material in this paper is based <lb/>on work partially supported by Cisco Systems under award #23013611. <lb/></div>

        <listBibl>REFERENCES <lb/>Abbas Acar, Hidayet Aksu, A. Selcuk Uluagac, and Mauro Conti. 2018. A Survey on Homomorphic Encryption Schemes: <lb/>Theory and Implementation. ACM Computing Surveys (CSUR) 51, 4 (July 2018), 79:1-79:35. https://doi.org/10.1145/ <lb/>3214303 <lb/>Coşku Acay, Joshua Gancher, Rolph Recto, and Andrew C. Myers. 2024. Secure Synthesis of Distributed Cryptographic <lb/>Applications (Technical Report). https://doi.org/10.48550/arXiv.2401.04131 arXiv:2401.04131 [cs] <lb/>Coşku Acay, Rolph Recto, Joshua Gancher, Andrew C. Myers, and Elaine Shi. 2021. Viaduct: An Extensible, Optimizing <lb/>Compiler for Secure Distributed Programs. In Proceedings of the 42nd ACM SIGPLAN International Conference on Pro-<lb/>gramming Language Design and Implementation (PLDI 2021). Association for Computing Machinery, New York, NY, USA, <lb/>740-755. https://doi.org/10.1145/3453483.3454074 <lb/>Amal Ahmed. 2006. Step-Indexed Syntactic Logical Relations for Recursive and Quantified Types. In Programming Languages <lb/>and Systems (Lecture Notes in Computer Science), Peter Sestoft (Ed.). Springer, Berlin, Heidelberg, 69-83. https://doi.org/ <lb/>10.1007/11693024_6 <lb/>Yuyan Bao, Kirshanthan Sundararajah, Raghav Malik, Qianchuan Ye, Christopher Wagner, Nouraldin Jaber, Fei Wang, <lb/>Mohammad Hassan Ameri, Donghang Lu, Alexander Seto, Benjamin Delaware, Roopsha Samanta, Aniket Kate, Christina <lb/>Garman, Jeremiah Blocki, Pierre-David Letourneau, Benoit Meister, Jonathan Springer, Tiark Rompf, and Milind Kulkarni. <lb/>2021. HACCLE: Metaprogramming for Secure Multi-Party Computation. In Proceedings of the 20th ACM SIGPLAN <lb/>International Conference on Generative Programming: Concepts and Experiences (GPCE 2021). Association for Computing <lb/>Machinery, New York, NY, USA, 130-143. https://doi.org/10.1145/3486609.3487205 <lb/>Gilles Barthe, Gustavo Betarte, Juan Campo, Carlos Luna, and David Pichardie. 2014. System-Level Non-Interference for <lb/>Constant-Time Cryptography. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications <lb/>Security (CCS &apos;14). Association for Computing Machinery, Scottsdale, Arizona, USA, 1267-1279. https://doi.org/10.1145/ <lb/>2660267.2660283 <lb/>Gilles Barthe, Gustavo Betarte, Juan Diego Campo, and Carlos Luna. 2019. System-Level Non-Interference of Constant-Time <lb/>Cryptography. Part I: Model. Journal of Automated Reasoning 63, 1 (June 2019), 1-51. https://doi.org/10.1007/s10817-<lb/>017-9441-5 <lb/>Amos Beimel. 2011. Secret-Sharing Schemes: A Survey. In Coding and Cryptology (Lecture Notes in Computer Science), <lb/>Yeow Meng Chee, Zhenbo Guo, San Ling, Fengjing Shao, Yuansheng Tang, Huaxiong Wang, and Chaoping Xing (Eds.). <lb/>Springer, Berlin, Heidelberg, 11-46. https://doi.org/10.1007/978-3-642-20901-7_2 <lb/>Niklas Büscher, Daniel Demmler, Stefan Katzenbeisser, David Kretzmer, and Thomas Schneider. 2018. HyCC: Compilation <lb/>of Hybrid Protocols for Practical Secure Computation. In Proceedings of the 2018 ACM SIGSAC Conference on Computer <lb/>and Communications Security (CCS &apos;18). ACM, New York, NY, USA, 847-861. https://doi.org/10.1145/3243734.3243786 <lb/>Sunjay Cauligi, Gary Soeller, Brian Johannesmeyer, Fraser Brown, Riad S. Wahby, John Renner, Benjamin Grégoire, Gilles <lb/>Barthe, Ranjit Jhala, and Deian Stefan. 2019. FaCT: A DSL for Timing-Sensitive Computation. In Proceedings of the 40th <lb/>ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019). Association for Computing <lb/>Machinery, Phoenix, AZ, USA, 174-189. https://doi.org/10.1145/3314221.3314605 <lb/>Meghan Cowan, Deeksha Dangwal, Armin Alaghi, Caroline Trippel, Vincent T. Lee, and Brandon Reagen. 2021. Porcupine: <lb/>A Synthesizing Compiler for Vectorized Homomorphic Encryption. In Proceedings of the 42nd ACM SIGPLAN International <lb/>Conference on Programming Language Design and Implementation (PLDI 2021). Association for Computing Machinery, <lb/>New York, NY, USA, 375-389. https://doi.org/10.1145/3453483.3454050 <lb/>David Darais, Ian Sweet, Chang Liu, and Michael Hicks. 2020. A Language for Probabilistically Oblivious Computa-<lb/>tion. Proceedings of the ACM on Programming Languages 4, POPL (Jan. 2020), 1-31. https://doi.org/10.1145/3371118 <lb/>arXiv:1711.09305 <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <note place="headnote">Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation <lb/></note>

        <page>144:29 <lb/></page>

        <listBibl>Roshan Dathathri, Blagovesta Kostova, Olli Saarikivi, Wei Dai, Kim Laine, and Madan Musuvathi. 2020. EVA: An Encrypted <lb/>Vector Arithmetic Language and Compiler for Efficient Homomorphic Computation. In Proceedings of the 41st ACM <lb/>SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020). Association for Computing <lb/>Machinery, New York, NY, USA, 546-561. https://doi.org/10.1145/3385412.3386023 <lb/>Leonardo de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT Solver. In Tools and Algorithms for the Construction and <lb/>Analysis of Systems (Lecture Notes in Computer Science), C. R. Ramakrishnan and Jakob Rehof (Eds.). Springer, Berlin, <lb/>Heidelberg, 337-340. https://doi.org/10.1007/978-3-540-78800-3_24 <lb/>David Evans, Vladimir Kolesnikov, and Mike Rosulek. 2018. A Pragmatic Introduction to Secure Multi-Party Computation. <lb/>Foundations and Trends® in Privacy and Security 2, 2-3 (2018), 70-246. https://doi.org/10.1561/3300000019 <lb/>Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. 1993. The Essence of Compiling with Continuations. <lb/>ACM SIGPLAN Notices 28, 6 (June 1993), 237-247. https://doi.org/10.1145/173262.155113 <lb/>Craig Gentry. 2009. Fully Homomorphic Encryption Using Ideal Lattices. In Proceedings of the Forty-First Annual ACM <lb/>Symposium on Theory of Computing (STOC &apos;09). Association for Computing Machinery, New York, NY, USA, 169-178. <lb/>https://doi.org/10.1145/1536414.1536440 <lb/>J. A. Goguen and J. Meseguer. 1982. Security Policies and Security Models. In 1982 IEEE Symposium on Security and Privacy. <lb/>11-11. https://doi.org/10.1109/SP.1982.10014 <lb/>O. Goldreich, S. Micali, and A. Wigderson. 1987. How to Play ANY Mental Game. In Proceedings of the Nineteenth Annual <lb/>ACM Symposium on Theory of Computing (STOC &apos;87). Association for Computing Machinery, New York, New York, USA, <lb/>218-229. https://doi.org/10.1145/28395.28420 <lb/>M. Hastings, B. Hemenway, D. Noble, and S. Zdancewic. 2019. SoK: General Purpose Compilers for Secure Multi-Party <lb/>Computation. In 2019 2019 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, Los Alamitos, CA, USA, <lb/>479-496. https://doi.org/10.1109/SP.2019.00028 <lb/>Carmit Hazay and Yehuda Lindell. 2010. Efficient Secure Two-Party Protocols: Techniques and Constructions. Springer, Berlin ; <lb/>London. <lb/>Matthew E Hoekstra. 2015. Intel SGX for Dummies (Intel SGX Design Objectives). https://www.intel.com/content/www/ <lb/>us/en/develop/blogs/protecting-application-secrets-with-intel-sgx.html <lb/>Peeter Laud and Liina Kamm (Eds.). 2015. Applications of Secure Multiparty Computation. Number volume 13 in Cryptology <lb/>and Information Security Series. IOS Press, Amsterdam, Netherlands. <lb/>Chang Liu, Michael Hicks, and Elaine Shi. 2013. Memory Trace Oblivious Program Execution. In 2013 IEEE 26th Computer <lb/>Security Foundations Symposium. 51-65. https://doi.org/10.1109/CSF.2013.11 <lb/>C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi. 2015. ObliVM: A Programming Framework for Secure Computation. In <lb/>2015 IEEE Symposium on Security and Privacy. 359-376. https://doi.org/10.1109/SP.2015.29 <lb/>Raghav Malik, Kabir Sheth, and Milind Kulkarni. 2023. Coyote: A Compiler for Vectorizing Encrypted Arithmetic Circuits. <lb/>In Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and <lb/>Operating Systems, Volume 3 (ASPLOS 2023). Association for Computing Machinery, New York, NY, USA, 118-133. <lb/>https://doi.org/10.1145/3582016.3582057 <lb/>Raghav Malik, Vidush Singhal, Benjamin Gottfried, and Milind Kulkarni. 2021. Vectorized Secure Evaluation of Decision <lb/>Forests. In Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and <lb/>Implementation (PLDI 2021). Association for Computing Machinery, New York, NY, USA, 1049-1063. https://doi.org/10. <lb/>1145/3453483.3454094 <lb/>Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. 2004. Fairplay -a Secure Two-Party Computation System. In <lb/>Proceedings of the 13th Conference on USENIX Security Symposium -Volume 13 (SSYM&apos;04). USENIX Association, USA, 20. <lb/>Ueli Maurer. 2006. Secure Multi-Party Computation Made Simple. Discrete Applied Mathematics 154, 2 (Feb. 2006), 370-381. <lb/>https://doi.org/10.1016/j.dam.2005.03.020 <lb/>A. Rastogi, M. A. Hammer, and M. Hicks. 2014. Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty <lb/>Computations. In 2014 IEEE Symposium on Security and Privacy. 655-670. https://doi.org/10.1109/SP.2014.48 <lb/>Aseem Rastogi, Nikhil Swamy, and Michael Hicks. 2019. Wys*: A DSL for Verified Secure Multi-Party Computations. In <lb/>Principles of Security and Trust (Lecture Notes in Computer Science), Flemming Nielson and David Sands (Eds.). Springer <lb/>International Publishing, 99-122. https://doi.org/10.1007/978-3-030-17138-4_5 <lb/>A. Sabelfeld and A.C. Myers. 2003. Language-Based Information-Flow Security. IEEE Journal on Selected Areas in Communi-<lb/>cations 21, 1 (Jan. 2003), 5-19. https://doi.org/10.1109/JSAC.2002.806121 <lb/>Ian Sweet, David Darais, David Heath, William Harris, Ryan Estes, and Michael Hicks. 2023. Symphony: Expressive Secure <lb/>Multiparty Computation with Coordination. The Art, Science, and Engineering of Programming 7, 3 (Feb. 2023), 14:1-14:55. <lb/>https://doi.org/10.22152/programming-journal.org/2023/7/14 <lb/>Alexander Viand, Patrick Jattke, Miro Haller, and Anwar Hithnawi. 2023. HECO: Fully Homomorphic Encryption Compiler. <lb/>In 32nd USENIX Security Symposium (USENIX Security 23). USENIX Association, Anaheim, CA, USA, 4715-4732. https: <lb/>//www.usenix.org/conference/usenixsecurity23/presentation/viand <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. <lb/></note>

        <page>144:30 <lb/></page>

        <note place="headnote">Qianchuan Ye and Benjamin Delaware <lb/></note>

        <listBibl>Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. 2016. EMP-toolkit: Efficient MultiParty computation toolkit. https: <lb/>//github.com/emp-toolkit. <lb/>Jean Yang, Kuat Yessenov, and Armando Solar-Lezama. 2012. A Language for Automatically Enforcing Privacy Policies. In <lb/>Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages -POPL &apos;12. <lb/>ACM Press, Philadelphia, PA, USA, 85. https://doi.org/10.1145/2103656.2103669 <lb/>Andrew C. Yao. 1982. Protocols for Secure Computations. In 23rd Annual Symposium on Foundations of Computer Science <lb/>(Sfcs 1982). 160-164. https://doi.org/10.1109/SFCS.1982.38 <lb/>Qianchuan Ye and Benjamin Delaware. 2022. Oblivious Algebraic Data Types. Proceedings of the ACM on Programming <lb/>Languages 6, POPL (Jan. 2022), 51:1-51:29. https://doi.org/10.1145/3498713 <lb/>Qianchuan Ye and Benjamin Delaware. 2023. Taype: A Policy-Agnostic Language for Oblivious Computation. Proceedings <lb/>of the ACM on Programming Languages 7, PLDI (June 2023), 147:1001-147:1025. https://doi.org/10.1145/3591261 <lb/>Qianchuan Ye and Benjamin Delaware. 2024. Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious <lb/>Computation: OOPSLA24 Artifact. Zenodo. https://doi.org/10.5281/zenodo.10701642 <lb/>Samee Zahur and David Evans. 2015. Obliv-C: A Language for Extensible Data-Oblivious Computation. Technical Report <lb/>1153. https://eprint.iacr.org/2015/1153 <lb/>Stephan Arthur Zdancewic. 2002. Programming Languages for Information Security. Ph. D. Dissertation. Cornell University, <lb/>USA. <lb/>Yihua Zhang, Aaron Steele, and Marina Blanton. 2013. PICCO: A General-Purpose Compiler for Private Distributed <lb/>Computation. In Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp; Communications Security (CCS &apos;13). <lb/>Association for Computing Machinery, New York, NY, USA, 813-826. https://doi.org/10.1145/2508859.2516752 <lb/></listBibl>

        <front>Received 21-OCT-2023; accepted 2024-02-24 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 144. Publication date: April 2024. </note>


	</text>

</TEI>