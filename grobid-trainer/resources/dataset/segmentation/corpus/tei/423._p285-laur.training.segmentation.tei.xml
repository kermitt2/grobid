<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>~@ Computer Graphics, Volume 25, Number 4, July 1991 <lb/>Hierarchical Splatting: <lb/>A Progressive Refinement Algorithm <lb/>for <lb/>Volume Rendering <lb/>David Laur and Pat Hanrahan <lb/>Princeton University <lb/>Princeton, NJ 08544, USA <lb/>Abstract <lb/>This paper presents a progressive refinement algorithm <lb/>for volume rendering which uses a pyramidal volume repre-<lb/>sent at ion. Besides storing average values, the pyramid stores <lb/>estimated error, so an octtree can be fit to the pyramid given <lb/>a user-supplied precision. This octtree is then drawn using <lb/>a set of splats, or footprints, each scaled to match the size <lb/>of the projection of a cell. The splats themselves are ap <lb/>proximate <lb/>with RGBA Gouraud-shaded <lb/>polygons, so that <lb/>they can be drawn efficiently on modern graphics worksta-<lb/>tions. The result is a real-time rendering algorithm suitable <lb/>for interactive applications. <lb/>CR Categories <lb/>and Subject Descriptors: <lb/>1.3.7 [Com-<lb/>pu ter Graphics]: Three-Dimensional <lb/>Graphics and Realism. <lb/>Key Words: volume rendering, coherence, progressive re-<lb/>finement, interactive techniques. <lb/></front>

			<body>1 Introduction <lb/>Volume visualization is a collection of techniques for visual-<lb/>izing 3D functions. The earliest methods extracted conven-<lb/>tional computer graphics primitives such as surfaces, curves, <lb/>or points, and then displayed them. More recent methods <lb/>render the volume directly, without this intermediate conver-<lb/>sion. This involves forming an RGBA (color and opacity) <lb/>volume, and projecting it from the desired point of view. <lb/>RGBA volumes can represent both interiors and the sur-<lb/>faces representing the boundaries between different regions. <lb/>If just surfaces are shown, the pictures look quite similar to <lb/>those generated by first extracting surfaces and then render-<lb/>ing them. However, if interiors are also shown, they appear <lb/>as clouds with varying density and color. A big advantage <lb/>of volume rendering is that this interior information is not <lb/>thrown away; a disadvantage is that cloudy interiors are hard <lb/>to interpret. <lb/>This paper presents an algorithm for rendering opacity <lb/>projections at interactive rates on a typical high performance <lb/>graphics workstation. Motion is very helpful in understand-<lb/>ing opacity projections. <lb/>For example, the output of com-<lb/>mercial medicaJ imaging systems generate film loops and not <lb/>just static imagery. Furthermore, the amount of information <lb/>gained from a motion study is much greater if the motion <lb/>is under interactive control, for then the user can vary the <lb/>motion to highlight what they are currently focusing on. <lb/></body>

			<front>Pem]ission [o cnpy w!lhmrlfw dll nr p~rt !~fthis material is grtintccl <lb/>provided that the cnpiei are nut made nr distributed for direct <lb/>commercial advantage. the ACM cnpyright nnt!cc md [he d[Ie nf the <lb/>puhli~dtimr tindits date appear, iindnnticcis gtvcn [hat copying IS by <lb/>pcm~issionof the Asnciation f&apos;t~rComputing Mtichlnery. To cnpy <lb/>otherwise. or to rcpuhlish, requires a fce anchr specific permission. <lb/>(&apos;1 1991 <lb/>ACM-O-89791 -436-8/!Tl/007/f)285 <lb/>$00.75 <lb/></front>

			<body>Our algorithm is based on two key ideas: coherence and <lb/>progressive refinement. <lb/>Recent research has shown how to <lb/>take advantage of coherence when performing opacity pro-<lb/>jections of large cells filled with cloudy material [9; 8; 6; <lb/>11]. The most relevant to the work reported here are those <lb/>methods that approximate the projection with a collection <lb/>of Gouraud-shaded <lb/>RGBA polygons [8; 11]. Progressive re-<lb/>finement involves simplifying either the model or the ren-<lb/>dering algorithm, or both, until pictures can be produced <lb/>at interactive rates, and then computing successively better <lb/>images when free time is available, for example, when the <lb/>user pauses to examine an interesting image [1]. <lb/>This paper proposes a splatting aigorithm [3; 10] that <lb/>works on a pyramidal representation of the volume. Splat-<lb/>ting works by first sorting cells from back to front and <lb/>then compositing the projection of each cell, called its @-<lb/>print, into an accumulating projection image. Our algorithm <lb/>builds a set of footprints at different sizes-one for each level <lb/>in the pyramid. The time to draw a splat is constant, or at <lb/>worst rrroDortional to its area. so substantial time is saved <lb/>by dra~in~a single large splat &apos;instead of a volume of smaller <lb/>splats. More interestingly, the algorithm does not just draw <lb/>a reduced resolution version of the volume, but determines <lb/>the number of the splats by fitting a collection of cells at dif-<lb/>ferent resolutions in the pyramid to the original data based <lb/>on a user-supplied error criten&quot;a. Progretwive refinement pr-<lb/>ceeds by gradually reducing the error associated with the fit, <lb/>2 <lb/>Reconstruction <lb/>and Projection <lb/>The ideal volume rendering algorithm performs the following <lb/>three steps: (i) reconstructs the continuous function from the <lb/>discrete samples, (ii) transforms the continuous function for <lb/>viewing, and (iii) evaluates the opacity integral along each <lb/>line-of-sight. <lb/>Splatting algorithms approximate this proce-<lb/>dure. The reconstruction function is transformed according <lb/>to the current viewing transformation, and then is projected <lb/>using the opacity integral to form a 2D footprint. There is <lb/>only one footprint per view per volume if the data is uni-<lb/>formly sampled and the viewing transformation is a parallel <lb/>projection. To generate the complete image, the footprints <lb/>are composite <lb/>on top of each other in back to front orderl. <lb/>Splatting algorithms are not equivalent to the idealized ren-<lb/>dering process outlined above, because reconstruction <lb/>and <lb/>projection cannot be reordered, if the reconstruction <lb/>func-<lb/>tions from different samples overlap, which is necessary to <lb/></body>

			<note place="footnote">&apos;Actually Westover&apos;s rdgorithm reconstructs all the sam-<lb/>ples from a Ianar slice into a slice ima e,. and then com-<lb/>Y&quot; <lb/>f <lb/>posltes the s lce Image onto the accumu atmg final Image. <lb/></note>

			<page>285 <lb/></page>

			<note place="headnote">Z SIGGRAPH &apos;91 Las Vegas, 28 July-2 August 1991 <lb/></note>

			<body>Figure 1: Different splat shapes and their footprints. <lb/>generate a smooth continuous image. <lb/>Current splatting algorithms simplify this procedure even <lb/>further. Westover approximates the footprint with a 2D el-<lb/>liptical Gaussian [lo]. This is an approximation because <lb/>the reconstruction function and scattering model are never <lb/>specified. More recently, methods have been developed for <lb/>rendering the opacity projections of polyhedral cells using <lb/>RGBA polygons. Wilhelms breaks the projection of a cu-<lb/>bical cell into topologically uniform regions, and then com-<lb/>putes the opacity at the vertices according to various pro-<lb/>jection formula [ll]. A similar approach can be applied to <lb/>tetrahedra, which have the advantage that there are only <lb/>two topologically distinct casea to consider [8]. <lb/>We have built a flexible system based on approximating <lb/>footprints with a collection of Gonraud-shaded polygons. <lb/>These polygons can be used to build a piecewise linear ap <lb/>proximation to any footprint function. A generalized &quot;Gaus-<lb/>sian&quot; splat is defined by (1) the number of angular subdi-<lb/>visions, (2) the number of radial subdivisions, and (3) the <lb/>opacity of the splat at a given radial distance. Some typical <lb/>splats are shown in Figure 1. <lb/>The advantage of outputting Gouraud-shaded polygons <lb/>is that workstations have been optimized to draw them for <lb/>surface rendering applications. Recent workstations have <lb/>added the ability to interpolate Q along with color, and to <lb/>provide hardware assist for compositing [7]. Also, since the <lb/>graphics hardware is handling the transformation and scan <lb/>conversion, both orthographic and perspective projections <lb/>are possible. Furthermore, if the polygon is point sampled <lb/>correctly and if the vertices have subpixel position, then the <lb/>of the splat can also be positioned accurately. Our <lb/>algorithm approximates the volume at multiple resolutions, <lb/>and hence, we need to draw different sized splats. This is <lb/>done by scaling the polygons, and hence, the <lb/>amount of data describing a splat is independent of splat <lb/>size. Therefore, the overhead involved in transferring the <lb/>splat to the graphics engine is independent of size. The cost <lb/>of a splat, however, does involve an area depen-<lb/>Figure 2: Plot of opacity correction <lb/>dent term, because the time needed for scan conversion and <lb/>compositing depend on the actual number of pixels output. <lb/>There is one major complication when rendering different <lb/>sized splats, and that is doubling the size of splat <lb/>more than doubles its opacity. This is important effect <lb/>that we like to qualitatively. To approximate <lb/>this effect, we compute the transparency of a single double-<lb/>sized Gaussian splat that is equivalent to compositing two <lb/>smaller unit-sized splats directly on top of each other. <lb/>(1 -02)e -=2/G = ((1 _ a1)e-+3)2 <lb/>where crl and 61 are the opacities and standard deviations, <lb/>respectively, of the smaller unit splat, and ~2 and a2 are the <lb/>corresponding derived quantities for the double-sized splat. <lb/>The effective opacity and sigma for the larger splat are <lb/>(1 -a2) = (1 -~~)2 <lb/>and <lb/>4 = 0:/2 <lb/>Thus, when a splat is doubled in size, a new opacity can <lb/>be computed using this formula. Figure 2 plots this opacity <lb/>correction as a function of opacity and resolution. As can <lb/>be seen, this is large effect. Note also that the of <lb/>the footprint also changes with scale. Regions close to the <lb/>center are less transparent than regions far from the center, <lb/>causing the splat to appear narrower and more concentrated. <lb/>However, this effect is countered by the fact that not only are <lb/>splats composited in depth, but they also cover the image in <lb/>x-y; this causes the two smaller splats to actually be larger <lb/>than the double.-size splat. For this reason, we simply scale <lb/>splats and ignore any shape changes. <lb/>Figure 3 shows a set of splats at different resolutions with <lb/>and opacity correction. Figure 4 shows the projec-<lb/>tion of a constant-valued volume with different sized splats, <lb/>with and the opacity correction. Ideally, changing <lb/>the resolution should have no effect. Although our approxi-<lb/>mation does not perfectly, it is much better than using <lb/>no correction, as can be seen by the examples. <lb/>3 Hierarchical Traversal <lb/>To take advantage of the ability to draw different sized splats <lb/>efficiently, we build a multiresolution representation of the <lb/>original volume. In thii paper, we use the word &quot;pyramid&quot; <lb/>to indicate a complete resolution set, and word &quot;oct-<lb/>tree&quot; to indicate some subset of the pyramid that completely <lb/>spans the volume. Pyramids and act-trees have been used <lb/></body>

			<page>286 <lb/></page>

			<note place="headnote">@Q Computer Graphics, Volume 25, Number 4, July 1991<lb/></note>

			<body>Figure 3: Footprint of a single splat vs. power-of-two resoiu-<lb/>tion. The upper row shows the uncorrected opacity prob-<lb/>tion, and hence, as the splats increase in size they become <lb/>more transparent. The lower row shows the corrected opac-<lb/>ity projection. <lb/>previously for volume rendering. Levoy [4] used a binary <lb/>pyramid to indicate the presence of non-transparent material <lb/>to accelerate ray tracing. Levoy [5] also used a pyramid <lb/>of averaged values, commonly called a mip-map [13]. for <lb/>gaze-directed rendering. Others have used min-mazor range <lb/>pyramids to allow efficient iso-surface extraction [14; 2; 121. <lb/>The regular structure of pyramids and act-trees allows <lb/>them to be traversed in front-to-back or back-t-front order <lb/>just as easily as uniformly sampled voxel arrays. Note that <lb/>the order in which the children are traversed is the same <lb/>everywhere for a parallel projection, but may change for a <lb/>perspective projection. <lb/>In the pyramid that build, each node contains sev-<lb/>eral pieces of information. As with a mip-map, every node <lb/>contains the average RGBA value of all its children. These <lb/>values are used for drawing the splats. Since the RGBA <lb/>assignments depend on the current scalar to RGBA map <lb/>ping, the mip-map needs to be recomputed every time the <lb/>transfer function changes. Also since the RGBA assignment <lb/>depends on shading, only view-independent shading formula <lb/>are handled efficiently by this approach. <lb/>Every node in the pyramid also contains a variable in-<lb/>dicating the average error associated with that node. This <lb/>error term measures the average cost of approximating this <lb/>region of space with a constant function equal to the node&apos;s <lb/>average value, rather than with the original set of voxel val-<lb/>ues contained in the region. The root mean square error due <lb/>to this approximation is <lb/>where e: is the error associated with node i at level I, r$ <lb/>is the number of voxels comprising that region, and si IS <lb/>the value of voxel i. This error measure can be computed <lb/>efficiently using a single traversal of the pyramid. <lb/>To approximate the volume most efficiently, we would <lb/>like the error per unit volume to be uniformly distributed <lb/>throughout the volume. Moreover, we would like to use the <lb/>lowest resolution in the pyramid that falls within the al-<lb/>lowable error. Since the error in the approximation is data <lb/>dependent, different regions in the volume will in general <lb/>need different levels of detail. We can think of this process <lb/>Figure 4: Projection of a constant-valued volume with dif-<lb/>ferent sized splats. The left column shows the resolution, <lb/>the middle column shows the uncorrected opacity projec-<lb/>tion, and the right column the corrected opacity projection. <lb/>Figure 5: Ott-trees with different error contours <lb/>as fitting an act-tree to a pyramid. This fit can be performed <lb/>with a single traversal of the pyramid. At each level in the <lb/>pyramid, the desired error per unit volume is compared to <lb/>the average error for the given node, if the average error is <lb/>less than the desired error, the traversal is terminated at this <lb/>level, otherwise it proceeds downward. <lb/>Several act-trees, with decreasing total error, are shown <lb/>in Figure 5. Note the desired effect, where the data changes <lb/>rapidly it is approximated with many small nodes, and where <lb/>it changes slowly, it is approximated with fewer large nodes. <lb/>Furthermore, the number of nodes varies with error; the <lb/>lower the error the more nodes. Thus, this error representa-<lb/>tion is ideal for automatically adjusting the number of nodes <lb/>in the volume representation, as required for progressive re-<lb/>finement. <lb/></body>

			<page>287 <lb/></page>

			<note place="headnote">Z SIGGRAPH &apos;91 Las Vegas, 28 July-2 August 1991 <lb/></note>

			<body>Figure 6: Engine block (256x256~110). <lb/>4 Results <lb/>Figure 6 shows an industrial CT-scan of an engine block <lb/>drawn at three different resolutions. The resolutions were <lb/>chosen by the following three criteria: (i) What can be drawn <lb/>5 times a second-this is what the image looks like during <lb/>motion, (ii) what can be drawn in 5 seconds-this is what <lb/>the image looks like after motion has stopped and the image <lb/>has been refined for a reasonable amount of time, and (iii) <lb/>what the resulting image looks like at full resolution. <lb/>Several conclusions can be drawn. First, the highest res-<lb/>olution pictures do not look as good as the very best previ-<lb/>ous volume rendering techniques. The approximations intro <lb/>duced to achieve interactive rates, unfortunately, still sacri-<lb/>fices quality for speed. Second, although the lowest resolu-<lb/>tion image looks crude when viewed as a still, it is surpris-<lb/>ingly effective when viewed in motion. <lb/>5 Discussion <lb/>Previous approaches to using multi-resolution volume rep <lb/>resentations were based on the discrete concept of pruning <lb/>away regions which didn&apos;t contribute to the final answer. A <lb/>desirable property of the algorithm described in this paper <lb/>is that the pruning is function of both opacity and accuracy. <lb/>Opacity indicates presence, and if no material is present, <lb/>cells are pruned just as in the previous work. However, the <lb/>error indicates the accuracy of the approximation, and low <lb/>error in a large region indicates that it is homogeneous, and <lb/>1 homogeneous regions can be drawn efficiently using large <lb/>splats. We expect that these ideas also can be used to accel-<lb/>erate high-quality ray tracing-based volume rendering algo <lb/>rithms. We also think this multi-resolution approximation <lb/>scheme has many other applications in computer graphics. <lb/></body>

			<div type="acknowledgement">Acknowledgments <lb/>This research was supported by an equipment grant fxom <lb/>Silicon Graphics. <lb/></div>

			<listBibl>References <lb/>PI ~~~ysp~c;wan, Henry Fuchs, Eric Grant, and Su-<lb/>Image rendering by adaptive refine-<lb/>ment. Computer Gmphics (SIGGRAPH &apos;86 Proceed-<lb/>ings), 20(4):29-38, August 1986. <lb/>PI <lb/>[31 <lb/>[41 <lb/>PI <lb/>PI <lb/>[71 <lb/>PI <lb/>PI <lb/>PO1 <lb/>IllI <lb/>P21 <lb/>P31 <lb/>P41 <lb/>Jules Bloomenthal. <lb/>Polygonization of implicit sur-<lb/>faces. Computer Aided Geometric Design, 5(4):341-355, <lb/>November 1988. <lb/>Harvey E. Cline, William E. Lorensen, Sigwalt Ludke, <lb/>Carl R. Crawford, and Bruce C. Teeter. Two algo-<lb/>rithms for the reconstruction of surfaces from tomo-<lb/>grams. Medical Physics, 15(3):320-327, June, 1988. <lb/>Marc Levoy. Efficient ray tracing of volume data. ACM <lb/>Tmnsactions on Graphics, 9(3):245-261, July 1990. <lb/>Marc Levoy and Ross Whitaker. Gaze-directed volume <lb/>rendering. Computer Gmphics (Symposium on Interac-<lb/>tive SD Gmphics), 24(2):217-223, March 1990. <lb/>Nelson Max, Pat Hanrahan, and Roger Crawfis. Area <lb/>and volume coherence for efficient visualization of 3d <lb/>scalar functions. Computer Graphics (San Diego Work-<lb/>shop on Volume Visualitaton), 24(5):27-33, November <lb/>1990. <lb/>Thomas Porter and Tom Duff. Cornpositing digital im-<lb/>ages. Computer Graphics (SIGGRAPH &apos;84 Proceed-<lb/>ings), 18(3):253-260, July 1984. <lb/>Peter Shirley and Allan Tuchman. A polygonal approx-<lb/>imation to direct scalar volume rendering. Computer <lb/>Graphics (San Diego Workshop on Volume Visualiza-<lb/>ton), 24(5):63-70, November 1990. <lb/>Craig Upson and Michael Keeler. V-buffer: Visible <lb/>volume rendering. Computer Graphics (Proceedings of <lb/>SIGGRAPH &apos;88), 22(4):59-64, August 1988. <lb/>Lee Westover. Footprint evaluation for volume render-<lb/>ing. Computer Gmphics, 24(4):367-376, August 1990. <lb/>Jane Wilhelms. A coherent projection approach to <lb/>direct volume rendering. <lb/>Computer Graphics (SIG-<lb/>GRAPH &apos;91 Proceedings), July 1991. <lb/>Jane Wilhelms and Allan Van Gelder. Octrees for <lb/>faster isosurface generation. Computer Gmphics (San <lb/>Diego Workshop on Volume Visualitaton), 24(5):57-62, <lb/>November 1990. <lb/>Lance Williams. Pyramidal parametrics. Computer <lb/>Graphics (SIGGRAPH &apos;83 Proceedings), 17(3):1-l 1, <lb/>July 1983. <lb/>Brian Wyvill, Craig McPheeters, and Geoff Wyvill. <lb/>Data structure for soft objects. The Visual Computer, <lb/>2(4):227-234, 1986. </listBibl>


	</text>
</tei>
