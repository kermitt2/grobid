<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
		<front>The Semantics of the C Programming Language <lb/>Yuri Gurevich and James K. Huggins <lb/>EECS Department, University o f M i c higan, Ann Arbor, MI 48109-2122, USA <lb/>February 19, 1993 <lb/>This paper rst appeared in GH2], and incorporates the corrections indicated in GH3]. <lb/></front>

		<body>0 Introduction <lb/>We present formal operational semantics for the C programming language. Our starting point is the ANSI <lb/>standard for C as described in KR]. Knowledge of C is not necessary (though it may be helpful) for <lb/>comprehension, since we explain all relevant aspects of C as we proceed. <lb/>Our operational semantics is based on evolving algebras. An exposition on evolving algebras can be <lb/>found in the tutorial Gu]. In order to make this paper self-contained, we recall the notion of a (sequential) <lb/>evolving algebra in Sect. 0.1. <lb/>Our primary concern here is with semantics, not syntax. Consequently, w e assume that all syntactic <lb/>information regarding a given program is available to us at the beginning of the computation (via static <lb/>functions). We i n t e n d e d t o c o ver all constructs of the C programming language, but not the C standard <lb/>library functions (e.g. fprintf(), fscanf()). It is not di cult to extend our description of C to include <lb/>any desired library function or functions. <lb/>Evolving algebra semantic speci cations may b e p r o vided on several abstraction levels for the same <lb/>language. Having several such algebras is useful, for one can examine the semantics of a particular feature of <lb/>a programming language at the desired level of abstraction, with unnecessary details omitted. It also makes <lb/>comprehension easier. We present a series of four evolving algebras, each a re nement of the previous one. <lb/>The nal algebra describes the C programming language in full detail. <lb/>Our four algebras focus on the following topics respectively: <lb/>1. Statements (e.g. if, for) <lb/>2. Expressions <lb/>3. Memory allocation and initialization <lb/>4. Function invocation and return <lb/>What about possible errors, i.e., division by zero or de-referencing a pointer to an invalid address? These <lb/>issues are very implementation-dependent. Even what constitutes an error is implementation-dependent. If <lb/>an external function does not produce any v alue in a state where a value is expected, the evolving algebra <lb/>will be stalled in that state forever. It is natural to suppose that if an external function does produce a value, <lb/>it is of the appropriate type. One may w ant to augment the guards of transition rules to check for errors <lb/>in this way, the evolving Nalgebra will halt on error conditions (and may e v en output an error message if <lb/>desired). There are more subtle ways to handle errors. We ignore the issue here. <lb/>To re ect the possibility of di erent implementations, our evolving algebras contain implementation-<lb/>dependent parameters. For example, the set of values \storable&quot; in a pointer variable is implementation-<lb/>dependent. Thus, each of our four evolving algebras gives rise to a family of di erent e v olving algebras. <lb/></body>

            <front>Partially supported by ONR and NSF. <lb/></front>

            <page>1 <lb/></page>

            <page>2 <lb/></page>

            <note place="headnote">0 INTRODUCTION <lb/></note>

            <body>0.1 Evolving Algebras <lb/>An evolving algebra A is an abstract machine. Here we restrict attention to sequential evolving algebras. <lb/>The signature of A is a ( nite) collection of function names, each n a m e h a ving a xed arity. A state of <lb/>A is a set, the superuniverse, together with interpretations of the function names in the signature. These <lb/>interpretations are called basic functions of the state. The superuniverse does not change as A evolves the <lb/>basic functions may. <lb/>Formally, a basic function of arity r (i.e. the interpretation of a function name of arity r) i s a n r-ary <lb/>operation on the superuniverse. (We often use basic functions with r = 0 s u c h basic functions will be called <lb/>distinguished elements.) But functions naturally arising in applications may be de ned only on a part of the <lb/>superuniverse. Such partial functions are represented by total functions in the following manner. <lb/>The superuniverse contains distinct elements true, false, undef which allow us to deal with relations <lb/>(viewed as binary functions with values true or false) and partial functions (where f(a) = undef means f <lb/>is unde ned at the tuple a). These three elements are logical constants. Their names do not appear in the <lb/>signature this is similar to the situation in rst-order logic with equality where equality is a logical constant <lb/>and the sign of equality does not appear in the signature. In fact, we use equality as a logical constant a s <lb/>well. <lb/>Further, a universe U is a special type of basic function: a unary relation usually identi ed with the <lb/>set fx : U(x)g. The universe Bool = ftrue falseg is another logical constant. When we speak about, <lb/>say, a function f from a universe U to a universe V , w e mean that formally f is a unary operation on <lb/>the superuniverse such that f(a) 2 V for all a 2 U and f(a) = undef otherwise. We use self-explanatory <lb/>notations like f : U ! V , f : U 1 U 2 ! V , a n d f : V . The last means that the distinguished element f <lb/>belongs to V . <lb/>In principle, a program of A is a nite collection of transition rules of the form <lb/>if t 0 then f(t 1 : : : t r ) : = t r+1 endif <lb/>(1) <lb/>where t 0 , f(t 1 : : : t r ), and t r+1 are closed terms (i.e. terms containing no free variables) in the signature of <lb/>A. An example of such a term is g(h 1 h 2 ) where g is binary and h 1 and h 2 are zero-ary. The meaning of the <lb/>rule shown above is this: Evaluate all the terms t i in the given state if t 0 evaluates to true then change the <lb/>value of the basic function f at the value of the tuple (t 1 : : t r ) to the value of t r+1 , otherwise do nothing. <lb/>In fact, rules are de ned in a slightly more liberal way if k is a natural number, b 0 : : : b k are terms and <lb/>C 0 : : : C k+1 are sets of rules then both of the following are rules: <lb/>if b 0 then C 0 <lb/>if b 0 then C 0 <lb/>elseif b 1 then C 1 <lb/>elseif b 1 then C 1 <lb/>. . . <lb/>. . . <lb/>elseif b k then C k <lb/>elseif b k then C k <lb/>else C k+1 <lb/>endif <lb/>endif <lb/>Since the C i are sets of rules, nested transition rules are allowed (and occur frequently). To s a ve space, <lb/>we abbreviate the series of endif&apos;s at the tail of a transition rule by ENDIF. <lb/>A program is a set of rules. It is easy to transform a program to an equivalent program comprising only <lb/>rules of the stricter form (1). We use rules of the more liberal form, as well as macros (textual abbreviations), <lb/>for brevity. <lb/>How d o e s A evolve from one state to another? In a given state, the demon (or interpreter) evaluates <lb/>all the relevant terms and then makes all the necessary updates. If several updates contradict each other <lb/>(trying to assign di erent v alues to the same basic function at the same place), then the demon chooses <lb/>nondeterministically one of those updates to execute. <lb/>We call a function (name) f dynamic if the demon (interpreter) may c hange f as the algebra evolves i.e. <lb/>if an assignment of the form f(t 1 : : : t r ) : = t 0 appears anywhere in the transition rules. Functions which <lb/></body>

            <note place="headnote">0.2 Acknowledgements <lb/></note>

            <page>3 <lb/></page>

            <body>are not dynamic are called static. T o a l l o w our algebras to interact conveniently with the outside world, <lb/>we also make use of external functions within our algebra. External functions are syntactically static (that <lb/>is, never changed by rules), but have their values determined by an oracle. Thus, an external function may <lb/>have di erent v alues for the same arguments as the algebra evolves. <lb/></body>

            <div type="acknowledgement">0.2 Acknowledgements <lb/>An earlier version of this paper appeared as a technical report GH1]. We gratefully acknowledge comments <lb/>made by on the original report by E g o n B orger, Andre Burago, Martin J. D urst, Stefano Guerrini, Raghu <lb/>Mani, Arnd Poetzsch-He ter, Dean Rosenzweig, and Marcus Vale, as well as comments in the errata made <lb/>by Lars Ole Andersen, L. Douglas Baker, Arnd Poetzsch-He ter, Thomas Tsukada, and Chuck W allace. <lb/></div>

            <body>1 Algebra One: Handling C Statements <lb/>Our rst evolving algebra models the control structures of C. <lb/>1.1 Some Basic Functions <lb/>A universe tasks consists of elements representing tasks to be accomplished by the program interpreter. The <lb/>notion of task is a general one: e.g., a task may be the execution of a statement, initialization of a variable, <lb/>or the evaluation of an expression. The elements of this universe are dependent on the particular C program <lb/>being executed by the abstract machine. It is often useful to mark a given task with tags indicating its <lb/>nature. This gives rise to a universe of tags. <lb/>A distinguished element CurTask: tasks indicates the current task. In order to execute tasks in the proper <lb/>order, a static function NextTask: tasks ! tasks indicates the next task to be performed once the current <lb/>task has been completed. A static function TaskType: tasks ! tags indicates the action to be performed by <lb/>the task. <lb/>A universe results contains values which m a y appear as the result of a computation. <lb/>1.2 Macro: Moveto <lb/>Often, we transfer control to a particular task, modifying CurTask to indicate the transfer of control. In <lb/>Algebra Two, the rules for modifying CurTask will change somewhat in order to facilitate this change, we <lb/>will use the Moveto(Task) macro each time that we wish to transfer control. For now, the de nition of <lb/>Moveto(Task) is shown in Fig. 1. <lb/>Moveto(Task) <lb/>CurTask := Task <lb/>Figure 1: De nition of the Moveto(Task) macro. <lb/>1.3 Statement Classi cation in C <lb/>According to KR], there are six categories of statements in C: <lb/>1. Expression statements, which e v aluate the associated expression. <lb/></body>

            <page>4 <lb/></page>

            <note place="headnote">1 ALGEBRA ONE: HANDLING C STATEMENTS <lb/></note>

            <body>2. Selection statements (if and switch). <lb/>3. Iteration statements (for, while, a n d do-while). <lb/>4. Jump statements (goto, continue, break, a n d return). <lb/>5. Labeled statements (case and default statements used within the scope of a switch statement, and <lb/>targets of goto statements). <lb/>6. Compound statements, consisting of a (possibly empty) list of local variable declarations and a (possibly <lb/>empty) list of statements. <lb/>. <lb/>1.4 Expression Statements <lb/>An expression statement has one of the following forms: <lb/>expression-statement ! <lb/>expression-statement ! expression <lb/>To execute an expression statement, evaluate the attached expression (if any), even though the resulting <lb/>value will not be used. While this may seem unnecessary, note that the evaluation of an expression in C may <lb/>generate side-e ects (such as assigning a value to a variable). Note also that the evaluation of an expression <lb/>may not halt. In this algebra, the evaluation of expressions is handled by an external function TestValue: <lb/>tasks ! results. <lb/>Since expression statements perform no additional work, the algebra simply proceeds to the next task. <lb/>The transition rule for expression tasks is shown in Fig. 2. <lb/>if TaskType(CurTask) = expression then <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 2: Transition rule for expression tasks. <lb/>1.5 if Statements <lb/>There are two t ypes of selection statements in C: if statements and switch statements. An if statement <lb/>has one of the following forms: <lb/>if-statement ! if ( expression ) statement1 <lb/>if-statement ! if ( expression ) statement1 else statement2 <lb/>where statement1 and statement2 are statements. <lb/>To execute an if statement, begin by e v aluating the guard expression. If the resulting value is non-<lb/>zero, execute statement1 . If the resulting value is zero and an else clause is present, execute statement2 . <lb/>otherwise, execute the statement f o l l o wing the if statement. Static partial functions TrueTask: tasks ! <lb/>tasks and FalseTask: tasks ! tasks indicate the task to be performed if the guard of the if statement <lb/>evaluates to a non-zero value or zero, respectively. <lb/></body>

            <note place="headnote">1.6 switch Statements <lb/></note>

            <page>5 <lb/></page>

            <body>The branching decision made in the if statement is represented by an element o f t h e tasks universe for <lb/>which the TaskType function returns branch. W e illustrate a typical if statement with the graph in Fig. 3, <lb/>where ovals represent tasks, labeled arcs represent the corresponding unary functions, and boxes represent <lb/>subgraphs. If an else clause is not present i n a n if statement, the corresponding task graph omits the <lb/>lower portion of Fig. 3, with the FalseTask function connecting the branch task to the task following the if <lb/>statement. The transition rule for branch tasks is shown in Fig. 4. <lb/>NextTask <lb/>T r u e T a s k <lb/>F a l s e T a s k <lb/>N ex tT as k <lb/>FalseTask <lb/>N e x tT a s k <lb/>expression <lb/>branch <lb/>stmt1 <lb/>stmt2 <lb/>Figure 3: A typical if statement. <lb/>if TaskType(CurTask) = branch then <lb/>if TestValue(CurTask) 6 = 0 then <lb/>Moveto(TrueTask(CurTask)) <lb/>elseif TestValue(CurTa s k ) = 0 then <lb/>Moveto(FalseTask(CurTask)) <lb/>ENDIF <lb/>Figure 4: Transition rule for branch tasks. <lb/>Remark. Fig. 3 shows a typical if statement, but it is not representative o f a l l if statements. The <lb/>presence of a jump statement i n statement1 or statement2 may cause NextTask to point to a di erent task <lb/>than the one which immediately follows the if statement. <lb/>1.6 switch Statements <lb/>A switch statement has the following form: <lb/>switch-statement ! switch ( expression ) body <lb/>where body is a statement, usually compound. <lb/>Within the body of a switch statement there are (usually) labeled case and default statements. Each <lb/>case or default is associated with the smallest enclosing switch statement. <lb/>To execute a switch statement, evaluate the guard expression, and within the body of the switch, transfer <lb/>control to the case statement f o r t h e switch whose labeled value matches the value of the expression, or to <lb/>the default statement for the switch, whichever comes rst. If no such statement is found, transfer control <lb/>to the statement following the switch statement. <lb/></body>

            <page>6 <lb/></page>

            <note place="headnote">1 ALGEBRA ONE: HANDLING C STATEMENTS <lb/></note>

            <body>Labels on case <lb/>statements are required to be unique within a switch, <lb/>and a switch <lb/>may not have more <lb/>than one default <lb/>statement. Thus, for a given expression value, there is exactly one statement to which <lb/>control should be passed. A static partial function SwitchTask: tasks results <lb/>! tasks <lb/>indicates the next <lb/>task to be executed for a given expression value. We illustrate a typical switch <lb/>statement with the graph <lb/>in Fig. 5 with regard to the possible e ects of embedded jump statements, see the remark in Sect. 1.5. The <lb/>rule for switch <lb/>tasks is shown in Fig. 6. <lb/>switch <lb/>statements <lb/>SwitchTask <lb/>NextTask <lb/>NextTask <lb/>expression <lb/>Figure 5: A typical switch <lb/>statement. <lb/>if TaskType(CurTask) = switch <lb/>then <lb/>Moveto(SwitchTask(CurTask,TestValue(CurTask))) <lb/>endif <lb/>Figure 6: Transition rules for switch <lb/>tasks. <lb/>1.7 while <lb/>Statements <lb/>A while <lb/>statement has the following form: <lb/>while-statement <lb/>! while ( <lb/>expression ) <lb/>body <lb/>where body <lb/>is a statement. <lb/>To execute a while <lb/>statement, keep evaluating the guard expression until the value of the expression <lb/>becomes zero. Each time that the value of the guard expression is not zero, execute body. <lb/>We illustrate a typical while <lb/>statement with the graph in Fig. 7 with regard to the possible e ects of <lb/>embedded jump statements, see the remark in Sect. 1.5. Since the only types of tasks used to represent while <lb/>statements are the expression <lb/>and branch <lb/>tasks, our previously-presented transition rules are su cient t o <lb/>model the behavior of while <lb/>statements. <lb/>Note that it is possible to enter a while <lb/>loop by means of a goto <lb/>statement, thus circumventing the <lb/>initial test of the expression at the beginning of the loop. The ANSI standard KR] does not give speci c <lb/>semantics for such behavior. In such a situation, our abstract machine would continue as if the loop had <lb/>been entered normally (i.e., after completion of the statement b o d y , c o n trol returns to the guard expression <lb/>to be evaluated). We n believe this is a reasonable interpretation of such a n e v ent. <lb/></body>

            <note place="headnote">1.8 do-while Statements <lb/></note>

            <page>7 <lb/></page>

            <body>expression <lb/>TrueTask <lb/>NextTask <lb/>NextTask <lb/>FalseTask <lb/>branch <lb/>body <lb/>Figure 7: A typical while statement. <lb/>1.8 do-while Statements <lb/>A do-while statement has the following form: <lb/>do-while-statement ! do body while ( expression ) <lb/>where body is a statement. <lb/>do-while statements are identical to while statements except that the guard expression and statement <lb/>body are visited in the opposite order. We illustrate a typical do-while with the graph shown in Fig. 8 <lb/>with regard to the possible e ects of embedded jump statements, see the remark in Sect. 1.5. (Note the <lb/>similarity b e t ween this graph and that of the while loop.) As with while loops, no new transition rules are <lb/>required to model the behavior of do-while statements. <lb/>expression <lb/>TrueTask <lb/>FalseTask <lb/>NextTask <lb/>NextTask <lb/>branch <lb/>body <lb/>Figure 8: A typical do-while statement. <lb/>1.9 for Statements <lb/>The most complete form of the for statement is: <lb/>for-statement ! for ( initializer test update ) body <lb/>where initializer, test, a n d update are expressions, any o f w h i c h m a y be omitted, and body is a statement, <lb/>usually compound. We begin by describing the behavior and representation of a for statement when all <lb/>expressions are present. <lb/>In executing a for statement, begin by e v aluating the initializer. Evaluate the test next if the result is <lb/>non-zero, execute the body and evaluate the update (in that order) and re-evaluate the test. If the value of <lb/>the test is zero, transfer control to the statement following the for loop. <lb/></body>

            <page>8 <lb/></page>

            <note place="headnote">1 ALGEBRA ONE: HANDLING C STATEMENTS <lb/></note>

            <body>We illustrate a typical for statement with the graph in Fig. 9 with regard to the possible e ects of <lb/>embedded jump statements, see the remark in Sect. 1.5. Again, no new transition rules are required to <lb/>model the behavior of for statements. <lb/>TrueTask <lb/>FalseTask <lb/>NextTask <lb/>NextTask <lb/>NextTask <lb/>NextTask <lb/>branch <lb/>initâˆ’ <lb/>ializer <lb/>test <lb/>update <lb/>body <lb/>Figure 9: A typical for statement. <lb/>The graphs for for loops missing one or more of the three expressions (initializer, test, and update) <lb/>omit the corresponding tasks, with NextTask pointing to the next task in the graph sequence. If the test is <lb/>omitted, both the test and the branch task are omitted, which creates an in nite loop (which m a y still be <lb/>broken through the use of jump statements). <lb/>1.10 Jump Statements <lb/>A jump statement has one of the following forms: <lb/>jump-statement ! goto identi er <lb/>jump-statement ! continue <lb/>jump-statement ! break <lb/>jump-statement ! return <lb/>jump-statement ! return expression <lb/>Each of these jump statements is a command indicating that control should be unconditionally transferred <lb/>to another task in the task graph: <lb/>goto statements indicate directly the task to which c o n trol passes. <lb/>continue statements may only occur within the body of an iteration statement. For a given continue <lb/>statement C, let S be the smallest iteration statement w h i c h includes C. Executing C transfers control <lb/>to the task within S following the statement body of S: e.g., for for statements, control passes to the <lb/>update expression, while for while statements, control passes to the guard expression. <lb/>break statements may occur within the body of an iteration or switch statement. For a given break <lb/>statement B, let S be the smallest iteration or switch statement w h i c h includes B. Executing B transfers <lb/>control to the rst task following S. <lb/>return statements occur within the body of function abstractions, indicating that the current function <lb/>execution should be terminated. A more complete discussion of return statements will be presented in <lb/>Algebra Four, where function abstractions are presented. For now, we assert that executing a return <lb/>statement should set CurTask to undef , w h i c h will bring a halt to the algebra, since we only have one <lb/>function (main) being executed. <lb/>The NextTask function contains the above (static) informationfor jump statement tasks. Thus, the transition <lb/>rule for jump statements (shown in Fig. 10) is trivial. <lb/></body>

            <note place="headnote">1.11 Labeled Statements <lb/></note>

            <page>9 <lb/></page>

            <body>if TaskType(CurTask) = jump then <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 10: Transition rule for jump tasks. <lb/>1.11 Labeled Statements <lb/>A labeled statement has one of the following forms: <lb/>labeled-statement ! identi er : statement <lb/>labeled-statement ! case constant-expression : statement <lb/>labeled-statement ! default : statement <lb/>Statement labels identify the targets for control transfer in goto and switch statements. NextTask and <lb/>SwitchTask return the appropriate tasks in each case no further transition rules are needed. <lb/>1.12 Compound Statements <lb/>A compound statement has the following form: <lb/>compound-statement ! f declaration-list statement-list g <lb/>where the declaration and/or statement lists may b e e m p t y.) <lb/>Since NextTask indicates the order in which tasks are processed, we h a ve no need for rules concerning <lb/>compound statements. Each statement or declaration in a compound statement is linked to its successor <lb/>via NextTask. (Declarations are not treated until Algebra Three nonetheless, the same principle holds for <lb/>declaration tasks.) <lb/>1.13 Initial and Final States <lb/>We assert that initially, CurTask indicates the rst task of the rst statement of the program. <lb/>A nal state in our algebra is any state in which CurTask = undef . In this state, no rules will be executed, <lb/>since TaskType(undef) = undef. <lb/>2 Algebra Two: Evaluating Expressions <lb/>Our second evolving algebra re nes the rst and focuses on the evaluation of expressions. <lb/>We replace each occurrence of a task of type expression from the rst algebra with numerous tasks <lb/>re ecting the structure of the expression. Also, TestValue is now a n i n ternal, dynamic function. <lb/>In Algebra Two, we treat the evaluation of expressions at a relatively high level of abstraction. We map <lb/>variable identi ers to memory locations through external functions. We also treat function invocations as <lb/>expressions whose values are provided by external functions. In Algebras Three and Four we will eliminate <lb/>these abstractions. <lb/></body>

            <page>10 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>2.1 New Basic Functions Related To Memory Management <lb/>In C, one may (re)cast types. For example, one may c a s t a p o i n ter to a structure into a pointer to an array o f <lb/>characters. Thus, one can access the individual bytes of most values which m i g h t exist during the execution <lb/>of the program. 1 <lb/>A static function Size: typename ! integer indicates how m a n y b ytes are used by a particular value <lb/>type in memory. A dynamic function Memory: addresses ! bytes indicates the values stored in memory <lb/>at a given byte. Since most values of interest are larger than a byte, we need a means for storing members <lb/>of results as individual bytes. For example, assume that the int value 258 is represented in the memory of <lb/>a particular system by the four (eight-bit) bytes 0, 0, 1, and 2, stored consecutively. W e n e e d a w ay t o g o <lb/>from a value in results (e.g., 258) to its component b ytes (0, 0, 1, 2) and vice versa. <lb/>A static partial (n+1)-ary function ByteToResult: typename byte n ! results converts the memory <lb/>representation of a value of the speci ed basic type into its corresponding value in the results universe. Here <lb/>n is the maximum numb e r o f b ytes used by the memory representation of any particular basic type (and <lb/>is implementation-dependent). For types whose memory representations are less than n bytes in length, we <lb/>ignore any u n used parameters. In our example above, ByteToResult(int,0,0,1,2) = 258 . <lb/>A static partial function ResultToByte: results integer typename ! byte yields the speci ed byte of <lb/>the memory representation of the speci ed value from the speci ed universe. This function can be thought <lb/>of as the inverse of ByteToResult. In our example above, ResultToByte(258,3,int) = 2 . ( W e assume tacitly <lb/>that the arguments of ResultToByte uniquely de ne the value of the function, which is the case in all the <lb/>implementations that we k n o w.) <lb/>We de ne an abbreviation MemoryValue: address typename ! results, which indicates the value of <lb/>the speci ed type being stored in memory beginning at the indicated address. MemoryValue (addr,type) <lb/>abbreviates ByteToResult (type, Memory(addr), Memory(addr+1), . . . ,Memory(addr + Size(type) -1)). <lb/>2.2 Other New Basic Functions <lb/>Two sub-universes of results, t h e u n i v erse of computational results, are of particular interest in Algebra Two. <lb/>A universe bytes contains those values which m a y be \stored&quot; in a char variable. (This universe is usually <lb/>identical to f0,1,.. .,255g, but we prefer the more general de nition.) A universe addresses contains positive <lb/>integers corresponding to valid memory locations. This is also the universe of values which m a y be stored <lb/>in a pointer-type variable. (Of course, these two u n i v erses are implementation-dependent.) <lb/>A u n i v erse typename contains elements representing the di erent t ypes of storable values. A static partial <lb/>function ValueType: tasks ! typename indicates the type of the resulting value when an expression has been <lb/>evaluated. <lb/>Static partial functions LeftTask, RightTask: tasks ! tasks indicate the left and right operands of binary <lb/>operators whose order of evaluation is not de ned within C (e.g., +). A static partial function Parent: tasks <lb/>! tasks indicates the parent ( i.e., closest enclosing) expression for a given expression. For expressions which <lb/>are not contained in any other expressions, Parent returns the corresponding branch task which uses the <lb/>expression (if one exists) or undef (if none exists). A static partial function WhichChild: tasks ! f left, <lb/>right, only, test, . . . g (where left, etc. are members of the tags universe) indicates the relationship between <lb/>a task and its parent. <lb/>Dynamic partial functions LeftValue, RightValue: tasks ! results indicate the results of evaluating the <lb/>left and right operands of binary operators with ambiguous evaluation order. Similarly, a dynamic partial <lb/>function OnlyValue: tasks ! results indicates the result of evaluating the single operand of a unary operator. <lb/>A static partial function ConstVal: tasks ! results indicates the values of program constants. <lb/></body>

            <note place="footnote">1 The distinguished value void is an example of a value which cannot be accessed in this manner. <lb/></note>

            <note place="headnote">2.3 Macro: DoAssign <lb/></note>

            <page>11 <lb/></page>

            <body>2.3 Macro: DoAssign <lb/>Our rules for assignment to memory are a little complicated, since a given assignment m a y require an <lb/>arbitrarily large number of updates to the Memory function. We need rules which perform a loop to make <lb/>those arbitrarily large number of updates in a systematic fashion. 2 <lb/>To facilitate this loop, we use several distinguished elements. CopyValue: results denotes the value to <lb/>be copied. CopyType: typename denotes the type of value to be copied. CopyLocation: address denotes the <lb/>location to which the value is to be copied. CopyByte: integer denotes which b yte of the representation of <lb/>CopyValue is being copied into memory. OldTask: tasks denotes the task which i n voked the memory copying <lb/>procedure. CopyTask: tasks is a static distinguished element used to indicate that the copying procedure <lb/>should begin. <lb/>We will invoke the copying procedure using the DoAssign(address, value, type) macro, de ned in Fig. 11. <lb/>The copying process itself is relatively straightforward. We utilize the distinguished element CopyByte to <lb/>denote which b yte of the memory representation of CopyValue we are copying into memory at a given moment <lb/>in time. We copy b ytes singly, incrementing the value of CopyByte after each assignment to memory, halting <lb/>when all bytes have been copied. The transition rule for copying to memory is shown in Fig. 12. <lb/>DoAssign(address, value, type) <lb/>CopyValue := value <lb/>CopyType := type <lb/>CopyLocation := address <lb/>CopyByte := 0 <lb/>OldTask := CurTask <lb/>CurTask := CopyTask <lb/>Figure 11: De nition of the DoAssign macro. <lb/>if CurTask = CopyTask then <lb/>if CopyByte &lt; Size(CopyType) then <lb/>Memory(CopyLocation + CopyByte) := <lb/>ResultToByte(CopyValue, CopyByte, CopyType) <lb/>CopyByte := CopyByte + 1 <lb/>elseif CopyByte = Size(CopyType) then <lb/>CurTask := NextTask(OldTask) <lb/>endif <lb/>endif <lb/>Figure 12: Transition rule for copying to memory. <lb/></body>

		<note place="footnote">2 Most computer systems provide a means for memory assignments in units larger than a byte, but the particular sizes <lb/>available are implementation-dependent. We t h us present rules using the lowest-common denominator, the byte. <lb/></note>

		<page>12 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>2.4 Macro: ReportValue <lb/>When we process tasks corresponding to expression evaluation, we assign the value of an evaluated expression <lb/>to the appropriate storage function in the parent expression (e.g. LeftValue(Parent(CurTask))). We use the <lb/>ReportValue macro (de ned in Fig. 13) to accomplish this. <lb/>ReportValue(value) <lb/>if WhichChild(CurTask) = left then <lb/>LeftValue(Parent(CurTask)) := value <lb/>elseif WhichChild(CurTask) = right then <lb/>RightValue(Parent(CurTask)) := value <lb/>elseif WhichChild(CurTask) = only then <lb/>OnlyValue(Parent(CurTa s k ) ) : = v a l u e <lb/>elseif WhichChild(CurTask) = test then <lb/>TestValue(Parent(CurTask)) := value <lb/>endif <lb/>Figure 13: De nition of the ReportValue macro. <lb/>2.5 Macros: EvaluateOperands and Moveto <lb/>In C, as described by KR], many binary operators (such as the assignment operator \=&quot;) do not have a <lb/>de ned order of evaluation: either operand may b e e v aluated rst. When one or more operands of such a n <lb/>operator generate side e ects (as in \a i] = i++&quot;), the value or the side-e ects generated by the expression <lb/>may depend upon the order of evaluation. Writing such code is usually unwise, since such c o d e m a y n o t <lb/>be portable however, an optimizing compiler may take a d v antage of this ambiguity to generate code which <lb/>minimizes the resources required to perform a particular computation ASU]. <lb/>For expressions involving such operators, our algebra must be exible enough to re ect any possible <lb/>evaluation order of an expression&apos;s operands, even if this decision is made at run-time. While we believe <lb/>most compilers make this decision at compile-time, we m ust still provide a mechanism for making this <lb/>decision dynamically. (If this decision is always made statically in a particular system, the algebra may <lb/>be explicitly structured to incorporate those static decisions into the task graph). We will use an external <lb/>function ChooseTask to represent this decision. <lb/>We illustrate how expressions with such operators are represented in our algebra by the graph in Fig. 14. <lb/>A dynamic function Visited: tasks ! f left, right, both, neitherg indicates which subexpressions have b e e n <lb/>evaluated at a given moment. Initially, Visited has the value neither for all tasks. <lb/>To e v aluate expressions of this type, begin by e v aluating the sub-expression indicated by ChooseTask. <lb/>When that sub-expression has been evaluated, evaluate the other sub-expression. Finally, w h e n b o t h e x -<lb/>pressions have b e e n e v aluated, perform the desired operation. <lb/>To handle the portion of this behavior dealing with the operator task, we use the EVALUATE OPERANDS <lb/>macro. Informally, the macro means \Evaluate both operands in the order given by ChooseTask when both <lb/>operands are evaluated, then do . . . &quot;. To handle the portion of this behavior dealing with movement b e t ween <lb/>subtasks, we rede ne the Moveto(Task) macro to jump directly between the subtasks of an operator of this <lb/>type. The de nitions for EVALUATE OPERANDS and Moveto are shown in Fig 15 and Fig. 16. <lb/></body>

            <note place="headnote">2.5 Macros: EvaluateOperands and Moveto <lb/></note>

            <page>13 <lb/></page>

            <body>L e f t T a s k <lb/>R i g h t T a s k <lb/>NextTask <lb/>operator <lb/>leftexp <lb/>rightexp <lb/>NextTask <lb/>Figure 14: Binary operators. <lb/>EVALUATE OPERANDS WITH <lb/>statements <lb/>END EVALUATE <lb/>if Visited(CurTask) = neither then <lb/>if ChooseTask(CurTask) = LeftTask(CurTask) then <lb/>Visited(CurTask) := left <lb/>elseif ChooseTask(CurTask) = RightTask(CurTask) then <lb/>Visited(CurTask) := right <lb/>endif <lb/>Moveto(ChooseTask(CurTask)) <lb/>elseif Visited(CurTask) = both then <lb/>Visited(CurTask) := neither <lb/>statements <lb/>endif <lb/>Figure 15: De nition of the EVALUATE OPERANDS macro. <lb/></body>

            <page>14 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>Moveto(Task) <lb/>if Visited(Task) = neither then <lb/>CurTask := Task <lb/>elseif Visited(Task) = both then <lb/>CurTask := Task <lb/>elseif Visited(Task) = left then <lb/>CurTask := RightTask(Task) <lb/>Visited(Task) := both <lb/>elseif Visited(Task) = right then <lb/>CurTask := LeftTask(Task) <lb/>Visited(Task) := both <lb/>endif <lb/>Figure 16: Revised de nition of the Moveto(Task) macro. <lb/>2.6 Comma Operators <lb/>A comma expression has the following form: <lb/>comma-expression ! expr1 , expr2 <lb/>where expr1 and expr2 are expressions. <lb/>To e v aluate a comma expression, evaluate expr1 and expr2 , left to right, returning the value of expr2 as <lb/>the value of the parent expression. (Though it may seem unnecessary to evaluate the rst expression since <lb/>we ignore its value, recall that expressions in C may generate side-e ects.) We represent comma expressions <lb/>as a sequence of two expressions linked by t h e NextTask function. Thus, no additional transition rules are <lb/>needed to process comma operators. <lb/>2.7 Conditional Expressions <lb/>A conditional expression has the following form: <lb/>conditional-expression ! expr1 ? expr2 : expr3 <lb/>where expr1 , expr2 , a n d expr3 are expressions. <lb/>To e v aluate a conditional expression, evaluate expr1 . If the resulting value is non-zero, evaluate expr2 <lb/>and return its value as the value of the parent expression otherwise, evaluate expr3 and return its value as <lb/>the value of the parent expression. <lb/>We will represent conditional expressions in our algebra in a manner similar to that in which w e represent <lb/>conditional statements, as illustrated in Fig. 17. The tasks corresponding to the center and right s u b -<lb/>expressions will update the appropriate Value function for the parent expression upon completion of the <lb/>evaluation of the subexpression. No new transition rules are needed to handle conditional expressions. <lb/>2.8 Logical OR Expressions <lb/>A logical OR expression has the following form: <lb/>logical-OR-expression ! expr1 || expr2 <lb/></body>

            <note place="headnote">2.9 Logical AND expressions <lb/></note>

            <page>15 <lb/></page>

            <body>NextTask <lb/>T r u e T a s k <lb/>F a l s e T a s k <lb/>N e x tT a s k <lb/>expression <lb/>expression <lb/>N e x tT a s k <lb/>branch <lb/>expression <lb/>Figure 17: Conditional expression. <lb/>where expr1 and expr2 are expressions. <lb/>To e v aluate a logical OR expression, start by e v aluating expr1 . If the result is non-zero, the value of the <lb/>parent expression is 1 and expr2 is not evaluated. Otherwise, the value of the parent expression is the value <lb/>of expr2 , with non-zero values coerced to 1. <lb/>To represent a logical OR expression, we will introduce two new task types, OR and makeBool. W e <lb/>illustrate how logical OR expressions are represented in our algebra by the graph in Fig. 18. <lb/>OR <lb/>makeBool <lb/>NextTask <lb/>TrueTask <lb/>FalseTask <lb/>NextTask <lb/>N e x t T a s k <lb/>rightexp <lb/>leftexp <lb/>Figure 18: Logical OR expression. <lb/>In processing the OR task, the value of expr1 will be examined. If the value is not zero, the rules for <lb/>OR tasks will set the value of the expression to 1 and end processing of the parent expression. Otherwise, <lb/>the rules will pass control to the tasks which e v aluate expr2 . The rules for makeBool tasks will examine the <lb/>value of expr2 and coerce it to 0 or 1. The transition rules for OR and makeBool tasks are shown in Fig. 19 <lb/>and Fig. 20. <lb/>2.9 Logical AND expressions <lb/>A logical AND expression has the following form: <lb/>logical-AND-expression ! expr1 &amp;&amp; expr2 <lb/>where expr1 and expr2 are expressions. <lb/>To e v aluate an AND expression, begin by e v aluating expr1 . If the resulting value is 0, the value of the <lb/>parent expression is 0. Otherwise, the value of expr2 (coerced to 0 or 1) is the value of the parent expression. <lb/></body>

		<page>16 <lb/></page>

		<note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

		<body>if TaskType(CurTask) = OR then <lb/>if OnlyValue(CurTask) 6 = 0 then <lb/>ReportValue(1) <lb/>Moveto(TrueTask(CurTask)) <lb/>elseif OnlyValue(CurTask) = 0 then <lb/>Moveto(FalseTask(CurTask)) <lb/>ENDIF <lb/>Figure 19: Transition rule for OR tasks. <lb/>if TaskType(CurTask) = makeBool then <lb/>if OnlyValue(CurTask) 6 = 0 then <lb/>ReportValue(1) <lb/>elseif OnlyValue(CurTask) = 0 then <lb/>ReportValue(0) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 20: Transition rule for makeBool tasks. <lb/>The representation of logical AND expressions is similar to that of logical OR expressions, as illustrated in <lb/>Fig. 21. The transition rule for AND tasks (used in such representations) is shown in Fig. 22. <lb/>makeBool <lb/>NextTask <lb/>TrueTask <lb/>FalseTask <lb/>NextTask <lb/>N e x t T a s k <lb/>AND <lb/>rightexp <lb/>leftexp <lb/>Figure 21: Logical AND expression. <lb/>2.10 Assignment Expressions <lb/>A simple assignment has the following form: <lb/>assignment-expression ! expr1 = expr2 <lb/>where expr1 and expr2 are expressions. <lb/></body>

            <note place="headnote">2.10 Assignment Expressions <lb/></note>

            <page>17 <lb/></page>

            <body>if TaskType(CurTask) = AND then <lb/>if OnlyValue(CurTask) = 0 then <lb/>ReportValue(0) <lb/>Moveto(FalseTask(CurTask)) <lb/>elseif OnlyValue(CurTask) 6 = 0 then <lb/>Moveto(TrueTask(CurTask)) <lb/>ENDIF <lb/>Figure 22: Transition rule for AND tasks. <lb/>To e v aluate a simple assignment expression, copy t h e v alue of expr2 into the memory location given by <lb/>expr1 , returning that value as the value of the parent expression. <lb/>This is the rst occurrence of an operator in Algebra Two with an ambiguous evaluation order, as <lb/>discussed in Sect. 2.5. Thus, the expression is represented in our algebra as in Fig. 14. The transition rule <lb/>for assignment operators is shown in Fig. 23. <lb/>if TaskType(CurTask) = simple-assignment then <lb/>EVALUATE OPERANDS WITH <lb/>DoAssign( LeftValue(CurTask),RightValue(CurTask), <lb/>ValueType(CurTask)) <lb/>ReportValue(RightValue(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 23: Transition rule for simple assignment tasks. <lb/>Within C, there are other assignment operators (\+=&quot;, \*=&quot;, etc.) which perform a mathematic operation <lb/>on the value of expr2 and the value stored in the memory location given by expr1 . The result is copied into <lb/>the memory location given by expr1 . F or example, \i * = 2 &quot; h a s t h e s a m e v alue and e ect as \i = i * 2 &quot;. <lb/>However, it is not true in general that \a op= b &quot; can be seen as an abbreviation for \a = a op b&quot;, since <lb/>the expression a is evaluated only once in the former expression, but twice in the latter. Since evaluating <lb/>expressions in C may cause side e ects, the distinction is important. Thus, we m ust present additional <lb/>transition rules for such operators. <lb/>With two exceptions, all these assignment operators have transition rules like that shown in Fig 24 for <lb/>the multiplicative assignment operator (\*=&quot;). <lb/>The two exceptions are the additive and subtractive assignment operators, \+=&quot; and \-=&quot;. In C, one <lb/>may add an integer i to a pointer expression p, with the result being a pointer which i s i units forward <lb/>in memory from p. Thus, to process``a += b&apos;&apos;, w e m ust perform di erent actions if a is a pointer <lb/>variable. The transition rule for additive assignment i n volving pointers is shown in Fig 25. The rule for <lb/>additive assignment i n volving non-pointers is like t h a t s h o wn above f o r m ultiplicative assignments, with the <lb/>additional condition PointerType(LeftChild(CurTask)) = false inserted in the guard of the rule. The rules <lb/>for subtractive assignment are similar and thus omitted. <lb/></body>

            <page>18 <lb/></page>

            <body>2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></body>

            <body>if TaskType(CurTask) = multiplicative-assignment then <lb/>EVALUATE OPERANDS WITH <lb/>DoAssign( LeftValue(CurTask), <lb/>MemoryValue LeftValue(CurTask),ValueType(CurTask)] <lb/>* R ightValue(CurTask), <lb/>ValueType(CurTask)) <lb/>ReportValue(MemoryValue LeftValue(CurTask),ValueType(CurTask)] <lb/>* R ightValue(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 24: Transition rule for multiplicative assignment. <lb/>if TaskType(CurTask) = additive-assignment <lb/>and PointerType(LeftChild(CurTask)) = true then <lb/>EVALUATE OPERANDS WITH <lb/>DoAssign( LeftValue(CurTask), <lb/>MemoryValue(LeftValue(CurTask),ValueType(CurTask)) <lb/>+ Size(PointsToType(CurTask)) * RightValue(CurTask), <lb/>ValueType(CurTask) <lb/>ReportValue(MemoryValue(LeftValue(CurTask),ValueType(CurTask)) <lb/>+ Size(PointsToType(CurTask)) * RightValue(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 25: Transition rule for additive assignment with pointers. <lb/></body>

            <note place="headnote">2.11 The sizeof Operator <lb/></note>

            <page>19 <lb/></page>

            <body>2.11 The sizeof Operator <lb/> Expressions involving sizeof have one of the following forms: <lb/>sizeof-expression ! sizeof expression <lb/>sizeof-expression ! sizeof ( type-name ) <lb/>The ValueType function converts either operand into a value in the typename universe. With that <lb/>information, we m a y use the Size function to determine the size, in bytes, of an element of that particular <lb/>type and return that number as the value of the unary expression. The transition rule for size operators is <lb/>shown in Fig. 26. <lb/>if TaskType(CurTask) = sizeof then <lb/>ReportValue(Size(ValueType(CurTask))) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 26: Transition rule for sizeof tasks. <lb/>2.12 Constants <lb/>For constant expressions, the ConstVal function returns the appropriate value. (Note that we treat enumer-<lb/>ated type values as constants.) The transition rules for constants is shown in Fig. 27. <lb/>if TaskType(CurTask) = constant then <lb/>ReportValue(ConstVal(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 27: Transition rule for constant tasks. <lb/>2.13 General Mathematic Expressions <lb/>There are a large number of mathematic expressions in C involving binary operators (\*&quot;, \+&quot;, \-&quot;, etc.) <lb/>whose behaviors are similar. (We treat the bit-wise operators (e.g., |, &amp;) as ordinary mathematic operators.) <lb/>We assume that in x functions corresponding to these C functions are present within our algebra. Thus, <lb/>to evaluate one of these expressions, evaluate both operand expressions and apply the appropriate function. <lb/>We present the transition rule for multiplication in Fig.28 as a representative of this category of expressions, <lb/>and omit the rules for other binary operators of this form for brevity. <lb/>Rules for the addition and subtraction operators are slightly more complicated, since one may add or <lb/>subtract an integer to a pointer. One may add an integer i to a pointer variable p with the result being a <lb/>pointer which i s i units forward in memory from p. Consider, for example, a pointer p to an int in a system <lb/></body>

            <page>20 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>if TaskType(CurTask) = multiplication then <lb/>EVALUATE OPERANDS WITH <lb/>ReportValue(LeftValue(CurTask) * RightValue(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 28: Transition rule for multiplication tasks. <lb/>where ints require 4 bytes in memory. The expression \p+1&quot; refers to the location in memory 4 bytes after <lb/>p. <lb/>Similarly, one may subtract an integer i from a pointer variable p, with the result being a pointer i units <lb/>in memory preceding p. (In our example, \p;1&quot; refers to the location in memory 4 bytes before p.) Further, <lb/>one may subtract two pointers of the same type, resulting in the number of units of memory lying between <lb/>the two pointers. (Thus, ((p + i) ; p) = i.) In each case, the size of a \unit&quot; of memory is determined by <lb/>the size of the object type to which the pointer points. <lb/>This requires specialized rules for the addition and subtraction operators. As we process each o f t h e s e <lb/>operators, it now becomes necessary to know whether or not a given variable is a pointer a static partial <lb/>function PointerType: tasks ! f true, falseg contains this information. For tasks for which PointerType <lb/>returns true, a static partial function PointsToType : tasks ! typename indicates the object type to which <lb/>the pointer points. <lb/>The transition rules for the addition and subtraction operators are shown in Fig. 29 and Fig. 30. <lb/>if TaskType(CurTask) = addition then <lb/>EVALUATE OPERANDS WITH <lb/>if PointerType(LeftTask(CurTask)) = true then <lb/>ReportValue(LeftValue(CurTask) <lb/>+ (Size(PointsToType(CurTask)) * RightValue(CurTask))) <lb/>elseif PointerType(RightTask(CurTask)) = true then <lb/>ReportValue(RightValue(CurTask) <lb/>+ (Size(PointsToType(CurTask)) * LeftValue(CurTask))) <lb/>else <lb/>ReportValue(LeftValue(CurTask) + RightValue(CurTask)) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 29: Transition rule for addition tasks. <lb/></body>

            <note place="headnote">2.14 Mathematical Unary Operators <lb/></note>

            <page>21 <lb/></page>

            <body>if TaskType(CurTask) = subtraction then <lb/>if PointerType(LeftTask(CurTask)) = true and <lb/>PointerType(RightTask(CurTask)) = true then <lb/>ReportValue((LeftValue(CurTask) -RightValue(CurTask)) <lb/>/ Size(PointsToType(CurTask))) <lb/>elseif PointerType(LeftTask(CurTask)) = true and <lb/>PointerType(RightTask(CurTask)) = false then <lb/>ReportValue(LeftValue(CurTask) <lb/>-(Size(PointsToType(CurTask)) * RightValue(CurTask))) <lb/>else <lb/>ReportValue(LeftValue(CurTask) -RightValue(CurTask)) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 30: Transition rule for subtraction tasks. <lb/>2.14 Mathematical Unary Operators <lb/>Unary operator expressions have one of the following forms: <lb/>unary-expression ! + expression <lb/>unary-expression ! -expression <lb/>unary-expression !~expression <lb/>unary-expression ! ! expression <lb/>Evaluating these expressions takes a form similar to that for binary mathematical operators. We present <lb/>the transition rule for the negation operator in Fig. 31 as a representative example. <lb/>if TaskType(CurTask) = negation then <lb/>ReportValue( -OnlyValue(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 31: Transition rule for negation tasks. <lb/>2.15 Casting Expressions <lb/>A casting expression has the following form: <lb/>cast-expression ! ( type-name ) expression <lb/>A static function CastType: tasks ! typename indicates the old type from which the value of the <lb/>expression is to be cast ValueType indicates the new type into which t h e v alue will be cast. A static <lb/>function Convert: typename typename values ! values converts elements from one universe into the <lb/></body>

            <page>22 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>corresponding elements of another universe. For example, Convert( oat,int,X) is the closest integer to X <lb/>(assuming X is a oating-point v alue). Note that the meaning of \closest&quot; is implementation-de ned. <lb/>To perform a cast, evaluates the argument expression and use the Convert function to generate the proper <lb/>return value. Our task sequence places the expression to be cast before the task which performs the casting <lb/>thus, the argument of the cast has been evaluated already and its value is available. The transition rule for <lb/>casting expressions is shown in Fig. 32. <lb/>if TaskType(CurTask) = cast then <lb/>ReportValue(Convert( CastType(CurTask), <lb/>ValueType(CurTask), OnlyValue(CurTask))) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 32: Transition rule for cast tasks. <lb/>2.16 Pre-Increment and Pre-Decrement <lb/>A pre-increment or pre-decrement expression has the following form: <lb/>pre-incr-expression ! ++ expression <lb/>pre-decr-expression ! --expression <lb/>To e v aluate a pre-increment (resp. pre-decrement) expression, increment (decrement) the value stored at <lb/>the indicated memory location by one and store the new value into that memory location the incremented <lb/>(decremented) value is the value of the parent expression. Note that the expression to be modi ed may <lb/>be a pointer in this case, the value in memory is incremented (decremented) by the size of the object to <lb/>which the pointer points (as with normal pointer addition and subtraction). The transition rule for pre-<lb/>increment expressions is shown in Fig 33. The transition rules for pre-decrement expressions are similar to <lb/>those presented here and thus omitted. <lb/>2.17 Post-Increment and Post-Decrement <lb/>A post-increment or post-decrement expression has the following form: <lb/>postincr-expression ! expression ++ <lb/>postdecr-expression ! expression --<lb/>Post-increment (resp. post-decrement) operators are handled in the same manner as pre-increment <lb/>(pre-decrement) operators except that the sequence of operations is reversed: i.e., t h e v alue of the parent <lb/>expression is established before the incrementing (decrementing) takes place. The transition rule for the <lb/>post-increment operator is shown in Fig. 34. (As before, the transition rules for the post-decrement operator <lb/>are similar and thus omitted.) <lb/></body>

            <note place="headnote">2.17 Post-Increment a n d P ost-Decrement <lb/></note>

            <page>23 <lb/></page>

            <body>if TaskType(CurTask) = pre-increment then <lb/>if PointerType(CurTask) = true then <lb/>DoAssign(OnlyValue(CurTask), <lb/>MemoryValue(OnlyValue(CurTask),ValueType(CurTask)) <lb/>+ Size(PointsToType(CurTask)), <lb/>ValueType(CurTask)) <lb/>ReportValue( MemoryValue(OnlyValue(CurTask), <lb/>ValueType(CurTask)) <lb/>+ Size(PointsToType(CurTask))) <lb/>else <lb/>DoAssign(OnlyValue(CurTask), <lb/>MemoryValue(OnlyValue(CurTask),ValueType(CurTask)) + 1, <lb/>ValueType(CurTask)) <lb/>ReportValue(MemoryValue( OnlyValue(CurTask), <lb/>ValueType(CurTask))+1) <lb/>ENDIF <lb/>Figure 33: Transition rule for pre-increment tasks. <lb/>if TaskType(CurTask) = post-increment then <lb/>if PointerType(CurTask) = true then <lb/>DoAssign(OnlyValue(CurTask), <lb/>MemoryValue(OnlyValue(CurTask),ValueType(CurTask)) <lb/>+ Size(PointsToType(CurTask)), <lb/>ValueType(CurTask)) <lb/>else <lb/>DoAssign(OnlyValue(CurTask), <lb/>MemoryValue(OnlyValue(CurTask),ValueType(CurTask))+1, <lb/>ValueType(CurTask)) <lb/>endif <lb/>ReportValue(MemoryValue( OnlyValue(CurTask), <lb/>ValueType(CurTask))) <lb/>endif <lb/>Figure 34: Transition rule for post-increment tasks. <lb/></body>

            <page>24 <lb/></page>

            <note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

            <body>2.18 Addresses <lb/>An addressing expression has the following form: <lb/>addressing-expression ! &amp; expr1 <lb/>where expr1 is an expression. <lb/>The &amp; operator in C passes back as its result the address of the memory location indicated by the <lb/>argument expression. <lb/>As we e v aluate expressions which refer to objects in memory, w e need to know whether we need to use <lb/>the address of an object or the object itself in our calculations. (For example, in the assignment statement <lb/>\a = b &quot;, the address or lvalue of variable a is needed, but the object being referenced or rvalue of variable <lb/>b is needed.) A static partial function ValueMode: tasks ! f lvalue, rvalueg indicates which o f t h e t wo pieces <lb/>of information should be computed for a given task. <lb/>We assert that ValueMode(e) = lvalue for the sub-expressions of expr1 t h us, the value returned through <lb/>evaluation of the argument expression is the address (and not the value) of the argument expression in <lb/>memory. We simply pass this address up the task graph. The resulting simple transition rule for the <lb/>addressing operator is shown in Fig. 35. <lb/>if TaskType(CurTask) = address then <lb/>ReportValue(OnlyValue(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 35: Transition rule for address tasks. <lb/>2.19 De-Referencing <lb/>A de-referencing expression has the following form: <lb/>de-reference-expression ! * expression <lb/>If the parent expression is an rvalue, evaluate the argument and use the Memory function to return the <lb/>value stored in memory at the indicated location. Otherwise, return the address indicated by the argument <lb/>(since the expression is an lvalue and requires that a pointer be returned to the parent expression). The <lb/>transition rule for de-referencing is shown in Fig. 36. <lb/>2.20 Array References <lb/>An array reference has the following form: <lb/>array-ref-expression ! expr1 expr2 ] <lb/>where expr1 and expr2 are expressions. <lb/>According to KR], an array reference of the form a b] is identical, by de nition, to the expression <lb/>*((a)+(b)). 3 This de nition is valid because the name of an array i n C m a y b e u s e d a s a p o i n ter to the <lb/>rst element of the array. <lb/></body>

		<note place="footnote">3 Note that this means that a b] and b a] evaluate to the same value. <lb/></note>

		<note place="headnote">2.21 Function Invocations <lb/></note>

		<page>25 <lb/></page>

		<body>if TaskType(CurTask) = de-referencing then <lb/>if ValueMode(CurTask) = rvalue then <lb/>ReportValue(MemoryValue( OnlyValue(CurTask), <lb/>ValueType(CurTask))) <lb/>elseif ValueMode(CurTask) = lvalue then <lb/>ReportValue(OnlyValue(CurTask)) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 36: Transition rule for de-referencing tasks. <lb/>We assert that any array references present in the program being modeled in our algebra are represented <lb/>as an expression of equivalent f o r m i n volving addition and de-referencing. Thus, we do not need to present <lb/>any additional rules to handle array references. <lb/>One may prefer to think of arrays as objects in their own right, and present an algebra intermediate to <lb/>Algebras One and Two where expressions like a b] could be treated at a higher level of abstraction. While <lb/>such a presentation is possible, we c hoose not to do so here. <lb/>2.21 Function Invocations <lb/>A function invocation has the following form: <lb/>func-invocation-expression ! expression ( expression-list ) <lb/>Since we h a ve disallowed function invocations for the moment, we will obtain the value of a function <lb/>invocation expression from an external function FunctionValue: tasks ! results. The transition rule for <lb/>function invocations is shown in Fig. 37. <lb/>if TaskType(CurTask) = function-invocation then <lb/>ReportValue(FunctionValue(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 37: Transition rule for function-invocation tasks. <lb/>2.22 Identi ers <lb/>An external function FindID: tasks ! addresses maps identi er expression tasks to the corresponding mem-<lb/>ory location used by the associated variable. (In Algebra Three we shall eliminate the use of this function.) <lb/>Thus, to handle an identi er expression, one returns the appropriate address or value from memory, a s <lb/>speci ed by t h e ValueMode function. The transition rule for identi ers is shown in Fig. 38. <lb/></body>

		<page>26 <lb/></page>

		<note place="headnote">2 ALGEBRA TWO: EVALUATING EXPRESSIONS <lb/></note>

		<body>if TaskType(CurTask) = identi er then <lb/>if ValueMode(CurTask) = lvalue then <lb/>ReportValue(FindID(CurTask)) <lb/>elseif ValueMode(CurTask) = rvalue then <lb/>ReportValue(MemoryValue( FindID(CurTask), <lb/>ValueType(CurTask))) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 38: Transition rule for identi er tasks. <lb/>2.23 struct or union References <lb/>A struct or union reference has the following form: <lb/>struct-expression ! expr1 . identi er <lb/>where expr1 is an expression evaluating to a struct or union. There is also another form: <lb/>struct-expression ! expr2 -&gt; identi er <lb/>where expr2 is an expression evaluating to a pointer to a struct or union. Expressions of the form \a-&gt;b&quot; <lb/>are equivalent to those of the form \(*a).b&quot;. Thus, we will only consider references of the form \a.b&quot;, <lb/>asserting that references of the other form are represented using their equivalent expansions. <lb/>The ConstVal function applied to the struct reference task returns the o set in memory to be used in <lb/>obtaining the address or value of the speci ed eld of the structure. The transition rule for struct references <lb/>is shown in Fig. 39. <lb/>if TaskType(CurTask) = struct-reference then <lb/>if ValueMode(CurTask) = lvalue then <lb/>ReportValue(OnlyValue(CurTask) + ConstVal(CurTask)) <lb/>elseif ValueMode(CurTask) = rvalue then <lb/>ReportValue(MemoryValue(OnlyValue(CurTask) <lb/>+ ConstVal(CurTask), <lb/>ValueType(CurTask))) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 39: Transition rule for struct-reference tasks. <lb/>2.24 Bit Fields <lb/>Bit elds are members of structs which use a user-speci ed number of bits for their representations. Bit <lb/>elds are used to minimize the space used by a struct or to represent accurately input or output values <lb/></body>

            <note place="headnote">2.24 Bit Fields <lb/></note>

            <page>27 <lb/></page>

            <body>with bit-level signi cance. Much about bit elds behave i s i m p l e m e n tation-dependent: e.g. how bit elds <lb/>are packed into adjacent b ytes, whether or not unnamed \holes&quot; will appear in structs between bit elds, <lb/>or whether bit elds are read left-to-right or right-to-left. As a rule, operaptions are done with bytes (even <lb/>bit operations) we show h o w to handle bit-elds in a byte-based model of memory. <lb/>An example of a struct using bit elds is shown in Fig. 40. Here, the eld b holds a 4-bit unsigned <lb/>integer and c holds a 15-bit unsigned integer. Since bytes usually comprise 8 bits, c will probably lie in two <lb/>or three consecutive b ytes in memory, possibly sharing a byte with b. <lb/>struct f <lb/>unsigned int a <lb/>unsigned int b:4 <lb/>unsigned int c:15 <lb/>g bitty <lb/>Figure 40: Example of a struct using bit elds. <lb/>Suppose that we w ant to execute bitty.c = 12. W e need to obtain the bytes which hold c&apos;s bits and <lb/>modify those bits accordingly while leaving all other bits unchanged. This gives rise to a static function <lb/>BitAssign: results typename results ! results which indicates the change occurring in the value of <lb/>the appropriate collection of contiguous bytes when a bit eld is modi ed. Given the content oldval of an <lb/>appropriate piece of memory, BitAssign(oldval, bittype, 12) returns the new value here bittype is the type <lb/>of c in bitty. <lb/>Assigning to bit-elds is thus slightly di erent than usual. We present the transition rule for simple <lb/>assignments to bit elds in Fig. 41. <lb/>if TaskType(CurTask) = bit-assignment then <lb/>EVALUATE OPERANDS WITH <lb/>DoAssign(LeftValue(CurTask), <lb/>BitAssign(MemoryValue( LeftValue(CurTask), <lb/>ValueType(CurTask)), <lb/>ValueType(CurTask), <lb/>RightValue(CurTask)), <lb/>ValueType(CurTask)) <lb/>ReportValue(RightValue(CurTask)) <lb/>END EVALUATE <lb/>endif <lb/>Figure 41: Transition rule for bit-assignment tasks. <lb/>Evaluating bit-eld references is also slightly di erent, since we need to extract the value of the bit <lb/>eld from the (usually) larger enclosing value. A static function BitExtract: results typename ! results <lb/>performs this extraction. A static partial function BitType: tasks ! typename indicates the type of bit eld <lb/>being references in such situations. <lb/>The transition rule for structure bit-eld references is shown in Fig. 42. <lb/></body>

		<page>28 <lb/></page>

		<note place="footnote">3 ALGEBRA THREE: ALLOCATING AND INITIALIZING MEMORY <lb/></note>

		<body>if TaskType(CurTask) = struct-bit-reference then <lb/>if ValueMode(CurTask) = lvalue then <lb/>ReportValue(OnlyValue(CurTask) + ConstVal(CurTask)) <lb/>elseif ValueMode(CurTask) = rvalue then <lb/>ReportValue(BitExtract( <lb/>MemoryValue(OnlyValue(CurTask) + ConstVal(CurTask), <lb/>BitType(CurTask)), <lb/>ValueType(CurTask))) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 42: Transition rule for struct-bit-reference tasks. <lb/>3 Algebra Three: Allocating and Initializing Memory <lb/>Algebra Three re nes Algebra Two and focuses on memory allocation and initialization of variables. <lb/>3.1 Declarations <lb/>We represent declarations in C as elements of the tasks universe, linked in the proper order with statement <lb/>tasks by NextTask. <lb/>C distinguishes between so-called static variables and other variables. The di erence between static and <lb/>non-static variables arises when control is passed to the declaration task for a variable. If the variable is not <lb/>static, new memory is always allocated to the variable and its initializing expression (if it exists) is evaluated <lb/>with the value of the expression being assigned to the new memory location. If the variable is static, the <lb/>above allocation and initialization is performed only the rst time that the declaration is executed should <lb/>the declaration become the focus of control once again, the same memory segment is allotted to the variable. <lb/>A static partial function DecType: tasks ! f static, non-staticg indicates what type of variable is being <lb/>declared. (Note that there are also extern variable declarations in C which do not reserve memory but <lb/>serve as syntactic linkage between variables. We omit consideration of such declarations since their function <lb/>is wholly syntactic in nature.) A static partial function Initializer: tasks ! tasks indicates the appropriate <lb/>initializing expression (if any). We will store the value of the initializing expression using RightValue. <lb/>A partial function StaticAddr: tasks ! addresses stores the current address (if any) that has been <lb/>assigned to a static variable. In Algebra Three, StaticAddr is not really needed, since the OnlyValue function <lb/>would provide the proper storage for the address of the static variable. However, it will simplify other rules <lb/>to be presented. An external function NewMemory: tasks ! addresses returns an address in memory to be <lb/>used for the given declaration task. The transition rules for declarations are shown in Fig. 43 and Fig. 44. <lb/>3.2 Automatic Variables and Non-Local Jumps <lb/>Automatic (or local) variables are allocated memory not only when a block i s e n tered normally, but also <lb/>if a non-local goto statement transfers control into a block. As an example, consider the following code <lb/>fragment: <lb/></body>

            <note place="headnote">3.2 Automatic Variables and Non-Local Jumps <lb/></note>

            <page>29 <lb/></page>

            <body>if TaskType(CurTask) = declaration and DecType(CurTask) = static then <lb/>if StaticAddr(CurTask) 6 = undef then <lb/>OnlyValue(CurTask) := StaticAddr(CurTask) <lb/>Moveto(NextTask(CurTask)) <lb/>elseif StaticAddr(CurTask) = undef then <lb/>if Initializer(CurTask) 6 = undef and <lb/>RightValue(CurTask) = undef then <lb/>Moveto(Initializer(CurTask)) <lb/>else <lb/>OnlyValue(CurTask) := NewMemory(CurTask) <lb/>StaticAddr(CurTask) := NewMemory(CurTask) <lb/>if Initializer(CurTask) 6 = undef then <lb/>DoAssign(NewMemory(CurTask), <lb/>RightValue(CurTask), ValueType(CurTask)) <lb/>else <lb/>Moveto(NextTask(CurTask)) <lb/>ENDIF <lb/>Figure 43: Transition rule for static declarations. <lb/>if TaskType(CurTask) = declaration and DecType(CurTask) 6 = static then <lb/>if Initializer(CurTask) 6 = undef and <lb/>RightValue(CurTask) = undef then <lb/>Moveto(Initializer(CurTask)) <lb/>else <lb/>OnlyValue(CurTask) := NewMemory(CurTask) <lb/>if Initializer(CurTask) 6 = undef then <lb/>DoAssign(NewMemory(CurTask), <lb/>RightValue(CurTask),ValueType(CurTask)) <lb/>else <lb/>Moveto(NextTask(CurTask)) <lb/>ENDIF <lb/>Figure 44: Transition rule for non-static declarations. <lb/></body>

            <page>30 <lb/></page>

            <note place="headnote">3 ALGEBRA THREE: ALLOCATING AND INITIALIZING MEMORY <lb/></note>

            <body>int flag <lb/>for ( ) f <lb/>. . . <lb/>int local = 1 <lb/>if (flag) goto target <lb/>printf(&quot;%i&quot; ,local) <lb/>. . . <lb/>target: local = 0 <lb/>printf(&quot;%i&quot; ,local) <lb/>g <lb/>In this fragment, if the for statement i s e n tered normally, v ariable local will be allocated memory and <lb/>initialized to 1. If the goto statement is executed, variable local should be allocated memory before the <lb/>statement labeled target is executed, although no initialization is performed. <lb/>Our rules for constructing task graphs only provide for a unique moment when a given variable may b e <lb/>allocated. Consequently, w e i n troduce a new task type indirect-declaration. Previously, NextTask mapped <lb/>each jump task directly to its target. Now, we p u t a n indirect-declaration task for each local variable between <lb/>the jump task and its target. The Decl function will map each new task to the original declaration of that <lb/>variable. The rule for handling indirect declarations (shown in Fig. 45) is pretty o b vious. <lb/>if TaskType(CurTask) = indirect-declaration then <lb/>OnlyValue(Decl(CurTask)) := NewMemory(Decl(CurTask)) <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 45: Transition rule for indirect declarations. <lb/>3.3 Revision: Identi ers <lb/>A static partial function Decl: tasks ! tasks maps tasks corresponding to occurrences of an identi er to the <lb/>task corresponding to the declaration task for that variable. The revised rule for identi ers (generated by <lb/>replacing each previous occurrence of FindID() with OnlyValue(Decl())) i s s h o wn in Fig. 46. <lb/>if TaskType(CurTask) = identi er then <lb/>if ValueMode(CurTask) = lvalue then <lb/>ReportValue(OnlyValue(Decl(CurTask))) <lb/>elseif ValueMode(CurTask) = rvalue then <lb/>ReportValue(MemoryValue( OnlyValue(Decl(CurTask)), <lb/>ValueType(CurTask))) <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 46: Revised transition rule for identi er tasks. <lb/></body>

            <note place="headnote">3.4 Initializers <lb/></note>

            <page>31 <lb/></page>

            <body>3.4 Initializers <lb/>Initializers in C come in two forms: expressions (for variables of the basic types) and lists of expressions (for <lb/>variables representing arrays and structures). <lb/>Our previous rules for evaluating expressions will handle initializers for simple expressions. To assist in <lb/>handling aggregate expressions, a static function AddTo: typename results results ! results appends a <lb/>value onto the end of an aggregate structure of the speci ed type. (For example, if 42 8] is an integer array, <lb/>then AddTo(array 42 8] 4) = 42 8 4].) <lb/>We illustrate how expressions with aggregate initializers (i.e. expressions whose initializer is an expression <lb/>list) are represented in our algebra by the graph in Fig. 47. Our previous transition rules will insure that <lb/>each expression in the initializer list will be evaluated we n e e d t o p r o vide rules that combine the results of <lb/>these evaluations into the proper aggregate value. <lb/>N e x t T a s k <lb/>NextTask <lb/>expression <lb/>expression <lb/>expression <lb/>. . . <lb/>initializer <lb/>Initializer <lb/>Parent <lb/>NextTask <lb/>Figure 47: Aggregate initializer. <lb/>The WhichChild function returns the value aggregate when the expression being evaluated is a component <lb/>of an aggregate initializer. We extend our ReportValue macro as shown in Fig. 48 to correctly combine <lb/>aggregate expressions. <lb/>if WhichChild(CurTask) = aggregate then <lb/>RightValue(Parent(CurTask)) := <lb/>AddTo(ValueType(Parent(CurTask)), <lb/>RightValue(Parent(CurTask)),value) <lb/>endif <lb/>Figure 48: Extension of the ReportValue macro. <lb/>3.5 Initial State <lb/>We assert that initially, CurTask indicates the rst declaration task for the program, or the rst task of the <lb/>rst statement of the program if no declaration tasks exist. <lb/>4 Algebra Four: Handling Function De nitions <lb/>Algebra Four revises Algebra Three and focuses on C function de nitions. In this way, w e also (implicitly) <lb/>present rules for starting a C program, since the starting function main is an ordinary C function (with <lb/></body>

            <page>32 <lb/></page>

            <note place="headnote">4 ALGEBRA FOUR: HANDLING FUNCTION DEFINITIONS <lb/></note>

            <body>externally provided parameters). <lb/>(There are also function declarations in C, which are used to specify syntactic information. Since their <lb/>purpose is wholly syntactic in nature, we ignore them.) <lb/>4.1 Modeling The Stack <lb/>C functions may h a ve several active incarnations at a given moment. Thus, we m ust have some means for <lb/>storing multiple values of a function for a given task. <lb/>The universe stack comprises the positive i n tegers, with a distinguished element StackRoot = 1 . Static <lb/>functions StackPrev: stack ! stack and StackNext: stack ! stack are the predecessor and successor functions <lb/>on the positive i n tegers. A dynamic distinguished element StackTop indicates the current top of the stack. <lb/>To store state-associated information on the stack, we modify the various Value functions LeftValue, <lb/>RightValue, OnlyValue, and TestValue to be binary functions from tasks stack to results. This requires <lb/>us to rewrite almost every rule that has appeared previously we simplify matters by stating that every <lb/>previous reference to V(X) should be replaced by V(X, StackTop), where V is one of the Value functions <lb/>listed above. Similarly, w e modify Visited to be a binary fruntion from tasks stack to tags, replacing all <lb/>previous occurrences of Visited(X) with Visited(X, StackTop). <lb/>4.2 Function Invocations: Caller&apos;s Story <lb/>A function invocation has the following form: <lb/>func-invocation ! func-name ( expression-list ) <lb/>In Algebra Two w e used an external function FunctionValue to obtain the value of a function invocation. <lb/>Here, we eliminate the use of this function. <lb/>The name of a function is often an identi er, but in general it is an expression referring to the address <lb/>of the function. (What resides in memory at that address is implementation-dependent.) A static partial <lb/>function AddrToFunc: addresses ! tasks maps function addresses to the rst task of the function de nition. <lb/>While processing a function invocation, we wish to copy t h e v alue 4 of each parameter to an appropriate <lb/>place for the callee to process. The Parent function (utilized by our ReportValue macro) maps each argument-<lb/>expression task to its corresponding function parameter task. A partial function ParamValue: tasks stack <lb/>! results indicates the values of parameters being passed. We append the rule shown in Fig. 49 to the <lb/>ReportValue macro. <lb/>if WhichChild(CurTask) = param then <lb/>ParamValue(Parent(CurTask),StackNext(StackTop)) := value <lb/>endif <lb/>Figure 49: Extension of the ReportValue macro. <lb/>We need to store the current task in order to resume execution at this point after the callee has nished. <lb/>A dynamic function ReturnTask: stack ! tasks indicates the new value of CurTask when the execution of <lb/>the current function terminates. We assert that when CurTask = 1 , ReturnTask(CurTask) = undef , which <lb/>will cause the algebra to terminate when the top-level function terminates. <lb/>To process a function invocation, evaluate the name of the function along with all of the arguments in <lb/>the expression list, and then transfer control to the speci ed function. At the same time, \push another <lb/></body>

		<note place="footnote">4 In C, all function parameters are call-by-value. <lb/></note>

		<note place="headnote">4.3 Function Invocations: Callee&apos;s Story <lb/></note>

            <page>33 <lb/></page>

            <body>frame onto the stack&quot; i.e., increment StackTop by 1. When control returns from the function, the stack <lb/>value will be \popped&quot; (i.e., decremented by 1) and the function&apos;s return value will be passed to the parent <lb/>expression. <lb/>As with the operands to most arithmetic operators, the ANSI standard KR] does not specify the order <lb/>in which arguments to a function are evaluated. We t h us must present specialized rules for evaluating <lb/>the expressions associated with a function invocation. The external function ChooseTask will indicate at <lb/>each moment which expression associated with a function invocation should be evaluated next. Thus, our <lb/>transition rules will simply make repeated calls to ChooseTask until all expressions have been evaluated, <lb/>which will occur when ChooseTask returns undef . The transition rule for function invocation is shown in <lb/>Fig. 50. <lb/>if TaskType(CurTask) = function-invocation then <lb/>if ChooseTask(CurTask) 6 = undef then <lb/>Moveto(ChooseTask(CurTask)) <lb/>elseif ChooseTask(CurTask) = undef then <lb/>if OnlyValue(CurTask,StackTop) = undef then <lb/>StackTop := StackNext(StackTop) <lb/>ReturnTask(StackNext(StackTop)) := CurTask <lb/>Moveto(AddrToFunc(LeftValue(CurTask,StackTop))) <lb/>elseif OnlyValue(CurTask,StackTop) 6 = undef then <lb/>ReportValue(OnlyValue(CurTask,StackTop)) <lb/>Moveto(NextTask(CurTask)) <lb/>ENDIF <lb/>Figure 50: Revised transition rule for function-invocation tasks. <lb/>4.3 Function Invocations: Callee&apos;s Story <lb/>A function de nition in C consists of a list of parameter declarations and a compound statement. To process <lb/>a parameter declaration, we allocate new memory for each parameter and assign the appropriate value <lb/>(stored here by the function invocation transition rules) to that new memory location. The transition rule <lb/>for parameter declarations is shown in Fig. 51. <lb/>if TaskType(CurTask) = parameter-declaration then <lb/>DoAssign(NewMemory(CurTask), <lb/>ParamValue(CurTask,StackTop),ValueType(CurTask)) <lb/>OnlyValue(CurTask,StackTop) := NewMemory(CurTask) <lb/>endif <lb/>Figure 51: Transition rule for parameter-declaration tasks. <lb/>A return statement has one of the following forms: <lb/></body>

            <page>34 <lb/></page>

            <note place="headnote">4 ALGEBRA FOUR: HANDLING FUNCTION DEFINITIONS <lb/></note>

            <body>return-statement ! return <lb/>return-statement ! return expression <lb/>If an expression is present, copy t h e v alue of the expression to the task which i n voked the current function <lb/>(as indicated by ReturnTask and StackPrev). Whether or not an expression is present, return control to the <lb/>invoking task. The transition rule for return statements is shown in Fig. 52. <lb/>if TaskType(CurTask) = return then <lb/>OnlyValue(ReturnTask(StackTop),StackPrev(StackTop)) := <lb/>OnlyValue(CurTask,StackTop) <lb/>StackTop := StackPrev(StackTop) <lb/>Moveto(ReturnTask(StackTop)) <lb/>endif <lb/>Figure 52: Transition rule for return tasks. <lb/>If a return statement is not explicitly present at the end of a function, our algebra will still contain a <lb/>return task as the last task of the function, as if the statement \ return &quot; w as present as the last statement <lb/>of the original C function. <lb/>4.4 Global Variables <lb/>Since function de nitions may not contain other function de nitions, a given variable identi er refers either <lb/>t o a v ariable local to the current function or to a variable declared outside any function. A static partial <lb/>function GlobalVar: tasks ! Bool indicates whether or not a given identi er refers to a global variable. We <lb/>present the modi ed transition rule for identi ers in Fig. 53. <lb/>4.5 Initial State <lb/>We assert that initially, CurTask indicates the rst declaration task for the global variables of the program, <lb/>or the rst task of the rst statement main() if no declaration tasks exist. <lb/></body>

		<note place="headnote">REFERENCES <lb/></note>

		<page>35 <lb/></page>

            <body>if TaskType(CurTask) = identi er then <lb/>if ValueMode(CurTask) = lvalue then <lb/>if GlobalVar(CurTask) = true then <lb/>ReportValue(OnlyValue(Decl(CurTask),StackRoot)) <lb/>elseif GlobalVar(CurTask) = false then <lb/>ReportValue(OnlyValue(Decl(CurTask),StackTop)) <lb/>endif <lb/>elseif ValueMode(CurTask) = rvalue then <lb/>if GlobalVar(CurTask) = true then <lb/>ReportValue(MemoryValue(OnlyValue <lb/>(Decl(CurTask),StackRoot),ValueType(CurTask))) <lb/>elseif GlobalVar(CurTask) = false then <lb/>ReportValue(MemoryValue(OnlyValue <lb/>(Decl(CurTask),StackTop),ValueType(CurTask))) <lb/>endif <lb/>endif <lb/>Moveto(NextTask(CurTask)) <lb/>endif <lb/>Figure 53: Revised transition rule for identi ers. <lb/></body>

		<listBibl>References <lb/>ASU] <lb/>Alfred V. Aho, Ravi Sethi, and Je rey D. Ullman, \Compilers: Principles, Techniques, and <lb/>Tools&quot;, Addison-Wesley, 1 9 8 8 . <lb/>Gu] <lb/>Yuri Gurevich, \Evolving Algebras: An Introductory Tutorial&quot;, Bulletin of European Assoca-<lb/>tion for Theoretical Computer Science, February 1991. (A slightly updated version will appear <lb/>in the EATCS Book of Columns, World Scienti c Publishers.) <lb/>GH1] <lb/>Yuri Gurevich and James K. Huggins, \The Evolving Algebra Semantics of C: Preliminary <lb/>Version&quot;, CSE-TR-141-92, EECS Department, University of Michigan, 1992. <lb/>GH2] <lb/>Yuri Gurevich and James K. Huggins, &quot;The Semantics of the C Programming Language&quot;, <lb/>Selected papers from CSL&apos;92 (Computer Science Logic), Springer Lecture Notes in Computer <lb/>Science 702, 1993, 274{308. <lb/>GH3] <lb/>Yuri Gurevich and James K. Huggins, \Errata to`The Semantics of the C Programming Lan-<lb/>guage&apos; &quot;, Selected papers from CSL&apos;93 , Springer Lecture Notes in Computer Science, to appear. <lb/>KR] <lb/>Brian W. Kernighan and Dennis M. Ritchie, \The C Programming Language&quot;, 2nd edition, <lb/>Prentice Hall, 1988. <lb/></listBibl>

		<div type="annex">Index <lb/>addresses 2.2 <lb/>AddrToFunc 4.2 <lb/>AddTo 3.4 <lb/>BitAssign 2.24 <lb/>BitExtract 2.24 <lb/>BitType 2.24 <lb/>Bool 0.1 <lb/>bytes 2.2 <lb/>ByteToResult 2.1 <lb/>CastType 2.15 <lb/>ChooseTask 2.5, 4.2 <lb/>ConstValue 2.2 <lb/>Convert 2.15 <lb/>CopyByte 2.3 <lb/>CopyLocation 2.3 <lb/>CopyTask 2.3 <lb/>CopyType 2.3 <lb/>CopyValue 2.3 <lb/>CurTask 1.1 <lb/> Decl 3.3 <lb/>DecType 3.1 <lb/>DoAssign 2.3 <lb/>EVALUATE OPERANDS 2.5 <lb/>FalseTask 1.5 <lb/>FindID 2.22 <lb/>FunctionValue 2.21 <lb/>GlobalVar 4.4 <lb/>Initializer 3.1 <lb/>LeftTask 2.2 <lb/>LeftValue 2.2, 4.1 <lb/>Memory 2.1 <lb/>MemoryValue 2.1 <lb/>Moveto 1.2, 2.5 <lb/>NewMemory 3.1 <lb/>NextTask 1.1 <lb/>OldTask 2.3 <lb/>OnlyValue 2.2, 4.1 <lb/>ParamValue 4.2 <lb/>Parent 2.2 <lb/>PointerType 2.13 <lb/>PointsToType 2.13 <lb/>results 1.1 <lb/>ReportValue 2.4, 3.4, 4.2 <lb/>ResultToByte 2.1 <lb/>ReturnTask 4.2 <lb/>RightTask 2.2 <lb/>RightValue 2.2, 4.1 <lb/>Size 2.1 <lb/>stack 4.1 <lb/>StackNext 4.1 <lb/>StackPrev 4.1 <lb/>StackTop 4.1 <lb/>StaticAddr 3.1 <lb/>SwitchTask 1.6 <lb/>tags 1.1 <lb/>tasks 1.1 <lb/>TaskType 1.1 <lb/>TestValue 1.4, 2, 4.1 <lb/>TrueTask 1.5 <lb/>typename 2.2 <lb/>ValueMode 2.18 <lb/>ValueType 2.2 <lb/>Visited 2.5 <lb/>WhichChild 2.2 <lb/></div>

		<page>36 </page>


	</text>
</tei>
