<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">The Complex(ity) Landscape of Checking Infinite Descent</title>
        <author>
          <persName>
            <forename>Liron</forename>
            <surname>Cohen</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Adham</forename>
            <surname>Jabarin</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Andrei</forename>
            <surname>Popescu</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Reuben N. S.</forename>
            <surname>Rowe</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-29T14:49:13.951477Z">29.10.2025 14:49:13</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3632888</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3632888</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Liron Cohen, Adham Jabarin, Andrei Popescu, Reuben N. S. Rowe. (2024). The Complex(ity) Landscape of Checking Infinite Descent. Proceedings of the ACM on Programming Languages, 8(POPL), 1352-1384. DOI: 10.1145/3632888</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-29T14:49:13.951477Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-29T14:49:13.951477Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
        <front>RichWasm: Bringing Safe, Fine-Grained, Shared-Memory <lb/>Interoperability Down to WebAssembly <lb/>MICHAEL FITZGIBBONS * , Northeastern University, USA <lb/>ZOE PARASKEVOPOULOU * , Ethereum Foundation, Germany and Northeastern University, USA <lb/>NOBLE MUSHTAK, Northeastern University, USA <lb/>MICHELLE THALAKOTTUR, Northeastern University, USA <lb/>JOSE SULAIMAN MANZUR, Northeastern University, USA <lb/>AMAL AHMED, Northeastern University, USA <lb/>Safe, shared-memory interoperability between languages with different type systems and memory-safety <lb/>guarantees is an intricate problem as crossing language boundaries may result in memory-safety violations. <lb/>In this paper, we present RichWasm, a novel richly typed intermediate language designed to serve as a <lb/>compilation target for typed high-level languages with different memory-safety guarantees. RichWasm is <lb/>based on WebAssembly and enables safe shared-memory interoperability by incorporating a variety of type <lb/>features that support fine-grained memory ownership and sharing. RichWasm is rich enough to serve as a <lb/>typed compilation target for both typed garbage-collected languages and languages with an ownership-based <lb/>type system and manually managed memory. We demonstrate this by providing compilers from core ML <lb/>and 3 , a type-safe language with strong updates, to RichWasm. RichWasm is compiled to regular Wasm, <lb/>allowing for use in existing environments. We formalize RichWasm in Coq and prove type safety. <lb/>CCS Concepts: • Software and its engineering → Formal language definitions; Assembly languages. <lb/>Additional Key Words and Phrases: WebAssembly, memory ownership, memory sharing, capability types <lb/>ACM Reference Format: <lb/>Michael Fitzgibbons, Zoe Paraskevopoulou, Noble Mushtak, Michelle Thalakottur, Jose Sulaiman Manzur, <lb/>and Amal Ahmed. 2024. RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to <lb/>WebAssembly. Proc. ACM Program. Lang. 8, PLDI, Article 214 (June 2024), 24 pages. https://doi.org/10.1145/ <lb/>3656444 <lb/></front>

        <body>1 INTRODUCTION <lb/>WebAssembly [10] (Wasm) is a portable binary format that enables almost-native execution speed <lb/>for a variety of languages. With around 40 languages compiling to Wasm, the WebAssembly <lb/>platform has huge potential to serve as a platform for language interoperability. This potential has <lb/>been recognized for some time, but there are two impediments. The first is that Wasm takes an <lb/>all-or-nothing approach to sharing memory. Each Wasm module has its own memory. If it wants to <lb/>share a data structure in its memory with another module, that effectively leaves all of its memory <lb/></body>

        <front> * Both authors contributed equally to this research. <lb/>Authors&apos; addresses: Michael Fitzgibbons, Northeastern University, Boston, USA, michaelfitzgibbons7@gmail.com; Zoe <lb/>Paraskevopoulou, Ethereum Foundation, Berlin, Germany and Northeastern University, Boston, USA, zoe.paraskevopoulou@ <lb/>gmail.com; Noble Mushtak, Northeastern University, Boston, USA, noble.mushtak@gmail.com; Michelle Thalakottur, <lb/>Northeastern University, Boston, USA, thalakottur.m@northeastern.edu; Jose Sulaiman Manzur, Northeastern University, <lb/>Boston, USA, sulaimanmanzur.j@northeastern.edu; Amal Ahmed, Northeastern University, Boston, USA, amal@ccs.neu.edu. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/6-ART214 <lb/>https://doi.org/10.1145/3656444 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/></note>

        <page>214:2 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>exposed to the other module, potentially allowing adversarial code to access and modify arbitrary <lb/>parts of that memory via pointer arithmetic. The multiple memories proposal [8] addresses this <lb/>by allowing modules to have multiple independent memories and only share some of them while <lb/>keeping others private. This mechanism is too coarse-grained, in both a spatial and temporal sense: <lb/>it does not allow fine-grained sharing of only one data structure in a memory or sharing for only a <lb/>while and then allowing access to be revoked. <lb/>The second impediment is that Wasm has only low-level types (32-and 64-bit integers and floats), <lb/>so when modules from different languages need to communicate, there is a question of how to <lb/>exchange high-level values. The Interface Types proposal [7] aimed to address this by introducing a <lb/>set of high-level &quot;interface types&quot; (e.g., char, list, record, variant, and more can be encoded) that can <lb/>be used to communicate across modules. However, the Interface Types proposal and its successor, <lb/>the Component Model proposal [5], support only &quot;shared-nothing&quot; interoperability, requiring that <lb/>values be copied across language boundaries when necessary. This ensures memory safety but <lb/>comes with runtime overhead for copying. <lb/>In this paper, we propose RichWasm, a richly typed intermediate language (IL) based on Web-<lb/>Assembly. Unlike existing proposals in the Wasm ecosystem, RichWasm supports safe, fine-grained, <lb/>shared-memory interoperability across Wasm modules, and it is also motivated by a longer-term <lb/>desire to provide a platform atop which language implementors can easily develop safe FFIs. A <lb/>particular goal is to enable statically detecting memory safety violations that happen across source-<lb/>language boundaries and thus cannot be detected by the source type system (though this does not <lb/>preclude FFI designers from adding constructs that defer interop errors to runtime). For instance, if <lb/>we mix a type-safe garbage-collected language such as OCaml with a type-safe non-GC&apos;d language-<lb/>e.g., Rust or 3 [14, 2]-and allow them to share memory, violations may include the Rust-like <lb/>language freeing some garbage-collected memory passed to it from OCaml, or OCaml copying <lb/>a mutable reference from the Rust-like language that the latter considers uniquely owned. We <lb/>wish to allow source-language designers to add inter-language communication through a simple <lb/>foreign-function interface that requires no changes to the existing source type systems and minimal <lb/>changes to the syntax of their languages. Then the source-language modules are compiled separately <lb/>to RichWasm modules. Typechecking at the RichWasm level can catch potentially problematic <lb/>interactions between modules, guaranteeing cross-module type and memory safety. <lb/>Overview of RichWasm. At the core of RichWasm&apos;s type system are capability types in the style <lb/>of 3 [14, 2], which is a linear language with locations and safe strong updates (updates that change <lb/>the type of a location). A key idea in 3 was that when we allocate a new reference and initialize it <lb/>with a value of type , we get back an existential package ∃ .!Ptr ⊗ Cap <lb/>that says that there <lb/>exists some location and we now have an unrestricted (copyable) pointer to that location and <lb/>we have a linear capability that tells us the type of value currently stored at that location. This <lb/>linear capability is essentially an ownership token required to access the reference -the capability <lb/>must be provided to read from, write to, or free the location. In RichWasm, we similarly have linear <lb/>capabilities that represent (allow access to) uniquely owned memory and support strong updates. <lb/>But we also have unrestricted capabilities, which represent (allow access to) garbage-collected <lb/>memory and are analogous to ML references in that they only support type-preserving updates. <lb/>Unlike 3 , capability types in RichWasm can provide either read-only access or read-write access. <lb/>Formally, RichWasm has a substructural type system, realized via two qualifiers, linear and <lb/>unrestricted, that annotate pretypes. In addition to capability pretypes, RichWasm supports poly-<lb/>morphism, recursive types, variants, structs, arrays and existential types. Unlike 3 , which assumes <lb/>a reference cell can hold a value of any size, RichWasm has a low-level memory model like Wasm&apos;s, <lb/>where each memory is simply a sequence of bytes and we must allocate data structures in the &quot;flat&quot; <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:3 <lb/></page>

        <body>memory. 1 This leads to an important novelty in the type system, which must keep track of the <lb/>size of memory slots and disallow strong updates that attempt to store a larger value in that slot. <lb/>Hence, capability types in RichWasm track the size of the memory slot originally allocated and <lb/>type variables must be annotated with a size bound that indicates the maximum size of the type <lb/>that can be instantiated with. <lb/>We implement compilers from core ML and 3 to RichWasm, demonstrating that RichWasm can <lb/>serve as a typed compilation target for both typed garbage-collected languages and languages with <lb/>an ownership-based type system and manually managed memory. We also compile RichWasm to <lb/>Wasm, providing a pathway to realistic use in many environments. We have formalized RichWasm <lb/>in Coq and we have proved type safety (progress and preservation) for the type system. <lb/>Situating RichWasm. Before we dive into the details of RichWasm, we would like to make clear <lb/>where it sits relative to two other pieces of related work. The first is the Wasm Component Model, <lb/>though we&apos;ve already discussed the salient difference above, namely &quot;shared-nothing&quot; vs. &quot;fine-<lb/>grained shared-memory&quot; interoperability. But there are additional similarities and differences. The <lb/>Component Model is intended to be a part of the WebAssembly ecosystem but not part of the <lb/>core Wasm spec and the same is true of RichWasm. The Component Model provides a means <lb/>to organize Wasm modules into components and instrument core Wasm modules so they can <lb/>take advantage of higher-level types when communicating across components, while RichWasm <lb/>supports higher-level types and then compiles (or lowers) them to Wasm. On the other hand, while <lb/>the Component Model implementation employs dynamic techniques to assure safety when it comes <lb/>to features like resources and handles, RichWasm uses static enforcement. <lb/>The second is recent work on safe FFIs by Patterson et al. [21] who proposed a framework for <lb/>design and verification of safe FFIs. Their main insight is that language designers should build a <lb/>model of source-level types as sets of target-level terms. Then for all conversions their FFI permits, <lb/>from a type in one language say to a type in the other say , the target-level glue code they <lb/>write to implement that conversion can be shown to be sound if: given target code that behaves like <lb/>, the conversion produces target code that behaves like . This is a perfectly reasonable recipe <lb/>for designing and verifying safe FFIs between languages that compile directly to Wasm. However, <lb/>we would argue that it is a rather heavyweight recipe, one that requires FFI designers to know how <lb/>to construct semantic models that would then guide their thinking. With RichWasm, we would <lb/>like to provide support for compiler writers who don&apos;t know how to build semantic models and <lb/>aren&apos;t interested in doing formal verification of FFIs. To that end, we&apos;ve developed a richly typed IR <lb/>capable of detecting unsafe interoperability via type checking of compiled code. To take advantage <lb/>of this, compiler writers must implement type-preserving compilers to RichWasm, a much easier <lb/>task than defining a target-level model of source-language types. Whenever the language designer <lb/>wants to support additional FFI functionality, they simply have to extend their compiler and see if <lb/>any additional conversions they allow result in type-checking errors at the RichWasm level. <lb/>Contributions. Our central contribution is RichWasm, a typed IL built on top of WebAssembly <lb/>that is designed to serve as a useful platform for safe FFI design. 2 <lb/>• RichWasm supports an advanced substructural type system with capabilities and size track-<lb/>ing that enables static assurance of safe, fine-grained shared memory interoperability in <lb/>a language with a low-level memory model (i.e., &quot;flat&quot; memory). The type system allows <lb/>precisely tracking memory ownership and sharing, and avoids memory safety violations <lb/>even when sharing memory across languages with garbage collection and manual memory <lb/>management ( §2 and §3). <lb/></body>

        <note place="footnote">1 In WebAssembly-speak, what we refer to as &quot;flat&quot; memory, i.e., memory that&apos;s a sequence of bytes, is called &quot;linear&quot; memory. <lb/>2 Our technical artifact is available at https://github.com/RichWasm/RichWasm-artifact <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:4 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>• We have formalized RichWasm in Coq and proved type safety (about 75k lines of Coq). <lb/>• We have type-preserving compilers from core ML and 3 to RichWasm and a simple FFI <lb/>between them that allows us to compile interoperating programs to RichWasm ( §5). <lb/>• We have a compiler from RichWasm to WebAssembly that allows us to run RichWasm <lb/>programs in all hosts of WebAssembly ( §6). <lb/>Limitations and Future Work. This paper describes the RichWasm Minimum Viable Product <lb/>(MVP), which is intended to demonstrate that it can serve as a platform for fine-grained safe <lb/>interoperability between a type-safe GC&apos;d language with aliasing and a type-safe language with <lb/>manual memory management and type-enforced memory ownership. The RichWasm MVP has <lb/>many feature limitations that require further research. In particular, it cannot serve as a target <lb/>for type-preserving compilation of Rust since the type system is not expressive enough to encode <lb/>Rust&apos;s borrowing and lifetimes. In §8, we discuss future work on extensions of the RichWasm MVP <lb/>to support source languages with borrowing, concurrency, effect handlers, etc. We also leave the <lb/>full-fledged design and evaluation of realistic FFIs on top of RichWasm to future work ( §8). Each <lb/>real FFI design ought to involve an investigation of flexibility/performance tradeoffs, along with an <lb/>evaluation of usabliity. <lb/>2 RICHWASM OVERVIEW <lb/>In this section, we give an overview of the RichWasm language, presenting its types and syntax <lb/>( §2.1). Then we sketch a simple FFI between 3 and ML and show an example of how RichWasm <lb/>can statically detect unsafe interop between them ( §2.2). <lb/>First, consider a small example to get a sense for the sort of errors RichWasm can catch. In Fig. 1 <lb/>we have a GC&apos;d program that provides two functions: an identity function on integer references, <lb/>which stashes a copy of the reference, and a function which returns the stashed copy. Our manually <lb/>managed program first creates a reference, passes it to the stash function, and frees the returned <lb/>reference. Next, the linear program retrieves the stashed reference and attempts to free it, resulting <lb/>in a double free. If compiled naively, RichWasm&apos;s type system will first complain that stash requires <lb/>an unrestricted reference, but is called with a linear reference. If stash were compiled to take a <lb/>linear reference, RichWasm would not admit the function since it duplicates a linear value. <lb/>let c = ref ( ref 0) in <lb/>fun stash ( r : Ref Int ) = c := r ; r in <lb/>fun get_stashed (() : Unit ) = ! c <lb/>(a) Garbage-collected program <lb/>free ( ml . stash ( new 42)); <lb/>free ( ml . get_stashed ()) (* CRASH *) <lb/>(b) Manually managed program <lb/>Fig. 1. Unsafe interoperability <lb/>RichWasm and Wasm. While RichWasm is coherent without comparison to Wasm, readers who <lb/>are familiar with Wasm will note the parallel structure of the two languages. Existing constructs <lb/>from Wasm are extended to support RichWasm&apos;s new types, while continuing to fulfill their original <lb/>purpose. For instance, Wasm has &quot;local variables&quot;: a location which lives for the duration of a <lb/>function call and can store one numeric type. RichWasm has an analagous concept. However, <lb/>RichWasm also has strong tools for reasoning about sizes and linearity. This allows us to use locals <lb/>even more effectively, strongly updating them while guaranteeing that there will be space for any <lb/>value we store and that we only duplicate or ignore values which are not linear. <lb/>The largest departure from Wasm is in RichWasm&apos;s treatment of memory. Because we want to <lb/>support strong memory invariants, RichWasm supports a series of structured memory types, rather <lb/>than the raw sequence of numeric types present in Wasm. Wasm&apos;s unfettered access to the memory <lb/>makes it impossible to maintain any invariants about one&apos;s memory layout when linking with <lb/>other code. We no longer support arbitrary memory operations, but thanks to the same size and <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:5 <lb/></page>

        <body>linearity reasoning tools that give us greater control over locals, we retain control over memory <lb/>layouts and sharing, without the burden of losing invariants when linking with other code. <lb/>2.1 RichWasm Syntax and Types <lb/>In Fig. 2 we give a full account of RichWasm types and programs. The highlighted constructs are <lb/>new in RichWasm and not present in Wasm. We start explaining the syntax of the language from <lb/>the top-level structures. <lb/>Types <lb/>∈ N <lb/>pretypes <lb/>::= unit | np | ( * ) | ref ℓ | ptr ℓ | cap ℓ | rec ⪯ . | ∃ . | coderef | own ℓ | <lb/>numeric pretypes <lb/>np ::= ui32 | ui64 | i32 | i64 | f32 | f64 <lb/>types <lb/>::= <lb/>qualifiers <lb/>::= <lb/>| unr | lin <lb/>memory privilege <lb/>::= rw | r <lb/>heap types <lb/>::= (variant * ) | (struct ( , sz) * ) | (array ) | (∃ ⪯ ≲ sz. ) <lb/>locations <lb/>ℓ ::= <lb/>| unr | lin <lb/>quantifiers <lb/>::= <lb/>| sz * ≤ ≤ sz * | * ⪯ ⪯ * | ⪯ ( ? ) ≲ sz <lb/>indices <lb/>z ::= ℓ | sz | | <lb/>arrow types <lb/>tf ::= <lb/>1 <lb/> * → 2 <lb/> * <lb/>function types <lb/>::= ∀ * . 1 <lb/> * → 2 <lb/> * <lb/>sizes <lb/>sz ::= <lb/>| sz + sz | <lb/>Terms <lb/>heap values ℎ ::= (variant ) | (struct * ) | (array * ) | (pack <lb/>) <lb/>values <lb/>::= () | <lb/>.const | ( * ) | ref ℓ | ptr ℓ | cap | fold | mempack ℓ | coderef <lb/>z * | own <lb/>instructions <lb/>::= | <lb/>. <lb/>| <lb/>. <lb/>| <lb/>. <lb/>| <lb/>. <lb/>′ | unreachable | nop | drop | select | <lb/>block tf ( , ) *  * end | loop tf * end | if tf ( , ) *  * else * end | br | br_if | br_table * | <lb/>get_local <lb/>| set_local | tee_local | get_global | set_global | qualify | <lb/>return | coderef | inst z * | call_indirect | call z * | <lb/>rec.fold | rec.unfold | mem.pack ℓ | mem.unpack tf ( , ) * . * <lb/>seq.group <lb/>| seq.ungroup | cap.split | cap.join | ref.demote | ref.split | ref.join | <lb/>struct.malloc sz * | struct.free | struct.get | struct.set | struct.swap | <lb/>variant.malloc * | variant.case <lb/>tf ( , ) * ( * ) * end | <lb/>array.malloc | array.get | array.set | array.free | <lb/>exist.pack <lb/>| exist.unpack <lb/>tf ( , ) * <lb/> * end | <lb/>i <lb/>::= clz | cnt | popcnt <lb/>i <lb/>::= add | sub | mul | div <lb/>| rem <lb/>| <lb/>and | or | xor | shl | shr | rotl | rotr <lb/>f <lb/>::= abs | neq | sqrt | ceil | floor | trunc | nearest <lb/>f <lb/>::= add | sub | mul | div | min | max | copysign <lb/>i <lb/>::= eqz <lb/>i <lb/>::= eq | ne | lt <lb/>| gt <lb/>| le <lb/>| ge <lb/>f <lb/>::= eq | ne | lt | gt | le | ge <lb/>::= convert | reinterpret <lb/>Top-level declarations <lb/>functions <lb/>::= * function local sz *  * | * function <lb/>globals <lb/>::= * glob mut ? * | * glob <lb/>table <lb/>::= * table * | * table <lb/>exports <lb/>::= export &quot; <lb/>&quot; <lb/>imports <lb/>::= import &quot; <lb/>&quot; <lb/>modules <lb/>::= module * <lb/> * <lb/>Fig. 2. RichWasm abstract syntax <lb/>Modules. A top-level RichWasm program is a module. A module consists of code in the form <lb/>of a list of functions and data in the form of a list of global declarations that can be mutable or <lb/>immutable. Each module also has a table that, as in WebAssembly, stores references to functions <lb/>which facilitate indirect calls. Functions, globals, and tables can be exported, making them visible <lb/>to other modules for import. <lb/>Functions. Functions are sequences of RichWasm instructions, taking as input a sequence of values <lb/>and returning a sequence of values. The function type, , can be polymorphic over various type-<lb/>level entities: memory locations, sizes, qualifiers (i.e., linearity annotations), and types. Functions <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:6 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>define their list of local variable using their sizes (sz * ) which will be initialized with an unrestricted <lb/>unit value. They are not tied to a particular type and their type may change during evaluation. <lb/>Value Types. The types of values consist of a pretype that is annotated with a qualifier. Concrete <lb/>qualifiers can be linear (lin) or unrestricted (unr) and indicate whether a value must be treated <lb/>linearly. Qualifiers can also be abstract variables bound in function quantification. Qualifiers <lb/>are ordered with unr ⪯ lin. This ordering helps us put restrictions on abstract types bound in <lb/>polymorphic, existential, or recursive types. <lb/>Simple pretypes include unit, numeric types (32 or 64 bit signed and unsigned integers and <lb/>floats), and tuples ( * ). Next we have references, pointers, and capabilities. Pointers are used to <lb/>access a memory location and capabilities provide ownership to a memory location. References <lb/>represent the pair of a capability and a pointer. Capabilities are a type-level reasoning tool and are <lb/>erased in RichWasm programs compiled to Wasm. The ability to split a reference into a capability <lb/>and a pointer allows a program to separate its static notion of ownership from its runtime data <lb/>layout. If pointers to a location are stashed in separate parts of a large data strucutre, ownership <lb/>(in the form of a capability) can be stored with one of them and then temporarily borrowed by <lb/>the other location by moving the capability. Since capabilities will be erased upon compilation to <lb/>Wasm, this transfer of ownership satisifies the type system without incurring any runtime cost. <lb/>The pretype ref ℓ is a reference to a location ℓ that contains a heap type and provides read or <lb/>read-write priviledge ( ) to it. A capability carries similar information, while a pointer is annotated <lb/>only with the location that it points to. The pretype own ℓ is an ownership token that represents <lb/>write ownership of a location. A read-write capability can be temporarily split into a read-only <lb/>capability and an ownership token and later recombined. <lb/>RichWasm has isorecursive types to represent recursive data structures. The pretype rec ⪯ . <lb/>is recursive over . The constraint ⪯, which will be discussed further below, asserts that the <lb/>recursive pretype will be unfolded only into locations with qualifiers greater than or equal to . <lb/>To facilitate location abstraction, which is necessary to statically represent references to memory <lb/>locations, RichWasm has existential pretypes over locations ∃ . . For instance, ∃ . (ref rw <lb/>) <lb/>represents a read-write reference to a statically unknown location with heap type . <lb/>Wasm allows &quot;indirect&quot; function calls, using a runtime value to lookup a function in a table. We <lb/>use the pretype coderef to represent a code pointer to some function in that table with type . <lb/>Lastly, a pretype can be a pretype variable , referring to a universal, existential, or recursive <lb/>binding site. <lb/>Heap Types and Memory Model. The memory model of RichWasm consists of two global flat <lb/>memories: the linear memory and the unrestricted memory. The linear memory is manually man-<lb/>aged and references to it must be treated linearly. The unrestricted memory is garbage collected and <lb/>stores ML-like references. Unlike Wasm, where memories are essentially byte arrays, in RichWasm <lb/>memories store high-level structured data. Heap types can be variants, structs, arrays, and existential <lb/>packages abstracting over pretypes. A variant heap type (variant * ) describes a heap value that <lb/>can contain more than one kind of value, where * is a list containing the type for each case of the <lb/>variant. An array heap type (array ) is a variable-length array containing values of type . A struct <lb/>heap type (struct ( , sz) * ) is a record type with the list ( , sz) * indicating the type and the size sz <lb/>of each field. Keeping the size of each field is necessary to support strong updates. Strong updates are <lb/>necessary when consuming linear struct fields, as the old value must be replaced with a new value <lb/>in order to prevent duplication. An existential heap type (∃ ⪯ ≲ sz. ) abstracts over a pretype <lb/>in a type . The qualifier denotes the minimum qualifier that the pretype should have when it is <lb/>used inside the type. The size denotes an upper bound for the size of the abstracted type, which is <lb/>useful when we want to do a strong update with this type (either into a field of a struct or a local). <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:7 <lb/></page>

        <body>Locations are natural numbers that refer either to the unrestricted or linear memory. Since we <lb/>have location polymorphism, locations can also be variables. <lb/>Function Types and Polymorphism. Function types are arrow types 1 <lb/> * → 2 <lb/> * that indicate that a <lb/>function consumes values with types 1 <lb/> * from the stack, and leaves values with types 2 <lb/> * on the <lb/>stack after its execution. To facilitate polymorphism, function types can quantify over four different <lb/>kinds: locations, sizes, qualifiers, and pretypes. Quantification over sizes, qualifiers, and pretypes <lb/>can impose constraints over the abstracted kind. <lb/>Location quantification is most straightforward: function declarations should be polymorphic <lb/>over locations since concrete locations are only available at runtime. <lb/>Functions can also be polymorphic over sizes. For instance, projecting a struct field is an operation <lb/>that should be agnostic to the size of the field, therefore the size must be abstracted. Quantification <lb/>over sizes can also be subject to constraints. In particular, the size variable can be upper-bounded <lb/>and lower-bounded by some sizes, written sz * ≤ ≤ sz ′ * . Allowing quantification over sizes to be <lb/>constrained in this way allows for richer reasoning about location usage. For instance, if a function <lb/>takes two arguments of sizes 1 and 2 and places a tuple consisting of the two arguments into a <lb/>local of size 3 , it must be known that 1 + 2 ≤ 3 . <lb/>To write functions that operate on both linear and unrestricted data, functions can also be <lb/>polymorphic on qualifiers. Qualifier quantification can be subject to the same sort of contraint as <lb/>size quantification, in this case written * ⪯ ⪯ ′ * . To see why qualifier constraints are necessary, <lb/>consider a function that takes two arguments and constructs a tuple. The qualifier of the tuple must <lb/>be greater than the qualifiers on the values inside the tuple. If this were not the case, we could have <lb/>a non-linear tuple which can be duplicated, containing a linear value which should not be. <lb/>Lastly, we have pretype polymorphism, which is the usual parametric polymorphism we find in <lb/>ML programs. The type constraints are ⪯ ( ? ) ≲ sz where is a lower bound for the qualifier of <lb/>the pretype, sz an upper bound for its size, and the presence of denotes whether this type can <lb/>contain capabilities. Upper bounds on sizes are straightforwardly useful to demonstrate that types <lb/>will fit into locations. A qualifier lower bound is, however, a bit less intuitive. Keep in mind that we <lb/>are quantifying over pretypes and not types, so any location where this pretype variable appears <lb/>will have a qualifier on it. These bounds provide two guarantees. Firstly, this pretype variable will <lb/>only be substituted into positions with qualifiers greater than or equal to the bound. Secondly, we <lb/>can only substitute a pretype in for such a pretype variable if it would be valid at that qualifier. To <lb/>see why this is important, consider an attempt to instantiate the variable in the type unr with the <lb/>tuple pretype (unit lin ). This instantiation would leave us with an unrestricted tuple containing a <lb/>linear value, a type we just determined would violate the guarantees of our type system. Having <lb/>quantifier lower bounds will guarantee that such instantiations never take place. Whether or not a <lb/>type contains capabilities is relevant only for garbage collection and will be discussed below. <lb/>Using polymorphism, we can write the type of a function that projects a linear field of a singleton <lb/>struct and replaces it with a value of a new type, performing a strong update: <lb/>∀ <lb/>1 (lin ⪯ 2 ≲ ). lin <lb/>2 (ref rw (struct ( lin <lb/>1 , ))) lin → lin <lb/>1 (ref rw (struct ( lin <lb/>2 , ))) lin <lb/>The function is polymorphic over the actual location of the struct, , the size of the struct field, <lb/>, the pretype of the struct field 1 , and the pretype of the new value, 2 , that is going to be put <lb/>in the struct slot. The constraints over 2 ensure that it will fit into the slot of size and can be <lb/>safely stored in the heap. The qualifier lower bound ensures that this function can be used on types <lb/>which must appear in at least linear positions. <lb/>Heap Values. Variant heap values are written (variant ), where is tag of the variant. Struct <lb/>values are written (struct * ). Array values are written (array * ), where is the size of the array. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:8 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>Lastly, existential packages are writen (pack <lb/>), where is the pretype witness, the heap <lb/>type of the existential package, and the value that is being packed. <lb/>Values and Instructions. Each RichWasm type has a corresponding value form. For unit, numeric <lb/>types, and tuples, these values are straightforward. References and pointers are annotated with the <lb/>memory location they point to. Capabilities and ownership tokens carry no information and are <lb/>computationally irrelevant. We have the typical constructor for isorecursive types (fold ). Existen-<lb/>tial location packages (mempack ℓ ) contain the packed value as well as the location witness of <lb/>the package, used to instantiate abstract locations in instructions once unpacked. The value form <lb/>for function references is coderef <lb/>z * , where is the index of the module instance, is the index <lb/>of the function in the function table, and z * the concrete instantiation of the polymorphic indices. <lb/>New RichWasm instructions include instructions for folding and unfolding recursive types, <lb/>packing and unpacking existential memory locations, grouping and ungrouping tuples, joining and <lb/>spliting capabilties and ownership tokens, joining and spliting capabilities and pointers to form <lb/>references, and manipulating heap values (each type of heap value has its own set of instructions). <lb/>Instructions that introduce blocks of instructions, like block or if then else, are annotated not <lb/>only with their type as in Wasm, but also with their local effects, ( , ) * . These describe the effect <lb/>that a list of instructions may have on the type of their local variable slots: the slot at position <lb/>gets type . <lb/>2.2 Simple ML-3 FFI and Catching Unsafe Interoperability <lb/>We extend the languages in the style of linking types [19, 20], which allow languages to maintain <lb/>their native reasoning principles while interacting with foreign types near language boundaries. <lb/>ML gets a type, written &lt; &gt;, which directs the compiler to make an ML type linear in RichWasm. <lb/>To store linear types, it also has a new construct ref_to_lin which creates a reference that can <lb/>either be empty or contain a linear value of the given type. Normal Ref operations can be used on <lb/>these references, but ML compiles them in such a way that if they are read from or written to twice, <lb/>they will fail at runtime, as this would violate linearity and is unsound 3 . 3 , which typically only <lb/>has capabilities and pointers, gets a new ML-like Ref type. To convert a capability plus pointer to <lb/>and from a Ref type at the boundary with ML, we give 3 two new constructs: join and split. <lb/>let c = ref_to_lin &lt; Ref Int &gt; in <lb/>fun stash ( r : &lt; Ref Int &gt;) : &lt; Ref Int &gt; = <lb/>c := r ; r <lb/>in <lb/>fun get_stashed (() : Unit ) = ! c <lb/>(a) ML program <lb/>import ( ml . stash : <lb/>!(( ∃ ℓ . Ref ℓ ! Int 1) ⊸ (∃ ℓ . Ref ℓ ! Int 1))); <lb/>import ( ml . get_stashed : <lb/>!(! Unit ⊸ (∃ ℓ . Ref ℓ ! Int 1))); <lb/>free ( split ( stash ( join ( new !42 1)))); <lb/>free ( split ( get_stashed !())) (* CRASH ! *) <lb/>(b) 3 program <lb/>Fig. 3. Unsafe interoperability <lb/>Fig. 3 shows an example akin to that in Fig. 1, but with syntax more accurate to ML and 3 . <lb/>The key differences are that the programs must use their new extensions to agree on types at <lb/>the linking boundary. The problematic function here is still ML&apos;s stash, and RichWasm will not <lb/>allow it to typecheck since it duplicates a linear value. If stash were to not return the linear value <lb/>(and correspondingly 3 were to no longer attempt to free that value, since it&apos;s not returned), this <lb/>program would type check and 3 &apos;s previously illegal attempt to free would be safe. <lb/>3 RICHWASM DYNAMIC SEMANTICS <lb/>Execution in RichWasm terms closely follows Wasm and is defined as a reduction relation. The <lb/>relation, written ; * ; sz * ; * ↩→ ′ ; ′ * ; ′ * , represents a reduction step in module from one <lb/></body>

        <note place="footnote">3 In the example in Fig. 3, the ML code uses the linear reference exactly once, which is valid. <lb/></note>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:9 <lb/></page>

        <body>program configuration ; * ; * ; * to another, where is the store, * the local values and * the <lb/>sizes of their slots, and * the instructions to be evaluated. Fig. 4 shows the definition of runtime <lb/>objects as well as important rules of the reduction relation. We elide rules that are identical to <lb/>Wasm, and we focus on the reduction rules of new constructs. <lb/>Store and Module Instances. A store represents the execution state. It holds the list of module <lb/>instances, which is the dynamic representation of static modules and the global memory. A module <lb/>instance consists of a dynamic function table that holds a list of closures which, as in Wasm, is used <lb/>for direct calls, a list of global values, and the dynamic table which is a list of closures that is used <lb/>for indirect calls. A closure, in the Wasm sense, is a dynamic instance of a function that consists of <lb/>the code and a pointer to the module that provides the function&apos;s environment. The global memory <lb/>has two components: the linear memory and the unrestricted memory. Both memories are maps <lb/>from locations to high-level heap values. <lb/>Administrative Instructions. As in Wasm, some reduction rules generate instructions that are not <lb/>part of the syntax of source programs and represent administrative operations. A trap instruction <lb/>signals an execution trap. We add two administrative instructions: malloc sz hv to allocate <lb/>memory of size sz holding a value hv in the memory , and free to deallocate parts of the linear <lb/>memory, given a reference. Allocation and deallocation of heap types reduce to these instructions. <lb/>The administrative instruction call z * is similar to Wasm&apos;s, but along with the closure , it is <lb/>annotated with the concrete instantiation of the polymorphic quantifiers in the function&apos;s type, z * . <lb/>Control Flow. Much like in Wasm, when running RichWasm programs, evaluation occurs within <lb/>some number of label instructions, each corresponding to a source block of code (introduced by <lb/>instructions like block, if, loop). The break instructions (br, br_if, br_table) allow programs to <lb/>jump to any of the surrounding locations by specifying how many labels to jump over. Nested label <lb/>instructions are represented with local contexts. A local context <lb/>[ * ] represents N nested label <lb/>instructions. A local context has a hole at its deepest label instruction, where evaluation can occur. <lb/>3.1 Reduction Relation <lb/>We give an overview of the most important reduction rules of RichWasm that are new or different <lb/>from those in Wasm. For space reasons, we drop the store and local variables in all the rules that <lb/>leave them unchanged. We may still use the store in side conditions where it is relevant, without <lb/>explicitly mentioning it in the rule. <lb/>Garbage Collection. The reduction relation has a rule that can be applied at any point, allowing <lb/>collection of unrestricted locations that are no longer accessible from the configuration. The roots <lb/>of collection are the unrestricted locations that appear in ref / cap values in the instructions, local <lb/>variables, or the module instances. Any location not reachable from the roots is collected. <lb/>If a reference to linear memory is placed into garbage collected memory, we say that the garbage <lb/>collector now owns that memory and is responsible for collecting it if the unrestricted location, <lb/>and thus the only reference to the linear location, should be collected. Freeing of linear memory <lb/>is a type-directed operation, and when compiling to Wasm, we can generate finalizer functions <lb/>that get called when such references are collected. But what would we do if a capability to linear <lb/>memory were in garbage-collected memory? When compiling to Wasm, capabilities will be erased, <lb/>which would leave the garbage collector with no way to reference the linear memory location it <lb/>owns at runtime. To resolve this, we require that capabilities always be paired with a pointer in the <lb/>form of a reference when placed in memory. <lb/>Function Calls. Function calls follow similar principles to those of Wasm. Few differences arise <lb/>from the polymorphic types of RichWasm functions and the way polymorphic binders are instanti-<lb/>ated. Direct function calls are performed with the call z * instruction, where is the index of the <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:10 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>store <lb/>::= {inst <lb/> * , mem <lb/>} <lb/>instances <lb/>::= {func * , glob * , tab * } <lb/>memory <lb/>::= {lin ↦ → ℎ , unr ↦ → ℎ } <lb/>closure <lb/>::= {inst , code } <lb/>administrative instructions <lb/>::= • • • | trap | call z * | label tf { 1 <lb/> * } 2 <lb/> * end | <lb/>local { ; ( , sz) * } * end | malloc sz ℎ <lb/>| free <lb/>local contexts <lb/>0 <lb/>::= * [_] * <lb/>+1 ::= * label tf { * } <lb/>end * <lb/>Reduction <lb/>; * ; sz * ; * ↩→ ′ ; ′ * ; ′ * <lb/>; * ; * ; * ↩→ ′ ; ′ * ; ′ * <lb/>; * ; * ; [ * ] ↩→ ′ ; ′ * ; [ ′ * ] <lb/>; * ; sz * ; * ↩→ ′ ; ′ * ; ′ * <lb/>; 0 <lb/> * ; * ; local { ; ( , sz) * } * end ↩→ ′ ; 0 <lb/> * ; local { ; ( ′ , sz) * } ′ * end <lb/>collect(locs( * ) ∪ locs( * ) ∪ locs( <lb/>), <lb/>, <lb/>′ ), <lb/>{inst <lb/> * , mem <lb/>}; * ; sz * ; * ↩→ {inst <lb/> * , mem <lb/>′ }; * ; * <lb/>; * ; * ; call z * ↩→ <lb/>; * ; call z * <lb/>where = ( inst ( ) ) tab ( ) <lb/>; * ; * ; coderef <lb/>z * ; call_indirect ↩→ <lb/>; * ; call z * <lb/>where = ( inst ( ) ) tab ( ) <lb/>call {inst , code function ∀ * . 1 → 2 local sz * } z * ↩→ <lb/>local { ; <lb/>} * [z * / * ] end <lb/>where <lb/>= ( , size( 1 [z * / * ] ) ) ( (), sz[z * / * ] ) <lb/>struct.malloc sz <lb/>↩→ <lb/>malloc size(sz ) (struct ) <lb/>struct.free ↩→ <lb/>free <lb/>(ref <lb/>) struct.get <lb/>↩→ <lb/>; * ; (ref <lb/>) <lb/>where <lb/>( mem ) <lb/>( ) = (struct 1 . . . . . . ) <lb/>; * ; * ; (ref <lb/>) struct.set <lb/>↩→ <lb/>′ ; * ; ref <lb/>where <lb/>( mem ) <lb/>( ) = (struct 1 . . . . . . ) <lb/>′ = with mem <lb/>( ) = (struct 1 . . . -1 . . . ) <lb/>; * ; * ; (ref <lb/>) struct.swap <lb/>↩→ <lb/>′ ; * ; (ref <lb/>) <lb/>where <lb/>( mem ) <lb/>( ) = (struct 1 . . . . . . ) <lb/>′ = with mem <lb/>( ) = (struct 1 . . . -1 . . . ) <lb/>variant.malloc * <lb/>↩→ <lb/>malloc (32 + size( ) ) (variant ) <lb/>ref <lb/>variant.case unr tf ( , ) * ( * ) end ↩→ <lb/>(ref <lb/>) <lb/>block tf ( , ) * ′ ( * ) ( ) end <lb/>where = (variant <lb/>) <lb/>tf = 1 → 2 <lb/> * <lb/>( mem ) <lb/>( ) = (variant ′ ) <lb/>; * ; * ; (ref lin ) <lb/>variant.case lin tf ( , ) * ( * ) end ↩→ <lb/>′ ; * ; (ref lin ) free <lb/>block tf ( , ) * ′ ( * ) ( ) end <lb/>where = (variant <lb/>) <lb/>tf = 1 → 2 <lb/> * <lb/>( mem ) lin ( ) = (variant ′ ) <lb/>′ = with mem lin ( ) = (array 0 ) <lb/>ui32.const array.malloc <lb/>↩→ <lb/>malloc ( × size( ) ) (array <lb/>) <lb/>(ref <lb/>) ( .const ) array.get ↩→ <lb/>(ref <lb/>) <lb/>where ( mem ) <lb/>( ) = (array ( 0 . . . . . . ) ) <lb/>(ref <lb/>) ( .const ) array.get ↩→ <lb/>trap <lb/>where ( mem ) <lb/>( ) = (array * ) <lb/>≥ or &lt; 0 <lb/>; * ; * ; (ref <lb/>) ( .const ) array.set ↩→ <lb/>′ ; * ; ref <lb/>where ( mem ) <lb/>( ) = (array 0 . . . -1 . . . ) <lb/>′ = with mem <lb/>( ) = (array 0 . . . -1 . . . ) <lb/>(ref <lb/>) ( .const ) array.set ↩→ <lb/>trap <lb/>where ( mem ) <lb/>( ) = (array * ) <lb/>≥ or &lt; 0 <lb/>exist.pack <lb/>↩→ <lb/>malloc (64 + size( ) ) (pack <lb/>) <lb/>(ref <lb/>) <lb/>exist.unpack unr tf ( , ) * <lb/> * end ↩→ <lb/>(ref <lb/>) <lb/>block tf ( , ) * ′ * [ / ] end <lb/>where ( mem ) <lb/>( ) = (pack <lb/>′ ) <lb/>tf = 1 → 2 <lb/> * <lb/>; * ; * ; (ref lin ) <lb/>exist.unpack lin tf ( , ) * <lb/> * end ↩→ <lb/>′ ; * ; (ref lin ) free <lb/>block tf ( , ) * ′ * [ / ] end <lb/>where ( mem ) lin ( ) (pack <lb/>′ ) <lb/>′ = with mem lin ( ) = (array 0 ) <lb/>tf = 1 → 2 <lb/> * <lb/>; * ; * ; (ref lin ) free ↩→ <lb/>′ ; * ; <lb/>where <lb/>′ = with ∉ dom(mem lin ) <lb/>; * ; * ; malloc sz hv <lb/>↩→ <lb/>′ ; * ; mempack ℓ (ref ℓ ) <lb/>where ′ = with mem (ℓ ) = hv <lb/>Fig. 4. RichWasm dynamic semantics <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:11 <lb/></page>

        <body>function in the function table and z * are concrete instantiations of the polymorphic binders. The <lb/>instruction call z * is reduced to the administrative instruction call cl z * , where cl is the corre-<lb/>sponding closure in the function table. Indirect function calls are performed with call_indirect, <lb/>whose argument is a code pointer coderef <lb/>z * that points to the th function of the th module <lb/>instance and z * are the concrete instantiations of polymorphic indices. <lb/>The administrative call instruction call cl z * , where cl is a closure containing a module number <lb/>and function body, takes as stack arguments the arguments of the function and reduces to a local <lb/>frame that performs the necessary substitutions of the polymorphic indices. For the sizes of local <lb/>variable slots we use the metafunction size(•) that returns the size of a type. <lb/>Heap Manipulation. Let&apos;s consider the rules for manipulating RichWasm&apos;s new heap structures. <lb/>All heap types have their own allocation instruction that reduces to the malloc instruction, which <lb/>in turn reduces to a reference contained in an existential package that abstracts the location. <lb/>Reduction rules for struct&apos;s get, set and swap operations are straightforward, taking a reference <lb/>from the stack and perhaps the value to put at the th field, performing any necessary memory <lb/>updates, and leaving the reference back on the stack, together with the read value, if any. <lb/>Variants can be used to perform case analysis. The case instruction expects on the stack the <lb/>reference to the variant and a list of values expected by the branches, that have types 1 . If the <lb/>allocated value is the th case of the variant, then we create an instruction block using the th <lb/>element of the list of instruction blocks ( * ) , written ( * ) ( ) . If the case instruction is annotated <lb/>with an unrestricted qualifier, the reference is returned to the stack for reuse. If the annotation is <lb/>linear, then a free instruction is generated to consume the reference. In this case the contents of the <lb/>memory are replaced with an empty array, so that the linearity invariants of the type system are <lb/>preserved. Existential types can be packed and unpacked. Packing an existential type triggers the <lb/>allocation of a pack heap value. Much like variants, the unpacking operation is a block instruction <lb/>which can optionally free the underlying memory. The unpack operation additionally needs to <lb/>substitute the witness pretype in the list of instructions to be evaluated. <lb/>4 RICHWASM TYPE SYSTEM <lb/>We now give a technical account of the type system as well as its safety properties. <lb/>Typing Environments. Typing environments in RichWasm (fig. 5) are similar to Wasm, but they <lb/>also keep track of the new kind variables (types, sizes, locations, qualifiers) and their constraints. <lb/>The local environment is a list of the types and sizes of the local variables of a program configu-<lb/>ration, where the th element corresponds to the size and the type of local variable . <lb/>The function environment stores information about the current evaluation context. It has 7 <lb/>components. As in Wasm, the label component keeps track of the return type of all the available jump <lb/>locations (i.e., nested labels). In RichWasm, it additionally tracks the resulting local environment, as <lb/>all jumps to a location must have the same view of the types of locals. The return component keeps <lb/>track of the return type of the current block of instructions. qual, size, and type are partial maps <lb/>from the variables in scope to the constraints placed on them, as explained in §2. loc keeps track of <lb/>declared location variables. Lastly, the linear environment contains a list of qualifiers representing <lb/>the greatest lower bound of the qualifiers of the values on the stack between two jump locations. <lb/>Jumping from the current evaluation context to an outer label will drop the contents of that label, <lb/>including any potentially linear values. The linear environment can be used to verify that all values <lb/>dropped when performing a jump to a given label are unrestricted. <lb/>To update a component of a typing environment we use similar notation as the WebAssembly <lb/>paper[10]. For instance, we write , linear unr :: linear to update the linear environment of by <lb/>adding the qualifier unr to the top of the list. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:12 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>Local Env <lb/>::= ( , sz) * <lb/>Function Env <lb/>::= { label ( * , ) * , return ( * ) ? , qual ⇀ ( * , * ), size ⇀ (sz * , sz * ), type ⇀ (sz, , ? ), loc ℓ * , linear * } <lb/>Module Env <lb/>::= { func tf * , global tg * , table tf * } <lb/>Store Typing <lb/>::= { inst * , unr ℓ ⇀ , lin ℓ ⇀ } <lb/>Fig. 5. Typing environments. <lb/>The module environment keeps track of the declared functions and globals in the current module. <lb/>Finally, we have the store typing that keeps track of the list of module instances (inst) and the <lb/>typing of the linear and unrestricted memories. The memory typing is a partial map from memory <lb/>locations to the stored heap type ( ). The linear memory typing is split across the typing of the <lb/>subexpressions in the premises of rules to ensure that no linear resource is used twice in the <lb/>program. We write = 1 ⊎ 2 to denote that the linear memory typing of lin is the disjoint union <lb/>of ( 1 ) lin and ( 2 ) lin , whereas the other components are exactly the same in all three store typings. <lb/>When typing a base value or instruction that has no linear memory locations, we require that the <lb/>linear store typing is empty, ie., no linear resource is ever dropped. <lb/>Value Typing. The value typing judgment, written ; ⊢ : , asserts that a value has type <lb/>in a store typing and function environment . Selected value typing rules are shown in Fig. 6. <lb/>Numeric constants have the corresponding numeric type and can have any qualifier. Tuples have a <lb/>tuple type consisting of the types of individual values. The top-level qualifier must be an upper <lb/>bound for each individual qualifier of any type <lb/>inside the list * . Pointers have type ptr ℓ , <lb/>which is independent of the heap type of the location, and do not consume a location from the <lb/>memory typing as they do not represent memory ownership. Typing of capabilities and references <lb/>is parallel in structure. We only explain references. In the unrestricted case, a reference ref ℓ unr has <lb/>type (ref ℓ unr ) , where is the type of ℓ unr in the unrestricted component of the heap. The <lb/>qualifier must be provably unrestricted in the constraints of qual , written ⪯ qual unr. The linear <lb/>component of the memory typing must be empty. The case with a linear location is similar: the <lb/>qualifier on the reference must be provably linear, and the linear component of the memory typing <lb/>must be the singleton map from ℓ to . The value fold has the recursive type (rec ⪯ . ) <lb/>′ , <lb/>if the value has type ( [rec ⪯ . / ]) where we have substituted with rec ⪯ . , and <lb/>the qualifier is upper bounded by ′ . Next we have existential packages mempack ℓ that have <lb/>an existential type (∃ . ) <lb/>′ if the type of value is ( [ℓ/ ]) <lb/>′ and qualifier is upper bounded <lb/>by ′ . Lastly, we have typing for code references coderef z * : if is the th module instance and <lb/>∀ * .tf the type of the th function in the table of , then the code reference has type (tf [z * / * ]) <lb/>where quantifier variables have been substituted with the indices z. <lb/>; ⊢ : <lb/>= <lb/>≤ <lb/>∀ ∈ <lb/>∈ , ; ⊢ : <lb/>∀ <lb/>∈ , <lb/>⪯ qual <lb/>; ⊢ <lb/>: ( ) <lb/>lin = ∅ <lb/>; ⊢ ptr ℓ : ptr ℓ <lb/>lin = ∅ <lb/>unr (ℓ ) = <lb/>⪯ qual unr <lb/>; ⊢ ref ℓ unr : (ref ℓ unr ) <lb/>lin = [ℓ ↦ → ] <lb/>lin ⪯ qual <lb/>; ⊢ ref ℓ lin : (ref ℓ lin ) <lb/>; ⊢ : ( [ℓ/ ] ) <lb/>⪯ qual <lb/>′ <lb/>; ⊢ mempack ℓ : (∃ . ) <lb/>′ <lb/>lin = ∅ <lb/>; ⊢ : ( [rec ⪯ . / ] ) <lb/>⪯ qual <lb/>′ <lb/>; ⊢ fold : (rec ⪯ . ) <lb/>′ <lb/>lin = ∅ <lb/>inst ( ) = <lb/>.table( ) = ∀ * .tf <lb/>; ⊢ coderef <lb/>z * : (tf [z * / * ] ) <lb/>Fig. 6. Value typing. <lb/>Heap Typing. The heap typing judgement is written ; ⊢ hv : and asserts that the heap value <lb/>hv has type in the store typing and function environment . <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:13 <lb/></page>

        <body>Instruction Typing. The core of RichWasm&apos;s type system is typing of instructions. The typing <lb/>judgement, written ; ; ; ⊢ * : 1 <lb/> * → * <lb/>2 | ′ asserts that a list of instructions * has type <lb/>1 <lb/> * → * <lb/>2 . , , and are the store typing, module environment and function environment <lb/>respectively. is the local environment that keeps track of the types and sizes of the local variables, <lb/>and ′ is the typing of the local variables after execution of * , which might change the types of <lb/>local variables. Many rules follow Wasm with the addition that we add the necessary premises <lb/>to ensure linearity (i.e., constraints on qualifiers and linear memory typing). In Fig. 7, we show <lb/>several important rules of the system. <lb/>; ; ; ⊢ * : 1 <lb/> * → * <lb/>2 | ′ <lb/>′ = ( , ) * [ ] <lb/>′ = , label ( 2 , ′ ) :: label , linear unr :: linear <lb/>; ; ′ ; ⊢ * : 1 <lb/> * → 2 <lb/> * | ′ <lb/>; ; ; ⊢ block 1 <lb/> * → 2 <lb/> * ( , ) *  * end : 1 <lb/> * → 2 <lb/> * | ′ <lb/>lin = ∅ <lb/>( ) = ( , sz) <lb/>( ⪯ qual unr ∧ ′ = ) ∨ (¬ ⪯ qual unr ∧ ′ = unit ) <lb/>; ; ; ⊢ get_local <lb/>: → <lb/>| [ ↦ → ( ′ , sz) ] <lb/>lin = ∅ <lb/>( ) = ( , sz) <lb/>⪯ qual unr <lb/>| | | | type ≤ size sz <lb/>; ; ; ⊢ set_local : → | [ ↦ → ( , sz) ] <lb/>lin = ∅ <lb/>; ; ; ⊢ mem.pack ℓ : ( [ℓ/ ] ) → (∃ . ) | <lb/>′ = ( , ) * [ ] <lb/>′ = , label ( 2 <lb/> * , ′ ) :: label , linear unr :: linear , loc :: loc <lb/>; ; ′ ; ⊢ * : 1 <lb/> * <lb/>→ 2 <lb/> * | ′ <lb/>; ; ; ⊢ mem.unpack 1 <lb/> * → 2 <lb/> * ( , ) * . * : 1 <lb/> * (∃ . ) → 2 <lb/> * | ′ <lb/>lin = ∅ <lb/>no_caps type <lb/>∀ ( , sz ) ∈ ( , sz) , | | | | type ≤ size sz <lb/>; ; ; ⊢ struct.malloc <lb/>: <lb/>→ ∃ . (ref rw (struct ( , sz) ) ) | <lb/>lin = ∅ <lb/> * <lb/>( ) = <lb/>⪯ qual unr <lb/>; ; ; ⊢ struct.get : (ref ℓ (struct ( , sz) * ) ) → (ref ℓ (struct ( , sz) * ) ) ; <lb/>| <lb/>lin = ∅ <lb/> * <lb/>( ) = <lb/>⪯ qual unr <lb/>| | ′ | | type ≤ size sz * <lb/>( ) <lb/>no_caps type <lb/>′ <lb/>lin ⪯ qual ∨ ′ = <lb/>; ; ; ⊢ struct.set : (ref ℓ (struct ( , sz) * ) ) ; ′ → (ref ℓ (struct ( [ ↦ → ′ ], sz) * ) ) | <lb/>lin = ∅ <lb/> * <lb/>( ) = <lb/>| | ′ | | type ≤ size sz * <lb/>( ) <lb/>no_caps type <lb/>′ <lb/>lin ⪯ qual ∨ ′ = <lb/>; ; ; ⊢ struct.swap : (ref ℓ (struct ( , sz) * ) ) ; ′ → (ref ℓ (struct ( [ ↦ → ′ ], sz) * ) ) ; <lb/>| <lb/>lin = ∅ <lb/>′ = ( , ) * [ ] <lb/>′ = , label ( 2 <lb/> * , ′ ) :: label , linear unr :: linear <lb/>∀ ≤ , ; ; ′ ; ⊢ ( * ) ( ) : 1 <lb/> * ( ) ( ) → 2 <lb/> * | ′ <lb/>lin ⪯ qual <lb/>lin ⪯ qual <lb/>= (variant ) <lb/>; ; ; ⊢ variant.case <lb/>1 <lb/> * → * <lb/>2 ( , ) * ( * ) end : (ref ℓ ) <lb/>1 <lb/> * → 2 <lb/> * | ′ <lb/>lin = ∅ <lb/>⪯ qual <lb/>′ <lb/>_ℎ linear ⪯ qual <lb/>′ <lb/>′ = ( , ) * [ ] <lb/>′ = , label ( 2 <lb/> * , ′ ) :: label , linear unr :: <lb/>_ℎ ′ <lb/>linear <lb/>∀ ≤ , ; ; ′ ; ⊢ ( * ) ( ) : 1 <lb/> * ( ) ( ) → 2 <lb/> * | ′ <lb/>∀ <lb/>∈ , <lb/>⪯ qual unr <lb/>⪯ qual unr <lb/>= (variant ) <lb/>; ; ; ⊢ variant.case <lb/>1 <lb/> * → * <lb/>2 ( , ) * ( * ) end : (ref ℓ ) <lb/>1 <lb/> * → (ref ℓ ) <lb/>2 <lb/> * | ′ <lb/>; ⊢ hv : <lb/>⊢ qual <lb/>no_caps type <lb/>; ; ; ⊢ malloc sz hv : → (∃ . (ref rw <lb/>) ) | <lb/>lin = ∅ <lb/>lin ⪯ qual <lb/>⊢ (ref rw ℓ ) type <lb/>; ; ; ⊢ free : (ref rw ℓ ) → | <lb/>ℎ = get_hd linear <lb/>ℎ ⪯ qual <lb/>∀ <lb/>∈ * , <lb/>⪯ qual <lb/>′ = , linear <lb/>_ℎ <lb/>linear <lb/>∀ ∈ * , ⊢ type <lb/>; ; ′ ; ⊢ * : 1 <lb/> * → 2 <lb/> * | ′ <lb/>; ; ; ⊢ * : * <lb/>1 <lb/> * → * <lb/>2 <lb/> * | ′ <lb/>Fig. 7. Instruction typing. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:14 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>All block-style instructions follow similar principles, so let&apos;s examine the block instruction <lb/>block tf ( , ) *  * end. The block instruction is annotated with the type of the inner list of <lb/>instructions 1 <lb/> * → * <lb/>2 and the local effects ( , ) * , which describe the effect that this block of <lb/>instructions has on the local environment. The premises of the rule first construct the returned <lb/>local environment ′ , by applying the local effects to the initial local environment, which is written <lb/>( , ) * [ ] and means that the type of the th slot of changes to * <lb/>( ) . Then the premises assert that <lb/>block of instructions has the expected type inside a new function environment that we obtain by <lb/>pushing ( 2 , ′ ) to the label component and unr to the linear component. The former tracks the <lb/>return type and local environment of the label we are creating. The latter gives us a new qualifier <lb/>with which we will track linearity of values on the stack inside this new block and &quot;locks in&quot; the <lb/>qualifier corresponding to the linearity of the values on the stack between the previous enclosing <lb/>block and this new block. We choose unr because upon entering a block there are no linear values <lb/>which might be jumped over. The head element of the linear environment can be increased by <lb/>the frame rule, which as in Wasm, allows typing rules to ignore values lower on the stack. Since <lb/>break instructions will not see ignored values, the only way they can know whether they will be <lb/>dropping linear values is by consulting this environment. <lb/>Let&apos;s look at some instructions for manipulating locals. The get_local <lb/>instruction fetches <lb/>the value of the th local slot. If the qualifier of the slot, , is linear, then the contents of the slot <lb/>must be updated to ensure linearity. We replace it with the unit value and update the typing of <lb/>the slot accordingly. The set_local instruction updates the th local slot, allowing to update its <lb/>type as well. It ensures that the previous value was unrestricted, so it can freely be dropped, and <lb/>that the upper bound of the size of the new type || || type , fits into the size of the slot, written <lb/>|| || type ≤ size sz. The size function takes the type environment component as parameter to lookup <lb/>the upper bound for the size of type variables. The ≤ size operation takes as parameter the size <lb/>component to take into account the size constraints that are in scope. <lb/>Creating an existential package is done with mem.pack ℓ. It receives a value from the stack <lb/>containing a location ℓ and creates an existential package that hides this location. The typing rule <lb/>for mem.unpack tf ( , ) * . * is more complicated. It combines the typing of instructions that <lb/>introduce a new block with unpacking an existential location. The instruction receives from the <lb/>stack the arguments of the instruction block 1 <lb/> * and a packed value with an existential location type. <lb/>Then it puts the location variable in the loc environment component to type the instructions in <lb/>the block. The handling of the label and linear components is the same as in the block instruction. <lb/>Next we discuss instructions for manipulation heap values. Each family of heap values has its <lb/>own malloc instruction. For example, the struct.malloc <lb/>instruction allocates space for a <lb/>struct of values with sizes <lb/>. It receives from the stack values of types and it returns a <lb/>reference whose location is abstracted with an existential type and has the corresponding struct <lb/>type. We require that the size of the types fit into the requested sizes of the slots. We also put the <lb/>restriction that there are no capabilities in the types, for the reasons described in §3. Structs have <lb/>get, set, and swap operations shown in the following rules. struct.get gets the th element of a <lb/>struct, that must be an unrestricted value, and struct.set sets the th element with the a value it <lb/>finds on the stack. The qualifier of the previous value that is dropped must be unrestricted. If the <lb/>reference on the stack is linear then the type of the new value can be arbitrary, otherwise it must <lb/>be the same as the type of the previous value, as only linear structs support strong updates. There <lb/>is also a check that the new value fits in the size of the slot. The only way to read and write a linear <lb/>entry from a struct is with a struct.swap operation that combines set and get by simultaneously <lb/>getting and setting a struct cell and therefore ensuring that neither value is dropped or duplicated. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:15 <lb/></page>

        <body>The instruction variant.case (variant ) 1 <lb/> * → * <lb/>2 ( , ) * ( * ) end performs case analysis <lb/>on a variant with type (variant ) and, depending on the result, executes one block of instructions <lb/>from the branch list ( * ) . The rule expects 1 <lb/> * on the stack and returns 2 <lb/> * . If the qualifier of the <lb/>instruction is linear, then the underlying memory will be freed after the case analysis and the given <lb/>(linear) reference will not be returned. Each of the instruction blocks ( * ) are typed in the updated <lb/>(in the usual way) function context and are required to have type 1 <lb/> * <lb/>→ 2 <lb/> * , where is the type <lb/>of the th variant. The unrestricted case is similar, with the distinction that the reference is returned <lb/>onto the stack after the case analysis and the underlying memory is left intact. In addition, the <lb/>second element of the linear component (corresponding to the values outside this case block, but <lb/>inside the nearest surrounding block) is switched to an arbitrary ′ that is stricter than both the <lb/>qualifier of the variant reference and the previous qualifier of linear . This ensures that any jumps <lb/>beyond this case block will need to consider whether the reference we&apos;re leaving on the stack is <lb/>linear, as such a jump would drop it. <lb/>Configuration and Store Typing. At the top level we have the typing judgements for stores and <lb/>program configurations, show in Fig. 8. The spirit is the same as in Wasm, but we have to split <lb/>the linear store typing across the typing of different components of the configuration. First we <lb/>introduce an auxiliary judgement ; ( * ) ? ⊢ ; sz ; * : * that asserts that in the store typing <lb/>the configuration ; ; sz ; * will result in a stack of type (or potentially return) * . The premises <lb/>require that the local values are well-typed with some types and that the size of each (closed) <lb/>value fits in the size of the corresponding slot. The instructions have type → * under the empty <lb/>function context containing only an optional return type and under the local context ( , ) . The <lb/>store typing is the disjoint union of the store typing used across all typing judgements of the <lb/>premises. Furthermore, we require that in the final local environment there are no linear values, as <lb/>all of them must be consumed. <lb/>The store typing judgement ⊢ : heap ; prog asserts that the store has typing heap ; prog . The <lb/>two store typings heap and prog have identical instances and unrestricted memory typings, but <lb/>disjoint linear typings. The linear typing of prog contains the surface locations found syntactically <lb/>in a configration, i.e., the root pointers, while the linear typing of heap contains the linear locations <lb/>needed to type the contents of the memory. The rule asserts that the domain of the linear memory <lb/>coincides with the locations contained in the linear typing of heap and prog , and the same for the <lb/>unrestricted memory. It also asserts that every pair of location and heap value in the unrestricted <lb/>store has the corresponding type prescribed by the unrestricted memory typing. For the reasons <lb/>described previously, it also requires that no capabilities are present on the heap. Additionally, heap <lb/>must be the disjoint union of all the individual store typing components used in typing the heap <lb/>components. Lastly, the rule asserts that the length of the module instances | inst | must coincide <lb/>with the length of the instance typings | inst | and that each instance in the list has the corresponding <lb/>instance typing. We elide the instance typing judgement as it is similar to that of Wasm. <lb/>The top level judgement ⊢ ; ; sz ; * : * asserts that the store is well typed in some store <lb/>typings heap and prog , and that the configuration is well typed in the store typing prog . <lb/>4.1 Type Safety <lb/>We prove, in Coq, that our language is type safe by proving soundness via progress and preservation. <lb/>Progress. If a configuration is well-typed ⊢ ; , sz * ; * : * , then either * are all values, or it is a <lb/>single trap instruction, or the configuration can take a non-GC step ; * ; sz * ; * ↩→ ′ ; ′ * ; ′ * . <lb/>Preservation. If a well-formed and well-typed configuration, ⊢ ; , sz * ; * : * , takes any step <lb/>; * ; sz * ; * ↩→ ′ ; ′ * ; ′ * then the resulting configuration is well-typed with the same type <lb/>⊢ ′ ; ′ , sz * ; ′ * : * <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:16 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>; ( * ) ? ⊢ <lb/>; sz ; * : * <lb/>= <lb/>⊎ 1 ⊎ . . . ⊎ <lb/>∀ ∈ <lb/>sz ∈ sz , ; <lb/>⊢ : <lb/>∧ ∥ ∥ ≤ sz <lb/>= <lb/>, return( * ) ? <lb/>; inst ( ); ; ( , sz) ⊢ * : → * | ′ <lb/>∀ ( , sz) ∈ ′ , ⪯ qual unr <lb/>; ( * ) ? ⊢ <lb/>; sz ; * : * <lb/>⊢ : heap ; prog <lb/>= ℎ <lb/>⊎ <lb/>dom lin = dom lin <lb/>dom unr = dom unr <lb/>unr = { ( unr 1 , hv unr 1 ), . . . , ( unr , hv unr ) } <lb/>lin = { ( lin 1 , hv lin 1 ), . . . , ( lin , hv lin ) } <lb/>∀ ≤ | unr |, unr ; <lb/>⊢ hv unr : unr ( unr ) <lb/>∀ ≤ | lin |, lin ; <lb/>⊢ hv lin : lin ( lin ) ∧ lin ∈ codom unr ⇒ no_caps (hv lin ) <lb/>ℎ <lb/>= <lb/>≤ <lb/>unr ⊎ <lb/>≤ <lb/>lin <lb/>| inst | = | inst | <lb/>∀ ≤ | inst |, inst ⊢ inst ( ) : inst ( ) <lb/>⊢ : heap ; prog <lb/>⊢ ; , sz * ; * : * <lb/>⊢ : ℎ ; <lb/>; ⊢ <lb/>; sz ; * : * <lb/>⊢ ; ; sz ; * : * <lb/>Fig. 8. Configuration typing. <lb/>Coq Development. We have formalized the language, its static and dynamic semantics, and the <lb/>proof of type safety via progress and preservation in Coq. The effort is substantial, consisting <lb/>of 17k lines of specifications (definitions and theorem statements) and 58k lines of proofs, all <lb/>directly related to the type system. The proof development is available as an artifact. It contains one <lb/>remaining admitted lemma related to substitution (among many others that we have fully proved). <lb/>4.2 RichWasm Example <lb/>We conclude this section with an example of how RichWasm&apos;s fine-grained memory sharing might <lb/>be useful for real programs. Imagine a library for some performance-critical operation implemented <lb/>in a manually managed language, such as a graphics library. Instances of this graphics data structure <lb/>might take some mutable configuration state that can change over the course of a program, such <lb/>as quality settings or dimensions. Next, suppose we want to write the higher-level logic of our <lb/>program in a GC&apos;d language that uses this graphics library. That would require the GC&apos;d code to <lb/>reference linear values, which in turn reference some shared mutable state. <lb/>For our example, we&apos;ll keep this structure, but simplify our library down to a small mutable <lb/>counter. The shared runtime state will configure how much to increment counters by. The GC&apos;d <lb/>portion of our program will use this linear library, but hide it behind an interface which allows it <lb/>to use the library without reasoning about linearity. <lb/>Client := (∃ unr ⪯ ≲ 64. ( unr (coderef ∀ . unr → i32 unr ) unr ) unr ) <lb/>:= (∃ℓ. (ref ℓ rw (struct <lb/>, 64) ) unr ) unr <lb/>Counter := (∃ℓ. (ref ℓ rw (struct ( <lb/>, 64) ( <lb/>, 64) ) ) lin ) lin <lb/>State := (∃ℓ. (ref ℓ rw (struct i32 unr , 32) ) lin ) lin <lb/>Config := (∃ℓ. (ref ℓ r (struct i32 unr , 32) ) unr ) unr <lb/>Fig. 9. Memory layout. (ref = solid blue line) (coderef = dashed pink line) and type definitions. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:17 <lb/></page>

        <body>Fig. 9 presents a memory layout for such an example. Client is the type of the value that our <lb/>GC-ed portion will be interacting with. It contains a pair of an abstract value and a coderef <lb/>which, given that value, increments the counter and returns the new count. The witness for <lb/>the hidden type contains a struct referencing Counter, the main data structure provided by <lb/>our linear library. Counter points at a struct that contains a pair of references, one granting <lb/>write access (rw) to its internal mutable state (State), and one granting read access (r) to the <lb/>shared configuration (Config). With this heap in place, the GC&apos;d portion of the program can <lb/>configure and use the counter without reasoning about linearity. <lb/>function ∀ . → i32 unr local 32 <lb/>get_local 0 unr <lb/>mem.unpack → (1, i32 unr ) ℓ. <lb/>| (i32.const 0) (struct.malloc 32 unr) <lb/>| mem.unpack → Config ℓ. <lb/>| <lb/>(ref.demote) (mem.pack ℓ ) <lb/>| call 0 <lb/>#creates a new Counter <lb/>| struct.swap 0 <lb/>| mem.unpack → Counter (1, i32 unr ) ℓ. <lb/>| | struct.get 1 <lb/>| | mem.unpack → (1, i32 unr ) ℓ. <lb/>| | | (struct.get 0) (set_local 1) <lb/>| | | drop <lb/>| | () (struct.swap 0) <lb/>| | mem.unpack → State ℓ. <lb/>| | | (struct.get 0) (get_local 1 unr) <lb/>| | | (i32.add) (tee_local 1) <lb/>| | | (struct.set 0) (mem.pack ℓ ) <lb/>| | (struct.swap 0) (drop) (mem.pack ℓ ) <lb/>| struct.swap 0 <lb/>| mem.unpack → <lb/>ℓ. <lb/>| | () (struct.swap 0) <lb/>| | mem.unpack → <lb/>ℓ. struct.free <lb/>| | struct.free <lb/>| drop <lb/>get_local 1 unr <lb/>Fig. 10. The incr function <lb/>Fig. 10 presents the RichWasm code for the incr function, which is referenced by the coderef <lb/>in the Client value and increments the contents of State by the current contents of Config. This <lb/>function relies on another function of type ∀ . Config → Counter, which creates a fresh Counter. <lb/>To use the linear data in a Client, incr swaps a new Counter for the existing one. Because the <lb/>GC expects to be pointing at a Counter and linear data cannot be owned by both the stack and <lb/>the heap, we give the GC a replacement reference temporarily. We could avoid recreating the <lb/>linear component of the data structure by using a variant type, but we&apos;ve elected to do something <lb/>inefficient to keep the example manageably small. <lb/>After getting a Counter on the stack, we get the current value of Config and store it in local <lb/>1 (see the innermost mem.unpack in the left column). Next, we use a strong update to swap a <lb/>unit value for the State, read the current contents, add the number we stored in local 1, and store <lb/>the result in both local 1 and in the State reference (see the innermost mem.unpack in the right <lb/>column). The remainder of the function stores the State back in the Counter, swaps the Counter <lb/>back into its original position, frees the temporary Counter, and returns the int in local 1. <lb/>Note that despite working with both manually managed and GC&apos;d memory, it&apos;s not immediately <lb/>apparent from the code where the boundary is because of RichWasm&apos;s ability to abstract over <lb/>management strategies. The full code for this example is available in our artifact. <lb/>5 COMPILING ML AND 3 TO RICHWASM <lb/>To demonstrate that RichWasm suffices as a target for very different high-level languages, we <lb/>implement type-preserving compilers from a garbage-collected language (ML) and a manually <lb/>managed language ( 3 ). To exhibit RichWasm&apos;s ability to serve as a platform for interop between <lb/>languages, we extend ML and 3 with the necessary FFI constructs, discussed in §2.2, to reference <lb/>each other&apos;s types in a limited fashion. These extensions follow a linking-types [19, 20] approach, <lb/>which aims to allow users of a source language to link with types inexpressible in their own <lb/>language, without losing native reasoning principles. Programs that do not mention any linking-<lb/>types extensions are unaffected by the extensions&apos; presence in the language. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:18 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>ML. Our ML implementation supports the standard types: unit, integers, references, variants, <lb/>products, recursive types, and functions with parametric polymorphism. Since RichWasm has <lb/>similar types, the choice of representation is straightforward. We also extend ML with standard <lb/>constructs for writing multi-module code, such as function imports and exports and the ability to <lb/>define global state that exported functions can close over. Such extensions provide a good basis for <lb/>exploring multi-module code in RichWasm and eventually interoperability with other languages. <lb/>As discussed in §2.2, we extend ML with the ability to direct the compiler to compile particular <lb/>types as linear and provide a construct ref_to_lin that allows the creation of references containing <lb/>linear types. The ML type checker explicitly does not check whether types annotated as linear <lb/>are used linearly, as we can rely on link-time type checking in RichWasm to ensure safety. The <lb/>goal of interoperability is to allow programmers to use the right language for each task, without <lb/>burdening them by turning the type system of their source into something as complex as RichWasm. <lb/>Programmers are still writing ML, only using these linking types at the boundary between languages. <lb/>In our current implementation, the programmer will see RichWasm errors when violating invariants <lb/>not checked by their source language, but we think it would be fairly straightforward to tag <lb/>RichWasm code with some generic source information to improve error messages. Rather than <lb/>providing an opaque message about qualifiers, we might inform a user that there was a linearity <lb/>issue with a particular source variable. <lb/>3 . We compile the core 3 language [14, 2] with a minor adjustment. We require that 3 <lb/>capabilities explicitly track the size of the memory they reference. This reflects the fact that here <lb/>3 is a type-safe but C-like low-level source language with precise control over use of memory. <lb/>While 3 &apos;s ability to perform strong updates is powerful, it must be accompanied by reasoning <lb/>about the size of the location being updated to be useful. As discussed in §2.2, we extend 3 with <lb/>an ML-like reference Ref type in order to allow memory interop between the two languages, as <lb/>well as constructs (join and split) to convert between capability-pointer pairs and references. <lb/>Readers familiar with 3 might note that its source programs often put capabilities on the heap, <lb/>an operation which is disallowed in the version of RichWasm presented in this paper. We plan to <lb/>relax this restriction in RichWasm such that capabilities are only disallowed in the parts of the <lb/>heap owned by the garbage collector. This requires updating our Coq formalism, but our prototype <lb/>compilers and RichWasm typechecker already support this more relaxed restriction. <lb/>Compilation. Compilation to untyped or less strongly typed targets requires compiler writers <lb/>to expend significant effort on low-level details like data layout, calling conventions, and bit <lb/>manipulation. In contrast, compilation to RichWasm is largely an exercise in satisfying RichWasm&apos;s <lb/>type system. While this is not entirely straightforward, we have found it to be tractable. <lb/>The ML compiler has three phases of note: typed closure conversion, annotation, and code <lb/>generation. Typed closure conversion is standard in compilers for functional languages. What is <lb/>notable is that (after the remaining passes) RichWasm is going to check the soundness of these <lb/>passes, examining the size and qualifier annotations that we use when generating existential <lb/>packages to hide the environments of closures. Since all type variables in RichWasm have size <lb/>and qualifier bounds and ML has no such notion at the source, we introduce an annotation phase <lb/>to change the types of functions appropriately, annotating definitions and call sites with the <lb/>appropriate information. Code generation is overall quite similar to code generation to any stack-<lb/>based language. However, there are some type-based complications. For instance, instead of relying <lb/>on a compiler writer&apos;s carefulness when shuffling values around, RichWasm requires explanation <lb/>of one&apos;s use of locals in the form of a local effect annotation on every block of code, allowing it to <lb/>check that duplication only occurs when allowed. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:19 <lb/></page>

        <body>3 is a much lower level language, without the ability to existentially or universally quantify <lb/>types. Thus, it is much easier to compile to RichWasm, and we can do so in one code generation <lb/>phase which primarily determines what locals are needed and generates the appropriate type <lb/>annotations. To keep things simple and since we&apos;ve already demonstrated how to do so in ML, we <lb/>don&apos;t implement closure conversion in 3 . <lb/>5.1 Source-Language Interoperability Examples <lb/>fun swap_pair : ( p : ( Int * Int )) = <lb/>let ( i1 , i2 ) = p in ( i2 , i1 ) <lb/>in <lb/>import l3 . create_cell : ( Int → &lt;Ref Int&gt;); <lb/>• • • <lb/>(a) ML <lb/>import ( ml . swap_pair <lb/>: !(! &lt;! Int * ! Int &gt; ⊸ !&lt;! Int * ! Int &gt;)); <lb/>fun create_cell ( n : ! Int ) = join ( new n 1 ) in <lb/>let &lt;a , b &gt; = swap_pair ! &lt;!1 , !2 &gt; in <lb/>• • • <lb/>(b) 3 <lb/>Fig. 11. An a empt at interop: without and with linking types <lb/>We now present examples to illustrate source-level interoperability between ML and 3 atop <lb/>RichWasm. First, to see what goes wrong if programs try to interoperate without the use of linking <lb/>types, consider Fig. 11, but to start the reader should ignore any text in red. Both swap_pair, a <lb/>function that swaps the positions of two integers in a pair, and create_cell, a function that puts <lb/>a given integer into a fresh manually managed location on the heap, seem to superficially match <lb/>the type at which they&apos;re imported. But the 3 program mistakenly claims that swap_pair is a <lb/>function on linear pairs (if we ignore the code in red), and the ML program mistakenly claims <lb/>create_cell returns a normal ML reference. As a result, neither function import will succeed in <lb/>RichWasm. A programmer at a language boundary must be aware of these differences and insert <lb/>the correct annotations (shown in red in Fig. 11). This is where linking types come in. The angle <lb/>bracket syntax in ML allows the programmer to mark any type (in this case a reference) as linear. <lb/>For 3 , the programmer can insert !s where necessary to mark types as unrestricted and use the <lb/>new join construct to join capability-pointer pairs into a reference. The versions modified with <lb/>the red annotations are then accepted by RichWasm. <lb/>type ravg = <lb/>&lt; Ref &lt; Int * Int * Ref Int &gt; &gt;; <lb/>fun get_multiplier ( r : Ref Int ) = <lb/>! r <lb/>in <lb/>import l3 . create_ravg : ( Ref Int → t ); <lb/>import l3 . free_ravg : ( ravg → Unit ); <lb/>import l3 . add_sample : <lb/>( ravg Int → ravg ); <lb/>import l3 . average : <lb/>( ravg → &lt; ravg * Int &gt;); <lb/>let multiplier = new 2 in <lb/>let r = create_ravg multiplier in <lb/>let r = add_sample r 4 in <lb/>multiplier := 6; <lb/>let r = add_sample r 8 in <lb/>multiplier := 10; <lb/>let r = add_sample r 16 in <lb/>let r , average = average r in <lb/>free_ravg r ; <lb/>average (* returns 12 *) <lb/>(a) ML <lb/>type ravg = ∃ ℓ . <lb/>Ref ℓ &lt;! Int * ! Int * !∃ ℓ . ! Ref ℓ ! Int 1 &gt; 4; <lb/>type m = !∃ ℓ . ! Ref ℓ ! Int 1; <lb/>import ml . get_multiplier : !( m ⊸ ! Int ); <lb/>fun create_ravg ( m : m ) = join ( new &lt;!0 , !0 , m &gt; 4) in <lb/>fun free_ravg ( r : ravg ) = free ( split r ); !* in <lb/>fun add_sample ( r : ravg ) ( sample : ! Int ) = <lb/>let {ℓ , &lt;cap , ptr &gt;} = split r in <lb/>let &lt;cap , vals &gt; = swap ptr &lt;cap , !* &gt; in <lb/>let &lt;sum , count , m_ref &gt; = vals in <lb/>let &lt;m &gt; = &lt; get_multiplier m_ref &gt; in <lb/>let &lt;cap , * &gt; = swap ptr &lt;cap , <lb/>&lt; sum + ( sample * m ) , ( count + m ) , m_ref &gt; &gt; <lb/>in join {ℓ , &lt;cap , ptr &gt;} <lb/>in <lb/>fun average ( r : ravg ) = <lb/>let {ℓ , &lt;cap , ptr &gt;} = split r in <lb/>let &lt;cap , vals &gt; = swap ptr &lt;cap , !* &gt; in <lb/>let &lt;sum , count , m_ref &gt; = vals in <lb/>let &lt;cap , * &gt; = swap ptr &lt;cap , vals &gt; in <lb/>&lt; join {ℓ , &lt;cap , ptr &gt;} , sum / count &gt; <lb/>in * <lb/>(b) 3 <lb/>Fig. 12. Computation of rolling averages <lb/>Next, let&apos;s examine a more substantial example of ML and 3 interop. Fig. 12 presents two <lb/>programs: an 3 program that provides an interface for computing rolling averages and an ML <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:20 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>program that uses that interface to compute a result. The type ravg (presented in each of the <lb/>languages&apos; syntax) is the type of the main data structure, which both languages compile down to <lb/>the same RichWasm type. It is a reference to a manually managed location containing a total sum, <lb/>number of samples, and a shared mutable reference representing how much we should believe <lb/>any new samples. Should the confidence level in new data change, the ML program can freely <lb/>update its confidence level directly, and all future data points will be adjusted accordingly. If the <lb/>ML program were to attempt to use r after the call to free_ravg, that would be caught statically <lb/>by the RichWasm typechecker because it would duplicate a linear value. <lb/>Static vs Dynamic Interop Errors. Note that all of the examples we&apos;ve shown so far have caught all <lb/>interop errors at compile time. We have, however, also included a construct, namely ref_to_lin, in <lb/>our ML and 3 FFI that would allow some errors to be caught at runtime. Imagine taking a version <lb/>of the example in Fig. 3 that type checks as discussed at the end of §2.2, and modifying it so that <lb/>the function get_stashed reads from c twice in an attempt to duplicate the linear value inside. <lb/>Recall from §2.2 that references created with ref_to_lin, such as c, are compiled as a variant of <lb/>either a unit value or the linear value we wish to store. In the case where we try to read from an <lb/>empty reference or write to a reference already containing a value, the ML compiler generates an <lb/>unreachable instruction. In RichWasm and Wasm, unreachable typechecks to any valid type, <lb/>but aborts the program if it is executed, allowing us to defer the error to runtime. Our program in <lb/>Fig. 12 could easily be written in the ref_to_lin style, stashing and retrieving the data structure <lb/>at every use site, but that seems like a poor choice as it would give us fewer static guarantees. <lb/>Note that in this paper it was our choice as FFI designers to provide a ref_to_lin construct in ML. <lb/>If we had chosen to omit it, there would be no way to write programs where ML and 3 interop <lb/>errors are caught at runtime. The design of more ergonomic source-level FFIs that do not make <lb/>use of runtime errors deserves thorough investigation as part of future work, but we believe that <lb/>RichWasm&apos;s ability to support more and less principled FFIs (more static error detection vs. more <lb/>runtime error detection) while guaranteeing safety is a valuable property. <lb/>6 COMPILING RICHWASM TO WASM <lb/>Compilation from RichWasm to WebAssembly is type directed. It requires some type information <lb/>that is implicit in RichWasm instructions which is provided by the type checker. The RichWasm <lb/>to Wasm compiler takes in the type annotated RichWasm code produced by the RichWasm type <lb/>checker and compiles to WebAssembly 1.0 with the multi-value extension, where functions and <lb/>instructions can return more than one value. <lb/>Lowering RichWasm&apos;s Type System. Every RichWasm type will be translated to a series of base <lb/>Wasm numeric types. Types with no runtime information, such as unit, cap and own , are erased. <lb/>Numeric types are translated to the corresponding WebAssembly type. ref and ptr are lowered <lb/>to a single i32 pointer. If the size of a pretype is (transitively) bounded above by a constant, we <lb/>compile that variable into a series of numeric types. If that size is unbounded, the is boxed on the <lb/>heap and it is translated to an i32 pointer. To translate recursive types, we just compile the inner <lb/>type, since RichWasm gives us an invariant that the recursive type appears only inside a level of <lb/>indirection. For existential pretypes on locations, we similarly just lower the inner type. <lb/>Operations on Local and Global Variables. Local variables in RichWasm can have arbitrary sizes <lb/>and can have multiple types over their lifetime. In Wasm, however, local variables can only be <lb/>one of four numeric types. Therefore, we lower a RichWasm local to a series of Wasm locals. For <lb/>example, if a RichWasm local has size 160 it will be stored across three Wasm locals of types i64, <lb/>i64 and i32. This sequence of locals might be used to store any type of size up to 160, for example <lb/>(i32 i64 i64). Therefore, the first local will store the first i32 component of the tuple and the first <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:21 <lb/></page>

        <body>half of the second i64 component. The compilation of local.set and local.get needs to perform <lb/>the correct accesses to fetch the entire value onto the stack, and is informed by the RichWasm type. <lb/>Operations on global variables in RichWasm are similar to locals. <lb/>Memory Model and Heap Types. In Wasm we use only one flat memory to represent both Rich-<lb/>Wasm&apos;s memories. We use a simple free list allocator to allocate and free pointers in Wasm memory. <lb/>Structs and arrays are encoded in the Wasm memory as a consecutive bytes. Similar to local <lb/>variables, the representation of a field or an array slot might need to use more than one consecutive <lb/>memory slot. Variants are represented in memory as a sequence of bytes containing the numeric <lb/>tag followed by the corresponding type. variant.case instructions are compiled as a switch case for <lb/>every case in the variant. Switch cases are represented in Wasm using nested blocks, with blocks <lb/>for every case, and a br_table instruction in the innermost block that jumps to the case being <lb/>executed. At the start of every case, we provide instructions to read data from the heap according to <lb/>the type of that case. exists.pack stores a single RichWasm value on the heap, and exists.unpack <lb/>reads it, with the help of an annotation of the type. <lb/>Function Calls. Functions in RichWasm can be polymorphic on types with unknown size bounds <lb/>that are represented in Wasm as i32 pointers. Say that a caller needs to pass an argument of <lb/>type (i64 i32) to a function that expects a boxed representation of the same argument as it is <lb/>polymorphic on its type. The caller will put an i64 and i32 on the stack. Then, we need to perform <lb/>a stack coercion, replacing the i64 and i32 with a pointer to the same data on the heap. Stack <lb/>coersions like this will always be required when functions expect or return values of boxed types. <lb/>For indirect calls, coderef instructions compile to an i32 index into the function table. To coerce <lb/>the stack to the shape that the callee expects, we make a case for each possible shape in the table <lb/>that could correspond to this call, and at runtime we jump to the correct case depending on the <lb/>value of the index to the table. <lb/>Remaining Instructions. Instructions that have identical counterparts in Wasm are left unaltered. <lb/>rec.fold , rec.unfold, mem.pack ℓ, seq.group , seq.ungroup, cap.split, cap.join, ref.demote, <lb/>ref.split, ref.join, qualify , inst are all erased since they are type level operations. <lb/>7 RELATED WORK <lb/>In §1, we&apos;ve already discussed the three most closely related piece of work: 3 , the Component <lb/>Model, and Patterson et al.&apos;s semantic framework for sound interoperability. In a general sense, <lb/>RichWasm is also influenced by work on substructural types, using unr and lin qualifiers to <lb/>annotate pretypes as in [1], and by work on type-preserving compilation and typed low-level <lb/>languages [13, 15, 16, 11]. <lb/>Wasm does not currently support garbage collection natively, but a proposal to do so is currently <lb/>working its way through the standardization process [6]. RichWasm&apos;s heap types are intentionally <lb/>designed to be compatible with this proposal, but we believe it lacks one crucial feature: finalizers. <lb/>Many languages use finalizers, and for RichWasm they are essential to allowing the garbage collector <lb/>to own, and thus sometimes free, linear memory. At present, with Wasm&apos;s current GC proposal, <lb/>RichWasm&apos;s runtime needs to implement its own garbage collector. <lb/>MSWasm [12] (Memory-Safe Wasm) is an extension of Wasm designed to enforce memory-safe <lb/>execution of unsafe code, e.g., code compiled from C or C++. MSWasm extends Wasm with language <lb/>constructs for CHERI-like [27] fine-grained dynamically checked memory capabilities so code <lb/>compiled from C will be checked for memory safety at runtime. In contrast, RichWasm has static <lb/>rather than dynamic capabilities, which have the benefit of zero runtime overhead. But RichWasm <lb/>is meant to be a target for type-safe source languages; when compiling an unsafe language like C, <lb/>one would have to do significant static analysis to produce type-annotated RichWasm code that is <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:22 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <body>well typed since the type information and safety guarantees don&apos;t exist in the source. Even then, <lb/>this analysis could only work on the subset of C programs which are memory safe. <lb/>Iris-Wasm [23] is a mechanized higher-order separation logic for modularly verifying Wasm 1.0 <lb/>programs. Iris-Wasm has been used to build a logical relation for Wasm and prove type safety. By <lb/>contrast, we have a mechanized type safety proof for a language with a far richer type system, but <lb/>RichWasm is a typed language not a verification logic. <lb/>8 DISCUSSION AND FUTURE WORK <lb/>As discussed in §1, this paper describes the RichWasm MVP, which we plan to extend in future <lb/>work so it can serve as a platform for safe interoperability between a wide range of typed languages. <lb/>Our first priority in future work is type-preserving compilation from safe Rust to RichWasm. There <lb/>are two interesting challenges: how to encode lifetime constraints and how to encode immutable <lb/>borrows in RichWasm. The latter may require fractional capabilities so we can create many borrows, <lb/>such that when all of these borrows end, we can collect together the fractions and produce a linear <lb/>capability to return to the owner. A further challenge is to compile Rust with concurrency to a <lb/>concurrent extension of RichWasm, in turn compiling that to the recent Wasm threads proposal [9]. <lb/>Next, we will tackle compiling languages with advanced control effects, e.g., algebraic effect <lb/>handlers. This will require extending RichWasm with linearly typed continuations and compiling <lb/>RichWasm to Wasm with the recent typed-continuations proposal [3, 22]. The latter dynamically <lb/>ensures that continuations are used linearly instead of providing static assurance using linear types. <lb/>The latter are expensive to implement as they preclude in-place updates. In RichWasm, we can <lb/>statically ensure linear usage of continuations and then have the compiler to Wasm perform the <lb/>optimization to use in-place updates. We plan to verify correctness of such optimizations using a <lb/>logical relation. <lb/>Wasm provides custom sections and the ability to implement additional type checking by <lb/>examining annotations in custom sections. We can leverage this to keep RichWasm type information <lb/>around in Wasm, enabling a rich form of proof-carrying code [18, 17]. <lb/>Another broad area of future work is designing safe FFIs between practical typed languages <lb/>that compile to RichWasm. We plan to start with OCaml and Rust and investigate what form of <lb/>&quot;linking types&quot; or other interoperability mechanisms make sense, but numerous other language <lb/>pairs would be good candidates for researchers to study. Evaluation of such FFI designs ought <lb/>to involved user studies to to assess ease of interoperability, as well as measure the annotation <lb/>and comprehension burden on programmers. There is also a need to assess the ease of building <lb/>type-preserving compilers for these core-languages-plus-FFIs. <lb/>We would like to support safe interop between type-safe languages compiled to RichWasm <lb/>and unsafe languages such as C and C++ compiled to Wasm. The simplest solution for safe <lb/>interoperabiltiy is to use Component Model [5] interface types at the boundary between RichWasm <lb/>(compiled to Wasm) and Wasm modules, ensuring that safe and unsafe code never mix. If we <lb/>instead want to support memory sharing between RichWasm and Wasm, the interop between more <lb/>precisely and less precisely typed modules is reminicent of gradual typing [24, 26, 25], but more <lb/>general since the term languages have differences. This essentially requires tackling gradual typing <lb/>between a language with linear capability types and one without. We plan to design a RichWasm-<lb/>Wasm multilanguage, which would have to identify the static guarantees or dynamic checks we <lb/>need at boundaries; then we will investigate a combination of type inference and static contract <lb/>verification to eliminate these static and dynamic checks. Interop of RichWasm with MSWasm [12] <lb/>would be an easier way of achieving the goal since MSWasm already supports dynamic capability <lb/>checking, but to be performant, MSWasm needs specialized hardware such as CHERI [27]. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <note place="headnote">RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly <lb/></note>

        <page>214:23 <lb/></page>

        <div type="availability">9 DATA-AVAILABILITY STATEMENT <lb/>All software artifacts are available on Zenodo [4]. The artifact contains, a mechanized proof of <lb/>RichWasm&apos;s type safety, compilers from ML and L3 to RIchWasm, an annotator and type checker <lb/>for RichWasm code and a compiler from RichWasm to WebAssembly. The artifact is also avaiable <lb/>on GitHub at https://github.com/RichWasm/RichWasm-artifact. <lb/></div>

        <div type="acknowledgement">ACKNOWLEDGMENTS <lb/>This material is based upon work supported by the National Science Foundation (NSF awards CCF-<lb/>1816837 and grant 2030859 to the Computing Research Association for the CIFellows Project) and <lb/>the Defense Advanced Research Projects Agency (DARPA) under Contract No. N66001-21-C-4023. <lb/>Any opinions, findings and conclusions or recommendations expressed in this material are those of <lb/>the author(s) and do not necessarily reflect the views of the funding agencies. <lb/>We would like to thank John Li for his help with our initial formalization of substitution in Coq. <lb/></div>

        <listBibl>REFERENCES <lb/>[1] Amal Ahmed, Matthew Fluet, and Greg Morrisett. &quot;A Step-Indexed Model of Substructural State&quot;. In: <lb/>International Conference on Functional Programming (ICFP). Sept. 2005, pp. 78-91. https://doi.org/10. <lb/>1145/1086365.1086376. <lb/>[2] Amal Ahmed, Matthew Fluet, and Greg Morrisett. &quot;L3 : A Linear Language with Locations&quot;. In: Funda-<lb/>menta Informaticae 77.4 (June 2007), pp. 397-449. https://content.iospress.com/articles/fundamenta-<lb/>informaticae/fi77-4-06. <lb/>[3] WasmFX developers. Effect handlers for WebAssembly. 2022. https://wasmfx.dev. <lb/>[4] Michael Fitzgibbons et al. RichWasm Artifact. 2024. https://doi.org/10.5281/zenodo.10906088. https: <lb/>//doi.org/10.5281/zenodo.10906088. <lb/>[5] WebAssembly GitHub. Component Model Design and Specification. 2022. https://github.com/WebAssembly/ <lb/>component-model/blob/main/design/mvp/Explainer.md. <lb/>[6] WebAssembly GitHub. GC Extension Proposal. 2021. https://github.com/WebAssembly/gc/blob/master/ <lb/>proposals/gc/Overview.md. <lb/>[7] WebAssembly GitHub. Interface Types Proposal. 2021. https://github.com/WebAssembly/interface-<lb/>types/blob/main/proposals/interface-types/Explainer.md. <lb/>[8] WebAssembly GitHub. Multi Memory Proposal for WebAssembly. 2022. https://github.com/WebAssembly/ <lb/>multi-memory/blob/main/proposals/multi-memory/Overview.md. <lb/>[9] WebAssembly GitHub. Threading Proposal for WebAssembly. 2022. https://github.com/WebAssembly/ <lb/>threads/blob/main/proposals/threads/Overview.md. <lb/>[10] Andreas Haas et al. &quot;Bringing the web up to speed with WebAssembly&quot;. In: PLDI 2017 (June 2017). <lb/>https://doi.org/10.1145/3062341.3062363. <lb/>[11] Chris Hawblitzel et al. &quot;A Garbage-Collecting Typed Assembly Language&quot;. In: ACM SIGPLAN Workshop <lb/>on Types in Language Design and Implementation (TLDI). Jan. 2007. https://doi.org/10.1145/1190315. <lb/>1190323. <lb/>[12] Alexandra E. Michael et al. &quot;MSWasm: Soundly Enforcing Memory-Safe Execution of Unsafe Code&quot;. In: <lb/>Proc. ACM Program. Lang. 7.POPL (Jan. 2023). https://doi.org/10.1145/3571208. <lb/>[13] Yasuhiko Minamide, Greg Morrisett, and Robert Harper. &quot;Typed Closure Conversion&quot;. In: ACM Sympo-<lb/>sium on Principles of Programming Languages (POPL), St. Petersburg Beach, Florida. Jan. 1996, pp. 271-283. <lb/>https://doi.org/10.1145/237721.237791. <lb/>[14] Greg Morrisett, Amal Ahmed, and Matthew Fluet. &quot;L3: A Linear Language with Locations&quot;. In: (2005), <lb/>pp. 293-307. https://doi.org/10.1007/11417170_22. <lb/>[15] Greg Morrisett et al. &quot;From System F to Typed Assembly Language&quot;. In: ACM Transactions on Program-<lb/>ming Languages and Systems 21.3 (May 1999), pp. 527-568. https://doi.org/10.1145/319301.319345. <lb/>[16] Greg Morrisett et al. &quot;Stack-based typed assembly language&quot;. In: Journal of Functional Programming <lb/>12.1 (2002), pp. 43-88. https://doi.org/10.1017/S0956796801004178. <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. <lb/></note>

        <page>214:24 <lb/></page>

        <note place="headnote">Fitzgibbons, Paraskevopoulou, Mushtak, Thalako ur, Sulaiman Manzur, Ahmed <lb/></note>

        <listBibl>[17] George Necula. &quot;Proof-carrying Code&quot;. In: ACM Symposium on Principles of Programming Languages <lb/>(POPL), Paris, France. ACM Press, Jan. 1997, pp. 106-119. https://doi.org/10.1145/263699.263712. <lb/>[18] George Necula and Peter Lee. &quot;Safe Kernel Extensions Without Run-Time Checking&quot;. In: Proceed-<lb/>ings of Operating System Design and Implementation. Seattle, Washington, Oct. 1996, pp. 229-243. <lb/>https://doi.org/10.1145/238721.238781. <lb/>[19] Daniel Patterson and Amal Ahmed. &quot;Linking Types for Multi-Language Software: Have Your Cake and <lb/>Eat It Too&quot;. In: 2nd Summit on Advances in Programming Languages (SNAPL 2017). Ed. by Benjamin S. <lb/>Lerner, Rastislav Bodík, and Shriram Krishnamurthi. Vol. 71. Leibniz International Proceedings in <lb/>Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2017, <lb/>12:1-12:15. isbn: 978-3-95977-032-3. https://doi.org/10.4230/LIPIcs.SNAPL.2017.12. <lb/>[20] Daniel Patterson, Andrew Wagner, and Amal Ahmed. &quot;Semantic Encapsulation using Linking Types&quot;. <lb/>In: Proceedings of the 8th ACM SIGPLAN International Workshop on Type-Driven Development. TyDe <lb/>2023. , Seattle, WA, USA, Association for Computing Machinery, 2023, pp. 14-28. isbn: 9798400702990. <lb/>https://doi.org/10.1145/3609027.3609405. <lb/>[21] Daniel Patterson et al. &quot;Semantic Soundness for Language Interoperability&quot;. In: Proceedings of the <lb/>43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation. <lb/>PLDI 2022. San Diego, CA, USA: Association for Computing Machinery, 2022, pp. 609-624. isbn: <lb/>9781450392655. https://doi.org/10.1145/3519939.3523703. <lb/>[22] Luna Phipps-Costin et al. &quot;Continuing WebAssembly with Effect Handlers&quot;. In: Proceedings of the ACM <lb/>on Programming Languages (PACMPL) 7.OOPSLA (2023). https://doi.org/10.1145/3622814. <lb/>[23] Xiaojia Rao et al. &quot;Iris-Wasm: Robust and Modular Verification of WebAssembly Programs&quot;. In: Proc. <lb/>ACM Program. Lang. 7.PLDI (June 2023). https://doi.org/10.1145/3591265. <lb/>[24] Jeremy G. Siek and Walid Taha. &quot;Gradual Typing for Functional Languages&quot;. In: Scheme and Functional <lb/>Programming Workshop (Scheme). Sept. 2006, pp. 81-92. <lb/>[25] Asumu Takikawa et al. &quot;Is Sound Gradual Typing Dead?&quot; In: ACM Symposium on Principles of Program-<lb/>ming Languages (POPL), St. Petersburg, Florida. 2016. https://doi.org/10.1145/2837614.2837630. <lb/>[26] Sam Tobin-Hochstadt and Matthias Felleisen. &quot;Interlanguage Migration: From Scripts to Programs&quot;. In: <lb/>Dynamic Languages Symposium (DLS). Oct. 2006, pp. 964-974. https://doi.org/10.1145/1176617.1176755. <lb/>[27] Robert N. M. Watson et al. &quot;CHERI: A Hybrid Capability-System Architecture for Scalable Software <lb/>Compartmentalization&quot;. In: Proceedings of the 2015 IEEE Symposium on Security and Privacy. SP &apos;15. <lb/>USA: IEEE Computer Society, 2015, pp. 20-37. isbn: 9781467369497. https://doi.org/10.1109/SP.2015.9. <lb/></listBibl>

        <front>Received 2023-11-16; accepted 2024-03-31 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. PLDI, Article 214. Publication date: June 2024. </note>


	</text>

</TEI>