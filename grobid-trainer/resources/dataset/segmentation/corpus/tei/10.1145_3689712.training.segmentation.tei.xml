<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title level="a">A Dependent Nominal Physical Type System for Static Analysis of Memory in Low Level Code</title>
        <author>
          <persName>
            <forename>Julien</forename>
            <surname>Simonnet</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Matthieu</forename>
            <surname>Lemerre</surname>
          </persName>
        </author>
        <author>
          <persName>
            <forename>Mihaela</forename>
            <surname>Sighireanu</surname>
          </persName>
        </author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2025-10-30T11:56:25.766334Z">30.10.2025 11:56:25</date>
          <title>grobid.training.segmentation [default]</title>
          <idno type="fileref">10.1145$1$3689712</idno>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Association for Computing Machinery (ACM)</publisher>
        <availability>
          <licence target="https://creativecommons.org/licenses/by/4.0/"/>
        </availability>
        <date type="publication">2024</date>
        <idno type="DOI">10.1145/3689712</idno>
      </publicationStmt>
      <sourceDesc>
        <bibl>Julien Simonnet, Matthieu Lemerre, Mihaela Sighireanu. (2024). A Dependent Nominal Physical Type System for Static Analysis of Memory in Low Level Code. Proceedings of the ACM on Programming Languages, 8(OOPSLA2), 30-59. DOI: 10.1145/3689712</bibl>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <appInfo>
        <application version="1.0" ident="pdf-tei-editor" type="editor">
          <ref target="https://github.com/mpilhlt/pdf-tei-editor"/>
        </application>
        <application version="0.8.3-SNAPSHOT" ident="GROBID" when="2025-10-30T11:56:25.766334Z" type="extractor">
          <desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
          <label type="revision">eb7768b</label>
          <label type="flavor">default</label>
          <label type="variant-id">grobid.training.segmentation</label>
          <ref target="https://github.com/kermitt2/grobid"/>
        </application>
      </appInfo>
    </encodingDesc>
    <revisionDesc>
      <change when="2025-10-30T11:56:25.766334Z" status="draft">
        <desc>Generated with createTraining API</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en">
        <front>Scenario-Based Proofs for Concurrent Objects <lb/>CONSTANTIN ENEA, LIX -CNRS -École Polytechnique, France <lb/>ERIC KOSKINEN, Stevens Institute of Technology, USA <lb/>Concurrent objects form the foundation of many applications that exploit multicore architectures and their <lb/>importance has lead to informal correctness arguments, as well as formal proof systems. Correctness arguments <lb/>(as found in the distributed computing literature) give intuitive descriptions of a few canonical executions <lb/>or &quot;scenarios&quot; often each with only a few threads, yet it remains unknown as to whether these intuitive <lb/>arguments have a formal grounding and extend to arbitrary interleavings over unboundedly many threads. <lb/>We present a novel proof technique for concurrent objects, based around identifying a small set of scenarios <lb/>(representative, canonical interleavings), formalized as the commutativity quotient of a concurrent object. <lb/>We next give an expression language for defining abstractions of the quotient in the form of regular or <lb/>context-free languages that enable simple proofs of linearizability. These quotient expressions organize <lb/>unbounded interleavings into a form more amenable to reasoning and make explicit the relationship between <lb/>implementation-level contention/interference and ADT-level transitions. <lb/>We evaluate our work on numerous non-trivial concurrent objects from the literature (including the <lb/>Michael-Scott queue, Elimination stack, SLS reservation queue, RDCSS and Herlihy-Wing queue). We show that <lb/>quotients capture the diverse features/complexities of these algorithms, can be used even when linearization <lb/>points are not straight-forward, correspond to original authors&apos; correctness arguments, and provide some new <lb/>scenario-based arguments. Finally, we show that discovery of some object&apos;s quotients reduces to two-thread <lb/>reasoning and give an implementation that can derive candidate quotients expressions from source code. <lb/>CCS Concepts: • Software and its engineering → Formal software verification; • Theory of computation <lb/>→ Logic and verification; Program reasoning; • Computing methodologies → Concurrent algorithms. <lb/>Additional Key Words and Phrases: verification, linearizability, commutativity quotient, concurrent objects <lb/>ACM Reference Format: <lb/>Constantin Enea and Eric Koskinen. 2024. Scenario-Based Proofs for Concurrent Objects. Proc. ACM Program. <lb/>Lang. 8, OOPSLA1, Article 140 (April 2024), 30 pages. https://doi.org/10.1145/3649857 <lb/></front>

        <body>1 INTRODUCTION <lb/>Efficient multithreaded programs typically rely on optimized implementations of common abstract <lb/>data types (adts) like stacks, queues, and sets, whose operations execute in parallel to maximize <lb/>efficiency. Synchronization between operations must be minimized to increase throughput [Herlihy <lb/>and Shavit 2008]. Yet this minimal amount of synchronization must also be adequate to ensure that <lb/>operations behave as if they were executed atomically, so that client programs can rely on their <lb/>(sequential) adt specification; this de-facto correctness criterion is known as linearizability [Herlihy <lb/>and Wing 1990]. These opposing requirements, along with the general challenge in reasoning about <lb/>interleavings, make concurrent data structures a ripe source of insidious programming errors. <lb/>Algorithm designers (e.g., researchers defining new concurrent objects) argue about correctness <lb/>by considering some number of &quot;scenarios&quot;, i.e., interesting ways of interleaving steps of different <lb/></body>

        <front>Authors&apos; addresses: Constantin Enea, LIX -CNRS -École Polytechnique, Paris, France, cenea@lix.polytechnique.fr; Eric <lb/>Koskinen, Stevens Institute of Technology, Hoboken, USA, eric.koskinen@stevens.edu. <lb/>© 2024 Copyright held by the owner/author(s). <lb/>ACM 2475-1421/2024/4-ART140 <lb/>https://doi.org/10.1145/3649857 <lb/>Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/>This work is licensed under a Creative Commons Attribution 4.0 International License. <lb/>140:2 <lb/>Constantin Enea and Eric Koskinen <lb/></front>

        <body>operations, and showing for instance, that each one satisfies some suitable invariant (which is not <lb/>necessarily inductive). For example, a scenario of the Michael and Scott [1996] queue is described <lb/>as: many threads concurrently reading, one enqueuer thread taking a specific read path finding a <lb/>tail pointer to be outdated, and then succeeding a compare-and-swap (CAS) operation, causing <lb/>others to fail their compare-and-swap (paraphrasing from Herlihy and Shavit [2008]). Such scenario <lb/>descriptions are powerful because they describe unboundedly many threads and often generalize <lb/>to cover many executions that are equivalent due to commutative re-orderings. Consequentially, <lb/>informal correctness arguments need only consider a few representative scenarios. Furthermore, <lb/>another critical benefit of scenario-based reasoning is that scenarios are more readily explainable <lb/>to software developers, who need not have a background in formal logic. <lb/>Despite the intuitive benefit of these operational, scenario-based proofs-which continue to be <lb/>widely used in the concurrent algorithms literature-it remains unknown as to whether they have <lb/>a formal grounding. This has lead to cases where objects thought to be linearizable [Detlefs et al. <lb/>2000] where later determined to contain bugs in unconsidered scenarios [Doherty et al. 2004]. <lb/>1.1 Formalizing Scenarios with <lb/>otients <lb/>In this paper, we show that operational, scenario-based correctness arguments can be formally <lb/>grounded. To that end, we propose a new proof methodology that is based on formal arguments <lb/>while keeping the intuition of scenario-based reasoning. This methodology relies on a reduction to <lb/>reasoning about a subset of representative interleavings (i.e. a formal version of informal scenarios), <lb/>which cover the whole space of interleavings modulo repeatedly swapping adjacent commutative <lb/>steps. The latter corresponds to the standard equivalence up to commutativity between the executions <lb/>of an object (e.g., Mazurkiewicz traces [Mazurkiewicz 1986]). <lb/>Reductions based on commutativity arguments have been formalized in previous work, e.g., Lip-<lb/>ton&apos;s reduction theory [Lipton 1975], QED [Elmas et al. 2009], CIVL [Hawblitzel et al. 2015], and <lb/>they generally focus on identifying atomic sections, i.e., sequences of statements in a single thread <lb/>that can be assumed to execute without interruption (without sacrificing completeness). Relying on <lb/>atomic sections for reducing the space of interleavings has its limitations, especially in the context <lb/>of concurrent objects. These objects rely on intricate algorithms where almost every step is an <lb/>access to the shared memory that does not commute with respect to other steps. <lb/>Our reduction argument reasons about a quotient of the set of object executions, which is a subset <lb/>of executions that contains a representative from each equivalence class. In general, an execution <lb/>of an object interleaves an unbounded number of invocations to the object&apos;s methods, each from a <lb/>different thread 1 . These executions can be seen as a word over an infinite alphabet, each symbol of <lb/>the alphabet representing a statement in the code and the thread executing that statement 2 . We show <lb/>that when abstracting away thread ids from executions, carefully chosen quotients become regular <lb/>or context-free languages. This is not true for any quotient since representatives of equivalence <lb/>classes can be chosen in an adversarial manner to make the language more complex. <lb/>The principal benefit of quotients is that reasoning about correctness can be done by considering <lb/>only a few representative execution interleavings, yet those conclusions generalize to all executions. <lb/>For some kinds of concurrent object implementations (defined later), deriving representative traces <lb/>can be reduced via induction to two-thread reasoning. <lb/>Proofs with program logics. Our work is inspired by the success of many prior works on proofs for <lb/>concurrent objects based on program logics such as Owicki and Gries [1976], Rely/Guarantee [Jones <lb/>1983], Concurrent separation logic [Brookes 2007; O&apos;Hearn 2007], RGSep [Vafeiadis and Parkinson <lb/></body>

        <note place="footnote">1 Typically, it can be assumed w.l.o.g. that each thread performs a single invocation in an execution. <lb/>2 Such a sequence will be called a trace in the formalization we give later in the paper. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:3 <lb/></page>

        <body>2007], Deny-Guarantee [Dodds et al. 2009], Views [Dinsdale-Young et al. 2013], Iris [Jung et al. <lb/>2018, 2015] and interactive proof tools for such logics. <lb/>The goal of this paper is orthogonal and focuses on finding a formal grounding for the operational, <lb/>scenario-based correctness arguments present in the algorithms literature. To this end, our method-<lb/>ology is based on taking representative interleaved traces upfront and using commutativity-based <lb/>equivalence classes for modularity/generalization rather than exploiting the program structure and <lb/>invariants for modularity/generalization. Achieving this alternative reasoning strategy nonetheless <lb/>requires careful formalization of what is meant by &quot;representative traces&quot;, as well as how those <lb/>classes of traces can be expressed abstractly, which we outline below. Our results show that (i) <lb/>scenario-based reasoning can be done formally through quotients, (ii) quotients can be given for <lb/>a variety of concurrent objects with subtle differences including non-fixed linearization points, <lb/>(iii) quotients improve the correctness arguments from the literature, and (iv) for some cases, <lb/>quotients-which represent interleavings of unboundedly many threads-can be automatically <lb/>discovered through a reduction to two-thread reasoning. <lb/>1.2 Example: Scenario-Based Proofs of the Michael-Sco <lb/>eue <lb/>For the sake of concreteness, we now show how quotients make concurrent reasoning simpler, using <lb/>the canonical Michael-Scott Queue (MSQ) as an example. Ultimately the theory and algorithms <lb/>in this paper lead to an implementation that is able to automatically derive the representation <lb/>discussed below, from the object&apos;s source code. The MSQ is implemented as a linked-list, with head <lb/>and tail pointers and a sentinel head node, as depicted to the left below. <lb/>x 2 <lb/>head <lb/>tail <lb/>x 3 <lb/>x 1 <lb/>Enqueuer i <lb/>x i <lb/>CAS <lb/>x 2 <lb/>head <lb/>tail <lb/>x 3 <lb/>x 1 <lb/>Advance the tail <lb/>x i <lb/>CAS <lb/>An enqueue (enq) operation, such as <lb/>in the diagram above, repeatedly attempts <lb/>to enqueue a new element by using an atomic compare-and-swap (CAS) operation on the tail <lb/>element&apos;s next pointer, replacing null with the address of the new node ( in the diagram above). <lb/>It is possible that this CAS operation will fail due to a concurrent enqueuer (of which there can <lb/>be unboundedly many). Nonetheless, due to the CAS, one enqueuer will succeed. At this point, <lb/>although the element is linked, it is not logically in the queue because the tail pointer is lagging. <lb/>The enqueuer will thus perform a second CAS operation, as shown on the digram above to the <lb/>right, to advance tail to point to . To ensure progress, concurrent enqueuers will also check to <lb/>see if the tail lags and, if so, attempt to advance the tail before they attempt to enqueue their <lb/>elements (i.e. helping). A dequeue (deq) operation repeatedly attempts to advance the head pointer <lb/>to make 1 the new sentinel node, but also has to check that the queue is non-empty and that other <lb/>threads have not recently dequeued. (To achieve all of these cases, deq must begin by reading the <lb/>head pointer, the tail pointer and head&apos;s next pointer and validating to see which case applies.) <lb/>To verify the correctness of objects like the MSQ, one has to consider all of the ways in which <lb/>concurrent invocations of unboundedly many methods could interleave. One strategy to tackle <lb/>this problem has been through the aforementioned program logics such as rely-guarantee where, <lb/>roughly, one defines state-based invariants and then shows they are preserved and threads don&apos;t <lb/>interfere with other threads&apos; actions. Nevertheless, the correctness arguments laid out by algorithm <lb/>designers (e.g., in the distributed computing community) typically are organized in a more opera-<lb/>tional manner and instead focus on discussing various &quot;scenarios. &quot; Consider the following excerpt <lb/>from The Art of Multiprocessor Programming [Herlihy and Shavit 2008] regarding the MSQ: <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:4 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>An enqueuer creates a new node, reads tail, and finds the node that appears to be last. To verify <lb/>that node is indeed last, it checks whether that node has a successor. If so, the thread attempts <lb/>to append the new node with CAS. (A CAS is required because other threads may be trying the <lb/>same thing.) [Assume that] the CAS succeeds. <lb/>Such sentences describe scenarios that involve unboundedly many threads executing some portion <lb/>of their programs. They are chosen to highlight tricky situations and describe why those situations <lb/>are still acceptable. The above example can be thought of as the sequence: <lb/>(1) Unboundedly many threads are reading the data structure. <lb/>(2) There is a distinguished thread, let&apos;s call <lb/>. <lb/>(3) <lb/>reads the tail and the tail&apos;s next pointer. <lb/>(4) <lb/>finds that tail&apos;s next is null. <lb/>(5) <lb/>atomically updates tail&apos;s next to point to its new node. <lb/>(6) The other (unboundedly many) threads fail their CASes on tail&apos;s next and restart. <lb/>This scenario has a particular shape about it: unboundedly many threads read, then a single thread <lb/>performs a write, then the remaining threads react to that write. This is a common setup in many <lb/>non-blocking concurrent algorithms and a useful pattern (although, in general, we will describe <lb/>scenarios beyond those of this shape). One might think of it as a regular expression denoted next : <lb/>next ≡ ( ∈ : <lb/>+ <lb/>: <lb/>) * • ( <lb/>: cas/succeed) • ( ∈ : <lb/>) * <lb/>where is the (unbounded) set of all threads excluding <lb/>. Above next expresses that some <lb/>unboundedly many threads from set (including <lb/>) perform only <lb/>-path actions, then <lb/>succeeds its cas, then those unboundedly many threads restart. This expression is more powerful <lb/>than it may first appear. There are a few important considerations: <lb/>• Conciseness. The entirety of MSQ&apos;s concurrent execution behaviors can be represented with <lb/>this and only two other similarly concise representative interleavings, along with four even <lb/>simpler read-only interleavings. Expressions tail and head are similarly defined and represent <lb/>advancing the tail pointer and the head pointer (due to a dequeuer), respectively. <lb/>• Unbounded. With these concise descriptions, the interleavings between an unbounded number <lb/>of enqueuers and dequeuers can be seen as an unbounded alternation ( next + tail + head ) * . <lb/>(Below we will further refine this approximation with stateful automata.) <lb/>This starred-union description does not include all possible ways of interleaving steps of en-<lb/>queuers, e.g., it does not include interleavings where a thread restarts after two successful CASs <lb/>since it last read the shared memory. It includes just a subset of representatives that we call a <lb/>quotient, which is succinct enough to correspond to the designer&apos;s intuition and large enough to <lb/>cover the whole space of interleavings modulo repeatedly swapping adjacent commutative steps <lb/>(i.e., the standard equivalence up to commutativity between executions known as Mazurkiewicz <lb/>traces [Mazurkiewicz 1986]). For instance, an interleaving where a thread restarts after two suc-<lb/>cessful CASs (since it last read the shared memory) is equivalent to one where the restart step <lb/>is reordered to the left to occur immediately after the first CAS. This is because the restarting <lb/>condition is fulfilled after this first CAS as well and the restart step does not perform any writes. <lb/>The MSQ falls into a special class of objects for which quotients can be expressed in this inductive <lb/>way, as a sequence of what we call &quot;layers&quot; (above next , tail and head are layers) wherein only <lb/>a single shared memory write action occurs per layer, and all other actions are thread-local/read-<lb/>only (perhaps restarting due to a failed CAS). Consequently, it is possible via induction to reduce <lb/>reasoning to a collection of two-threaded arguments (one writer, one reader). While quotients and <lb/>their abstractions are a much broader class, layers are nonetheless an important subclass since they <lb/>apply to many lock-free implementations and can be automated, as discussed below. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:5 <lb/></page>

        <body>1.3 Challenges and Contributions <lb/>We now identify several challenges toward enabling scenario-based reasoning and discuss how we <lb/>address them in this paper. <lb/>1. Concurrent Object Quotients. How can scenario-based reasoning be done formally? (Sec. 3) We <lb/>show that scenario-based reasoning can be made formal through a methodology wherein reasoning <lb/>about all executions of a concurrent object is reduced to reasoning only about a smaller set of <lb/>representative interleavings. At the technical core is the definition of an object&apos;s execution quotient <lb/>which collapses executions that are equivalent up to swapping commutative adjacent actions. A <lb/>quotient is parameterized by this equivalence relation and has both a minimality constraint (no <lb/>two executions are equivalent) and a completeness constraint (all executions are equivalent to <lb/>some execution in the quotient). We prove that linearizability of the quotient is sufficient to show <lb/>linearizability of the object. The upshot is that concurrent object correctness is now accomplished <lb/>via reasoning about a collection of scenarios (as in typical informal proofs). <lb/>2. Expressing Quotients. How can a quotient set be described? (Sec. 4) A next question is how to <lb/>finitely express a quotient, which can have unboundedly many interleavings. In Sec. 3, we introduce a <lb/>quotient expression language that permits a mixture of regular expressions (e.g., Kleene-star iterations <lb/>of subexpressions) and context-free grammars (e.g., unbounded but balanced subexpressions). <lb/>We then give an interpretation/semantics for these expressions that maintains the minimality <lb/>condition: there will only be one interleaving (with threads organized in a canonical order) for <lb/>every unboundedly many unrolling. The MSQ expression ( next + tail + head ) * above provides an <lb/>intuition for the quotient expression for the MSQ. (Technically, the <lb/>actions are paths and the <lb/> * -iterations within the x subexpressions are replaced with a context-free form of iteration.) <lb/>As we will show later, quotients and their abstractions are expressive and can capture canonical <lb/>concurrent objects as well as more complicated ones such as the Herlihy and Wing [1990] queue and <lb/>the elimination stack of Hendler et al. [2004], each having different kinds of non-fixed linearization <lb/>points. These are notoriously hard cases for today&apos;s proof methodologies. We note that, while the <lb/>idea of reasoning about execution quotients is generic, identifying precise limits for the applicability <lb/>of the particular class of quotients expressions is hard in general. This is similar to using abstract <lb/>domains in the context of static analysis: it is hard to determine precisely the class of programs for <lb/>which interval or polyhedra abstractions are effective. <lb/>3. Layer Quotient Expressions and Automata. (Sec. 5) In addition to broad expressivity, <lb/>are there classes of objects whose quotients have a simpler structure? To increase accessibility and <lb/>automation, we next describe certain kinds of quotient expressions for which reasoning can actually <lb/>be reduced, via induction, to two-thread reasoning. Specifically, for objects whose implementation <lb/>can be written as a collection of (possibly restarting) read-only/local paths and paths that have only <lb/>a single atomic read-write, we define layer quotients to more conveniently and inductively capture <lb/>the quotient. Although this does not apply to all objects, it does apply to canonical examples such as <lb/>the MSQ, Treiber&apos;s Stack, and even the Scherer III et al. [2006] synchronous reservation queue. For <lb/>these objects, executions can be decompiled into a sequence of layers, each described by context-free <lb/>quotient expressions of the form ( 1 + 1 + . . .) • • ( 2 + 2 + . . .) where 1 • 2 is a read-only <lb/>path through the method implementation (possibly restarting), and is a path with a successful <lb/>atomic read-write. The exponents in both expressions indicate the unbounded replication of local <lb/>paths ( is not fixed; it ensures prefix/suffix balancing). Then an overall quotient expression can be <lb/>made from regular compositions of these context-free layers, leading to an inductive argument. <lb/>Furthermore, each layer can be discovered with two-thread reasoning: considering how each write, <lb/>treated atomically, impacts each other read-only/local path. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:6 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>Fig. 1. Layer automaton for the Michael/Sco <lb/>eue. <lb/>We describe how layer expressions can be conveniently represented as finite-state automata <lb/>(and further below also used for automation). The layer automaton for the Michael-Scott Queue is <lb/>shown in Fig. 1. We will discuss it in detail in Sec. 6.1 but, roughly, the states track whether the <lb/>queue is empty and whether the tail is lagging. The layer-labeled edges define the local/read-only <lb/>(unbold) control-flow paths and how they are impacted by the write path (bold). There are also <lb/>read-only layers, which we will describe later. <lb/>4. Evaluation: Verifying Concurrent Objects. (Sec. 6) We consider a broad range of concurrent <lb/>objects including Treiber&apos;s stack [Treiber 1986], the Michael and Scott [1996] queue, the Scherer III <lb/>et al. [2006] synchronous reservation queue, the Herlihy and Wing [1990] queue, the Hendler et al. <lb/>[2004] elimination stack, and the Restricted Double-Compare Single-Swap (RDCSS) [Harris et al. <lb/>2002]. Each object has its own subtleties, including complications like multiple CAS steps and <lb/>non-fixed linearization points. For each object we (i) show that its behavior and linearizability can <lb/>be captured through a quotient and (ii) revisit the object&apos;s authors&apos; correctness arguments. We find <lb/>that quotients capture those intuitive scenarios and make scenarios explicit and comprehensive. <lb/>5. Generating Candidate Quotient Expressions. (Sec. 7) Automating quotient-based proofs of <lb/>concurrent objects is a rather large question (perhaps warranting new forms of induction) which we <lb/>mostly leave to future work. Nonetheless, we present an algorithm and prototype implementation <lb/>Cion for generating candidate quotient expressions, directly from a concurrent object&apos;s source code. <lb/>We manually confirmed that these expressions are sound abstractions of those objects&apos; quotients. <lb/>We applied Cion to layer-compatible objects such as Treiber&apos;s Stack and the Michael/Scott Queue, <lb/>finding that candidate layer expressions can be discovered in a few minutes. <lb/>For lack of space, some detail has been omitted and is available in the extended version [Enea et al. <lb/>2023] of this paper. Our implementation Cion is available on GitHub 3 , along with benchmark sources. <lb/>2 PRELIMINARIES <lb/>Running example: A simple concurrent counter. Fig. 2 lists a concurrent counter with methods <lb/>for incrementing and decrementing. Both methods of the counter return the value of the counter <lb/>before modifying it, and the counter is decremented only if it is strictly positive. <lb/>Each method consists of a retry-loop that reads the shared variable ctr representing the counter <lb/>and tries to update it using a Compare-And-Swap (CAS). A CAS atomically tests whether ctr <lb/>equals the second argument and if this is the case, then it assigns the value specified by the third <lb/></body>

        <note place="footnote">3 https://github.com/quotientprovers/cion <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:7 <lb/></page>

        <body>Fig. 3. The steps of an execution with three increment-only threads whose actions are aligned horizontally. <lb/>For readability, we rename the local variable c in thread to c . The curved blue arrows depict data-flow <lb/>dependencies between reads/writes of ctr. <lb/>argument. If the test fails, then the CAS has no effect. The return value of CAS represents the truth <lb/>value of the equality test. If the CAS is unsuccessful, i.e., it returns false, then the method retries <lb/>the same steps in another iteration. <lb/>1 int increment () { <lb/>2 <lb/>while ( true ) { <lb/>3 <lb/>int c = ctr ; <lb/>4 <lb/>if ( CAS ( ctr ,c , c +1)) <lb/>5 <lb/>return c ; <lb/>6 <lb/>} <lb/>7 } <lb/>8 int decrement () { <lb/>9 <lb/>while ( true ) { <lb/>10 <lb/>int c = ctr ; <lb/>11 <lb/>if ( c == 0 ) <lb/>12 <lb/>return 0; <lb/>13 <lb/>if ( CAS ( ctr ,c ,c -1)) <lb/>14 <lb/>return c ; <lb/>15 <lb/>} <lb/>16 } <lb/>Fig. 2. A concurrent counter. <lb/>The executions of the concurrent counter are interleavings of an <lb/>arbitrary number of increment or decrement invocations from an <lb/>arbitrary number of threads. Each invocation executes a number <lb/>of retry-loop iterations until reaching the return. An iteration <lb/>corresponds to a control-flow path that starts at the beginning of <lb/>the loop and ends with a return or goes back to the beginning. For <lb/>instance, the increment method consists of two possible iterations: <lb/>(1) c = ctr; CAS(ctr, c, c+1); return c, and <lb/>(2) c = ctr; assume(ctr != c). <lb/>Iteration #1 is called successful because it contains a successful <lb/>CAS, and the unsuccessful CAS in the iteration #2 is written as an <lb/>assume that blocks if the condition is not satisfied. <lb/>An invocation can execute more iterations if ctr is modified by <lb/>another thread in between reading it at line 3 or 10 and executing <lb/>the CAS at line 4 or 13, respectively. Fig. 3 pictures an execution <lb/>with 3 increments that execute between 1 and 3 retry-loop iterations. The first iteration of threads <lb/>2 and 3 contains unsuccessful CASs because thread 1 executed a successful CAS and modified ctr, <lb/>and these invocations must retry, execute more iterations. Note that there are unboundedly many <lb/>such executions and, even with bounded threads, exponentially many interleavings. <lb/>Concurrent Object Syntax. We model concurrent objects using Kleene Algebra with Tests [Kozen <lb/>1997] (KAT). Intuitively, a KAT represents the code of an object method using regular expressions <lb/>over symbols that represent conditionals (tests) or statements (actions). <lb/>Definition 2.1. [Kleene Algebra with Tests] A KAT K is a two-sorted structure (Σ, B, +, • , * , , 0, 1), <lb/>where (Σ, +, • , * , 0, 1) is a Kleene algebra, (B, +, • , , 0, 1) is a Boolean algebra, and the latter is a <lb/>subalgebra of the former. There are two sets of symbols: A for primitive actions, and B for primitive <lb/>tests. The grammar of boolean test expressions is <lb/>::= ∈ B | • | + | | 0 | 1, and the <lb/>grammar of KAT expressions is <lb/>::= ∈ A | ∈ <lb/>| • | + | * | 0 | 1. For 1 , 2 ∈ K, <lb/>we write 1 ≤ 2 if 1 + 2 = 2 . <lb/>The primitive actions and tests used in examples in this paper will be along the lines of A = {x := <lb/>y, x.f := y, . . .} and B = {x = y, x.f = y, x = null, x.f = null . . .}. <lb/>Atomic read-write (ARW). We conservatively extend KAT with a syntactic notation ⟨ ⟨b•a⟩ ⟩, used to <lb/>indicate a condition and action , between which no other actions can be interleaved. Apart from <lb/>restricting interleaving (defined below), this does not impact the semantics so it can be represented <lb/>with two special symbols &quot;⟨ ⟨&quot; and &quot;⟩ ⟩&quot; whose semantics are the identity relation. For example a <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:8 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>compare-and-swap cas(x,v,v&apos;) can be represented as (⟨ ⟨[x=v] • x:=v&apos;⟩ ⟩ • ) + ([x=v] • ′ ), where <lb/>[ = ] is a primitive test and the assignment is a primitive action. Overline indicates negation, as <lb/>in KAT notation. is the code to be executed when cas succeeds and ′ when it fails. <lb/>Methods of a concurrent object. We define a method signature ( ì )/ì with a vector of arguments <lb/>ì and return values ì (often a singleton ). For a vector ì , denotes its -th component. An <lb/>implementation of a method is a KAT expression , whose actions may refer to argument values, <lb/>e.g., x := args . A concurrent object is a set of methods = { 1 ( ì 1 )/ì 1 : 1 , . . .}, associating <lb/>signatures with implementations. The set of method names in an object is denoted by Meth( ). <lb/>Example 2.2. The counter from Sec. 2 is formalized as <lb/>= {inc()/ : <lb/>, dec()/ : <lb/>} <lb/>= (c:=ctr • (⟨ ⟨[c=ctr] • ctr:=c+1⟩ ⟩ • ret(c)) + ( [c=ctr]) ) * <lb/>= (c:=ctr• ([c=0] •ret(0)) + ( [c=0] • ⟨ ⟨[c=ctr] • ctr:=c-1⟩ ⟩ •ret(c)) + ( [c=ctr]) ) * <lb/>The outer * in <lb/>corresponds to the while (true) loop in the method increment while the inner <lb/>+ corresponds to the two branches of the conditional. The KAT expression <lb/>represents every <lb/>control-flow path of increment which goes a number of times through the assignment c:=ctr <lb/>and the &quot;false&quot; branch of the conditional before succeeding the atomic read-write and returning <lb/>(other sequences represented by this regular expression, e.g., , iterating multiple times through the <lb/>atomic read-write and return will be excluded when defining the semantics). <lb/>Concurrent Object Semantics. A full semantics for these concurrent objects is given in the <lb/>extended version [Enea et al. 2023]. In brief, the semantics involves local states ∈ Σ , shared <lb/>states <lb/>∈ Σ , and nondeterministic thread-local transition relation , , ↓ ℓ <lb/>′ , ′ , ′ , which <lb/>optionally involve label ℓ ( and ′ are KAT expressions representing code to be executed). These <lb/>labels are taken from the set of possible labels L ⊆ A ∪ B ∪ call (ì ) ∪ ret(ì ) ∪ ⟨ ⟨ • ⟩ ⟩ which <lb/>includes primitive actions, primitive tests, call actions, return actions or ARWs. (We here write <lb/>call (ì ) with free variables to refer to the set of all call actions and similar for returns and ARWs.) <lb/>Next, a configuration = ( , ) where : T ⇀ (Σ × (K ∪ {⊥})) comprises a shared state <lb/>∈ Σ and a mapping for each active thread to its local state and current code. We use T to <lb/>denote the set of thread ids, which is equipped with a total order &lt;. Configurations of an object <lb/>transition according to the relation <lb/>_ : C × (T × L) × C, labeled with a thread id and a label. <lb/>An object is acted on by a finite environment E : T → × ì <lb/>Val, specifying which threads <lb/>invoke which methods, with which argument values. Val denotes a set of values and ì <lb/>Val denotes <lb/>the set of tuples of values. We assume that object methods can not access thread identifiers (which <lb/>is true for concurrent objects defined in the literature) and therefore, each invocation is assumed <lb/>to be executed by a different thread. An execution of in the environment E is a sequence of <lb/>labeled transitions between configurations 0 <lb/>_ . . . <lb/>_ <lb/>that starts in the initial configuration 0 <lb/>w.r.t. E and ends in configuration . A configuration <lb/>= ( , ) is final iff ( ) = ( , ⊥), <lb/>for some , for all ∈ dom( ). An execution is completed if it ends in a final configuration. <lb/>⊗ E denotes the set of completed executions of in the environment E. A trace ∈ Traces <lb/>is a sequence of T × L pairs, i.e., thread-indexed labels 0 : ℓ 0 , . . . , : ℓ . A trace of an execution <lb/>denoted is a projection of the thread-indexed labels out of the transitions in the execution. <lb/>The semantics <lb/>of a concurrent object is defined as the set of traces under all possible <lb/>environments (i.e., for any number of threads invoking any methods with any inputs). Formally, <lb/>= { | ∈ <lb/>⊗ E , for some environment E}. <lb/>Linearizability For an object , an operation symbol (or operation for short) = ( ì )/ ì <lb/>represents an invocation of a method ∈ Meth( ) with signature ( ì )/ì , where ì is a vector of <lb/>values for the corresponding arguments ì , and ì is a vector of values for the corresponding returns <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:9 <lb/></page>

        <body>ì . A sequential specification for an object is a set of sequences over operation symbols. <lb/>For instance, the sequential specification for the counter object includes sequences of increments <lb/>and decrements corresponding to executions where each invocation executes in isolation, e.g., <lb/>inc()/0 • inc()/1 • inc()/2 or inc()/0 • dec()/1 • dec()/0. <lb/>A trace of an object is linearizable w.r.t. a specification if there exists a (linearization-point) <lb/>mapping ( ) : T → N where the label at position (index) ( ) in is considered to be the <lb/>so-called linearization point of &apos;s invocation, and must satisfy the following: <lb/>(1) the position ( ) is after &apos;s invocation label and before &apos;s return, <lb/>(2) the (linearization) sequence lin( , ) of operation symbols ( ì )/ ì , where the -th symbol <lb/>represents the invocation of the -th thread w.r.t. the positions ( , ), belongs to . <lb/>For example, Fig. 3 pictures a trace which is linearizable w.r.t. the counter specification described <lb/>above because there exists a linearization-point mapping which associates each thread with <lb/>the position of the -th successful CAS. The linearization inc()/0 • inc()/1 • inc()/2 induced by <lb/>this mapping is admitted by the specification. <lb/>For simplicity, we omit invocation labels from traces and consider the first instruction in an <lb/>invocation to play the same role. Object is linearizable wrt a spec. if all traces in <lb/>are <lb/>linearizable wrt . <lb/>3 OBJECT QUOTIENTS <lb/>To formalize scenarios, we introduce the concept of a quotient of an object which is a subset of its <lb/>traces that represents every other trace modulo reordering of commutative steps or renaming thread <lb/>ids. For an expert reader, the quotient is a partial order reduction [Godefroid 1996] composed with a <lb/>symmetry reduction [Clarke et al. 1998] of its set of traces. In general, an object may admit multiple <lb/>quotients, but as we show later, there exist quotients which can be finitely-represented using regular <lb/>expressions or extensions thereof. We interpret scenarios as components (sub-expressions) of these <lb/>finite representations. <lb/>Two executions 1 and 2 are equivalent up to commutativity, denoted as 1 ≡ 2 , if 2 can be <lb/>obtained from 1 (or vice-versa) by repeatedly swapping adjacent commutative steps. An execution <lb/>2 is obtained from 1 through one swap of adjacent commutative steps, denoted as 1 ≡ 1 2 , if <lb/>1 = E <lb/>0 • • • <lb/>( :ℓ ) <lb/>+1 <lb/>( ′ :ℓ ′ ) <lb/>+2 • • • , and 2 = E <lb/>0 • • • <lb/>( ′ :ℓ ′ ) <lb/>′ <lb/>+1 <lb/>( :ℓ ) <lb/>+2 • • • <lb/>( 2 is obtained from 1 by re-ordering the steps labeled by : ℓ and ′ : ℓ ′ ). When there exist <lb/>executions 1 and 2 as above, we say that the re-ordered labels ℓ and ℓ ′ are possibly commutative. <lb/>Definition 3.1. The equivalence relation ≡⊆ E × E between executions is the least reflexive-<lb/>transitive relation that includes ≡ 1 . <lb/>The relation ≡ is extended to traces as expected: 1 ≡ 2 if 1 and 2 are traces of executions 1 and <lb/>2 , respectively, and 1 ≡ 2 . <lb/>For example, the Counter executions below are equivalent up to commutativity (related by ≡ 1 ): <lb/>= 0 • • • 1 <lb/>( :[c =ctr] ) <lb/>2 <lb/>( ′ :c ′ :=ctr) <lb/>3 • • • and ′ = 0 • • • 1 <lb/>( ′ :c ′ :=ctr) <lb/>′ <lb/>2 <lb/>( :[c =ctr] ) <lb/>3 • • • <lb/>assuming that ctr &gt; 0 at configuration 1 (recall that [c =ctr] represents an unsuccessful CAS). <lb/>Definition 3.2. Two traces 1 and 2 are equivalent up to thread renaming, denoted as 1 ≃ 2 , if <lb/>there is a bijection between thread ids in 1 and 2 , resp., s.t. 2 is the trace obtained from 1 by <lb/>replacing every thread id label with ( ). <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:10 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>For example, 0 <lb/>( : ) <lb/>1 <lb/>( ′ : ) <lb/>2 and 0 <lb/>( ′ : ) <lb/>1 <lb/>( : ) <lb/>2 are equivalent up to thread renaming. <lb/>We define a quotient of an object as a subset of its traces that is complete in the sense that <lb/>it represents every other trace up to commutative reorderings or thread renaming, and that is <lb/>optimal in that sense that it does not contain two traces that are equivalent up to commutativity. <lb/>Optimality does not include equivalence up to thread renaming (symmetry reduction) because the <lb/>finite representations we define later abstract away thread ids. <lb/>Definition 3.3 (Quotient). A quotient of object is a set of traces ⟨⌊ ⌋⟩ ⊆ <lb/>such that: <lb/>• ∀ ∈ <lb/>. ∃ ′ , ′′ . ≃ ′ ∧ ′ ≡ ′′ ∧ ′′ ∈ ⟨⌊ ⌋⟩ (completeness), and <lb/>• ∀ , ′ ∈ ⟨⌊ ⌋⟩. <lb/>′ (optimality) <lb/>Note that an object admits multiple quotients since representatives of equivalence classes w.r.t. <lb/>≡ can be chosen arbitrarily. <lb/>For a quotient ⟨⌊ ⌋⟩, a set Swaps of pairs of possibly-commutative labels (in L × L) is called <lb/>⟨⌊ ⌋⟩-sufficient if all the swaps needed to establish ′ ≡ ′′ in Def. 3.3 are between pairs of labels <lb/>in Swaps. <lb/>Example 3.4 (Quotient and representative/canonical traces for the Counter). The trace of three <lb/>increment-only threads from Fig. 3 represents many other traces of the Counter modulo commuta-<lb/>tive reorderings or thread renaming. It can be thought of as a sequence of three canonical phases, <lb/>depicted with stacked parallelograms as follows: <lb/>Each phase above groups together the retry-loop iterations that interact with each other: a single <lb/>successful CAS instruction causes the other attempts to fail. For instance, it represents another <lb/>trace where the first &quot;cas fails&quot; step occurs after the second successful CAS: <lb/>This &quot;late&quot; CAS failure would also fail if moved to the left as shown above. Similarly, it also <lb/>represents traces where the action 2 = 0 is swapped with 3 = 0 and even 1 = 0, or traces where <lb/>thread ids change from 1, 2, 3 to 4, 5, 6 for instance. <lb/>One can define a quotient ⟨⌊ <lb/>⌋⟩ of Counter which includes representative traces of this form. <lb/>The representative traces only differ in the number of incrementers/decrementers and the order in <lb/>which they succeed their CASs. ⟨⌊ <lb/>⌋⟩ will contain similar canonical traces for, say, an environment <lb/>with 4 incrementers, 2 decrementers acting in the sequence <lb/>; <lb/>; <lb/>; <lb/>; <lb/>; <lb/>(wherein the second <lb/>does nothing). See Example 4.3 for a more precise description. <lb/>Preserving Linearizability Through Commutative Reorderings. Our goal is to reduce the <lb/>problem of proving linearizability for all traces of an object to proving linearizability only for <lb/>traces in a quotient. Therefore, given two traces and ′ that are equivalent up to commutativity <lb/>( ≡ ′ ), where for instance, would be part of a quotient, an important question is whether <lb/>the linearizability of implies the linearizability of ′ . We show that this holds provided that the <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:11 <lb/></page>

        <body>reordering allowed by the equivalence ≡ is consistent with a commutativity relation between <lb/>operations in the specification. <lb/>Given a specification , two operations 1 and 2 are -commutative when 1 • 1 • 2 • 2 ∈ iff <lb/>1 • 2 • 1 • 2 ∈ , for every 1 , 2 sequences of operations. Given a set of pairs of labels Swaps ⊆ L×L, <lb/>a linearization point mapping ( ) of a trace is robust against Swaps-reorderings if for every <lb/>two threads 1 and 2 , if the linearization points of 1 and 2 form a pair in Swaps, then the operations <lb/>of 1 and 2 are -commutative. <lb/>Theorem 3.5. Let ≡ ′ be two equivalent traces, such that ′ is obtained from by swapping <lb/>pairs of labels in some set Swaps. If is linearizable w.r.t. some specification via a linearization point <lb/>mapping ( ) that is robust against Swaps-reorderings, then ′ is linearizable w.r.t. . <lb/>The above holds by defining ( ′ ) by ( ′ )( ) = the index in ′ of the label ( )( ), for every . <lb/>Theorem 3.5 implies that proving linearizability for an object reduces to proving linearizability <lb/>only for the traces in a quotient ⟨⌊ ⌋⟩ of , provided that the used linearization point mappings are <lb/>robust against Swaps-reorderings for a set Swaps which is ⟨⌊ ⌋⟩-sufficient (thread renaming does <lb/>not affect this reduction because specifications are agnostic to thread ids). <lb/>4 FINITE ABSTRACT REPRESENTATIONS OF QUOTIENTS <lb/>We define finite representations of sets of traces, quotients in particular, which resemble regular <lb/>expressions and which denote context-free languages over a finite alphabet. The finite alphabet is <lb/>obtained by projecting out thread ids from labels in a trace. As we show in the evaluation section, <lb/>scenarios in previous informal proofs of many concurrent objects correspond to components of <lb/>these expressions, and linearization points can be identified directly within such expressions. <lb/>Let Abs be the set of expressions expr defined by the following grammar <lb/>expr = | 1 • expr • 2 | expr * | expr + expr | expr • expr <lb/>such that , 1 , 2 ∈ (A ∪ B ∪ ⟨ ⟨ • ⟩ ⟩) * are finite sequences of labels, and for every application of the <lb/>production rule 1 • expr • 2 , is a fresh variable not occurring in expr (this ensures context-free <lb/>abstractions). Therefore, for every expression in Abs, a variable is used exactly twice. <lb/>Such expressions have a natural interpretation as context-free languages by interpreting * , +, <lb/>and • as the Kleene star, union, and concatenation in regular expressions, and interpreting every <lb/>1 • expr • 2 as sequences 1 , . . . , 1 • expr • 2 , . . . , 2 where the number of 1 repetitions on <lb/>the left of expr&apos;s interpretation, denoted as expr , equals the number of 2 repetitions on the right. <lb/>We define an interpretation expr of expressions expr as sets of traces, which differs from the <lb/>above only in the interpretation of , * , and 1 • expr • 2 , for finite sequences of labels , 1 , 2 . <lb/>Definition 4.1 (Interpretation of an expression). For an expression expr, <lb/>= { : | ∈ T }, where : means that all the labels in are associated <lb/>with the same thread id , <lb/> * <lb/>= { 0 : , . . . , : | ∈ N, 0 &lt; . . . &lt; }, sequences of labels associated <lb/>with increasing thread ids, <lb/>1 • expr • 2 <lb/>= { 0 : 1 , . . . , : 1 , expr , : 2 , . . . , 0 : 2 | ∈ N, 0 &lt; . . . &lt; }, <lb/>sequences of labels where the same sequence of increasing thread ids is <lb/>associated to 1 and 2 repetitions (in reverse order), respectively, <lb/>expr * <lb/>= expr , . . . , expr , sequences of repetitions of expr , <lb/>expr 1 + expr 2 <lb/>= expr 1 ∪ expr 2 , union of interpretations, and <lb/>expr 1 • expr 2 <lb/>= expr 1 , expr 2 , concatenation of interpretations. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:12 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>ctr=0 <lb/>ctr&gt;0 <lb/>Read-Only Layer 1 <lb/>(See definition of Layer 4 to the right) <lb/>Layer 2 <lb/>Layer 3 <lb/>Layer 4 <lb/>Layer 4 <lb/>&lt; l a t e x i t s h a 1 _ b a s e 6 4 = &quot; S H 7 f w X a 2 D w f d x A h T g z p Y n L V w t k o = &quot; &gt; A A A C Z H i c b V F b a 9 R A G J 3 E S 2 u s m l p 8 E m R o V 9 g V X B L B K x S K v g i + V H D b w s 6 6 T L 5 8 2 R 0 6 m Y S Z L + I S 8 n P 8 Q 7 7 5 J L 7 o 3 3 D 2 I m j r g Y H D O d 9 l 5 k x W a + U o S b 4 F 4 Z W r 1 6 5 v b d + I b u 7 c u n 0 n 3 r 1 7 4 q r G A o 6 g 0 p U 9 y 6 R D r Q y O S J H G s 9 q i L D O N p 9 n 5 m 6 V / + g m t U 5 X 5 Q I s a J 6 W c G V U o k O S l a d z 2 e p H I c K Z M K 6 2 V i 6 6 F L n q 8 B h c i E h o L 6 g v C z 0 T U 9 u H V I Z A d d F x A X h E f / z H g M O k m G 3 G l u a K 1 S F 0 / G Q i r Z n M a f H z E Z S T Q 5 J s 9 U a 8 3 j Q + S Y b I C v 0 z S D T k 4 e p d 8 + b 7 / 8 t f x N P 4 q 8 g q a E g 2 B l s 6 N 0 6 S m i R 9 I C j R 2 k W g c 1 h L O 5 Q z H n h p Z o p u 0 q 5 A 6 / t A r O S 8 q 6 4 8 h v l L / 7 m h l 6 d y i z H x l K W n u L n p L 8 X / e u K H i x a R V p m 4 I D a w X F Y 3 m V P F l 4 j x X F o H 0 w h M J V v m 7 c p h L K 4 H 8 v 0 Q + h P T i k y + T k y f D 9 N n w 6 X u f x m u 2 x j a 7 z / Z Z n 6 X s O T t i b 9 k x G z F g P 4 K t I A 5 2 g 5 / h T r g X 3 l u X h s G m Z 4 / 9 g / D B b 6 t 8 u H w = &lt; / l a t e x i t &gt; <lb/>((c:=ctr) • [c=0] • ret(0)) <lb/> * <lb/>&lt; l a t e x i t s h a 1 _ b a s e 6 4 = &quot; g Z J / e H R z u / F L i E Q T M v f f g j c 8 X R k = &quot; &gt; A A A D d H i c f V L L j t M w F H V T H k N 4 d W D B A h Y e 2 p F a D V Q N E g 8 h I Y 1 g w 4 L F I N G Z k e p Q O Y 7 T W m M 7 k X 2 D q K L 8 A J / H C n 6 A P R v W u E l b + g C u Z O n o 3 n N 8 f Y 4 c Z V J Y G A y + N 7 z m p c t X r u 5 d 8 6 / f u H n r d m v / z q l N c 8 P 4 k K U y N e c R t V w K z Y c g Q P L z z H C q I s n P o o s 3 8 / n Z J 2 6 s S P U H m G U 8 V H S i R S I Y B d c a 7 z e + d D o + i f h E 6 I I a Q 2 d l w U r / c V 2 Y E J 9 I n k C 3 S 4 B / B o C C v X z F w J S 9 c S E 0 K 4 k R k y n 0 P h a 6 x I T F K e B / 0 m O + R l c r O h k F S o X + j m B 5 G 9 U T y c n B A o x W t I o V V q x V D 4 w T H w V u z V J V g + W u O c 8 m h e F Q / t l X 9 v B i T l e v q U 2 Q 1 A U 3 z 7 X Y X l t u 2 l E b 3 v 8 r W w 9 N Y 5 9 w H S 9 i 9 z u d c a s 9 6 A + q w r s g W I D 2 c f j j H f 0 W P T o Z t 7 6 S O G W 5 4 h q Y p N a O g k E G o b s Q B J O 8 9 E l u e U b Z B Z 3 w k Y O a K m 7 D o v o 0 J T 5 0 n R g n q X F H A 6 6 6 6 4 q C K m t n K n J M R W F q t 2 f z 5 t 9 m o x y S F 6 F z m u X A n d 1 q U Z J L D C m e / 0 A c C 8 M Z y J k D l B n h 3 o r Z l B r K w P 1 T 3 4 U Q b F v e B a d P + s G z / t P 3 L o 3 X q K 4 9 d B 8 9 R F 0 U o O f o G L 1 F J 2 i I W O O n d 8 / D 3 o H 3 q / m g 2 W 4 e 1 l S v s d D c R R v V 7 P 8 G z W w i c w = = &lt; / l a t e x i t &gt; <lb/>-------<lb/>((c:=ctr)inc) <lb/>n <lb/>• ((c:=ctr)dec) <lb/>m <lb/>• <lb/>(c:=ctr) • hh [c=ctr] • ctr:=c+1ii • ret(c) • <lb/>[c=ctr] dec <lb/>m <lb/>• [c=ctr] inc <lb/>n <lb/>&lt; l a t e x i t s h a 1 _ b a s e 6 4 = &quot; 2 y a f 4 K / + B O 3 n a C C u / y w H T G O a 2 7 Q = &quot; &gt; A A A D d H i c f V L L j t M w F H V T H k N 4 d W D B A h Y e 2 p F a a a Z q k H g I C W k E G x Y s B o n O j F S H y n G c 1 B r b i e w b R B X l B / g 8 V v A D 7 N m w x k 0 f 9 A F c y d L R v e f 4 + h w 5 y q W w M B h 8 b 3 j N K 1 e v X d + 7 4 d + 8 d f v O 3 d b + v T O b F Y b x I c t k Z i 4 i a r k U m g 9 B g O Q X u e F U R Z K f R 5 d v Z v P z T 9 x Y k e k P M M 1 5 q G i q R S I Y B d c a 7 z e + d D o + i X g q d E m N o d O q Z J V / P C 9 M i E 8 k T 6 D b J c A / A 0 D J X r 5 i Y K r e u B S a V c S I d A K 9 j 6 W u M G F x B v i f 9 J i v 0 d W K T k a B U q G / I 1 j e R n U q O T l Y g N G K V r P C m r X q g X H i 4 8 C t W a r m Y L l r x r N J a T h U f / Z V P b y Y 0 9 V r 5 i Z I 5 o K b 5 V p u r 6 0 2 7 a g N 7 / + V r Y e m s U + 4 j h e x + 5 3 O u N U e 9 A d 1 4 V 0 Q L E D 7 J P z x j n 6 L j k 7 H r a 8 k z l i h u A Y m q b W j Y J B D 6 C 4 E w S S v f F J Y n l N 2 S V M + c l B T x W 1 Y 1 p + m w o e u E + M k M + 5 o w H V 3 X V F S Z e 1 U R Y 6 p K E z s 9 m z W / N t s V E D y I n R O 8 w K 4 s 1 s v S g q J I c O z H 4 h j Y T g D O X W A M i P c W z G b U E M Z u H / q u x C C b c u 7 4 O x J P 3 j W f / r e p f E a z W s P P U S P U R c F 6 D k 6 Q W / R K R o i 1 v j p P f C w d + D 9 a j 5 q t p u H c 6 r X W G j u o 4 1 q 9 n 8 D 0 e g i d Q = = &lt; / l a t e x i t &gt; <lb/>-------<lb/>((c:=ctr)inc) <lb/>n <lb/>• ((c:=ctr)dec) <lb/>m <lb/>• <lb/>(c:=ctr) • hh [c=ctr] • ctr:=c-1ii • ret(c) • <lb/>[c=ctr] dec <lb/>m <lb/>• [c=ctr] inc <lb/>n <lb/>&lt; l a t e x i t s h a 1 _ b a s e 6 4 = &quot; Y f B A 1 9 m q w l v A o p L 2 D P k M j r t s k B I = &quot; &gt; A A A D D n i c b V L L j t M w F H X C a w i v D i z Z G K Z I r W C q B o m H k J B G s G H B Y p D o z E h 1 q B z 3 p r X G c S L 7 B l F F + Q I 2 / A o b F i D E l j U r + A G + A z f J F K b l S p G O 7 j n H 1 + f G c a 6 k x e H w l + e f O X v u / I W t i 8 G l y 1 e u X u t s X z + w W W E E j E S m M n M U c w t K a h i h R A V H u Q G e x g o O 4 + P n S / 7 w L R g r M / 0 a F z l E K Z 9 p m U j B 0 b U m 2 1 6 3 2 w 1 Y D D O p S 2 4 M X 1 S l q I L d p i h j A V O Q Y K / H E N 4 h Y i m e P B V o q v 6 k l F p U z M j Z H P t v S l 1 R J q Y Z O s c 4 T N M o 2 D C 0 t O J 6 p o D d a s F 4 J a t V U a 1 a 9 d A 4 8 9 3 Q j T l x N e B k 1 l J n k 9 I A V n / n V X 3 a 8 n x 1 m y Y E y 9 w m l o s q 1 8 d W p + N o G j D Q 0 3 Y h Q b c 7 6 e w M B 8 O 6 6 C Y I W 7 C z F / 1 + y X / G 9 / Y n n R 9 s m o k i B Y 1 C c W v H 4 T D H y B 2 I U i i o A l Z Y y L k 4 5 j M Y O 6 h 5 C j Y q 6 9 9 Z 0 T u u M 6 V J Z t y n k d b d f x 0 l T 6 1 d p L F T p h z n d p 1 b N v / H j Q t M H k c u a V 4 g u L j 1 o K R Q F D O 6 f B t 0 K g 0 I V A s H u D D S 3 Z W K O T d c o H t B g V t C u B 5 5 E x z c H 4 Q P B w 9 e u W 0 8 I 0 1 t k Z v k N u m R k D w i e + Q F 2 S c j I r z 3 3 k f v s / f F / + B / 8 r / 6 3 x q p 7 7 W e G + R U + d / / A E U 0 / c 4 = &lt; / l a t e x i t &gt; <lb/>-------<lb/>((c:=ctr)inc) <lb/>n <lb/>• <lb/>(c:=ctr) • hh [c=ctr] • ctr:=c+1ii • ret(c) • <lb/>[c=ctr] inc <lb/>n <lb/>Fig. 4. An expression representing a quotient of the Counter. For readability we present it as four sub-<lb/>expressions called &quot;layers&quot; whose composition with regular expression operators (concatenation, union, <lb/>star) is represented using an automaton (all states are accepting). The full formal definitions of an example <lb/>layer-from the quotient expression grammar-is given in Example 5.3. In this figure, for conciseness, we <lb/>subscript the primitives to indicate whether they were from increment-vs-decrement. Layer 1 represents <lb/>decrements acting alone and finding the counter to be 0, Layer 2 corresponds to the first successful increment, <lb/>Layer 3 and Layer 4 represent successful increments and decrements. For Layers 2 -4, some number of <lb/>threads begin to read then a single different thread performs its complete write path, and then all threads <lb/>fail their CAS instructions. Technically, Layer 2 is a specialization of Layer 3, by le ing = 0. However, <lb/>treating them as separate layers provides a more refined representation. <lb/>For example, in the first case of Def. 4.1, {( : x:=v), ( : x++)} ∈ x:=v • x++ . For an expression <lb/>(x:=r • y:=s • skip • s:=y+1 • r:=x+1 ), its interpretation includes traces such as <lb/>( 1 : x:=r), ( 2 : x:=r), ( 3 : y:=s), ( 4 : skip), ( 3 : s:=y+1), ( 2 : r:=x+1), ( 1 : r:=x+1) <lb/>Definition 4.2 (Abstractions of quotients). An expression expr ∈ Abs is called an abstraction of <lb/>an object quotient ⟨⌊ ⌋⟩ if ⟨⌊ ⌋⟩ ⊆ expr . <lb/>Example 4.3 (Abstraction of a Quotient of the Counter). An expression representing a quotient of <lb/>the counter is given in Figure 4. The following trace is in the interpretation of this expression (for <lb/>readability, we split the trace across lines, with segments labeled by layer names): <lb/>Layer 2 : 2 : ( := ) • 3 : ( := ) • ( 1 : ( := ) • 1 : ⟨ ⟨[ = ] • <lb/>:= + 1⟩ ⟩ • 1 : ret(0))• <lb/>3 : [ = ] • 2 : [ = ] • <lb/>Layer 3 : 3 : ( := ) • 2 : ( := ) • 2 : ⟨ ⟨[ = ] • <lb/>:= + 1⟩ ⟩ • 2 : ret(1) • 3 : [ = ]• <lb/>Layer 3 : 3 : ( := ) • 3 : ⟨ ⟨[ = ] • <lb/>:= + 1⟩ ⟩ • 3 : ret(2) <lb/>Linearizability. Each layer corresponds to linearizing a single effectful invocation, i.e., an increment <lb/>invocation or a decrement invocation when the counter is non-zero, or an arbitrary number of <lb/>read-only invocations, i.e., decrement invocations when the counter is zero. <lb/>5 LAYERS: AN INDUCTIVE QUOTIENT LANGUAGE <lb/>We show that, for a broad class of objects, we can provide a subclass of quotient abstraction <lb/>expressions-that we will call layer expressions-which, via an inductive argument, reduce reasoning <lb/>about all executions (and about linearizability) to two-threads. This applies to numerous canonical <lb/>examples such as Treiber Stack, the Michael-Scott Queue, a linked-list Set, and even the SLS <lb/>Reservation Queue. For illustrative purposes, we will continue to use the concurrent Counter, <lb/>whose quotient can also be expressed with layers. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:13 <lb/></page>

        <body>Many lock-free 4 objects rely on a form of optimistic concurrency control where an operation <lb/>repeatedly reads the shared-memory state in order to prepare an update that reflects the specification <lb/>and tries to apply a possible update using an atomic read-write. The condition of the atomic read-<lb/>write checks for possible interference from other threads since reading the shared-memory state. <lb/>The executions of such objects can be seen as sequences of what we call &quot;layers, &quot; each one being <lb/>a triple consisting of (i) many threads all performing commutative local (e.g., read) actions, (ii) a <lb/>single non-commutative atomic read-write ARW on the shared state, and (iii) those same initial <lb/>threads reacting to the ARW with more local commutative actions. For example, incrementing the <lb/>counter involves a successful cas operation on the shared variable, which leads to other threads&apos; <lb/>old reads to go down a failure/restart path. In fact, with this layer language one can consider an <lb/>arbitrary number of control-flow paths executed by an arbitrary number of threads where at most <lb/>one can contain an atomic read-write. In the remainder of this section we discuss this in detail and <lb/>then discuss automated discover of layers in Sec. 7. <lb/>5.1 Local-vs-Write Paths <lb/>For an implementation call ( ì ) • <lb/>∈ K of a method ( ì )/ì , a full (control-flow) path of <lb/>is a KAT expression such that ≤ <lb/>and contains only primitive actions, tests or ARWs, <lb/>composed together with • ( contains no + or * constructor). In a representation with control-flow <lb/>graphs of &apos;s code, corresponds to a path from the entry point to the exit point. A path is <lb/>any contiguous subsequence ′ of a full path , i.e., there exists (possibly empty) 1 and 2 such <lb/>that = 1 • ′ • 2 . The set of paths of method is denoted by Π( ), and as a straightforward <lb/>extension, the set of paths of an object defined by a set of methods <lb/>with 1 ≤ ≤ is defined <lb/>as Π( ) = 1≤ ≤ Π( ). Π ( ) denotes the subset of full paths in Π( ). <lb/>A primitive action is called local when it cannot affect actions or tests executed by another thread <lb/>(atomic read-writes included), e.g., it represents a read of a shared variable or it reads/writes a <lb/>memory region that has been allocated but not yet connected to a shared data structure (this region <lb/>is still owned by the thread). Formally, let <lb/>: (Σ × Σ ) → (Σ × Σ ) and <lb/>: (Σ × Σ ) → <lb/>{true, false} denote the functions defining the semantics of actions ∈ A and tests ∈ B. Then, <lb/>an action ∈ A is local iff for every ( ′ , ′ ) = <lb/>( , ) and every ∈ A ∪ B that occurs in some <lb/>method implementation, ( ′′ , ) = <lb/>( ′′ , ′ ), for every local state ′′ . <lb/>A path is called local if it contains only local actions, and a write path, otherwise. Given a KAT <lb/>expression ′ that represents a path, we use first ( ′ ) and last ( ′ ) to denote the first and the last <lb/>action or test in ′ , respectively. <lb/>Example 5.1. Returning to the counter object <lb/>, the full paths are as follows: <lb/>(c:=ctr) • [c=ctr] <lb/>(c:=ctr) • [c=0] • ret(0) <lb/>(c:=ctr) • ⟨ <lb/>⟨[c=ctr] • ctr:=c+1⟩ ⟩ • ret(c) (c:=ctr) • [c=ctr] <lb/>(c:=ctr) • ⟨ <lb/>⟨[c=ctr] • ctr:=c-1⟩ ⟩ • ret(c) <lb/>The first two paths are from <lb/>and the last three are from <lb/>. Paths without ARWs consist of <lb/>only local actions, that may read global ctr, but they do not mutate any global variables. <lb/>5.2 The Language of Layers <lb/>We now define layer expressions and discuss how they represent an object&apos;s quotient. <lb/>Definition 5.2 (Basic Layer Expressions). A basic layer expression has one of two forms: <lb/></body>

        <note place="footnote">4 Lock-freedom requires that at least one thread makes progress, if threads are run sufficiently long. A slow/halted thread <lb/>may not block others, unlike when using locks. <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:14 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>• local layer: ( ) * where is a local path in Π( ). <lb/>• write layer: ( <lb/>← -<lb/>1 ) 1 • ( <lb/>← -<lb/>2 ) 2 • • • ( <lb/>← -) <lb/>• <lb/>• ( <lb/>-<lb/>→ ) • ( <lb/>-<lb/>→ <lb/>-1 ) -1 • • • ( <lb/>-<lb/>→ <lb/>1 ) 1 , where <lb/>(1) <lb/>is a write path in Π( ), <lb/>(2) for each ∈ [1, ], <lb/>← -• <lb/>-<lb/>→ is a local path in Π( ) and the prefix and suffix are each <lb/>repeated times, <lb/>(3) last ( <lb/>← -) and first ( <lb/>-<lb/>→ ) do not commute with respect to the ARW in . <lb/>The first type, local layers, represent unboundedly many threads executing a local path . Since <lb/>each instance of the path is local, they all commute with each other, so the interpretation puts them <lb/>into a single, canonical order which follows the increasing order between their thread ids (by the <lb/>interpretation of * in quotient expressions; see Def. 4.1). <lb/>The second type, write layers, represents an interleaving where threads execute read-only <lb/>prefix <lb/>← -of paths (in a canonical, serial order), then a different thread executes a non-local path <lb/>, and then corresponding suffixes <lb/>-<lb/>→ occur, finishing their iteration reacting to the write of <lb/>. Again, the interpretation <lb/>of a write layer associates these KAT action labels with increasing <lb/>thread ids. Prefixes and suffixes of local paths can be assumed to execute serially as in the first <lb/>type of layer. The non-commutativity constraint ensures that such an interleaving is &quot;meaningful&quot;, <lb/>i.e., it is not equivalent to one in which complete paths are executed serially. <lb/>A layer expression is a collection of basic layer expressions, combined in a regular way via •, +, <lb/>or * (defined in Sec. 4). That is, a layer expression represents complete traces as sequences of layers. <lb/>Example 5.3. The expression given in Fig. 4 representing a quotient of the Counter is a layer <lb/>expression. It combines a single read-only layer with other three write layers. One layer <lb/>pertains to the increment write path, along with the local paths that fail their CAS attempts. Here, <lb/>we consider full paths. This basic expression <lb/>is: <lb/>≡ <lb/>⊙ <lb/>(c:=ctr) <lb/>(c:=ctr) <lb/>• (c:=ctr) • ⟨ ⟨[c=ctr] • ctr:=c+1⟩ ⟩ •ret(c) • ⊙ <lb/>[c=ctr] <lb/>[c=ctr] <lb/>⊛ <lb/>This layer interleaves the write path between prefixes/suffixes of the two local paths. We subscript <lb/>the primitives to indicate whether they were from increment-vs-decrement. The first and last <lb/>actions/tests do not commute with the interleaved writer&apos;s ARW. <lb/>Support of a Layer. The support of a basic layer expression , denoted by supp( ), is defined as a <lb/>set of KAT expressions where a single prefix/suffix local path is concretized to a single occurrence, <lb/>and interleaved with the write path. Intuitively, the support of a write layer characterizes all of the <lb/>pair-wise interference by representing interleavings of two paths executed by different threads. <lb/>Definition 5.4. For basic layer expression , supp( ) is defined as: <lb/>• If is a local layer = ( ) * , then supp( ) = { }. <lb/>• If is a write layer = ( <lb/>← -<lb/>1 ) 1 • ( <lb/>← -<lb/>2 ) 2 • • • ( <lb/>← -) <lb/>• • ( <lb/>-<lb/>→ ) • ( <lb/>-<lb/>→ <lb/>-1 ) -1 • • • ( <lb/>-<lb/>→ <lb/>1 ) 1 , <lb/>then supp( ) = { <lb/>← -• <lb/>• <lb/>-<lb/>→ | ∈ [1, ]}. <lb/>Example 5.5. For Layer 3 in Fig. 4 involving the increment write path <lb/>= (c:=ctr) • ⟨ <lb/>⟨[c=ctr] • <lb/>ctr:=c+1⟩ ⟩ • ret(c), supp(Layer 3) = {(c:=ctr) • <lb/>• [c=ctr] , (c:=ctr) • <lb/>• [c=ctr] }. <lb/>Here there are only two elements of the support, the first being a local path through increment and <lb/>the second being a local path through decrement. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:15 <lb/></page>

        <body>The paths Π( ) of a basic layer expression are defined from its support: (1) if is a local layer, <lb/>then Π( ) = supp( ), and (2) if is a write layer, then { , <lb/>← -• <lb/>-<lb/>→ } ⊆ Π( ) iff <lb/>← -• <lb/>• <lb/>-<lb/>→ is <lb/>included in supp( ). The paths Π(expr) of a layer expression expr is obtained as the union of Π( ) <lb/>for every basic layer expression in expr. <lb/>5.3 Proof Methodology with Two-Thread Reasoning <lb/>Recall that layer expressions represent languages of traces so we now ask whether a given expression <lb/>is an abstraction of an object&apos;s quotient (Def. 4.2). That is: whether each execution of an object is <lb/>equivalent to some execution ′ ≡ , where the trace of ′ is in the interpretation of the expression. <lb/>Interestingly, this can be done by considering only two threads at a time, since local paths do <lb/>not affect the feasibility of a trace. Therefore, it is sufficient to focus on interleavings between <lb/>a single local or write path (on a first thread) and a sequence ì of (possibly different) write <lb/>paths (on a second thread), and show that they can be reordered as a sequence of layers, i.e., <lb/>executes in isolation if it is a write path, and interleaved with at most one other write path in ì , <lb/>otherwise (it is a local path). Applying such a reordering for each path while ignoring other <lb/>local paths makes it possible to group paths into layers. The reordering must preserve a stronger <lb/>notion of equivalence defined as follows: two executions and ′ are strongly equivalent if they <lb/>are ≡-equivalent, they start and resp., end in the same configuration, and they go through the same <lb/>sequence of shared states modulo stuttering. This notion of equivalence guarantees that any local <lb/>path enabled in the context of an arbitrary interleaving between and ì remains enabled in the <lb/>context of an interleaving where for instance, executes in isolation. A more detailed proof for the <lb/>following theorem is given in the extended version [Enea et al. 2023]. <lb/>Theorem 5.6. Let be an object defined by a set of methods <lb/>with implementations call ( ì ) • <lb/>∈ K. A layer expression expr = ( 1 + . . . + ) * is an abstraction of a quotient of if <lb/>• the layers cover all statements in the implementation: Π(expr) ⊆ Π( ) and for each primitive <lb/>action, test or ARW in <lb/>for some , there exists a path in Π(expr) which contains , <lb/>• for every path ∈ Π(expr) and every execution of starting in a reachable configuration <lb/>that represents 5 an interleaving || ì , where ì is a sequence of write paths in Π(expr), <lb/>-Write Path Condition (WPC): if is a write path, there is an exec. ′ of s.t. ′ is strongly <lb/>equivalent to , and ′ represents a write path sequence ì 1 • • ì 2 where ì = ì 1 • ì 2 , <lb/>-Local Path Condition (LPC): if is a local path, there exists an execution ′ of such that ′ <lb/>is strongly equivalent to and <lb/> * ′ represents a path sequence ì 1 • • ì 2 where ì = ì 1 • ì 2 ( executes in isolation) and <lb/>is the support of a local layer , 1 ≤ ≤ , or <lb/> * a sequence ì 1 • 1 • • 2 • ì 2 where ì = ì 1 • • ì 2 and <lb/>is a write path ( interleaves <lb/>with a single write path ), and 1 • <lb/>• 2 ∈ supp( ) for some write layer , 1 ≤ ≤ . <lb/>Example 5.7 (Counter layers via two-thread reasoning). We now proceed to show that the starred <lb/>union of the basic layer expressions defined in Fig. 4 is an abstraction of a quotient. Concerning <lb/>WPC, a write path is of the form (c:=ctr) • ⟨ <lb/>⟨[c=ctr] • ctr:=c+1⟩ ⟩ • ret(c). Such paths can be <lb/>reordered to execute in isolation because the ARW is enabled only if the counter did not change <lb/>its value since the read, and therefore, the read c:=ctr can be reordered after any step of another <lb/></body>

        <note place="footnote">5 An execution represents an interleaving | | ì if it interleaves two sequences of steps labeled with symbols in and <lb/>ì , respectively (in the same order). An execution represents a path sequence ì when it is a sequence of steps labeled <lb/>with symbols in ì (in the same order). <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:16 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>thread that may occur until the ARW. Also, the return action is local and can be reordered to occur <lb/>immediately after the ARW. LPC holds because any &quot;late&quot; CAS failure (that occurs after more than <lb/>one successful CAS) would also fail if moved to the left (as explained in Example 3.4). <lb/>5.4 Automaton Representation of Layer <lb/>otients <lb/>A layer expression comprised simply of a starred union of basic layer expressions is not always <lb/>appealing since some layers are not enabled from some configurations. For instance, as shown <lb/>in Figure 4 for the Counter, the read-only &quot;decrement returning 0&quot; layer cannot occur after one <lb/>successful increment layer. (In formal notation, layer <lb/>0 of <lb/>in Example 5.3 is enabled only <lb/>when ctr is 0.) In other words, the starred starred union composition of layers can be refined <lb/>further to enforce certain orders in which layers can occur, by taking into account reachability. <lb/>We therefore describe a more convenient representation as a layer automaton, in which the <lb/>automaton states represent abstractions (sets) of concrete configurations in executions (as defined <lb/>in Sec. 2) and the transitions are labeled by basic layer expressions. Another example of such <lb/>an automaton was seen for the Michael-Scott queue in Fig. 1 in Sec. 1. Briefly, the control states <lb/>correspond to the configurations of the objects (e.g., , whether the MSQ is empty, tail is lagged, etc.), <lb/>and the transitions are labeled by basic layer expressions (e.g., , the &quot;Dequeue Succeed&quot; layer from <lb/>Fig. 1, in which one thread succeeds a CAS on the head pointer and other threads fail their CAS). <lb/>These layer automata are a convenient representation of the quotient and, as shown in Sec. 7, we <lb/>can derive candidate layer quotients represented as layer automata automatically from source code. <lb/>Definition 5.8 (Layer automaton). Given an object , a layer automaton is a tuple A = (Q, Q 0 , Λ, ) <lb/>where Q is a finite set of states representing abstractions (sets) of configurations of , Q 0 ⊆ Q is <lb/>the set of initial states, and ⊆ Q × 2 Λ × Q is a set of transitions labeled with basic layer expressions <lb/>(elements of Λ) with the constraint that an edge -→ ′ can only be one of two types: <lb/>(1) Unique self-loop: = 1 • • • is a sequence of ≥ 1 local layers, ′ = , and there are no <lb/>other self-loops <lb/>′ <lb/>-→ . <lb/>(2) Single write layer edges: = is a single write layer. <lb/>The interpretation of the automaton, denoted by A , as a layer expression is defined as <lb/>expected, except that the label of a self-loop is not starred. For instance, the interpretation of an <lb/>automaton consisting of a single state and self-loop -→ is defined as instead of * . <lb/>Theorem 5.9. Given an object and a layer automaton A = (Q, Q 0 , Λ, ), the layer expression <lb/>A is an abstraction of a quotient of if <lb/>• the starred union of the basic layer expressions labeling transitions of A is an abstraction of a <lb/>quotient of (Theorem 5.6), <lb/>• every initial configuration of is represented by some abstract state in Q 0 , and every reachable <lb/>configuration is represented by some abstract state in Q, <lb/>• for every layer in A , if there exists an execution representing from a reachable configu-<lb/>ration to a configuration ′ , then A contains a transition <lb/>′ <lb/>-→ where is an abstraction of <lb/>and ′ is an abstraction of ′ . <lb/>The automaton in Fig. 1 is a layer automaton for the MSQ (see Section 6.1 for more details). <lb/>Corollary 5.10. (To Thm. 3.5) If a layer expression expr is an abstraction of a quotient and there <lb/>is a linearization point mapping for every trace in expr that is robust against re-ordering, then the <lb/>object is linearizable. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:17 <lb/></page>

        <body>6 EVALUATION: VERIFYING CONCURRENT OBJECTS <lb/>As discussed in Sec. 1, our goal is to provide a formal foundation for the scenario-based linearizability <lb/>correctness arguments found in the distributed computing literature. To evaluate whether quotients <lb/>serve that purpose, we examined several diverse and challenging concurrent objects, listed below. <lb/>Concurrent Object <lb/>Quotient Features <lb/>Atomic counter <lb/>Sec. 2 <lb/>simple cas loop <lb/>Michael and Scott [1996] queue Sec. 6.1 <lb/>many cas, cleanup helping <lb/>Scherer III et al. [2006] queue <lb/>Sec. 6.2 <lb/>synchronous, mult. writes, LP helping <lb/>[Treiber 1986]&apos;s stack <lb/>Sec. 6.3 <lb/>simple cas loop <lb/>Hendler et al. [2004] stack <lb/>Sec. 6.3 <lb/>elimination, submodule, LP helping <lb/>Harris et al. [2002] RDCSS <lb/>Sec. 6.4 <lb/>mult. cas steps, phases <lb/>Herlihy and Wing [1990] queue Sec. 6.5 <lb/>future-dependent LPs <lb/>O&apos;Hearn et al. [2010] set <lb/>Ext. Ver. <lb/>lock-free traversal <lb/>For each object, we (i) determine whether quotients can be used for verification and (ii) revisit the <lb/>scenario-based correctness arguments given by the object&apos;s authors and compare those arguments <lb/>to the quotient. We discuss the quotients of most in this section (with bold Sec 6._ in the Quotient <lb/>column); further detail can be found in the appendix of the extended version [Enea et al. 2023]. <lb/>Results summary. As we show, all above algorithms can be captured with quotient expressions. <lb/>These expressions (i) capture the diverse features/complexities of these algorithms (per the Features <lb/>column), (ii) provide a succinct, formal foundation for the scenario-based arguments used by those <lb/>objects&apos; authors, (iii) organize unbounded interleavings into a form more amenable to reasoning, <lb/>(iv) make explicit the relationship between implementation-level contention/interference and <lb/>ADT-level transitions, and (v) provide a scenario proof for HWQ which did not have scenario <lb/>arguments. <lb/>6.1 The Michael/Sco <lb/>eue <lb/>Recall the implementation of MSQ, stored as a linked list from global pointers Q.head and Q.tail, <lb/>and manipulated as follows. (Some local variable definitions omitted for lack of space.) <lb/>1 int enq ( int v ){ loop { <lb/>2 node_t * node =...; <lb/>3 node -&gt; val = v ; <lb/>4 tail = Q . tail ; <lb/>5 next = tail -&gt; next ; <lb/>6 if ( Q . tail == tail ) { <lb/>7 <lb/>if ( next == null ) { <lb/>8 <lb/>if ( CAS (&amp; tail -&gt; next , <lb/>9 <lb/>next , node )) <lb/>10 <lb/>ret 1; <lb/>11 } } } } <lb/>1 int deq (){ loop { <lb/>2 int pval ; <lb/>3 head = Q . head ; tail = Q . tail ; <lb/>4 next = head -&gt; next ; <lb/>5 if ( Q . head == head ) { <lb/>6 <lb/>if ( head == tail ) { <lb/>7 <lb/>if ( next == null ) ret 0; <lb/>8 <lb/>} else { <lb/>9 <lb/>pval = next -&gt; val ; <lb/>10 <lb/>if ( CAS (&amp; Q -&gt; head , <lb/>11 <lb/>head , next )) <lb/>12 <lb/>ret pval ; <lb/>13 <lb/>} } } } } <lb/>Factored out tail advancement: <lb/>(see notes below) <lb/>1 adv (){ loop { <lb/>2 tail = Q . tail ; <lb/>3 next = tail -&gt; next ; <lb/>4 if ( next != null ){ <lb/>5 <lb/>if ( CAS (&amp; Q -&gt; tail , <lb/>6 <lb/>tail , next )) <lb/>7 <lb/>ret 0; <lb/>8 } <lb/>9 } } <lb/>Values are stored in the nodes between Q.head and Q.tail, with enq adding new elements <lb/>to the Q.tail, and deq removing elements from Q.head. During a successful CAS in enq, the <lb/>Q.tail-&gt;next pointer is changed from null to the new node. However, this new item cannot be <lb/>dequeued until adv advances Q.tail forward to point to the new node. A deq on an empty list <lb/>(when Q.head=Q.tail) returns immediately. Otherwise, deq attempts to advance Q.head and, if <lb/>success, returns the value in the now-omitted node. The original MSQ implementation includes the <lb/>adv CAS inside enq and deq iterations. We have done this for expository purposes and it is not <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:18 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>necessary. As we will see in Sec. 6.2, the SLS queue performs this tail (and head) advancing directly <lb/>in the enqueue/dequeue method implementation. <lb/>Quotient. The layer automaton that abstracts a quotient of MSQ, mentioned briefly in Sec. 1, is <lb/>shown in Fig. 1. The automaton states track whether Q.tail=Q.head and whether Q.tail-&gt;next <lb/>is null, in rounded dark boxes. Edges are labeled with layers (discussed below), defined to the right <lb/>in Fig. 1. The write operations in those layers induce the automaton state changes as shown by the <lb/>various edges between automaton states. For example, the Dequeue Succeed layer can move from <lb/>automaton state 2 to 1 . The three layers of the MSQ characterize three forms of interference: <lb/>The Dequeue Succeed layer occurs when a dequeue thread successfully advances the Q.head <lb/>pointer, causing concurrent dequeue CAS attempts to fail, as well as dequeue threads checking <lb/>on Line 5 whether Q.head has changed. (We abbreviate local paths using line numbers rather <lb/>than KAT expressions.) <lb/>The Advancer Succeed layer occurs when an advancer moves forward the Q.tail pointer, <lb/>causing concurrent advancer CAS attempts to fail, and causing concurrent enq threads to <lb/>find Q.tail changed on Line 6. <lb/>The Enqueue Succeed layer occurs when an enq thread successfully advances the Q.tail <lb/>pointer, causing concurrent enq threads to fail. <lb/>Naturally, some edges are not enabled. For example, there is no edge from 1 to 2 , because the <lb/>latter is not reachable from the former via a single write path/layer. Also, while there are outbound <lb/>edges from 1 , there is no layer involving a deq write operation (since the queue is empty). Some <lb/>non-local layers self-loop, such as the Dequeue Succeed layer self-loop at 4 . There are also four <lb/>local layers that self-loop. These involve local paths that return (e.g., Read Only Layer 1 where <lb/>deq returns because the queue is empty) or paths that loop while waiting (e.g., Read Only Layer 3 <lb/>where enq awaits the advancer thread). <lb/>Theorem 6.1. The above layer automaton is an abstraction of a quotient for Michael-Scott Queue. <lb/>Proof: Proof by the methodology of Def. 5.6. <lb/>The WPC condition requires that all write paths (that include successful CASs) can be reordered <lb/>to execute in isolation. This is a direct consequence of the semantics of a successful CAS which <lb/>checks that the value did not change since the last read of the written location. The deq successful <lb/>CAS on Q.head insures that Q.head did not change since it was read at Line 3, which also means <lb/>that its next pointer did not change (this pointer is written only once in enq() for every node in <lb/>the list). Therefore all actions on the deq path that includes the successful CAS can be reordered <lb/>to execute together at the place of reading Q.tail. Similarly the enq successful CAS ensures that <lb/>the actions between Line 5 and Line 8 can be reordered to occur together. Then, since the value of <lb/>Q.tail could not have changed without Q.tail-&gt;next first having been changed, Lines 2-4 can <lb/>also be reordered to occur together with the rest of the actions on this path. The case of the adv <lb/>write path is similar. <lb/>The LPC condition follows from the fact that CAS operations always change the value so it is <lb/>always possible to move a late &quot;failing&quot; CAS to the left so that it occurs after the first successful <lb/>CAS following the previous reads in the same iteration. <lb/>■ <lb/>Theorem 6.2. The Michael-Scott Queue is linearizable. <lb/>Proof: We show that the traces in the quotient are linearizable via a linearization-point mapping <lb/>which is robust against reorderings. Given a trace in the quotient (represented by the automaton <lb/>in Fig. 1), the linearization points are the successful CAS operations in the {Dequeue,Advancer} <lb/>Succeed layers (also in bold in the Fig. 1 layer definitions), as well as the action corresponding to <lb/>Line 7 in deq() which occurs in Read-Only Layer 1. The successful CAS operations are linearization <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:19 <lb/></page>

        <body>points of dequeues returning some enqueued value and enqueues, respectively, and Line 7 is the <lb/>linearization point of a dequeue returning empty. The validity of these linearization points can <lb/>be proved by induction on the number of layers. The induction hypothesis will relate the last <lb/>configuration of the quotient execution with a queue ADT state that is the sequence of elements <lb/>reachable from Q.head. For instance, the successful CAS in the Dequeue Succeed layer will remove <lb/>the first element in such a sequence which by the induction hypothesis is the oldest element in the <lb/>queue. <lb/>By the proof of the quotient&apos;s completeness (Theorem 6.1), successful CAS operations are never <lb/>reordered. The only linearization point labels that can be reordered are those corresponding to <lb/>Line 7 in deq() for a dequeue returning empty. It is easy to see that dequeues returning empty <lb/>commute in the queue specification, which implies that the above linearization-point mapping is <lb/>robust against a set of reorderings which is sufficient for this quotient. <lb/>■ <lb/>Comparison with the Authors&apos; Proof. We evaluated the quotient by comparing with the cor-<lb/>rectness arguments from Herlihy and Shavit [2008]. For lack of space, the following table gives <lb/>example elements of the correctness argument/proof from Herlihy and Shavit [2008], and identifies <lb/>where they occur in the quotient proof (see [Enea et al. 2023] for more details). <lb/>Proof Element <lb/>Herlihy and Shavit [2008] <lb/>Quotient Proof <lb/>ADT states <lb/>&quot;queue is nonempty, &quot; &quot;tail is lagged&quot; <lb/>ADT states, e.g. (Q.tail=Q.head <lb/>∧ Q.tail-&gt;next ≠ null) <lb/>Concurrent threads <lb/>&quot;some other thread&quot; <lb/>Superscripting (...) <lb/>Event order <lb/>&quot;only then&quot; <lb/>Arcs in the quo automaton <lb/>Thread-local step seq. &quot;reads tail, and finds the node that appears <lb/>to be last (Lines 12-13)&quot; <lb/>Layer paths, e.g., enq:2-6 <lb/>Linearization pts. <lb/>&quot;If this method returns a value, then its lin-<lb/>earization point occurs when it completes <lb/>a successful [CAS] call at Line 38, and oth-<lb/>erwise it is linearized at Line 33. &quot; <lb/>The successful CAS in the De-<lb/>queue Succeed Layer or Read-Only <lb/>Layer 1 <lb/>The layer quotient and, especially, the layer automaton helps make the Herlihy and Shavit [2008] <lb/>proof more explicit, without sacrificing the organization of the proof, for a few reasons. First, all of <lb/>the important ADT states are explicitly identified. Second, it can be determined, from each of them, <lb/>which layers are enabled as well as the target ADT states that are reached after each such layer <lb/>transition. This ensures that all cases are considered. Finally, linearization points are explicit in the <lb/>layer quotient, occurring once with each layer transition. <lb/>6.2 The SLS Synchronous Reservation <lb/>eue <lb/>The Scherer III et al. [2006] (SLS) queue builds on MSQ, but has some complications: queue operations <lb/>are synchronous (blocking), a single invocation can involve multiple sequentially composed write <lb/>paths that necessitate different layers, and linearization points must account for dequeuers arriving <lb/>before their corresponding enqueuer. <lb/>Implementation. Like MSQ, SLS has paths that read the head or tail pointer and subsequent <lb/>pointers, perform read validations and then attempt a CAS. Also like MSQ, enqueuers arriving <lb/>at an empty list (or list of items), attempt to append item nodes (and then try to advance the tail <lb/>pointer). Dequeuers arriving at a list of items, attempt to swap item node contents for null (and <lb/>then try to advance the head pointer). <lb/>SLS then has some further complexities. Dequeuers arriving at an empty list (or list of reservation <lb/>nodes) attempt to append reservation nodes (and attempt to advance tail). Enqueuers arriving at a <lb/>list of reservations, attempt to fulfill those reservations by swapping null for an item (and attempt <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:20 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>Dswap <lb/>Dswap <lb/>When the queue is a list of items <lb/>(enq appends items at tail, deq removes items at head) <lb/>When the queue is a list of reservations <lb/>(deq appends resv at tail, enq removes resv at head) <lb/>Layer <lb/>Definitions: <lb/>Layer <lb/>Automaton: <lb/>Eswap <lb/>Eswap <lb/>empty <lb/>head=tail <lb/>&gt;0 items <lb/>head good <lb/>tail good <lb/>&gt;0 items <lb/>head good <lb/>tail stale <lb/>&gt;0 items <lb/>head stale <lb/>tail good <lb/>&gt;0 items <lb/>head stale <lb/>tail stale <lb/>HR <lb/>TA <lb/>Eapp <lb/>TA <lb/>Eapp <lb/>HR <lb/>Eapp <lb/>&gt;0 reservs <lb/>head good <lb/>tail good <lb/>&gt;0 reservs <lb/>head good <lb/>tail stale <lb/>&gt;0 reservs <lb/>head stale <lb/>tail good <lb/>&gt;0 reservs <lb/>head stale <lb/>tail stale <lb/>HR <lb/>TA <lb/>Dapp <lb/>TA <lb/>Dapp <lb/>HR <lb/>Dapp <lb/>Tail advance (TA) <lb/>DE:cas()/t with (3 fail paths)* <lb/>DE&apos;:cas()/t with (3 fail paths)* <lb/>Head reap (HR) <lb/>DE:cas()/t with (9 fail paths)* <lb/>DE&apos;:cas()/t with (9 fail paths)* <lb/>DE&apos;:cas()/t with (9 fail paths)* <lb/>Enq swap res for item (Eswap) <lb/>with (2 fail paths)* <lb/>Enq append item node (Eapp) <lb/>(3t) <lb/>with (1 fail path)* <lb/>Deq swap item for null (Dswap) <lb/>with (2 fail paths)* <lb/>Deq append reservation (Dapp) <lb/>(3t) <lb/>with (1 fail path)* <lb/>DE:cas 1 /t <lb/>DE:cas 3&apos; /t <lb/>E:cas 3 /t <lb/>DE:cas 3&apos;&apos; /t <lb/>DE:cas 6 /t <lb/>DE:cas 7 /t <lb/>D:cas 3 /t <lb/>DE:cas 5 /t <lb/>DE:cas 5 /t <lb/>Fig. 5. Layer automaton for the synchronous SLS queue. Layers&apos; acronyms and their definitions are given in <lb/>the lower half of the figure. For conciseness, layer definitions do not split the prefix/suffix of the read paths. <lb/>to advance head). The list never contains both items and reservations; when the list becomes <lb/>empty it can then transition from an item list to a reservation list (or vice-versa). Finally, SLS is <lb/>synchronous: dequeuers with reservations block until those reservations have been fulfilled and <lb/>enqueuers with items block until those items have been consumed. (For the sake of comprehen-<lb/>siveness, the implementation is in the extended version [Enea et al. 2023], but not necessary for <lb/>a general understanding.) As noted, unlike MSQ where paths have at most 1 write operation, <lb/>a single SLS invocation can perform multiple write operations (e.g., a dequeue path inserting a <lb/>reservation, advancing tail, awaiting fulfillment, advancing head). Despite conceptual simplicity, <lb/>the implementation is non-trivial with many restart paths when validations or CAS operations fail. <lb/>Quotient. The quotient expression for the SLS queue is depicted as a layer automaton in Fig. 5. <lb/>In the upper portion, the automaton states differentiate between whether the queue is empty or <lb/>whether the queue consists of reservations (left hand region) or of items (right hand region). In <lb/>each of those regions, it is relevant as to whether the head pointer is stale or not, as well as whether <lb/>the tail pointer is stale or not. When the queue is a list of reservations, the head or tail could be <lb/>stale (hence four states) and similar when the queue is a list of items. <lb/>The basic layers of the quotient expression are defined at the bottom of Fig. 5. The black circles <lb/>(e.g., DE:CAS ℓ /t ) represent a write path in which a Dequeuer or Enqueuer has successfully per-<lb/>formed a CAS at some program location ℓ. Along with the write path, we simply summarize the <lb/>number of competing read-only paths, which are star-iterated. Two layers are enq/deq-agnostic: <lb/>advancing the tail pointer in TA and advancing the head pointer (and &quot;reaping&quot; the head node) in <lb/>HR. These helping operations happen in many places in the code, with corresponding read-only <lb/>&quot;_f&quot; failure paths. Enqueue can either append an item node (Eapp) when in the RHS states of the <lb/>automaton or else swap an item into a reservation node (Eswap) in the LHS. These layers have a <lb/>single CAS operation (e.g., E:CAS 5 /t ) along with read-only paths where concurrent competing <lb/>threads fail. The dequeue layers Dapp and Dswap are similar. <lb/>Finally, these (context-free) basic layer expressions are connected into an overall expression, <lb/>represented here as an automaton or (below) as a star-/plus-/or-combination of layer expressions. <lb/>Theorem 6.3. The SLS queue is linearizable. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:21 <lb/></page>

        <body>Proof: We associate linearization points with layers: Dswap is an LP for dequeue, Eapp is an LP <lb/>for enqueue, and Eswap is an LP for a combination of an enqueue followed by a dequeue. Next, we <lb/>project the linearization points out of the quotient to obtain simply ( • ) * • ( * + * ). Combining <lb/>this with a lemma that this expression is an abstraction of the quotient, we obtain that all executions <lb/>in the quotient meet the sequential spec. of a queue. This linearization point mapping is also robust <lb/>because successful CASs (linearization points) do not have to be swapped in order to prove the <lb/>completeness of the quotient. (Detail in the extended version [Enea et al. 2023].) <lb/>■ <lb/>Comparison with the Authors&apos; Proof. We evaluated the SLS quotient expression by revisiting <lb/>the authors&apos; proof in Scherer III et al. [2006]. Line numbers in the authors&apos; quotes below refer to <lb/>a reproduction of the source code given in in the extended version [Enea et al. 2023]. For lack of <lb/>space, some discussion of the authors&apos; quotes can be found in the extended version [Enea et al. <lb/>2023]. <lb/>The authors split the enqueue operation into two linearization points: a &quot;reservation linearization <lb/>point&quot; and a later &quot;follow up linearization point, &quot; so that synchronous, blocking enqueue implemen-<lb/>tations are a single reservation LP and then repeated follow-up LPs (as if the client is repeatedly <lb/>checking whether the operation has completed). <lb/>[Regarding enqueue,] the reservation linearization point for this code path occurs at line [...] <lb/>when we successfully insert our offering into the queue -Scherer III et al. [2006] <lb/>This prose describes a scenario, (i) identifying an alleged linearization point at E:cas 3 /t , involving <lb/>a specific change to shared memory (a CAS on the tail&apos;s next pointer), and (ii) identifying the <lb/>important ADT state transition (inserting an offer node into the queue). This scenario is formalized <lb/>by the Eapp layer in the quotient expression. The successful CAS E:cas 3 /t in Eapp is the <lb/>linearization point, with competing concurrent threads abstracted away by the starred fail path <lb/>expression, and the state transition is given in the automaton as the downward Eapp-labeled arcs <lb/>in the righthand region of the automaton. The scenario and LP for dequeue on a list of reservation <lb/>nodes is symmetric, and represented in the quotient expression as layer Dapp involving D:cas 3 /t <lb/>and competing fail path. <lb/>The quotient expression makes the interaction between LPs and ADT states more explicit <lb/>(e.g., through -marked layers) and comprehensive (e.g., the authors do not discuss the 9 different <lb/>automaton ADT states and which transitions are possible from each). The quotient expression can <lb/>be seen as an abstract view of an implementation of the sequential specification. <lb/>The other case occurs when the queue consists <lb/>of reservations (requests for data), and is de-<lb/>picted [to the right]. In this case, after originally <lb/>reading the head node (step A), we read its suc-<lb/>cessor (line [...]/step B) and verify consistency <lb/>(line [...]). Then, we attempt to supply our data to <lb/>the head-most reservation (line [...]/C). If this suc-<lb/>ceeds, we dequeue the former dummy node ([...]/D) <lb/>and return <lb/>This prose again indicates important mutations (e.g., swapping the node&apos;s contents pointer), ADT <lb/>state changes (e.g., supplying data) and that the head dummy node needs to be advanced. These <lb/>memory mutations and state changes are explicit in the quotient expression. For example, Eswap <lb/>performs a memory CAS and makes a ADT state transition. The staleness of the head is also <lb/>captured directly in the ADT states and the HR layers&apos; transitions. The authors&apos; prose also discusses <lb/>failure paths (see [Enea et al. 2023]) and retry, which are also captured in the layer definitions. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:22 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>1 void push / pop ( descriptor p ){ while (1) { <lb/>2 <lb/>one iteration of Treiber stack <lb/>3 <lb/>location [ mytid ] = p ; <lb/>4 <lb/>pos = nondet (); <lb/>5 <lb/>do { him = collision [ pos ] <lb/>6 <lb/>} while (! CAS (&amp; collision [ pos ] , him , mytid )) <lb/>7 <lb/>if him != NULL { <lb/>8 <lb/>q = location [ him ] <lb/>9 <lb/>if ( q != NULL &amp; q . id = him &amp; p . op != q . op ) { <lb/>10 <lb/>if ( CAS (&amp; location [ mytid ] ,p , NULL )) { <lb/>11 <lb/>if ( CAS (&amp; location [ him ] , q , p / NULL ) ) <lb/>12 <lb/>return NULL / q . input <lb/>13 <lb/>else continue <lb/>14 <lb/>} else { <lb/>15 <lb/>val = NULL / location [ mytid ]. input ; <lb/>16 <lb/>location [ mytid ] = NULL ; <lb/>17 <lb/>return val <lb/>18 <lb/>} } } <lb/>19 <lb/>if (! CAS (&amp; location [ mytid ] ,p , NULL )) { <lb/>20 <lb/>val = NULL / location [ mytid ]. data ; <lb/>21 <lb/>location [ mytid ] = NULL ; <lb/>22 <lb/>return val <lb/>23 }} } <lb/>(a) Elimination Stack source code <lb/>(b) Stack Quotients <lb/>Fig. 6. Elimination Stack <lb/>Summary. The layer quotient expression/automaton provides a succinct formal foundation for <lb/>the correctness arguments of Scherer III et al. [2006], capturing the authors&apos; discussions of LPs, <lb/>ADTs, impacts of writes, CAS contention, etc. <lb/>6.3 The Hendler et al. Elimination Stack <lb/>The Elimination Stack of Hendler et al. [2004] is difficult because the linearization point of some <lb/>invocation can happen in another (threads can awake to find they were linearized earlier) and it <lb/>uses a submodule: Treiber&apos;s stack [Treiber 1986]. <lb/>We first show the Treiber&apos;s stack quotient, and then build elimination on top. Since Treiber&apos;s <lb/>stack is simple, we explain only the basics here, with more detail in the extended version [Enea <lb/>et al. 2023]. The implementation of push prepares a new node and then attempts a CAS to swing <lb/>the top pointer, while pop attempts to advance the top pointer and return the removed node&apos;s <lb/>value. The quotient for Treiber&apos;s stack is shown in the upper right of Fig. 6 and is similar to the <lb/>counter, but with ADT states tracking emptiness (rather than non-zeroness) and CAS contention <lb/>on the top pointer (rather than the counter cell). There is one read-only layer for a pop and an <lb/>empty stack, and other layers involve one successful CAS with failed competing CAS attempts. <lb/>See [Enea et al. 2023] for more detail, as well as a lemma proving that this layer automaton is an <lb/>abstraction of the quotient. <lb/>The Elimination Stack, listed in Fig. 6(a), augments Treiber&apos;s stack with a protocol for &quot;colliding&quot; <lb/>push and pop invocations so that the push passes its input directly to the pop without affecting <lb/>the underlying data structure. An invocation starts this protocol after performing a loop iteration <lb/>in Treiber&apos;s stack and failing (due to contention on top). The protocol uses two arrays: (1) a <lb/>location array indexed by thread ids where a push or pop invocation publishes a descriptor tuple <lb/>(op,id,input) with fields op for the type of invocation (push or pop), id for the id of the invoking <lb/>thread, and input for the input of a push operation, and (2) a collision array indexed by arbitrary <lb/>integers which stores ids of threads announcing their availability to collide. <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:23 <lb/></page>

        <body>Each invocation starts by publishing their descriptor in the location array (line 3). Then, it <lb/>reads a random cell of the collision array while also trying to publish their id at the same index <lb/>using a CAS (lines 4-6). If it reads a non-NULL thread id, then it tries to collide with that thread. A <lb/>successful collision requires 2 successful CASs on the location cells of the two threads (we require <lb/>CASs because other threads may compete to collide with one of these two threads): the initiator of <lb/>the collision needs to clear its cell (line 10) and modify the cell of the other thread (line 11) to pass <lb/>its input if the other thread is a pop. The first CAS failing means that a third thread successfully <lb/>collided with the initiator and the initiator can simply return (lines 15-17). Failing the second CAS <lb/>leads to a restart (line 13). Succeeding the second CAS means there has been a successful collision <lb/>and the thread returns, returning null for a push and otherwise using the descriptor to obtain the <lb/>popped value (line 11). If the invocation reads a NULL thread id from collision, then it tries to <lb/>clear its cell before restarting (line 19). If it fails, then as in the previous case, a collision happened <lb/>with a third thread and the current thread can simply return (line 20-22). <lb/>Quotient. We use the automaton in the lower right of Fig. 6 to describe a sound abstraction <lb/>of the quotient. Layers of Treiber&apos;s stack interleave with layers of the collision protocol (some <lb/>components are not exactly layers as in Definition 5.2, but quite similar). Executions in the quotient <lb/>serialize collisions and proceed as follows: (1) some number of threads publish their descriptor <lb/>and choose a cell in the collision array, (2) some number of threads publish their id in the <lb/>collision array (there may be more than one such thread -note the self-loop on the &quot;Publish <lb/>collision intent&quot; state), (3) some number of threads succeed the CAS to clear their location cell <lb/>but only one succeeds to also CAS the location cell of some arbitrary but fixed thread him and <lb/>return, and (4) the thread him returns after possibly passing the tests at line 7 or 9. (Note that, for <lb/>succinctness, we have combined push/pop into the same method, which also makes the automaton <lb/>succinct. The code and corresponding automaton could also have been written in a more verbose <lb/>way where the bottommost layer is replaced with two layers: (1) a layer where a push&apos;s successful <lb/>CAS takes with it a corresponding pop, and (2) a layer where a pop&apos;s successful CAS takes with <lb/>it a corresponding push. For succinctness, we have combined those layers using the &quot;push/pop&quot; <lb/>notation.) We emphasize that collisions happen in a serial order, i.e., at any point there is exactly <lb/>one thread that succeeds on both CASs required for a collision and immediately after the collided <lb/>thread returns (publishing descriptors or collision intent interleaves arbitrarily with collisions). <lb/>Theorem 6.4. The Elimination Stack is linearizable. <lb/>Proof: Follows from the fact that the above expression is an abstraction of the quotient (See Enea <lb/>et al. [2023]), with the bold actions in the layers being the LPs. <lb/>■ <lb/>Comparison with the Authors&apos; Proof. A proof is given by Hendler et al. [2004] in that paper&apos;s <lb/>Section 5. It is a lengthy proof so, for lack of space, the full review is in in the extended version [Enea <lb/>et al. 2023] and summarized here. Overall, the correctness argument requires numerous lemmas <lb/>in the Hendler et al. [2004] proof, mostly focused on establishing a bijection between the active <lb/>thread and its correspondingly collided passive thread. The authors lay out a few definitions, which <lb/>are also captured by the quotient. For example, the authors&apos; prose includes: <lb/>[A] colliding operation op is active if it executes a successful CAS in lines C2 or C7. We say that <lb/>a colliding operation is passive if op fails in the CAS of line S10 or S19. [underlines added] -<lb/>Hendler et al. [2004] <lb/>Above the authors&apos; intuitive concept of &quot;active&quot; is captured by the paths in a layer that succeed their <lb/>CAS, denoted in bold in the quotient automaton above. Likewise for &quot;passive&quot; and CAS failure. <lb/>As mentioned above, the active thread is captured as the bold thread that succeeds its CAS in the <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:24 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>bottommost layer; the passive thread is the thread that finds itself collided with in the layers on <lb/>arcs exiting the bottommost layer. <lb/>we show that push and pop operations are paired correctly during collisions. Lemma 5.7. Every <lb/>passive collider collides with exactly one active collider. <lb/>The bottommost layer in the bold action, a single push or pop succeeds, colliding with another <lb/>operation of the oppose type, and passing the element from the push to the pop. <lb/>Authors&apos; LPs are given for &quot;active&quot; threads as the time when the second CAS succeeds, and <lb/>linearization points for &quot;passive&quot; threads &quot;the time of linearization of the matching active-collider <lb/>operation, and the push colliding-operation is linearized before the pop colliding-operation. &quot; The <lb/>linearization points in the quotient correspond to the bold successful CAS in the bottommost layer <lb/>in the quotient automaton (this linearizes both a push and a pop). Importantly, every run of the <lb/>quotient automaton gives a serial linearization order that is a repetition of pairs of active/passive <lb/>threads. All other executions are equivalent to one such serialized run, upto commutativity. <lb/>In summary, as detailed in the extended version [Enea et al. 2023], the quotient naturally and <lb/>succinctly captures the key concept of the Elimination stack: that a single successful CAS of one <lb/>type of operation is the LP for that operation as well as the corresponding matched operation. The <lb/>quotient captures &quot;active&quot; versus &quot;passive&quot; threads (in the automaton layers/states/transitions), <lb/>as well as this bijection through the runs of the automaton: every run in the automaton contains <lb/>some number of active/passive pairs and provides a representative serialization order (in each <lb/>pair the push is serialized before the pop). Linearization points and other logistics of threads <lb/>preparing/completing are similarly captured by the quotient automaton. <lb/>6.4 The Harris et al. Restricted Double-Compare Single-Swap (RDCSS) <lb/>RDCSS [Harris et al. 2002] is a restricted version of a double-word CAS which modifies a so-called <lb/>data address provided that this address and another so-called control address have some given <lb/>expected values (the tests and the write happen atomically). RDCSS attempts a standard CAS on the <lb/>data address to change the old value into a pointer to a descriptor structure that stores the inputs <lb/>of the operation. This fails if the data address does not have the expected value. A second standard <lb/>CAS on the data address is used to write the new value if the control address has the expected <lb/>value or the old value, otherwise. Faster threads can help complete the operations of slower threads <lb/>using the information stored in the descriptor. <lb/>The traces in the quotient of RDCSS interleave successful attempts at modifying the data address <lb/>with unsuccessful ones. A successful attempt consists of a thread succeeding the first CAS combined <lb/>with competing threads that fail, followed by another thread succeeding the second CAS (this <lb/>can be different from the first one in the case of helping) combined with other threads that fail. <lb/>An unsuccessful attempt may contain just a thread failing the first CAS, or it can contain two <lb/>successful CASs like a successful attempt (when the data address has the expected value but the <lb/>control address does not). Proving linearizability of quotient traces is obvious because they make <lb/>explicit the &quot;evolution&quot; of a data address, oscillating between storing values and descriptors, and <lb/>which CAS is enabled depending on the value of the control address. See Enea et al. [2023] for more <lb/>details. <lb/>6.5 The Herlihy-Wing <lb/>eue <lb/>The quotients of some data structures cannot be represented using layer automata. The Herlihy-<lb/>Wing Queue [Herlihy and Wing 1990] is one such example and it is notorious for linearization points <lb/>that depend on the future and that cannot be associated to fixed statements, see e.g. Schellhorn et al. <lb/>[2012]! The queue is implemented as an array of slots for items, with a shared variable back that <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:25 <lb/></page>

        <body>indicates the last possibly non-empty slot. An enq atomically reads and increments back and then <lb/>later stores a value at that location. A deq repeatedly scans the array looking for the first non-empty <lb/>slot in a doubly-nested loop. We show that the Herlihy-Wing queue quotient can be abstracted <lb/>by an expression (deqF * • (enqI) + • enqW * • deqT * ) * , where deqF captures dequeue scans that need <lb/>to restart, deqT scans succeed, enqI reads/increments back and enqW writes to the slot. For lack <lb/>of space, a detailed discussion about how this expression abstracts the quotient is given in the <lb/>extended version [Enea et al. 2023]. Importantly, linearization points in executions represented by <lb/>this expression are fixed, drastically simplifying reasoning from the general case where they are <lb/>non-fixed. <lb/>Theorem 6.5. The Herlihy-Wing Queue is linearizable. (see Enea et al. [2023]) <lb/>Comparison with the Authors&apos; Proof. Herlihy and Wing [1990] give intuitions of scenarios: <lb/>Enq execution occurs in two steps, which may be interleaved with steps of other concurrent <lb/>operations: an array slot is reserved by atomically incrementing back, and the new item is stored <lb/>in items. -Sec 4.1 of Herlihy and Wing [1990] <lb/>This describes a scenario with unboundedly many threads, though is not yet an argument for <lb/>why that scenarios is correct. This scenario appears in the quotient as the fact that enqI and enqW <lb/>are distinct. To cope with non-fixed LPs (in this and other objects), the authors introduce a proof <lb/>methodology based on tracking all possible linearizations that could happen in the future. This <lb/>general methododology complicates the proof. The quotient, by contrast, allows one to consider <lb/>scenarios along the lines of &quot;one or more enqueuers increment back, possibly some of them <lb/>write to the array, and then some dequeuers succeed, &quot; following the quotient&apos;s regular expression. <lb/>In summary, the quotient here provides the first scenario-based proof of correctness, through <lb/>representative executions that allow the linearization order to be fixed and all other executions are <lb/>equivalent to one such representative execution up to commutativity. <lb/>7 GENERATING CANDIDATE QUOTIENT EXPRESSIONS <lb/>In Sec. 6 we showed quotients can be defined for a wide range of concurrent objects, including <lb/>notoriously difficult ones. We leave the (rather large) question of automated quotient proofs for the <lb/>general case as future work. Here we take a first step asking, Can candidate quotient expressions can <lb/>be generated algorithmically? <lb/>This section answers this question with an algorithm, implementation and experiments showing <lb/>that, from the source code of concurrent data-structures such as Treiber&apos;s stack and the MSQ, <lb/>candidate quotients expressions (equivalent to those in Sec. 6) can be automatically discovered. We <lb/>manually confirmed that these generated candidates are indeed sound abstractions of the quotient, <lb/>a process that can also be automated (perhaps through new forms of induction) in future work. <lb/>7.1 Computing Layer Automata <lb/>Given a set of layers 1 ,. . ., whose starred union is an abstraction of an object quotient (cf. <lb/>Theorem 5.6), a layer automaton satisfying Theorem 5.9 can be computed automatically. The <lb/>algorithm consists of the following steps: <lb/>(1) States: Compute the automaton abstract states as boolean conjunctions of the weakest pre-<lb/>conditions (and their negations) of traces in the support of a layer with 1 ≤ ≤ . We <lb/>assume that the initial state can be determined from the object spec. <lb/>(2) Edges: Whenever a state implies the precondition of a write layer with write path , <lb/>compute every post-state ′ that can hold, and add an edge -→ ′ . This can be encoded as <lb/>an assertion violation in a program that assumes ; <lb/>and asserts the negation of ′ . <lb/></body>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:26 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <body>Table 1. Evaluation of Cion discovering candidate layers from source code. <lb/>States <lb/># Paths <lb/># Trans. # Layers Time # Solver <lb/>Example <lb/>| Q | <lb/># <lb/># <lb/>| | <lb/>| Λ( ) | <lb/>(s) Queries <lb/>evenodd.c <lb/>2 <lb/>2 <lb/>2 <lb/>6 <lb/>3 <lb/>52.2 <lb/>32 <lb/>counter.c <lb/>2 <lb/>3 <lb/>2 <lb/>6 <lb/>5 <lb/>67.8 <lb/>36 <lb/>descriptor.c <lb/>4 <lb/>6 <lb/>2 <lb/>6 <lb/>6 <lb/>160.2 <lb/>74 <lb/>treiber.c <lb/>2 <lb/>3 <lb/>2 <lb/>6 <lb/>5 <lb/>71.4 <lb/>37 <lb/>msq.c <lb/>4 <lb/>9 <lb/>3 <lb/>17 <lb/>7 <lb/>441.6 <lb/>314 <lb/>listset.c <lb/>7 <lb/>6 <lb/>2 <lb/>59 <lb/>7 <lb/>603.8 <lb/>494 <lb/>(3) Self-Loops: For every state collect every local layer that is enabled from and create a single <lb/>self-loop consisting of a concatenation of all these layers. <lb/>7.2 Implementation and Experiments <lb/>We built a proof-of-concept implementation of our algorithm, called Cion in ∼1,000 lines of OCaml <lb/>code, using CIL and Ultimate [Heizmann et al. 2018]. Cion is publicly available 6 . We applied Cion <lb/>to some of the Sec. 6 objects that were amenable to layers. Experiments were run on Ubuntu 22.04 <lb/>within a Parallels VM on a MacBook Pro M2 with 32GB RAM. Benchmarks are available in Cion <lb/>repository. We used Ultimate v0.2.1 (54a68f4) as a reachability solver, with its default configuration. <lb/>The results are summarized in Table 1. For each benchmark, we report the number of automaton <lb/>States | Q |, the number of local Paths # and number of write paths # . We then report the <lb/>number of Transitions | | in the automata constructed by Cion and the number of Layers, as well <lb/>as the wall-clock Time in seconds, and the number of Queries made to the solver (Ultimate). The <lb/>results show that Cion is able to efficiently generate candidate layer automata for some important <lb/>and challenging concurrent objects. <lb/>8 RELATED WORK <lb/>Linearizability proofs. Program logics for compositional reasoning about concurrent programs <lb/>and data structures have been studied extensively, as mentioned in Sec. 1.1. Improving on the <lb/>classical Owicki and Gries [1976] and Rely-Guarantee [Jones 1983] logics, numerous extensions of <lb/>Concurrent Separation Logic [Bornat et al. 2005; Brookes 2004; O&apos;Hearn 2004; Parkinson et al. 2007] <lb/>have been proposed in order to reason compositionally about different instances of fine-grained <lb/>concurrency, e.g. [da Rocha Pinto et al. 2014; Dragoi et al. 2013; Jung et al. 2018, 2020; Krishna et al. <lb/>2018; Ley-Wild and Nanevski 2013; Nanevski et al. 2019; Raad et al. 2015; Sergey et al. 2015; Turon <lb/>et al. 2013; Vafeiadis 2008, 2009]. We build on the success of such program logics toward improving <lb/>the confidence in the correctness of concurrent objects. In the current paper we alternatively focus <lb/>on the scenario-based reasoning found in the distributed computing literature, and have aimed to <lb/>capture those scenarios as formally-defined representative executions. In future work it could be <lb/>interesting to combine the benefits of program logics with those of quotients. Other more distantly <lb/>related works include: Berdine et al. [2008], Vafeiadis [2010], Bouajjani et al. [2013], Chakraborty <lb/>et al. [2015], Zhu et al. [2015], and Abdulla et al. [2016]. <lb/>Reduction. The reduction theory of Lipton [1975] introduced the concept of movers to define <lb/>a program transformation that creates atomic blocks of code. QED [Elmas et al. 2009] expanded <lb/>Lipton&apos;s theory by introducing iterated application of reduction and abstraction over gated atomic <lb/>actions. CIVL [Hawblitzel et al. 2015] builds upon the foundation of QED, adding invariant reasoning <lb/>and refinement layers [Kragl and Qadeer 2018; Kragl et al. 2018]. Reasoning via simplifying program <lb/></body>

        <note place="footnote">6 https://github.com/quotientprovers/cion <lb/></note>
        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:27 <lb/></page>

        <body>transformations has also been adopted in the context of mechanized proofs, e.g., [Chajed et al. 2018]. <lb/>Inductive sequentialization [Kragl et al. 2020] builds upon this prior work, and introduces a new <lb/>scheme for reasoning inductively over unbounded concurrent executions. The main focus of these <lb/>works is to define generic proof rules to prove soundness of such program transformations, whose <lb/>application does however require carefully-crafted artifacts such as abstractions of program code <lb/>or invariants. Our work takes a different approach and tries to distill common syntactic patterns <lb/>of concurrent objects into a simpler reduction argument. Our reduction is not a form of program <lb/>transformation since quotient executions are interleavings of actions in the implementation. <lb/>9 CONCLUSION <lb/>We have shown that scenario-based reasoning about concurrent objects has a formal grounding, <lb/>answering an open question. The key insight is the concept of a quotient, defined so that it admits <lb/>only representative traces and all other traces are merely equivalent to one of those representatives, <lb/>up to commutativity. We then gave a language for finitely expressing abstractions of those quotients <lb/>(as regular or context-free languages) and an inductive and automata-theoretical way of describing <lb/>them. Our results show that quotients provide a succinct formal foundation for scenario-based <lb/>reasoning, are capable of capturing a wide range of tricky objects, enhance original authors&apos; <lb/>correctness arguments, and that discovery of candidate quotient expressions can be automated. In <lb/>the future will explore further mechanization and other application domains. <lb/></body>

        <div type="availability">DATA-AVAILABILITY STATEMENT <lb/>Software that supports Sec. 7 is available on GitHub [Enea et al. 2024] and Zenodo [Koskinen 2024]. <lb/></div>

        <div type="acknowledgement">ACKNOWLEDGMENTS <lb/>We thank Matthew Parkinson and the anonymous reviewers for their feedback on this draft. <lb/>Koskinen was partially supported by NSF award CCF-2008633 and NSF award CCF-2315363. Enea <lb/>was partially supported by ANR award SCEPROOF. <lb/></div>

        <listBibl>REFERENCES <lb/>Parosh Aziz Abdulla, Bengt Jonsson, and Cong Quy Trinh. 2016. Automated Verification of Linearization Policies. In Static <lb/>Analysis -23rd International Symposium, SAS 2016, Edinburgh, UK, September 8-10, 2016, Proceedings (Lecture Notes in <lb/>Computer Science, Vol. 9837), Xavier Rival (Ed.). Springer, 61-83. https://doi.org/10.1007/978-3-662-53413-7_4 <lb/>Josh Berdine, Tal Lev-Ami, Roman Manevich, G. Ramalingam, and Shmuel Sagiv. 2008. Thread Quantification for Concurrent <lb/>Shape Analysis. In Computer Aided Verification, 20th International Conference, CAV 2008, Princeton, NJ, USA, July 7-14, <lb/>2008, Proceedings (Lecture Notes in Computer Science, Vol. 5123), Aarti Gupta and Sharad Malik (Eds.). Springer, 399-413. <lb/>https://doi.org/10.1007/978-3-540-70545-1_37 <lb/>Richard Bornat, Cristiano Calcagno, Peter W. O&apos;Hearn, and Matthew J. Parkinson. 2005. Permission accounting in separation <lb/>logic. In Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2005, <lb/>Long Beach, California, USA, January 12-14, 2005. 259-270. https://doi.org/10.1145/1040305.1040327 <lb/>Ahmed Bouajjani, Michael Emmi, Constantin Enea, and Jad Hamza. 2013. Verifying Concurrent Programs against Sequential <lb/>Specifications. In Programming Languages and Systems -22nd European Symposium on Programming, ESOP 2013, Held as <lb/>Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2013, Rome, Italy, March 16-24, 2013. <lb/>Proceedings (Lecture Notes in Computer Science, Vol. 7792), Matthias Felleisen and Philippa Gardner (Eds.). Springer, <lb/>290-309. https://doi.org/10.1007/978-3-642-37036-6_17 <lb/>Stephen Brookes. 2007. A semantics for concurrent separation logic. Theor. Comput. Sci. 375, 1-3 (2007), 227-270. https: <lb/>//doi.org/10.1016/j.tcs.2006.12.034 <lb/>Stephen D. Brookes. 2004. A Semantics for Concurrent Separation Logic. In CONCUR 2004 -Concurrency Theory, 15th <lb/>International Conference, London, UK, August 31 -September 3, 2004, Proceedings. 16-34. https://doi.org/10.1007/978-3-<lb/>540-28644-8_2 <lb/>Tej Chajed, M. Frans Kaashoek, Butler W. Lampson, and Nickolai Zeldovich. 2018. Verifying concurrent software using <lb/>movers in CSPEC. In OSDI. https://www.usenix.org/conference/osdi18/presentation/chajed <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:28 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <listBibl>Soham Chakraborty, Thomas A. Henzinger, Ali Sezgin, and Viktor Vafeiadis. 2015. Aspect-oriented linearizability proofs. <lb/>Log. Methods Comput. Sci. 11, 1 (2015). https://doi.org/10.2168/LMCS-11(1:20)2015 <lb/>Edmund M. Clarke, E. Allen Emerson, Somesh Jha, and A. Prasad Sistla. 1998. Symmetry Reductions in Model Checking. <lb/>In Computer Aided Verification, 10th International Conference, CAV &apos;98, Vancouver, BC, Canada, June 28 -July 2, 1998, <lb/>Proceedings (Lecture Notes in Computer Science, Vol. 1427), Alan J. Hu and Moshe Y. Vardi (Eds.). Springer, 147-158. <lb/>https://doi.org/10.1007/BFb0028741 <lb/>Pedro da Rocha Pinto, Thomas Dinsdale-Young, and Philippa Gardner. 2014. TaDA: A Logic for Time and Data Abstraction. <lb/>In ECOOP 2014 -Object-Oriented Programming -28th European Conference, Uppsala, Sweden, July 28 -August 1, 2014. <lb/>Proceedings. 207-231. https://doi.org/10.1007/978-3-662-44202-9_9 <lb/>David Detlefs, Christine H. Flood, Alex Garthwaite, Paul Alan Martin, Nir Shavit, and Guy L. Steele Jr. 2000. Even Better <lb/>DCAS-Based Concurrent Deques. In Distributed Computing, 14th International Conference, DISC 2000, Toledo, Spain, <lb/>October 4-6, 2000, Proceedings (Lecture Notes in Computer Science, Vol. 1914), Maurice Herlihy (Ed.). Springer, 59-73. <lb/>https://doi.org/10.1007/3-540-40026-5_4 <lb/>Thomas Dinsdale-Young, Lars Birkedal, Philippa Gardner, Matthew J. Parkinson, and Hongseok Yang. 2013. Views: <lb/>compositional reasoning for concurrent programs. In The 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles <lb/>of Programming Languages, POPL &apos;13, Rome, Italy -January 23 -25, 2013, Roberto Giacobazzi and Radhia Cousot (Eds.). <lb/>ACM, 287-300. https://doi.org/10.1145/2429069.2429104 <lb/>Mike Dodds, Xinyu Feng, Matthew J. Parkinson, and Viktor Vafeiadis. 2009. Deny-Guarantee Reasoning. In Programming <lb/>Languages and Systems, 18th European Symposium on Programming, ESOP 2009, Held as Part of the Joint European <lb/>Conferences on Theory and Practice of Software, ETAPS 2009, York, UK, March 22-29, 2009. Proceedings (Lecture Notes in <lb/>Computer Science, Vol. 5502), Giuseppe Castagna (Ed.). Springer, 363-377. https://doi.org/10.1007/978-3-642-00590-9_26 <lb/>Simon Doherty, David Detlefs, Lindsay Groves, Christine H. Flood, Victor Luchangco, Paul Alan Martin, Mark Moir, Nir <lb/>Shavit, and Guy L. Steele Jr. 2004. DCAS is not a silver bullet for nonblocking algorithm design. In SPAA 2004: Proceedings <lb/>of the Sixteenth Annual ACM Symposium on Parallelism in Algorithms and Architectures, June 27-30, 2004, Barcelona, Spain, <lb/>Phillip B. Gibbons and Micah Adler (Eds.). ACM, 216-224. https://doi.org/10.1145/1007912.1007945 <lb/>Cezara Dragoi, Ashutosh Gupta, and Thomas A. Henzinger. 2013. Automatic Linearizability Proofs of Concurrent Objects <lb/>with Cooperating Updates. In CAV &apos;13 (LNCS, Vol. 8044). Springer, 174-190. <lb/>Tayfun Elmas, Shaz Qadeer, and Serdar Tasiran. 2009. A calculus of atomic actions. In POPL. https://doi.org/10.1145/ <lb/>1480881.1480885 <lb/>Constantin Enea, Parisa Fathololumi, and Eric Koskinen. 2023. Scenario-Based Proofs for Concurrent Objects [Extended <lb/>Version]. arXiv:2301.05740 [cs.PL] <lb/>Constantin Enea, Parisa Fathololumi, and Eric Koskinen. 2024. CION: Concurrent Trace Reductions. https://github.com/ <lb/>quotientprovers/cion <lb/>Patrice Godefroid. 1996. Partial-Order Methods for the Verification of Concurrent Systems -An Approach to the State-Explosion <lb/>Problem. Lecture Notes in Computer Science, Vol. 1032. Springer. https://doi.org/10.1007/3-540-60761-7 <lb/>Timothy L. Harris, Keir Fraser, and Ian A. Pratt. 2002. A Practical Multi-word Compare-and-Swap Operation. In Distributed <lb/>Computing, 16th International Conference, DISC 2002, Toulouse, France, October 28-30, 2002 Proceedings (Lecture Notes in <lb/>Computer Science, Vol. 2508), Dahlia Malkhi (Ed.). Springer, 265-279. https://doi.org/10.1007/3-540-36108-1_18 <lb/>Chris Hawblitzel, Erez Petrank, Shaz Qadeer, and Serdar Tasiran. 2015. Automated and Modular Refinement Reasoning for <lb/>Concurrent Programs. In CAV. https://doi.org/10.1007/978-3-319-21668-3_26 <lb/>Matthias Heizmann, Yu-Fang Chen, Daniel Dietsch, Marius Greitschus, Jochen Hoenicke, Yong Li, Alexander Nutz, Betim <lb/>Musa, Christian Schilling, Tanja Schindler, and Andreas Podelski. 2018. Ultimate Automizer and the Search for Perfect <lb/>Interpolants -(Competition Contribution). In Tools and Algorithms for the Construction and Analysis of Systems -24th <lb/>International Conference, TACAS 2018, Held as Part of the European Joint Conferences on Theory and Practice of Software, <lb/>ETAPS 2018, Thessaloniki, Greece, April 14-20, 2018, Proceedings, Part II (Lecture Notes in Computer Science, Vol. 10806), <lb/>Dirk Beyer and Marieke Huisman (Eds.). Springer, 447-451. https://doi.org/10.1007/978-3-319-89963-3_30 <lb/>Danny Hendler, Nir Shavit, and Lena Yerushalmi. 2004. A scalable lock-free stack algorithm. In SPAA 2004: Proceedings of <lb/>the Sixteenth Annual ACM Symposium on Parallelism in Algorithms and Architectures, June 27-30, 2004, Barcelona, Spain, <lb/>Phillip B. Gibbons and Micah Adler (Eds.). ACM, 206-215. https://doi.org/10.1145/1007912.1007944 <lb/>Maurice Herlihy and Nir Shavit. 2008. The Art of Multiprocessor Programming. Morgan Kaufmann Publishers Inc., San <lb/>Francisco, CA, USA. <lb/>Maurice Herlihy and Jeannette M. Wing. 1990. Linearizability: A Correctness Condition for Concurrent Objects. ACM Trans. <lb/>Program. Lang. Syst. 12, 3 (1990), 463-492. https://doi.org/10.1145/78969.78972 <lb/>Cliff B. Jones. 1983. Specification and Design of (Parallel) Programs. In IFIP Congress. 321-332. <lb/>Ralf Jung, Robbert Krebbers, Jacques-Henri Jourdan, Ales Bizjak, Lars Birkedal, and Derek Dreyer. 2018. Iris from the <lb/>ground up: A modular foundation for higher-order concurrent separation logic. J. Funct. Program. 28 (2018), e20. <lb/>https://doi.org/10.1017/S0956796818000151 <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <note place="headnote">Scenario-Based Proofs for Concurrent Objects <lb/></note>

        <page>140:29 <lb/></page>

        <listBibl>Ralf Jung, Rodolphe Lepigre, Gaurav Parthasarathy, Marianna Rapoport, Amin Timany, Derek Dreyer, and Bart Jacobs. <lb/>2020. The future is ours: prophecy variables in separation logic. Proc. ACM Program. Lang. 4, POPL (2020), 45:1-45:32. <lb/>https://doi.org/10.1145/3371113 <lb/>Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal, and Derek Dreyer. 2015. Iris: <lb/>Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning. In Proceedings of the 42nd Annual ACM <lb/>SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015. <lb/>637-650. https://doi.org/10.1145/2676726.2676980 <lb/>Eric Koskinen. 2024. quotientprovers/cion: oopsla2024-artifact: Version used in evaluation for the OOPSLA&apos;24 paper &quot;Scenario-<lb/>Based Proofs for Concurrent Objects&quot;. https://doi.org/10.5281/zenodo.10814650 <lb/>Dexter Kozen. 1997. Kleene Algebra with Tests. ACM Trans. Program. Lang. Syst. 19, 3 (1997), 427-443. https://doi.org/10. <lb/>1145/256167.256195 <lb/>Bernhard Kragl, Constantin Enea, Thomas A. Henzinger, Suha Orhun Mutluergil, and Shaz Qadeer. 2020. Inductive <lb/>sequentialization of asynchronous programs. In Proceedings of the 41st ACM SIGPLAN International Conference on <lb/>Programming Language Design and Implementation, PLDI 2020, London, UK, June 15-20, 2020, Alastair F. Donaldson and <lb/>Emina Torlak (Eds.). ACM, 227-242. https://doi.org/10.1145/3385412.3385980 <lb/>Bernhard Kragl and Shaz Qadeer. 2018. Layered Concurrent Programs. In CAV. https://doi.org/10.1007/978-3-319-96145-3_5 <lb/>Bernhard Kragl, Shaz Qadeer, and Thomas A. Henzinger. 2018. Synchronizing the Asynchronous. In CONCUR. https: <lb/>//doi.org/10.4230/LIPIcs.CONCUR.2018.21 <lb/>Siddharth Krishna, Dennis E. Shasha, and Thomas Wies. 2018. Go with the flow: compositional abstractions for concurrent <lb/>data structures. PACMPL 2, POPL (2018), 37:1-37:31. https://doi.org/10.1145/3158125 <lb/>Ruy Ley-Wild and Aleksandar Nanevski. 2013. Subjective auxiliary state for coarse-grained concurrency. In The 40th Annual <lb/>ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL &apos;13, Rome, Italy -January 23 -25, 2013. <lb/>561-574. https://doi.org/10.1145/2429069.2429134 <lb/>Richard J. Lipton. 1975. Reduction: A Method of Proving Properties of Parallel Programs. Commun. ACM 18, 12 (1975). <lb/>https://doi.org/10.1145/361227.361234 <lb/>Antoni W. Mazurkiewicz. 1986. Trace Theory. In Petri Nets: Central Models and Their Properties, Advances in Petri Nets 1986, <lb/>Part II, Proceedings of an Advanced Course, Bad Honnef, Germany, 8-19 September 1986 (Lecture Notes in Computer Science, <lb/>Vol. 255), Wilfried Brauer, Wolfgang Reisig, and Grzegorz Rozenberg (Eds.). Springer, 279-324. https://doi.org/10.1007/3-<lb/>540-17906-2_30 <lb/>Maged M. Michael and Michael L. Scott. 1996. Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue <lb/>Algorithms. In PODC &apos;96. ACM, 267-275. <lb/>Aleksandar Nanevski, Anindya Banerjee, Germán Andrés Delbianco, and Ignacio Fábregas. 2019. Specifying concurrent <lb/>programs in separation logic: morphisms and simulations. Proc. ACM Program. Lang. 3, OOPSLA (2019), 161:1-161:30. <lb/>https://doi.org/10.1145/3360587 <lb/>Peter W. O&apos;Hearn. 2004. Resources, Concurrency and Local Reasoning. In CONCUR 2004 -Concurrency Theory, 15th <lb/>International Conference, London, UK, August 31 -September 3, 2004, Proceedings. 49-67. https://doi.org/10.1007/978-3-<lb/>540-28644-8_4 <lb/>Peter W. O&apos;Hearn. 2007. Resources, concurrency, and local reasoning. Theor. Comput. Sci. 375, 1-3 (2007). https://doi.org/10. <lb/>1016/j.tcs.2006.12.035 <lb/>Peter W. O&apos;Hearn, Noam Rinetzky, Martin T. Vechev, Eran Yahav, and Greta Yorsh. 2010. Verifying linearizability with <lb/>hindsight. In Proceedings of the 29th Annual ACM Symposium on Principles of Distributed Computing, PODC 2010, Zurich, <lb/>Switzerland, July 25-28, 2010, Andréa W. Richa and Rachid Guerraoui (Eds.). ACM, 85-94. https://doi.org/10.1145/ <lb/>1835698.1835722 <lb/>Susan S. Owicki and David Gries. 1976. Verifying Properties of Parallel Programs: An Axiomatic Approach. Commun. ACM <lb/>19, 5 (1976), 279-285. https://doi.org/10.1145/360051.360224 <lb/>Matthew J. Parkinson, Richard Bornat, and Peter W. O&apos;Hearn. 2007. Modular verification of a non-blocking stack. In <lb/>Proceedings of the 34th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2007, Nice, <lb/>France, January 17-19, 2007. 297-302. https://doi.org/10.1145/1190216.1190261 <lb/>Azalea Raad, Jules Villard, and Philippa Gardner. 2015. CoLoSL: Concurrent Local Subjective Logic. In Programming <lb/>Languages and Systems -24th European Symposium on Programming, ESOP 2015, Held as Part of the European Joint <lb/>Conferences on Theory and Practice of Software, ETAPS 2015, London, UK, April 11-18, 2015. Proceedings. 710-735. https: <lb/>//doi.org/10.1007/978-3-662-46669-8_29 <lb/>Gerhard Schellhorn, Heike Wehrheim, and John Derrick. 2012. How to Prove Algorithms Linearisable. In Computer Aided <lb/>Verification -24th International Conference, CAV 2012, Berkeley, CA, USA, July 7-13, 2012 Proceedings. 243-259. <lb/>William N Scherer III, Doug Lea, and Michael L Scott. 2006. Scalable synchronous queues. In Proceedings of the eleventh <lb/>ACM SIGPLAN symposium on Principles and practice of parallel programming. 147-156. <lb/></listBibl>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. <lb/></note>

        <page>140:30 <lb/></page>

        <note place="headnote">Constantin Enea and Eric Koskinen <lb/></note>

        <listBibl>Ilya Sergey, Aleksandar Nanevski, and Anindya Banerjee. 2015. Specifying and Verifying Concurrent Algorithms with <lb/>Histories and Subjectivity. In Programming Languages and Systems -24th European Symposium on Programming, ESOP <lb/>2015, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2015, London, UK, April <lb/>11-18, 2015. Proceedings. 333-358. https://doi.org/10.1007/978-3-662-46669-8_14 <lb/>R. K. Treiber. 1986. Systems Programming: Coping with Parallelism. Technical Report RJ 5118. IBM Almaden Research <lb/>Center. <lb/>Aaron Turon, Derek Dreyer, and Lars Birkedal. 2013. Unifying refinement and hoare-style reasoning in a logic for higher-<lb/>order concurrency. In ACM SIGPLAN International Conference on Functional Programming, ICFP&apos;13, Boston, MA, USA -<lb/>September 25 -27, 2013. 377-390. https://doi.org/10.1145/2500365.2500600 <lb/>V. Vafeiadis. 2008. Modular fine-grained concurrency verification. Ph. D. Dissertation. University of Cambridge. <lb/>Viktor Vafeiadis. 2009. Shape-Value Abstraction for Verifying Linearizability. In VMCAI &apos;09: Proc. 10th Intl. Conf. on <lb/>Verification, Model Checking, and Abstract Interpretation (LNCS, Vol. 5403). Springer, 335-348. <lb/>Viktor Vafeiadis. 2010. Automatically Proving Linearizability. In Computer Aided Verification, 22nd International Conference, <lb/>CAV 2010, Edinburgh, UK, July 15-19, 2010. Proceedings (Lecture Notes in Computer Science, Vol. 6174), Tayssir Touili, Byron <lb/>Cook, and Paul B. Jackson (Eds.). Springer, 450-464. https://doi.org/10.1007/978-3-642-14295-6_40 <lb/>Viktor Vafeiadis and Matthew J. Parkinson. 2007. A Marriage of Rely/Guarantee and Separation Logic. In CONCUR 2007 <lb/>-Concurrency Theory, 18th International Conference, CONCUR 2007, Lisbon, Portugal, September 3-8, 2007, Proceedings <lb/>(Lecture Notes in Computer Science, Vol. 4703), Luís Caires and Vasco Thudichum Vasconcelos (Eds.). Springer, 256-271. <lb/>https://doi.org/10.1007/978-3-540-74407-8_18 <lb/>He Zhu, Gustavo Petri, and Suresh Jagannathan. 2015. Poling: SMT Aided Linearizability Proofs. In Computer Aided <lb/>Verification -27th International Conference, CAV 2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part II. 3-19. <lb/></listBibl>

        <front>Received 21-OCT-2023; accepted 2024-02-24 <lb/></front>

        <note place="footnote">Proc. ACM Program. Lang., Vol. 8, No. OOPSLA1, Article 140. Publication date: April 2024. </note>


	</text>

</TEI>