<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>Building Interpreters by Composing Monads <lb/>Guy L. Steele Jr. <lb/>Thinking Machines Corporation <lb/>245 First Street <lb/>Cambridge, Massachusetts 02142 <lb/>(617) 234-2860 <lb/>gls@think.com <lb/>Abstract: We exhibit a set of functions coded in <lb/>Haskell that can be used as building blocks to construct <lb/>a variety of interpreters for Lisp-like languages. The <lb/>building blocks are joined merely through functional <lb/>composition. Each building block contributes code to <lb/>support a speci c feature, such as numbers, continua-<lb/>tions, functions calls, or nondeterminism. The result of <lb/>composing some number of building blocks is a parser, <lb/>an interpreter, and a printer that support exactly the <lb/>expression forms and data types needed for the com-<lb/>bined set of features, and no more. <lb/>The data structures are organized as pseudomonads, <lb/>a generalization of monads that allows composition. <lb/>Functional composition of the building blocks implies <lb/>type composition of the relevant pseudomonads. <lb/>Our intent was that the Haskell type resolution sys-<lb/>tem ought to be able to deduce the approprate data <lb/>types automatically. Unfortunately there is a de ciency <lb/>in current Haskell implementations related to recursive <lb/>data types: circularity must be re ected statically in the <lb/>type de nitions. <lb/>We circumvent this restriction by applying a purpose-<lb/>built program simpli er that performs partial evaluation <lb/>and a certain amount of program algebra. We construct <lb/>a wide variety of interpreters in the style of Wadler by <lb/>starting with the building blocks and a page of boiler-<lb/>plate code, writing three lines of code (one to specify the <lb/>building blocks and two to (redundantly) specify type <lb/>compositions), and then applying the simpli er. The <lb/>resulting code is acceptable Haskell code. <lb/>We have tested a dozen di erent interpreters with <lb/>various combinations of features. In this paper we dis-<lb/>cuss the overall code structuring strategy, exhibit sev-<lb/>eral building blocks, brie y describe the partial evalu-<lb/>ator, and present a number of automatically generated <lb/>interpreters. <lb/>This is a preprint of a paper that is to appear <lb/>in the Proceedings of the Twenty-rst Annual ACM <lb/>SIGPLAN-SIGACT Symposium on Principles of Pro-<lb/>gramming Languages, January 1994. <lb/></front>

			<body>1 Introduction <lb/>I really liked Phil Wadler&apos;s work on monads 15, 16]. <lb/>But I was not entirely satis ed with the methodology <lb/>for constructing new interpreters by writing a single in-<lb/>terpreter and then plugging in various monads. While it <lb/>was not necessary to modify the code of the interpreter, <lb/>it was necessary to alter \by hand&quot; the data structure <lb/>de nitions for both the input expressions and the output <lb/>values. It seemed to me that this could be automated. <lb/>Another problem was that, while there were many <lb/>monads to choose from, they were one to a customer. <lb/>You could have an interpreter with state, or an inter-<lb/>preter with continuations, but not an interpreter with <lb/>continuations and state. <lb/>I had a vision of building blocks, like Legos or Tinker-<lb/>toys, that could be used interchangeably and in com-<lb/>bination to build interpreters. It seemed that if they <lb/>could be combined by functional composition, then the <lb/>Haskell 2] type system, or an extension of it, ought to <lb/>be able to deduce the relevant data types automatically. <lb/>It can be done. With the function de nitions pre-<lb/>sented in this paper, the value of the Haskell expression <lb/>complete (nondeterministic (cbv interpreter)) <lb/>is in fact a complete nondeterministic call-by-value <lb/>interpreter|indeed, not only an interpreter, but a <lb/>parser and a printer as well. Similarly, the result of <lb/>complete (cbn (numbers interpreter)) <lb/>is a complete call-by-name numbers interpreter; and the <lb/>expression <lb/>complete (continuation (nondeterministic <lb/>(cbv (numbers interpreter)))) <lb/>produces a complete continuation nondeterministic call-<lb/>by-value numbers interpreter. <lb/>2 Pseudomonads <lb/>We structure our interpreter building blocks by using <lb/>pseudomonads, a generalization of monads that permits <lb/>infixl 4 &amp; <lb/>infixl 1 &lt;&lt;, #, &gt;&gt; <lb/>type Unitfn p q = p -&gt; q <lb/>type Bindfn p q = q -&gt; (p -&gt; q) -&gt; q <lb/>type Pseudobindfn p q = <lb/>--See text <lb/>Monad q r -&gt; q -&gt; (p -&gt; r) -&gt; r <lb/>data Monad p q = <lb/>Monad (Unitfn p q) (Bindfn p q) <lb/>unit :: Monad p q -&gt; Unitfn p q <lb/>unit (Monad u b) = u <lb/>bind :: Monad p q -&gt; Bindfn p q <lb/>bind (Monad u b) = b <lb/>idmonad :: Monad p p <lb/>idmonad = Monad (\x -&gt; x) (\z k -&gt; k z) <lb/>data Pseudomonad p q = <lb/>Pseudomonad (Unitfn p q) (Pseudobindfn p q) <lb/>pseudounit :: Pseudomonad p q -&gt; Unitfn p q <lb/>pseudounit (Pseudomonad u pb) = u <lb/>pseudobind :: <lb/>Pseudomonad p q -&gt; Pseudobindfn p q <lb/>pseudobind (Pseudomonad u pb) = pb <lb/>data Bindtemp p q a b c = Bind2 (p, q) <lb/>| Bind3 (a, b, c) <lb/>x &lt;&lt; y = Bind2 (x, y) <lb/>(Bind2 (x, y)) # z = Bind3 (x, y, z) <lb/>(Bind2 (x, y)) &gt;&gt; f = bind y x f <lb/>(Bind3 (x, y, z)) &gt;&gt; f = pseudobind z y x f <lb/>m&amp;p = Monad (unit m . pseudounit p) <lb/>(\z k -&gt; z &lt;&lt;m&gt;&gt; (\w -&gt; <lb/>w &lt;&lt;m#p&gt;&gt; k)) <lb/>Figure 1: Haskell code for supporting pseudomonads <lb/>composition. The theory of pseudomonads is described <lb/>in a companion paper 11]. The support code in Figure 1 <lb/>is taken verbatim from that paper. <lb/>In order to convey necessary type information, it is <lb/>convenient to reify monads and pseudomonads. We <lb/>represent a monad in Haskell as an algebraic datatype <lb/>Monad encapsulating the unit and bind operations for <lb/>the monad. Note that we use the name Monad as both <lb/>a type constructor and a data constructor, a convenient <lb/>pun permitted by Haskell. We then de ne generic unit <lb/>and bind operations. <lb/>In Wadler&apos;s style, one speaks of the type a and the <lb/>type M a to which the type constructor M maps a; the <lb/>monad in question is not itself an object of the language, <lb/>but merely the conceptual triple (M; unitM; bindM). In <lb/>our style, a monad is an object of type Monad a b, the <lb/>type of monads that map type a to type b; thus b cor-<lb/>responds to Wadler&apos;s type M a. <lb/>As an example, the declaration of idmonad in Figure 1 <lb/>de nes the usual identity monad. <lb/>(A word about syntax: Wadler used Haskell in x no-<lb/>tation for the various monad binding operations, writing <lb/>x `bindM`f instead of bindM x f. Our generic bind <lb/>operation takes three arguments: a monad, an object, <lb/>and a function. However, the in x notation is quite con-<lb/>venient, particularly for exhibiting the associative law <lb/>for monads, so we have devised a kluge: we de ne two <lb/>Haskell in x operators &lt;&lt; and &gt;&gt; so that we may write <lb/>bind m x f as x &lt;&lt;m&gt;&gt; f. The code for this is also in <lb/>Figure 1.) <lb/>A pseudomonad is only a slight generalization of a <lb/>monad. A pseudomonad encapsulates two operations <lb/>called pseudounit and pseudobind. The pseudounit <lb/>operation is identical in its nature to unit, but the <lb/>pseudobind operation takes an extra argument, before <lb/>the object and the function to be applied, that is itself a <lb/>monad. The idea is that pseudobind unwraps an object <lb/>of type q, revealing an object of type p. This may then <lb/>be fed to the function, but the function need not pro-<lb/>duce a result of type q; instead, it may produce a result <lb/>of some other type r. The monad argument must be <lb/>of type Monad q r, thus specifying a way to take values <lb/>of type q to type r. The motivation is that the pseu-<lb/>dobinding operation might not invoke the function after <lb/>all, in which case it needs some other way to produce a <lb/>result of type r. <lb/>(More about syntax: The generic pseudobind opera-<lb/>tion takes four arguments. We de ne # as yet another in-<lb/>x operator so that we may write pseudobind p m x f <lb/>as x &lt;&lt;m#p&gt;&gt; f. This syntax happens to be used only <lb/>once in the code gures in this paper, in the de nition <lb/>of &amp; in Figure 1.) <lb/>In short, a pseudomonad is simply a monad that has <lb/>been parameterized by another monad, in exactly the <lb/>same manner that Wadler parameterized an interpreter <lb/>by a monad. <lb/>Pseudomonads are assumed (and should be proved) <lb/>to obey three laws analogous to those for monads. The <lb/>monad laws, expressed in unit/bind form, are: <lb/>Left unit: <lb/>unit m a &lt;&lt;m&gt;&gt; f <lb/>f a <lb/>Right unit: <lb/>x &lt;&lt;m&gt;&gt; unit m <lb/>x <lb/>Associative: <lb/>x &lt;&lt;m&gt;&gt; (\a -&gt; f a &lt;&lt;m&gt;&gt; g) <lb/>(x &lt;&lt;m&gt;&gt; \a -&gt; f a) &lt;&lt;m&gt;&gt; g <lb/>(Remember that &lt;&lt;...&gt;&gt; has lower syntactic prece-<lb/>dence than function application.) <lb/>The analogous laws for pseudomonads are: <lb/>Left unit: <lb/>unit p a &lt;&lt;m#p&gt;&gt; f <lb/>f a <lb/>Right unit: <lb/>x &lt;&lt;m#p&gt;&gt; (h . unit p) <lb/>h x <lb/>Associative: <lb/>x <lb/>&lt;&lt;m#p&gt;&gt; (\a -&gt; f a &lt;&lt;m#p&gt;&gt; g) <lb/>(x &lt;&lt;idmonad#p&gt;&gt; \a -&gt; f a) &lt;&lt;m#p&gt;&gt; g <lb/>The composition operator m&amp;p composes a monad m <lb/>and a pseudomonad p to produce what might be a new <lb/>monad. If the monad obeys the three monad laws and <lb/>the pseudomonad obeys the three pseudomonad laws, <lb/>then the composition necessarily obeys the left unit and <lb/>right unit monad laws. A separate proof must be sup-<lb/>plied that the resulting monad obeys the monad asso-<lb/>ciative law (and this is consistent with the experience <lb/>of Moggi 6] and others that monads do not compose in <lb/>general). <lb/>(We note in passing that there is in fact a more general <lb/>theory of pseudmonads in which the rst argument to a <lb/>pseudobind operation is a pseudomonad rather than a <lb/>monad. The composition operator &amp; then combines two <lb/>pseudomonads to produce a third pseudomonad: <lb/>pb&amp;pa = Pseudomonad <lb/>(pseudounit mb . pseudounit pa) <lb/>(\pz x f -&gt; x &lt;&lt;pz#pb&gt;&gt; (\w -&gt; <lb/>w &lt;&lt;pz&amp;pb#pa&gt;&gt; f)) <lb/>This composition operator is associative (here we gloss <lb/>over a subtle point about in nite regress in the proof) <lb/>and its left and right identities are the identity pseu-<lb/>domonad. This more general theory is not required for <lb/>the remainder of this paper but provided substantial <lb/>theoretical motivation along the way.) <lb/>(But hold on, here! I have pulled a fast one! The <lb/>type de nition for Pseudobindfn in Figure 1 is not a <lb/>legitimate Haskell type declaration; it has a free type <lb/>variable. True enough, and that is entirely the point: <lb/>that is the extra hole, the escape hatch that allows an <lb/>arbitrary monad (or pseudomonad, in the more general <lb/>theory) to be plugged in. One might try to x the prob-<lb/>lem by introducing an extra type variable: <lb/>type Pseudobindfn p q r = ... <lb/>but this soon propagates throughout the code and be-<lb/>comes messy. Moreover, in the general theory it requires <lb/>yet another type variable s: <lb/>type Pseudobindfn p q r = <lb/>(Pseudomonad q r s) -&gt; q -&gt; (p -&gt; r) -&gt; r <lb/>and one gets caught in an in nite regress. This regress <lb/>is part of the fundamental structure of the paradigm. <lb/>Another idea is to wimp out and not say exactly what <lb/>that rst argument is: <lb/>type Pseudobindfn p q r x = <lb/>x -&gt; q -&gt; (p -&gt; r) -&gt; r <lb/>and hope that the Haskell type inference system will <lb/>be happy with that; but it is not. The best solution <lb/>is existential type variables; we would like to write the <lb/>rst de nition shown and to have r treated existentially. <lb/>I tried this out in the Chalmers Haskell implementation, <lb/>which supports an experimental version of existential <lb/>type variables. Unfortunately, that implementation im-<lb/>poses a restriction to the e ect that existential type vari-<lb/>ables must not \escape&quot;; but this application requires <lb/>that they do escape. We recommend that Haskell imple-<lb/>mentors consider full support for unrestricted existential <lb/>type variables. Our use of a program simpli er for the <lb/>work reported here circumvents the restrictions of the <lb/>Haskell type system.) <lb/>3 Towers of Data Types <lb/>An interpreter uses objects of two types: terms (input <lb/>expressions) and values (results). When an interpreter <lb/>is extended with a new capability, both of these types <lb/>may require modi cation. For example, to add numeric <lb/>processing to an interpreter, the value type must be ex-<lb/>tended to represent numbers and the term type must be <lb/>extended to represent operations such as addition. <lb/>A building block takes an interpreter that maps terms <lb/>of type t to values of type v and produces a new inter-<lb/>preter that maps terms of type t&apos; to values of type <lb/>v&apos;. It does this through the use of two pseudomon-<lb/>ads, one of type Pseudomonad t t&apos; and one of type <lb/>Pseudomonad v v&apos;. The same pseudomonads are used <lb/>to construct a new parser and printer. A parser maps <lb/>strings into terms; a printer maps values into strings. <lb/>The old parser is extended to produce terms of the new <lb/>type t&apos;. The old printer is extended to accept values of <lb/>the new type v&apos;. <lb/>Composing multiple building blocks results in com-<lb/>posing multiple pseudomonads. The result is to con-<lb/>struct two towers of data types. The nal parser maps <lb/>strings to the type at the top of the \term&quot; tower; the <lb/>nal interpreter maps these terms to the type at the top <lb/>of the \value&quot; tower; and the nal printer prints these <lb/>values. See Figure 2. <lb/>So far, this is all fairly straightforward. The nal llip <lb/>is that we wish both the nal term type and the nal <lb/>value type to be recursive. For example, we want a term <lb/>(+ x y) to be able to contain any two terms x and y, <lb/>and these terms must be of the topmost type in the <lb/>tower. It is no problem to express this implicitly, but it <lb/>causes a problem in the Haskell type checker. We deal <lb/>with this problem later. <lb/>term <lb/>value <lb/>tower <lb/>tower <lb/>T 00 <lb/>V 00 <lb/>. . . <lb/>. . . <lb/>This gure is incomplete.] T 2 <lb/>V 2 <lb/>See the proceedings.] T 1 <lb/>V 1 <lb/>String <lb/>T 0 <lb/>V 0 <lb/>String <lb/>Figure 2: Towers of types <lb/>4 Packages <lb/>In e ect, we need to compose not just functions but sets <lb/>of functions. Haskell modules are not rst-class in the <lb/>language, so we had to invent some other representation <lb/>for sets of functions. We use a simple association-list <lb/>representation (a list of routines, where if there is more <lb/>than one routine of the same type, the one earliest in <lb/>the list shadows the others. We call this structure a <lb/>package. <lb/>(We use an association list rather than, say, an 8-tuple <lb/>for the sake of modularity; not all building blocks are <lb/>concerned with all eight routine types. The association-<lb/>list structure allows us to add new routine types without <lb/>modifying all previously written building blocks.) <lb/>The necessary code for packages is shown in Figure 3. <lb/>In this gure t and v stand for the \current&quot; term and <lb/>value types, that is, the types at the level of the type <lb/>tower to which the package corresponds; t&apos;&apos; and v&apos;&apos; <lb/>stand for the term and value types at the top of the <lb/>tower. (The type ve stands for the type of values stored <lb/>in the environment.) Thus the interpreter accepts a <lb/>term at the current level of the type tower but produces <lb/>a value at the top of the type tower. It does so because <lb/>it produces a value at the current level and then, one <lb/>way or another, applies the unit operation for a monad <lb/>that will project the type to the top of the tower. (This <lb/>monad is constructed as a composition of pseudomonads <lb/>as the building blocks are composed.) <lb/>There are eight kinds of routines: <lb/>ParseR <lb/>the parser <lb/>InterpR <lb/>the interpreter <lb/>ShowvalR <lb/>the printer <lb/>ComplainR <lb/>signals an error <lb/>MakenumR <lb/>constructs a number value <lb/>MakefunR <lb/>constructs a function value <lb/>ApplyR <lb/>applies a function <lb/>NameR <lb/>a string that names the interpreter <lb/>Not every package will contain a routine of every kind. <lb/>For example, there is no MakenumR routine unless the <lb/>numbers building block has been included. These auxil-<lb/>iary routines provide a way for one building block to use <lb/>facilities provided by another. For example, as we shall <lb/>see, the continuations building block uses a MakefunR <lb/>routine to construct a function representing a continu-<lb/>ation; of course, it cannot do this unless the cbv or cbn <lb/>data Routine t v t&apos;&apos; v&apos;&apos; ve <lb/>= ParseR (String -&gt; (t&apos;&apos;, String)]) <lb/>| InterpR (t -&gt; (String, ve)] -&gt; v&apos;&apos;) <lb/>| ShowvalR (v -&gt; String) <lb/>| ComplainR (String -&gt; v&apos;&apos;) <lb/>| MakenumR (Int -&gt; v&apos;&apos;) <lb/>| MakefunR ((v&apos;&apos; -&gt; v&apos;&apos;) -&gt; ve) <lb/>| ApplyR (v&apos;&apos; -&gt; v&apos;&apos; -&gt; v&apos;&apos;) <lb/>| NameR String <lb/>data Package t v t&apos;&apos; v&apos;&apos; ve <lb/>= Package Routine t v t&apos;&apos; v&apos;&apos; ve] <lb/>update (Package pkg) new = <lb/>Package (new ++ pkg) <lb/>parser (Package p) = parse&apos; p where <lb/>parse&apos; (ParseR f:_) = f <lb/>parse&apos; (_:rest) = parse&apos; rest <lb/>interpr (Package p) = interp&apos; p where <lb/>interp&apos; (InterpR f:_) = f <lb/>interp&apos; (_:rest) = interp&apos; rest <lb/>showvalr (Package p) = showval&apos; p where <lb/>showval&apos; (ShowvalR f:_) = f <lb/>showval&apos; (_:rest) = showval&apos; rest <lb/>complainr (Package p) = complain&apos; p where <lb/>complain&apos; (ComplainR f:_) = f <lb/>complain&apos; (_:rest) = complain&apos; rest <lb/>makenumr (Package p) = makenum&apos; p where <lb/>makenum&apos; (MakenumR f:_) = f <lb/>makenum&apos; (_:rest) = makenum&apos; rest <lb/>makefunr (Package p) = makefun&apos; p where <lb/>makefun&apos; (MakefunR f:_) = f <lb/>makefun&apos; (_:rest) = makefun&apos; rest <lb/>applyr (Package p) = apply&apos; p where <lb/>apply&apos; (ApplyR f:_) = f <lb/>apply&apos; (_:rest) = apply&apos; rest <lb/>namer (Package p) = name&apos; p where <lb/>name&apos; (NameR x:_) = x <lb/>name&apos; (_:rest) = name&apos; rest <lb/>Figure 3: Support code for packages <lb/>building block has been included to provide a de nition <lb/>of such a routine. <lb/>The update function adds a set of new routines to <lb/>a package, possibly shadowing old ones of the same <lb/>type. The various access functions parser, interpr, <lb/>showvalr, etc., extract a routine of the appropriate type <lb/>from a package; the result is unde ned if the package <lb/>contains no routine of the required type. <lb/>data TermZ = Bogon <lb/>data ValueZ = Wrong <lb/>interpreter tmt tmv top = Package <lb/>ParseR parseZ, InterpR interpZ, <lb/>ShowvalR showvalZ, ComplainR complainZ, <lb/>NameR nameZ] <lb/>where <lb/>parseZ s = (unit tmt Bogon, s)] <lb/>interpZ Bogon _ = <lb/>complainr top &quot;invalid expression&quot; <lb/>complainZ s = unit tmv Wrong <lb/>showvalZ Wrong = &quot;&lt;wrong&gt;&quot; <lb/>nameZ = &quot;interpreter&quot; <lb/>Figure 4: The base interpreter prepackage <lb/>5 The Base Interpreter <lb/>The base interpreter, the one on which all variants are <lb/>built and on which the towers of types are erected, is <lb/>shown in Figure 4. It is a null interpreter. It interprets <lb/>a completely boring language: the only term is Bogon. <lb/>Every attempt to parse a string fails and produces a <lb/>Bogon|actually not Bogon, but Bogon projected to the <lb/>top of the term type tower. An attempt to interpret <lb/>Bogon results in a complaint. Complaining produces the <lb/>value Wrong|actually not Wrong, but Wrong projected <lb/>to the top of the value type tower. The value Wrong <lb/>prints as \&lt;wrong&gt;&quot;. The name of the base interpreter <lb/>is \interpreter&quot;. <lb/>How are types projected to the top of the tower? <lb/>The interpreter function takes two monads as argu-<lb/>ments: tmt (the Top Monad for Terms) and tmv (the <lb/>Top Monad for Values). These monads are constructed <lb/>as building blocks are composed and then passed back <lb/>down to all levels as arguments. The unit operations for <lb/>thse monads are used by parseZ and complainZ to lift <lb/>terms and values, respectively, to the top of the tower. <lb/>The interpreter function takes a third argument, <lb/>which is also passed back down from the top of the <lb/>tower. This is top, the completed top-level interpreter <lb/>package. Note that interpZ does not call complainZ <lb/>directly; it calls the complaint function of the top-level <lb/>package. If any of the building blocks should shadow <lb/>the complaint function with a new one, interpZ will <lb/>use the new one, not complainZ. <lb/>6 Completing the Interpreter <lb/>The interpreter function shown in Figure 4 is not re-<lb/>ally a complete, working interpreter; it is merely a func-<lb/>tion that needs some arguments to produce a package <lb/>of routines. We call such a function a prepackage; given <lb/>complete prepkg = top where <lb/>top = prepkg idmonad idmonad top <lb/>type Term = TermZ <lb/>--** <lb/>type Value = ValueZ <lb/>--** <lb/>interp_pkg = complete interpreter <lb/>--** <lb/>parse = parser interp_pkg <lb/>interp = interpr interp_pkg <lb/>showval = showvalr interp_pkg <lb/>complain = complainr interp_pkg <lb/>makenum = makenumr interp_pkg <lb/>makefun = makefunr interp_pkg <lb/>apply = applyr interp_pkg <lb/>name = namer interp_pkg <lb/>Figure 5: Code to complete a constructed interpreter <lb/>two monads and a top-level package it will produce a <lb/>new package (that may be at any point in the tower, <lb/>possibly at the bottom or the top). <lb/>We need to feed three appropriate arguments to the <lb/>prepackage. It is also handy to pull the constructed <lb/>package apart into individual functions with the custom-<lb/>ary names. The necessary code is shown in Figure 5. <lb/>The function complete is deceptively simple. Given <lb/>a prepackage, it simply caps the tower and returns the <lb/>top-level package top. How is top computed? By feed-<lb/>ing three arguments to the given prepackage. The rst <lb/>two arguments are simply the identity monad; whatever <lb/>package is returned by the prepackage will already be at <lb/>the top of the tower, so the identity monad su ces to <lb/>lift terms and values of that package to the top. The <lb/>third argument is top, the top-level package. It should <lb/>now be apparent that we are depending critically on the <lb/>fact that our implementation language, Haskell, is lazy. <lb/>Computing the value of top requires that top be passed <lb/>as an argument. <lb/>The result of the expression complete interpreter <lb/>is in fact a complete (null) interpreter package. The re-<lb/>maining de nitions simply name the individual routines <lb/>in this package. <lb/>Finally, it is necessary to make a working Haskell main <lb/>program. The driver code in Figure 6 implements a <lb/>read-eval-print loop with an initial friendly greeting and <lb/>a prompt before each interaction. Note that the parse <lb/>function, according to the usual Haskell style, actually <lb/>produces a list of possible parses; read_eval_print <lb/>simply uses the rst parse and discards any others. <lb/>When we apply our special-purpose program simpli-<lb/>er (more about this in Section 9) to all the code in <lb/>Figures 1{5, the result is as shown in Figure 7. <lb/>Here is a sample interaction with this interpreter (all <lb/>sample interactions in this paper are transcripts of ac-<lb/>tual console sessions with running code using the driver <lb/>data Term = Bogon <lb/>data Value = Wrong <lb/>parse s = <lb/>(Bogon, s) ] <lb/>interp Bogon _ = complain &quot;invalid expression&quot; <lb/>complain s = Wrong <lb/>showval Wrong = &quot;&lt;wrong&gt;&quot; <lb/>name = &quot;interpreter&quot; <lb/>Figure 7: Simpli ed code for the completed base inter-<lb/>preter <lb/>of Figure 6): <lb/>Welcome to the interpreter! <lb/>&gt; 3 <lb/>&lt;wrong&gt; <lb/>&gt; (2+3) <lb/>&lt;wrong&gt; <lb/>&gt; \x.x <lb/>&lt;wrong&gt; <lb/>&gt; Krazy Kat <lb/>&lt;wrong&gt; <lb/>Everything is &lt;wrong&gt;! How boring! <lb/>7 The Numbers Building Block <lb/>The numbers building block extends the term data type <lb/>to include numeric constants Con n and addition oper-<lb/>ations Add x y, where n is a Haskell integer and x and y <lb/>are top-level terms. It also extends the value data type <lb/>to include numeric values Num n. See Figure 8. <lb/>In the de nition of the type TermN, t&apos;&apos; refers to the <lb/>top-level term type and t refers to the term type at the <lb/>next level down from the numbers package. Similarly <lb/>for v&apos;&apos; and v in the de nition of ValueN. <lb/>The pseudomonad mTN is used to map from type t <lb/>to the type TermN t&apos;&apos; t. It augments the type t with <lb/>new possibilities Con n and Add x y for terms. <lb/>The pseudomonad mVN is used to map from type v to <lb/>the type ValueN v&apos;&apos; v. It augments the type v with <lb/>the new possibility Num n. (It may seem strange that <lb/>mVNbind is not coded more simply as <lb/>mVNbind m (Num x) f = unit m (Num x) <lb/>mVNbind m (OtherVN x) f = f x <lb/>rather than using the intermediate name qxfoo. It is in <lb/>fact strange and a kluge. The form in the gure tricks <lb/>the program simpli er into applying a certain transfor-<lb/>mation at just the right time. It&apos;s a hack. I&apos;m sorry.) <lb/>The function numbers, unlike interpreter, is not a <lb/>prepackage; it is a building block. A building block <lb/>read_eval_print s = showval (interp exp ]) where <lb/>((exp, _) : _) = parse s <lb/>main = appendChan stdout (&quot;Welcome to the &quot; ++ name ++ &quot;!\n&gt; &quot;) abort <lb/>(readChan stdin abort (\ contents -&gt; process (lines contents))) where <lb/>process ] = done <lb/>process (x:xs) = appendChan stdout (read_eval_print x) abort <lb/>(appendChan stdout &quot;\n&gt; &quot; abort <lb/>(process xs)) <lb/>Figure 6: Code to drive a constructed interpreter <lb/>takes an old prepackage and produces a new prepack-<lb/>age. Thus interpreter is a suitable rst argument for <lb/>numbers; the result, a prepackage, is a suitable argu-<lb/>ment to complete. This prepackage accepts the usual <lb/>three arguments tmt, tmv, and top and returns a new <lb/>package. This package is produced by updating the old <lb/>package with new routines| ve of them, in this case. <lb/>And where did this \old package&quot; come from? Ah, it <lb/>must be constructed from the old prepackage originally <lb/>given to the building block. The old prepackage will <lb/>need three arguments. It needs a monad that will lift <lb/>terms of the old package to the top. Well, tmt will <lb/>lift terms from the new package to the top; and mTN <lb/>will lift terms from the old package to the new package. <lb/>All we need to do is compose tmt and mTN with the <lb/>pseudomonad composition operator &amp;. Voil a! Similarly <lb/>for tmv and mVN. The top-level package top is passed <lb/>down unchanged. <lb/>All this structure is quite stereotypical and appears <lb/>more or less unchanged in every building block. Now <lb/>let us examine the particulars of the numbers building <lb/>block. <lb/>The parser is bulky (as parsers are wont to be, because <lb/>they must distinguish bad inputs from good) but quite <lb/>straightforward. There are three possibilities parse a <lb/>constant ddd to produce the term Con n, parse an ad-<lb/>dition operation (x+y) to produce the term Add x y, or <lb/>parse the way the old package parses. In the rst two <lb/>cases, the term is lifted to the top of the term type tower <lb/>by applying unit tmt. <lb/>The interpreter interpN and printer showvalN are <lb/>pretty much what you would expect after reading <lb/>Wadler&apos;s paper 16]. Interpreting a constant Con n re-<lb/>sults in an equivalent value Num n, lifted to the top of the <lb/>value type tower by applying unit tmv. The code for <lb/>interpreting an Add operation is just like Wadler&apos;s, with <lb/>interpr top in place of interp, &lt;&lt;tmv&gt;&gt; in place of <lb/>`bindM`, and slightly more elaborate complaining when <lb/>not both operands are numbers. <lb/>Finally, note that the name of the interpreter in the <lb/>new package is constructed by prepending the word <lb/>numbers to the name of the old package. <lb/>To incorporate the numbers facilities into an inter-<lb/>preter, all we need to do is replace the three lines marked <lb/>\**&quot; in Figure 5 with the following: <lb/>type Term = TermN Term TermZ <lb/>type Value = ValueN Value ValueZ <lb/>interp_pkg = complete (numbers interpreter) <lb/>When we then apply our program simpli er to all the <lb/>code in Figures 1{5 plus Figure 8, the result is as shown <lb/>in Figure 9. <lb/>A sample interaction with this interpreter: <lb/>Welcome to the numbers interpreter! <lb/>&gt; 3 <lb/>3 <lb/>&gt; (2+3) <lb/>5 <lb/>&gt; \x.x <lb/>&lt;wrong&gt; <lb/>&gt; Krazy Kat <lb/>&lt;wrong&gt; <lb/>&gt; ((1+2)+(3+(4+5))) <lb/>15 <lb/>It does indeed process numerical expressions and reject <lb/>everything else. <lb/>8 Recursive Types in Haskell <lb/>The complete function is where the knot is tied, re-<lb/>sulting in recursive term and value types; top is a x-<lb/>point. Unfortunately, existing implementations of the <lb/>Haskell type system choke on this circularity. The lan-<lb/>guage speci cation is hazy, so it is hard to determine <lb/>whether this is a language restriction or an implemen-<lb/>tation de ciency. The nub of the matter is that Haskell <lb/>allows recursive and mutually recursive datatypes, pro-<lb/>vided that \an algebraic datatype intervenes&quot; 2]. In <lb/>current implementations this is apparently a static re-<lb/>quirement; that is, any circularity of de nition must <lb/>be textually apparent rather than deduced by the type <lb/>mechanism. If the program simpli er is not used, then <lb/>the type checker discovers only dynamically for the type <lb/>data TermN t&apos;&apos; t = Con Int | Add t&apos;&apos; t&apos;&apos; | OtherTN t <lb/>data ValueN v&apos;&apos; v = Num Int | OtherVN v <lb/>mTN = Pseudomonad (\x -&gt; OtherTN x) mTNbind where <lb/>mTNbind m (Con x) f = unit m (Con x) <lb/>mTNbind m (Add x y) f = unit m (Add x y) <lb/>mTNbind m (OtherTN x) f = f x <lb/>mVN = Pseudomonad (\x -&gt; OtherVN x) mVNbind where <lb/>mVNbind m = qxfoo where <lb/>qxfoo (Num x) f = unit m (Num x) <lb/>qxfoo (OtherVN x) f = f x <lb/>numbers oldprepkg tmt tmv top = update oldpkg <lb/>ParseR parseN, InterpR interpN, ShowvalR showvalN, MakenumR makenumN, NameR nameN] <lb/>where <lb/>oldpkg = oldprepkg (tmt &amp; mTN) (tmv &amp; mVN) top <lb/>parseN s = (pcon s ++ psum s ++ parser oldpkg s) where <lb/>psum s = (unit tmt (Add x y), s5) | (&apos;(&apos;:s1) &lt;-dropWhile isSpace s], <lb/>(x, s2) &lt;-parser top s1, <lb/>(&apos;+&apos;:s3) &lt;-dropWhile isSpace s2], <lb/>(y, s4) &lt;-parser top s3, <lb/>(&apos;)&apos;:s5) &lt;-dropWhile isSpace s4]] <lb/>pcon (c:s) | (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) = pcon&apos; s (ord c -ord &apos;0&apos;) where <lb/>pcon&apos; (c:s) n | (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) = pcon&apos; s (10*n + (ord c -ord &apos;0&apos;)) <lb/>pcon&apos; s n = (unit tmt (Con n), s)] <lb/>pcon _ = ] <lb/>interpN (Con x) _ = unit tmv (Num x) <lb/>interpN (Add x y) env = interpr top x env &lt;&lt;tmv&gt;&gt; (\u -&gt; <lb/>interpr top y env &lt;&lt;tmv&gt;&gt; (\v -&gt; <lb/>case (u, v) of <lb/>(Num j, Num k) -&gt; unit tmv (Num (j+k)) <lb/>(_, _) -&gt; complainr top (&quot;should be numbers: &quot; ++ <lb/>showvalr top (unit tmv u) ++ &quot;, &quot; ++ <lb/>showvalr top (unit tmv v)) <lb/>)) <lb/>interpN (OtherTN x) env = interpr oldpkg x env <lb/>showvalN (Num x) = show x <lb/>showvalN (OtherVN x) = showvalr oldpkg x <lb/>makenumN x = unit tmv (Num x) <lb/>nameN = &quot;numbers &quot; ++ namer oldpkg <lb/>Figure 8: The numbers building block <lb/>TermN t&apos;&apos; t that in actual use t is TermZ and that <lb/>t&apos;&apos; is TermN t&apos;&apos; t. This last discovery produces an <lb/>\occurs error&quot; in both Chalmers Haskell and Glasgow <lb/>Haskell, despite the fact that an algebraic datatype (dy-<lb/>namically) intervenes. The simpli er reduces the type <lb/>declarations to a form in which the circularities are <lb/>textually manifest (see Figure 9), thus rendering them <lb/>palatable to these Haskell implementations. <lb/>9 The Program Simpli er <lb/>The principal activity of the program simpli er is ju-<lb/>dicious inlining of function de nitions followed by -<lb/>reduction of both lambda-expressions and Haskell case-<lb/>expressions. The simpli er also performs -conversion <lb/>where necessary and tries to do a smart job of it, renam-<lb/>ing variables by adding primes; a post-pass heuristically <lb/>tries to minimize the number of primes in the residual <lb/>code while maintaining readability. <lb/>Ideally the necessary types could be deduced com-<lb/>data Term = Con Int | Add Term Term | Bogon <lb/>data Value = Num Int | Wrong <lb/>parse s = pcon s ++ psum s ++ <lb/>(Bogon, s) ] <lb/>where <lb/>psum s&apos; = <lb/>(Add x y, s5) <lb/>| (&apos;(&apos; : s1) &lt;-<lb/>dropWhile isSpace s&apos; ], <lb/>(x, s2) &lt;-parse s1, <lb/>(&apos;+&apos; : s3) &lt;-<lb/>dropWhile isSpace s2 ], <lb/>(y, s4) &lt;-parse s3, <lb/>(&apos;)&apos; : s5) &lt;-<lb/>dropWhile isSpace s4 ] ] <lb/>pcon (c : s&apos;) | ((c &gt;= &apos;0&apos;) &amp;&amp; (c &lt;= &apos;9&apos;)) = <lb/>pcon&apos; s&apos; (ord c -ord &apos;0&apos;) where <lb/>pcon&apos; (c&apos; : s&apos;&apos;) n <lb/>| ((c&apos; &gt;= &apos;0&apos;) &amp;&amp; (c&apos; &lt;= &apos;9&apos;)) = <lb/>pcon&apos; s&apos;&apos; <lb/>((10 * n) + (ord c&apos; -ord &apos;0&apos;)) <lb/>pcon&apos; s&apos;&apos; n = <lb/>(Con n, s&apos;&apos;) ] <lb/>pcon _ = ] <lb/>interp (Con x) _ = Num x <lb/>interp (Add x y) env = <lb/>case (interp x env, interp y env) of <lb/>(Num j, Num k) -&gt; Num (j + k) <lb/>(_, _) -&gt; <lb/>complain (&quot;should be numbers: &quot; ++ <lb/>showval (interp x env) ++ <lb/>&quot;, &quot; ++ <lb/>showval (interp y env)) <lb/>interp Bogon _ = complain &quot;invalid expression&quot; <lb/>makenum x = Num x <lb/>complain s = Wrong <lb/>showval (Num x) = show x <lb/>showval Wrong = &quot;&lt;wrong&gt;&quot; <lb/>name = &quot;numbers interpreter&quot; <lb/>Figure 9: Simpli ed code for the complete numbers <lb/>interpreter <lb/>pletely automatically, but for this work we settled for <lb/>performing substitution and simpli cation on explicitly <lb/>provided type declarations for Term and Value. An in-<lb/>teresting wrinkle is that when two algebraic datatypes <lb/>are nested: <lb/>data Foo = Bar | Baz | OtherFoo Bletch <lb/>data Bletch = Quux | Ztesch <lb/>the type simpli er attens them: <lb/>data Foo = Bar | Baz | Quux | Ztesch <lb/>and arranges for the code simpli er to eliminate applica-<lb/>tions of OtherFoo and to atten nested case constructs <lb/>as appropriate. (This transformation can be justi ed by <lb/>an appeal to category theory; we omit the details here.) <lb/>A simple heuristic controls unrolling of recursive pro-<lb/>cedures: as the body of a procedure is inlined, any out-<lb/>ermost case statement is tagged with the name of the <lb/>procedure; and it is forbidden to inline within a case <lb/>statement for a procedure name that matches the tag. <lb/>Thus unrolling continues only if the gating case state-<lb/>ment can rst be eliminated by partial evaluation. <lb/>The simpli er uses a fast and fairly e ective pretty-<lb/>printer after the style of Waters 18, 12]. <lb/>10 The Nondeterministic Building Block <lb/>The nondeterministic building block extends the term <lb/>data type to include a choice construct Amb x y (surface <lb/>syntax (x|y)), where x and y are top-level terms, and <lb/>a failure operation Fail (surface syntax fail). It also <lb/>alters the value data type to be a list of values. See <lb/>Figure 10. <lb/>Once again the implementation of the interpreter <lb/>closely follows the work of Wadler 16]. Failure results <lb/>in a list of no value, but lifted to the top of value type <lb/>tower. Choice involves interpreting each of the subex-<lb/>pressions and then appending the two lists of results. <lb/>The di erence here from Wadler&apos;s interpreter is that <lb/>the values from the recursive calls to the interpreter are <lb/>not necessarily lists; they are of the top value type and <lb/>must be lowered back to the level of lists before con-<lb/>catenation. This is achieved by using the monad bind <lb/>operation &lt;&lt;tmv&gt;&gt;. The bind operation requires that <lb/>the result then be lifted back to the top value type (us-<lb/>ing unit tmv), which is exactly what we want anyway. <lb/>We choose to print the multiple values one per line, <lb/>followed by the line \That&apos;s all!&quot;. The name of the <lb/>interpreter is the name from the old package preceded <lb/>by the word nondeterministic. <lb/>We can make a nondeterministic interpreter in exactly <lb/>the same manner as we made a numbers interpreter; all <lb/>we need do is to replace the three lines marked \**&quot; in <lb/>Figure 5 with the following: <lb/>type Term = TermL Term TermZ <lb/>type Value = ValueL Value ValueZ <lb/>interp_pkg = complete <lb/>(nondeterministic interpreter) <lb/>However, it is even more interesting to make an inter-<lb/>preter that is nondeterministic and has numbers: <lb/>type Term = TermL Term (TermN Term TermZ) <lb/>type Value = <lb/>ValueL Value (ValueN Value ValueZ) <lb/>interp_pkg = complete <lb/>(nondeterministic (numbers interpreter)) <lb/>data TermL t&apos;&apos; t = Fail | Amb t&apos;&apos; t&apos;&apos; | OtherTL t <lb/>type ValueL v&apos;&apos; v = v] <lb/>mTL = Pseudomonad (\x -&gt; OtherTL x) mTLbind where <lb/>mTLbind m Fail f = unit m Fail <lb/>mTLbind m (Amb x y) f = unit m (Amb x y) <lb/>mTLbind m (OtherTL x) f = f x <lb/>mVL = Pseudomonad (\x -&gt; x]) mVLbind where <lb/>mVLbind m x f = foldr c (unit m ]) <lb/>f a | a &lt;-x ] where <lb/>c x y = x &lt;&lt;m&gt;&gt; (\q -&gt; y &lt;&lt;m&gt;&gt; (\r -&gt; unit m (q ++ r))) <lb/>nondeterministic oldprepkg tmt tmv top = update oldpkg <lb/>ParseR parseL, InterpR interpL, ShowvalR showvalL, NameR nameL] <lb/>where <lb/>oldpkg = oldprepkg (tmt &amp; mTL) (tmv &amp; mVL) top <lb/>parseL s = (pfail s ++ pchoice s ++ parser oldpkg s) where <lb/>pfail s = (unit tmt Fail, s1) | (&apos;f&apos;:&apos;a&apos;:&apos;i&apos;:&apos;l&apos;:s1) &lt;-dropWhile isSpace s]] <lb/>pchoice s = (unit tmt (Amb x y), s5) | (&apos;(&apos;:s1) &lt;-dropWhile isSpace s], <lb/>(x, s2) &lt;-parser top s1, <lb/>(&apos;|&apos;:s3) &lt;-dropWhile isSpace s2], <lb/>(y, s4) &lt;-parser top s3, <lb/>(&apos;)&apos;:s5) &lt;-dropWhile isSpace s4]] <lb/>interpL Fail _ = unit tmv ] <lb/>interpL (Amb x y) env = interpr top x env &lt;&lt;tmv&gt;&gt; (\u -&gt; <lb/>interpr top y env &lt;&lt;tmv&gt;&gt; (\v -&gt; <lb/>unit tmv (u ++ v) )) <lb/>interpL (OtherTL x) env = interpr oldpkg x env <lb/>showvalL m = unlines <lb/>showvalr oldpkg x | x &lt;-m] ++ &quot;That&apos;s all!&quot; <lb/>nameL = &quot;nondeterministic &quot; ++ namer oldpkg <lb/>Figure 10: The nondeterministic building block <lb/>When we then apply our program simpli er to all the <lb/>code in Figures 1{5 plus Figures 8 and 10, the result is <lb/>as shown in Figure 11. (To save space, we have chosen <lb/>to elide the parser from this gure. The parsers follow <lb/>a very predictable pattern anyway.) <lb/>A sample interaction with this interpreter: <lb/>Welcome to the nondeterministic numbers <lb/>interpreter! <lb/>&gt; (2+3) <lb/>5 <lb/>That&apos;s all! <lb/>&gt; (2|3) <lb/>2 <lb/>3 <lb/>That&apos;s all! <lb/>&gt; ((2+3)|(5+7)) <lb/>5 <lb/>12 <lb/>That&apos;s all! <lb/>&gt; ((2|3)|(5|7)) <lb/>2 <lb/>3 <lb/>5 <lb/>7 <lb/>That&apos;s all! <lb/>&gt; ((2|3)+(5|7)) <lb/>7 <lb/>9 <lb/>8 <lb/>10 <lb/>That&apos;s all! <lb/>(Note that the two pairs of values interacted to produce <lb/>four distinct sums.) <lb/>&gt; (fail|5) <lb/>5 <lb/>That&apos;s all! <lb/>&gt; fail <lb/>That&apos;s all! <lb/>&gt; ((2|3)+(fail|7)) <lb/>9 <lb/>10 <lb/>That&apos;s all! <lb/>data Term = Fail | Amb Term Term <lb/>| Con Int | Add Term Term | Bogon <lb/>type Value = <lb/>Value&apos; ] <lb/>data Value&apos; = Num Int | Wrong <lb/>parse s = ... <lb/>interp Fail _ = ] <lb/>interp (Amb x y) env = <lb/>interp x env ++ interp y env <lb/>interp (Con x) _ = <lb/>Num x ] <lb/>interp (Add x y) env = <lb/>foldr (++) <lb/>] <lb/>foldr (++) <lb/>] <lb/>case (a, a&apos;) of <lb/>(Num j, Num k) -&gt; <lb/>Num (j + k) ] <lb/>(_, _) -&gt; <lb/>complain <lb/>(&quot;should be numbers: &quot; <lb/>++ <lb/>showval <lb/>a ] ++ <lb/>&quot;, &quot; ++ <lb/>showval <lb/>a&apos; ]) <lb/>| a&apos; &lt;-interp y env ] <lb/>| a &lt;-interp x env ] <lb/>interp Bogon _ = complain &quot;invalid expression&quot; <lb/>makenum x = <lb/>Num x ] <lb/>complain s = <lb/>Wrong ] <lb/>showval m = <lb/>unlines <lb/>case x of <lb/>Num x&apos; -&gt; show x&apos; <lb/>Wrong -&gt; &quot;&lt;wrong&gt;&quot; <lb/>| x &lt;-m ] ++ <lb/>&quot;That&apos;s all!&quot; <lb/>name = &quot;nondeterministic numbers interpreter&quot; <lb/>Figure 11: Simpli ed code for the complete nondeter-<lb/>ministic numbers interpreter (parser elided) <lb/>11 The Call-By-Value Building Block <lb/>It is of particular interest that what we usually think of <lb/>as the very soul of an interpreter, the handling of vari-<lb/>ables and lambda-binding and function calls, is in fact <lb/>just another set of features that can be separated out <lb/>into a building block. The cbv building block extends <lb/>the term data type to include variable references Var v, <lb/>lambda expressions Lam v x, and function applications <lb/>App x y, where v is a string and x and y are top-level <lb/>terms. It also extends the value data type to include <lb/>functional values Fun f, where f is a function; the func-<lb/>tion maps values at the current level of the type tower <lb/>into values at the top of the type tower. See Figure 12. <lb/>Once again the implementation of the interpreter <lb/>closely follows the work of Wadler 16]. However, we <lb/>choose to nest the de nition of lookup within the de -<lb/>nition of one case of interpCBV. <lb/>Note that makefunCBV accepts a function f and com-<lb/>poses it with unit tmv. This is because a call-by-value <lb/>Fun value must be of type v -&gt; v&apos;&apos; but a MakefunR <lb/>routine takes an argument of type v&apos;&apos; -&gt; v&apos;&apos;. There <lb/>is a reason for this di erence: as we will see, the call-<lb/>by-name building block uses Fun values of a di erent <lb/>type, but the MakefunR interface remains constants. <lb/>This allows such clients of the MakefunR interface as <lb/>the continuation building block to be combined with <lb/>either the call-by-value or the call-by-name building <lb/>block. <lb/>We parse the surface syntax \\v.x&quot; for lambda expres-<lb/>sions and (f x) for application of function f to argument <lb/>x. We print functional values as \&lt;function&gt;&quot;. <lb/>To add the call-by-value features into our nondeter-<lb/>ministic numbers interpreter, we write this code: <lb/>type Term = TermCBV Term <lb/>(TermL Term (TermN Term TermZ)) <lb/>type Value = ValueCBV Value <lb/>(ValueL Value (ValueN Value ValueZ)) <lb/>interp_pkg = complete (cbv <lb/>(nondeterministic (numbers interpreter))) <lb/>A sample interaction with this interpreter: <lb/>Welcome to the call-by-value nondeterministic <lb/>numbers interpreter! <lb/>&gt; \x.x <lb/>&lt;function&gt; <lb/>&gt; ((\x.\y.(x+y) 3) 4) <lb/>7 <lb/>That&apos;s all! <lb/>&gt; ((\f.\x.(f (f (f x))) \q.(q+q)) 3) <lb/>24 <lb/>That&apos;s all! <lb/>Currying and functional arguments work ne. <lb/>&gt; ((\x.\y.(x+y) (2|3)) (5|7)) <lb/>7 <lb/>9 <lb/>8 <lb/>10 <lb/>That&apos;s all! <lb/>So far, so good : : : <lb/>&gt; ((\x.x|\y.(y+y)) 3) <lb/>3 <lb/>That&apos;s all! <lb/>data TermCBV t&apos;&apos; t = Var String | Lambda String t&apos;&apos; | App t&apos;&apos; t&apos;&apos; | OtherTCBV t <lb/>data ValueCBV v&apos;&apos; v = Fun (ValueCBV v&apos;&apos; v -&gt; v&apos;&apos;) | OtherVCBV v <lb/>mTCBV = Pseudomonad (\x -&gt; OtherTCBV x) mTCBVbind where <lb/>mTCBVbind m (Var x) f = unit m (Var x) <lb/>mTCBVbind m (Lambda v x) f = unit m (Lambda v x) <lb/>mTCBVbind m (App x y) f = unit m (App x y) <lb/>mTCBVbind m (OtherTCBV x) f = f x <lb/>mVCBV = Pseudomonad (\x -&gt; OtherVCBV x) mVCBVbind where <lb/>mVCBVbind m = qxfoo where <lb/>qxfoo (Fun x) f = unit m (Fun x) <lb/>qxfoo (OtherVCBV x) f = f x <lb/>cbv oldprepkg tmt tmv top = update oldpkg <lb/>ParseR parseCBV, InterpR interpCBV, ShowvalR showvalCBV, <lb/>MakefunR makefunCBV, ApplyR applyCBV, NameR nameCBV] where <lb/>oldpkg = oldprepkg (tmt &amp; mTCBV) (tmv &amp; mVCBV) top <lb/>parseCBV s = (pvar s ++ plambda s ++ papp s ++ parser oldpkg s) where <lb/>pvar (c:s) | c `elem`&quot;abcdefghijklmnopqrstuvwxyz&quot; = pvar&apos; s c] where <lb/>pvar&apos; (c:s) v | c `elem`&quot;abcdefghijklmnopqrstuvwxyz&quot; = pvar&apos; s (v ++ c]) <lb/>pvar&apos; _ v = (unit tmt (Var v), s)] <lb/>pvar _ = ] <lb/>plambda s = (unit tmt (Lambda v x), s4) | (&apos;\\&apos;:s1) &lt;-dropWhile isSpace s], <lb/>(Var v, s2) &lt;-pvar s1, <lb/>(&apos;.&apos;:s3) &lt;-dropWhile isSpace s2], <lb/>(x, s4) &lt;-parser top s3] <lb/>papp s = (unit tmt (App x y), s5) | (&apos;(&apos;:s1) &lt;-dropWhile isSpace s], <lb/>(x, (c:s2)) &lt;-parser top s1, <lb/>isSpace c, <lb/>s3 &lt;-dropWhile isSpace s2], <lb/>(y, s4) &lt;-parser top s3, <lb/>(&apos;)&apos;:s5) &lt;-dropWhile isSpace s4]] <lb/>interpCBV (Var v) env = lookup v env where <lb/>lookup v ((w,z):_) | (v == w) = unit tmv z <lb/>lookup v (_:e) = lookup v e <lb/>lookup v ] = complainr top (&quot;unbound variable: &quot; ++ v) <lb/>interpCBV (Lambda v x) env = unit tmv (Fun (\z -&gt; interpr top x ((v,z):env))) <lb/>interpCBV (App x y) env = interpr top x env &lt;&lt;tmv&gt;&gt; (\u -&gt; <lb/>interpr top y env &lt;&lt;tmv&gt;&gt; (\v -&gt; <lb/>applyr top u v )) <lb/>interpCBV (OtherTCBV x) env = interpr oldpkg x env <lb/>applyCBV (Fun f) x = f x <lb/>applyCBV u _ = complainr top (&quot;should be function: &quot; ++ <lb/>showvalr top (unit tmv u)) <lb/>showvalCBV (Fun x) = &quot;&lt;function&gt;&quot; <lb/>showvalCBV (OtherVCBV x) = showvalr oldpkg x <lb/>makefunCBV f = Fun (f . unit tmv) <lb/>nameCBV = &quot;call-by-value &quot; ++ namer oldpkg <lb/>Figure 12: The call-by-value building block <lb/>That&apos;s strange : : : why didn&apos;t it also print the value 6? <lb/>&gt; (\x.x|\y.(y+y)) <lb/>&lt;function&gt; <lb/>Ooh, weird! Trying to choose a function produces only <lb/>the rst one! And it didn&apos;t even print \That&apos;s all!&quot;! <lb/>(It didn&apos;t print it when we tried \\x.x&quot;, either.) <lb/>But this is entirely correct. We chose to add in the <lb/>call-by-value building block after adding in the nonde-<lb/>terministic building block. So the nondeterminism gov-<lb/>erns number values Num n but it doesn&apos;t govern func-<lb/>tional values Fun f. Let&apos;s look at just the de nition of <lb/>the Value type produced by the program simpli er: <lb/>data Value = Fun (Value -&gt; Value) <lb/>| OtherVCBV <lb/>Value&apos; ] <lb/>data Value&apos; = Num Int | Wrong <lb/>Sure enough, you can represent a list of numbers but <lb/>not a list of functions. <lb/>The moral is that while you can compose any build-<lb/>ing blocks you like, it matters in what order you do it. <lb/>This is not to say that the call-by-value nondeterminis-<lb/>tic numbers interpreter is \incorrect&quot; in any sense; it is <lb/>a perfectly legitimate, working combination of the spec-<lb/>i ed building blocks into a working interpreter. It just <lb/>may not be the interpreter we want for a given purpose. <lb/>Perhaps we would prefer the nondeterministic call-by-<lb/>value numbers interpreter: <lb/>type Term = TermL Term <lb/>(TermCBV Term (TermN Term TermZ)) <lb/>type Value = ValueL Value <lb/>(ValueCBV Value (ValueN Value ValueZ)) <lb/>interp_pkg = complete (nondeterministic <lb/>(cbv (numbers interpreter))) <lb/>When we then apply our program simpli er to all the <lb/>relevant code, the result is as shown in Figure 13. (Again <lb/>we elide the parser.) <lb/>A sample interaction with this interpreter: <lb/>Welcome to the nondeterministic call-by-value <lb/>numbers interpreter! <lb/>&gt; \x.x <lb/>&lt;function&gt; <lb/>That&apos;s all! <lb/>Ah, that&apos;s better! <lb/>&gt; ((\x.\y.(x+y) 3) 4) <lb/>7 <lb/>That&apos;s all! <lb/>&gt; ((\f.\x.(f (f (f x))) \q.(q+q)) 3) <lb/>24 <lb/>That&apos;s all! <lb/>&gt; ((\x.\y.(x+y) (2|3)) (5|7)) <lb/>7 <lb/>9 <lb/>8 <lb/>10 <lb/>That&apos;s all! <lb/>All this stu works as before. <lb/>&gt; ((\x.x|\y.(y+y)) 3) <lb/>3 <lb/>6 <lb/>That&apos;s all! <lb/>&gt; (\x.x|\y.(y+y)) <lb/>&lt;function&gt; <lb/>&lt;function&gt; <lb/>That&apos;s all! <lb/>And now we can also have choices of functions. <lb/>&gt; (\x.(x+x) (2|3)) <lb/>4 <lb/>6 <lb/>That&apos;s all! <lb/>This last exchange indicates that it is truly call-by-value: <lb/>the two references to x in the body of \x.(x+x) both <lb/>get the same value, either both 2 or both 3. <lb/>12 The Call-By-Name Building Block <lb/>The call-by-name building block is quite similar to the <lb/>call-by-value building block, with only some subtle dif-<lb/>ferences in the use of the monads (the ve lines di ering <lb/>other than in the names of variables from those in Fig-<lb/>ure 12 are marked ##). But this makes all the di erence <lb/>in the world. See Figure 14. <lb/>We can specify the nondeterministic call-by-name <lb/>numbers interpreter: <lb/>type Term = TermL Term <lb/>(TermCBN Term (TermN Term TermZ)) <lb/>type Value = ValueL Value <lb/>(ValueCBN Value (ValueN Value ValueZ)) <lb/>interp_pkg = complete (nondeterministic <lb/>(cbn (numbers interpreter))) <lb/>(We forebear to show the simpli ed code; as you might <lb/>expect, it di ers in exactly ve places from the simpli ed <lb/>call-by-value code in Figure 13.) <lb/>A sample interaction with this interpreter: <lb/>Welcome to the nondeterministic call-by-name <lb/>numbers interpreter! <lb/>&gt; \x.x <lb/>&lt;function&gt; <lb/>That&apos;s all! <lb/>&gt; ((\x.\y.(x+y) 3) 4) <lb/>7 <lb/>That&apos;s all! <lb/>data Term = Fail | Amb Term Term | Var String | Lambda String Term <lb/>| App Term Term | Con Int | Add Term Term | Bogon <lb/>type Value = <lb/>Value&apos; ] <lb/>data Value&apos; = Fun (Value&apos; -&gt; Value) | Num Int | Wrong <lb/>parse s = ... <lb/>interp Fail _ = ] <lb/>interp (Amb x y) env = interp x env ++ interp y env <lb/>interp (Var v) env = lookup v env where <lb/>lookup v&apos; ((w, z) : _) | (v&apos; == w) = <lb/>z ] <lb/>lookup v&apos; (_ : e) = lookup v&apos; e <lb/>lookup v&apos; ] = complain (&quot;unbound variable: &quot; ++ v&apos;) <lb/>interp (Lambda v x) env = <lb/>Fun (\ z -&gt; interp x ((v, z) : env)) ] <lb/>interp (App x y) env = <lb/>foldr (++) ] <lb/>foldr (++) ] <lb/>apply a a&apos; | a&apos; &lt;-interp y env ] | a &lt;-interp x env ] <lb/>interp (Con x) _ = <lb/>Num x ] <lb/>interp (Add x y) env = <lb/>foldr (++) ] <lb/>case a of <lb/>Fun x&apos; -&gt; <lb/>Fun x&apos; ] <lb/>x&apos; -&gt; <lb/>foldr (++) ] <lb/>case a&apos; of <lb/>Fun x&apos;&apos; -&gt; <lb/>Fun x&apos;&apos; ] <lb/>x&apos;&apos; -&gt; <lb/>case (x&apos;, x&apos;&apos;) of <lb/>(Num j, Num k) -&gt; <lb/>Num (j + k) ] <lb/>(_, _) -&gt; <lb/>complain (&quot;should be numbers: &quot; ++ <lb/>showval <lb/>x&apos; ] ++ <lb/>&quot;, &quot; ++ <lb/>showval <lb/>x&apos;&apos; ]) <lb/>| a&apos; &lt;-interp y env ] <lb/>| a &lt;-interp x env ] <lb/>interp Bogon _ = complain &quot;invalid expression&quot; <lb/>apply (Fun f) x = f x <lb/>apply u _ = complain (&quot;should be function: &quot; ++ showval <lb/>u ]) <lb/>makefun f = Fun (f . (\ x -&gt; <lb/>x ])) <lb/>makenum x = <lb/>Num x ] <lb/>complain s = <lb/>Wrong ] <lb/>showval m = <lb/>unlines <lb/>case x of <lb/>Fun x&apos; -&gt; &quot;&lt;function&gt;&quot; <lb/>Num x&apos; -&gt; show x&apos; <lb/>Wrong -&gt; &quot;&lt;wrong&gt;&quot; <lb/>| x &lt;-m ] ++ <lb/>&quot;That&apos;s all!&quot; <lb/>name = &quot;nondeterministic call-by-value numbers interpreter&quot; <lb/>Figure 13: Simpli ed code for the complete nondeterministic call-by-value numbers interpreter (parser elided) <lb/>data TermCBN t&apos;&apos; t = Var String | Lambda String t&apos;&apos; | App t&apos;&apos; t&apos;&apos; | OtherTCBN t <lb/>data ValueCBN v&apos;&apos; v = Fun (v&apos;&apos; -&gt; v&apos;&apos;) | OtherVCBN v <lb/>--## <lb/>mTCBN = ... <lb/>--identical to mTCBV except names have &quot;N&quot; instead of &quot;V&quot; <lb/>mVCBN = ... <lb/>--identical to mVCBV except names have &quot;N&quot; instead of &quot;V&quot; <lb/>cbn oldprepkg tmt tmv top = update oldpkg <lb/>ParseR parseCBN, InterpR interpCBN, ShowvalR showvalCBN, <lb/>MakefunR makefunCBN, ApplyR applyCBN, NameR nameCBN] where <lb/>oldpkg = oldprepkg (tmt &amp; mTCBN) (tmv &amp; mVCBN) top <lb/>parseCBN s = ... --identical to parseCBV <lb/>interpCBN (Var v) env = lookup v env where <lb/>lookup v ((w,z):_) | (v == w) = z <lb/>--## <lb/>lookup v (_:e) = lookup v e <lb/>lookup v ] = complainr top (&quot;unbound variable: &quot; ++ v) <lb/>interpCBN (Lambda v x) env = unit tmv (Fun (\z -&gt; interpr top x ((v,z):env))) <lb/>interpCBN (App x y) env = interpr top x env &lt;&lt;tmv&gt;&gt; (\u -&gt; <lb/>applyr top u (interpr top y env)) <lb/>--## <lb/>interpCBN (OtherTCBN x) env = interpr oldpkg x env <lb/>applyCBN (Fun f) x = f x <lb/>applyCBN u _ = complainr top (&quot;should be function: &quot; ++ <lb/>showvalr top (unit tmv u)) <lb/>showvalCBN (Fun x) = &quot;&lt;function&gt;&quot; <lb/>showvalCBN (OtherVCBN x) = showvalr oldpkg x <lb/>makefunCBN f = unit tmv (Fun f) <lb/>--## <lb/>nameCBN = &quot;call-by-name &quot; ++ namer oldpkg <lb/>--## <lb/>Figure 14: The call-by-name building block (some parts identical to those in call-by-value building block elided) <lb/>&gt; ((\f.\x.(f (f (f x))) \q.(q+q)) 3) <lb/>24 <lb/>That&apos;s all! <lb/>&gt; ((\x.\y.(x+y) (2|3)) (5|7)) <lb/>7 <lb/>9 <lb/>8 <lb/>10 <lb/>That&apos;s all! <lb/>&gt; ((\x.x|\y.(y+y)) 3) <lb/>3 <lb/>6 <lb/>That&apos;s all! <lb/>&gt; (\x.x|\y.(y+y)) <lb/>&lt;function&gt; <lb/>&lt;function&gt; <lb/>That&apos;s all! <lb/>This is all exactly as before. How do we know it is <lb/>call-by-name? <lb/>&gt; (\x.(x+x) (2|3)) <lb/>4 <lb/>5 <lb/>5 <lb/>6 <lb/>That&apos;s all! <lb/>This last exchange indicates that it is truly call-by-<lb/>name: the two references to x in the body of \x.(x+x) <lb/>each perform the calculation (2|3) anew, resulting in a <lb/>total of four possibilities. <lb/>13 The Continuation Building Block <lb/>The continuation building block extends the term data <lb/>type to include a construct Catch v y. (Wadler 16] <lb/>called this construct Callcc, but this was an error; it <lb/>has the form of the original Scheme CATCH construct 14]. <lb/>However, his function callccK was indeed a \callcc&quot;-<lb/>type operation.) The continuation building block also <lb/>alters the value data type to be a Haskell function that, <lb/>when given a continuation (a Haskell function that maps <lb/>values to values) produces a value. See Figure 15. <lb/>The continuation building block was the most di -<lb/>cult to construct|it took a long time to get the types <lb/>right! Even so, problems lurk. We would much prefer <lb/>that the value type be <lb/>type ValueC v&apos;&apos; v = ((v -&gt; r) -&gt; r) <lb/>where r is a free type variable. In other words, we <lb/>want the lifted value type to be polymorphic over var-<lb/>ious types of continuation that produce various types <lb/>of result, for there are con icting requirements. In <lb/>showvalC, we need to be able to extract an underlying <lb/>value by feeding the identity continuation to a ValueC <lb/>value; here we need r = v. But the implementation <lb/>of Catch shown in Figure 15 requires that a \captured <lb/>continuation&quot; return a value at the top of the type <lb/>tower; here we need r = v&apos;&apos;. The net e ect is that <lb/>we must have v = v&apos;&apos;. The practical e ect is to limit <lb/>the continuation building block to be the last (that is, <lb/>leftmost) one applied. (If you try to build a nondeter-<lb/>ministic continuation interpreter, for example, Haskell <lb/>will report a type error on the simpli ed code; it sim-<lb/>ply doesn&apos;t work out. A continuation nondeterministic <lb/>interpreter works ne.) <lb/>We can specify the continuation nondeterministic call-<lb/>by-value numbers interpreter: <lb/>type Term = TermC Term (TermL Term <lb/>(TermCBV Term (TermN Term TermZ)) <lb/>type Value = ValueC Value (ValueL Value <lb/>(ValueCBV Value (ValueN Value ValueZ)) <lb/>interp_pkg = complete (continuation <lb/>(nondeterministic (cbv <lb/>(numbers interpreter)))) <lb/>When we apply our program simpli er to all the relevant <lb/>code, the result is as shown in Figure 16. (This time we <lb/>elide the parser and the interpreter case for Add.) <lb/>Inspection of the interpreter case for Catch reveals <lb/>the expected code: x is interpreted in an environment <lb/>in which variable v is bound to a function that, when <lb/>given a value z and a continuation cc, proceeds to ig-<lb/>nore cc and instead feeds to z the continuation q of <lb/>the Catch expression. (Note that the simpli er wasn&apos;t <lb/>smart enough to do an -reduction on \a -&gt; q a.) <lb/>It is also of interest to examine the rst argument <lb/>to each occurrence of foldr in the interpreter case for <lb/>App. Recall that the call to foldr comes from the <lb/>nondeterministic building block; its purpose is to <lb/>append-reduce (in monad terminology, join) a list of <lb/>lists. Now that we have added in the continuation <lb/>building block, we see that the rst argument to foldr <lb/>is none other than the continuation-passing version of <lb/>++! And its second argument is the continuation-passing <lb/>version \c -&gt; c ] of the empty list ] <lb/>A sample interaction with this interpreter: <lb/>Welcome to the continuation nondeterministic <lb/>call-by-value numbers interpreter! <lb/>&gt; Catch v (2+3) <lb/>5 <lb/>That&apos;s all! <lb/>&gt; Catch v (2+(v 3)) <lb/>3 <lb/>That&apos;s all! <lb/>&gt; (4+Catch v (2+(v 3))) <lb/>7 <lb/>That&apos;s all! <lb/>&gt; (4+Catch v (2|(v 3))) <lb/>7 <lb/>That&apos;s all! <lb/>&gt; (4|Catch v (2|(v 3))) <lb/>4 <lb/>3 <lb/>That&apos;s all! <lb/>14 The Errors Building Block <lb/>The errors building block introduces no new terms; its <lb/>only purpose is to preserve the string argument given to <lb/>the complain function rather than discarding it, thereby <lb/>producing an error message perhapos more useful than <lb/>\&lt;wrong&gt;&quot;! <lb/>Welcome to the nondeterministic errors <lb/>call-by-value numbers interpreter! <lb/>&gt; (3+x) <lb/>Error: unbound variable: x <lb/>That&apos;s all! <lb/>&gt; (3+(x|(5|y))) <lb/>Error: unbound variable: x <lb/>8 <lb/>Error: unbound variable: y <lb/>That&apos;s all! <lb/>&gt; (3+(x|(|y))) <lb/>Error: unbound variable: x <lb/>Error: invalid expression <lb/>Error: unbound variable: y <lb/>That&apos;s all! <lb/>&gt; (3+(x|\y.y)) <lb/>Error: unbound variable: x <lb/>&lt;function&gt; <lb/>That&apos;s all! <lb/>The last interaction reminds us of an unsatisfactory <lb/>property of the interpreter framework we have used. Be-<lb/>cause functions are higher in the value tower than num-<lb/>bers, attempting to add a function to a number does not <lb/>produce the error message \should be numbers : : :&quot; <lb/>but merely returns the function (as dictated by the pseu-<lb/>dobind operation mVCBVbind in Figure 12). (A possible <lb/>solution: the code in interpN for Add should not use <lb/>pseudobinding to extract a numeric value, but a related <lb/>operation that calls an \error thunk&quot; if it is unable to <lb/>descend to the Num representation. The problem is that <lb/>this operation must be provided by all pseudomonads; <lb/>but it may be worth it.) <lb/>data TermC t&apos;&apos; t = Catch String t&apos;&apos; | OtherTC t <lb/>type ValueC v&apos;&apos; v = ((v -&gt; v) -&gt; v) <lb/>mTC = Pseudomonad (\x -&gt; OtherTC x) mTCbind where <lb/>mTCbind m (Catch v x) f = unit m (Catch v x) <lb/>mTCbind m (OtherTC x) f = f x <lb/>mVC = Pseudomonad (\x c -&gt; c x) mVCbind where <lb/>mVCbind m x f cc = x (\a -&gt; f a cc) <lb/>continuation oldprepkg tmt tmv top = update oldpkg <lb/>ParseR parseC, InterpR interpC, ShowvalR showvalC, NameR nameC] where <lb/>oldpkg = oldprepkg (tmt &amp; mTC) qxtmv top <lb/>qxtmv = tmv &amp; mVC <lb/>parseC s = (pcatch s ++ parser oldpkg s) where <lb/>pcatch s = (unit tmt (Catch v x), s3) <lb/>| (&apos;C&apos;:&apos;a&apos;:&apos;t&apos;:&apos;c&apos;:&apos;h&apos;:c1:s1) &lt;-dropWhile isSpace s], <lb/>isSpace c1, <lb/>(Var v, c2:s2) &lt;-parser top s1, <lb/>isSpace c2, <lb/>(x, s3) &lt;-parser top s2] <lb/>interpC (Catch v x) env = <lb/>callcc (\k -&gt; interp x ((v, makefunr top (\z -&gt; z &lt;&lt;qxtmv&gt;&gt; k)):env)) where <lb/>callcc h q = h (\b d -&gt; q b) q <lb/>interpC (OtherTC x) env = interpr oldpkg x env <lb/>showvalC x = showvalr oldpkg (x (\q -&gt; q)) <lb/>nameC = &quot;continuation &quot; ++ namer oldpkg <lb/>Figure 15: The continuation building block <lb/>15 Why Haskell? <lb/>The restrictions of the Haskell type system certainly <lb/>caused some problems along the way. Several times I <lb/>was sorely tempted to switch to Scheme or Common <lb/>Lisp. Had I used a dialect of Lisp, it would have been <lb/>much easier to code the program simpli er, because <lb/>Lisp already provides a parser and pretty-printer. Then <lb/>again, working in Lisp might have avoided the need for a <lb/>program simpli er altogether, since the principal prac-<lb/>tical motivation for it was to transform the code into a <lb/>form acceptable to the Haskell type-checker. <lb/>The truth is that (a) Wadler had conducted his work <lb/>in Haskell and it seemed appropriate to preserve nota-<lb/>tional continuity, and (b) I was looking for an excuse <lb/>to gain experience with using Haskell anyway. In the <lb/>end, I have to say that the type checking was more <lb/>help than hindrance, especially in the construction of <lb/>the continuations building block. I had the same ex-<lb/>perience with Haskell that I had twenty years ago with <lb/>ECL 19] (which was, in e ect, also a strongly-typed <lb/>dialect of Lisp): almost always, once I made the type <lb/>checker happy, the program was correct. Moreover, the <lb/>challenge of trying force pseudomonads into the Haskell <lb/>type framework taught me a lot about the strengths and <lb/>limitations of both, in much the same way that trying <lb/>to hammer a set of lovely but vague thoughts into the <lb/>form of a sonnet yields great insight into the strengths <lb/>and limitations of the English language (for example, <lb/>the wealth of synonyms but the paucity of rhymes for <lb/>\love&quot;) while clarifying, not always comfortably, one&apos;s <lb/>romantic impulses. <lb/>16 Why Monads? <lb/>More than one reviwer of this work has asked me, <lb/>\So what&apos;s the big deal about monads? Isn&apos;t what <lb/>you have done simply `good functional programming <lb/>style&apos;?&quot; I feel compelled to explain myself on this point. <lb/>Well, maybe that&apos;s all it is, \merely&quot; good style <lb/>(which perhaps I should simply accept as a compliment, <lb/>never mind that it may be back-handed!). But I feel <lb/>that I never would have thought of this style of decom-<lb/>posing interpreters without exposure to the structuring <lb/>ideas suggested by monads and the use to which Philip <lb/>Wadler, Mark Jones, and others have put them. The-<lb/>ory is not automatically wonderful by virtue of being <lb/>theory, but it justi es itself by leading one to pragmatic <lb/>solutions that would otherwise have seemed implausi-<lb/>ble. That is exactly what happpened in this instance. <lb/>data Term = Catch String Term | Fail | Amb Term Term | Var String <lb/>| Lambda String Term | App Term Term | Con Int | Add Term Term | Bogon <lb/>type Value = ( Value&apos; ] -&gt; <lb/>Value&apos; ]) -&gt; <lb/>Value&apos; ] <lb/>data Value&apos; = Fun (Value&apos; -&gt; Value) | Num Int | Wrong <lb/>parse s = ... <lb/>interp (Catch v x) env = \ q -&gt; <lb/>interp x ((v, makefun (\ z -&gt; \ cc -&gt; z (\ a -&gt; q a))) : env) q <lb/>interp Fail _ = \ c -&gt; c ] <lb/>interp (Amb x y) env = \ cc -&gt; interp x env (\ a -&gt; interp y env (\ a&apos; -&gt; cc (a ++ a&apos;))) <lb/>interp (Var v) env = lookup v env where <lb/>lookup v&apos; ((w, z) : _) | (v&apos; == w) = \ c -&gt; c <lb/>z ] <lb/>lookup v&apos; (_ : e) = lookup v&apos; e <lb/>lookup v&apos; ] = complain (&quot;unbound variable: &quot; ++ v&apos;) <lb/>interp (Lambda v x) env = \ c -&gt; c <lb/>Fun (\ z -&gt; interp x ((v, z) : env)) ] <lb/>interp (App x y) env = \ cc -&gt; <lb/>interp x env <lb/>(\ a -&gt; <lb/>foldr (\ x&apos; y&apos; -&gt; \ cc&apos; -&gt; x&apos; (\ a&apos; -&gt; y&apos; (\ a&apos;&apos; -&gt; cc&apos; (a&apos; ++ a&apos;&apos;)))) <lb/>(\ c -&gt; c ]) <lb/>\ cc&apos; -&gt; <lb/>interp y env <lb/>(\ a&apos;&apos; -&gt; <lb/>foldr (\ x&apos; y&apos; -&gt; <lb/>\ cc&apos;&apos; -&gt; <lb/>x&apos; (\ a&apos;&apos;&apos; -&gt; y&apos; (\ a&apos;&apos;&apos;&apos; -&gt; cc&apos;&apos; (a&apos;&apos;&apos; ++ a&apos;&apos;&apos;&apos;)))) <lb/>(\ c -&gt; c ]) <lb/>apply a&apos; a&apos;&apos;&apos; | a&apos;&apos;&apos; &lt;-a&apos;&apos; ] <lb/>cc&apos;) <lb/>| a&apos; &lt;-a ] <lb/>cc) <lb/>interp (Con x) _ = \ c -&gt; c <lb/>Num x ] <lb/>interp (Add x y) env = \ cc -&gt; ... <lb/>interp Bogon _ = complain &quot;invalid expression&quot; <lb/>apply (Fun f) x = f x <lb/>apply u _ = complain (&quot;should be function: &quot; ++ showval (\ c -&gt; c <lb/>u ])) <lb/>makefun f = Fun (f . (\ x c -&gt; c x) . (\ x -&gt; <lb/>x ])) <lb/>makenum x = \ c -&gt; c <lb/>Num x ] <lb/>complain s = \ c -&gt; c <lb/>Wrong ] <lb/>showval x = <lb/>unlines <lb/>case x&apos; of <lb/>Fun x&apos;&apos; -&gt; &quot;&lt;function&gt;&quot; <lb/>Num x&apos;&apos; -&gt; show x&apos;&apos; <lb/>Wrong -&gt; &quot;&lt;wrong&gt;&quot; <lb/>| x&apos; &lt;-x (\ q -&gt; q) ] ++ <lb/>&quot;That&apos;s all!&quot; <lb/>name = &quot;continuation nondeterministic call-by-value numbers interpreter&quot; <lb/>Figure 16: Simpli ed code for the complete continuation nondeterministic call-by-value numbers interpreter (parser <lb/>and interpreter case for Add elided) <lb/>type TermE t&apos;&apos; t = t <lb/>data ValueE v&apos;&apos; v = Err String | OtherVE v <lb/>mTE = Pseudomonad (\x -&gt; x) (\x f -&gt; f x) <lb/>mVE = Pseudomonad (\x -&gt; OtherVE x) mVEbind where <lb/>mVEbind m = parsequux where <lb/>parsequux (Err x) f = unit m (Err x) <lb/>parsequux (OtherVE x) f = f x <lb/>errors oldprepkg tmt tmv top = update oldpkg <lb/>ShowvalR showvalE, ComplainR complainE, <lb/>NameR nameE] where <lb/>oldpkg = oldprepkg (tmt &amp; mTE) (tmv &amp; mVE) top <lb/>complainE s = unit tmv (Err s) <lb/>showvalE (Err x) = &quot;Error: &quot; ++ x <lb/>showvalE (OtherVE x) = showvalr oldpkg x <lb/>nameE = &quot;errors &quot; ++ namer oldpkg <lb/>Figure 17: The errors building block <lb/>(I draw a parallel to the changes in style of an assembly <lb/>language programmer once exposed to the principles of <lb/>structured programming.) Moreover, I hold out some <lb/>hope that, once the slightly ad hoc techniques I have <lb/>stumbled across here have been back-translated into ap-<lb/>propriately mathematical language, some suitably qual-<lb/>i ed category theorist will remark, \Oh, yes, that&apos;s sim-<lb/>ilar to this notion we&apos;ve known about for years; it has <lb/>the following marvelous properties, and if you will only <lb/>do things this way instead you&apos;ll have a much easier time <lb/>of it.&quot; Which is an excellent relation for theory to hold <lb/>to practice. <lb/>17 Comparison with Other Work <lb/>This paper is essentially one long reformulation of <lb/>Wadler&apos;s work 16] to add the crucial capability of com-<lb/>position. It owes its roots to all the work that Wadler <lb/>cites, of course, notably that of Reynolds 10]. It is also <lb/>in the spirit of my own earlier work with Sussman 13]. <lb/>In this presentation I have omitted all the proofs, par-<lb/>ticularly proofs of monad associativity. In some cases <lb/>they do not exist; that is, some of the putative monads <lb/>that arise in the interpreters presented here are not re-<lb/>ally associative. This obstructs proofs of program equiv-<lb/>alence of the kind discussed by Wadler 16] but other-<lb/>wise seems to have little practical e ect. Nevertheless, <lb/>further investigation is warranted. Certain simple but <lb/>important cases, such as lists and simple coproducts, <lb/>are well-behaved; when provided as pseudomonads to <lb/>the composition operator &amp; the result obeys the monad <lb/>associative law and therefore really is always a monad. <lb/>King and Wadler 5], for example, consider not only lists <lb/>but also trees, bags, and sets. <lb/>Simon Peyton Jones and Wadler have investigated the <lb/>use of monads to perform I/O and other \imperative&quot; <lb/>tasks within a working compiler coded in Haskell 7]. <lb/>Jonathan Rees has coded monadic interpreters in <lb/>Scheme but this work apparently has not been pub-<lb/>lished 9]. <lb/>Mark Jones has developed Gofer, a variant of Haskell <lb/>that allows additional polymorphism through the use of <lb/>type classes 4]. Gofer supports programming with mul-<lb/>tiple monads, including a cleaner version of the monad <lb/>comprehension syntax proposed by Wadler 15]. Repre-<lb/>senting monads as a Gofer type class allows the Gofer <lb/>type system to deduce which monad is intended in a unit <lb/>or bind operation, avoiding the need to reify monads in <lb/>the manner shown in this paper. Jones has begun to <lb/>explore the possibility of recoding the interpreters pre-<lb/>sented here so as to use Gofer&apos;s simpler monadic pro-<lb/>gramming style 3]. <lb/>Many of the ideas presented here were anticipated by <lb/>Moggi 6]: <lb/>To give semantics to a complex language <lb/>L we propose a stepwise approach, which <lb/>starts from a monad (notion of computation) <lb/>corresponding to a toy sublanguage of L and <lb/>then at each step applies a monad construc-<lb/>tor which adds one feature to the language. <lb/>Moggi then goes on to present theoretical descriptions <lb/>of several useful monad constructors, including excep-<lb/>tions, side e ects, and continuations. To the best of our <lb/>knowledge, however, the work presented here is the rst <lb/>to put this idea into practice to produce actual working <lb/>interpreters from monad-like building blocks. <lb/>Our work also factors Moggi&apos;s monad constructors in <lb/>an interesting way into two parts: a pseudomonad and <lb/>the composition operator &amp;. The composition operator <lb/>is a nonvarying associative operator with left and right <lb/>identity; a pseudomonad is almost identical in structure <lb/>to a monad. If p is a pseudomonad, then (&amp;p) (which <lb/>in Haskell means the same as \x -&gt; (x&amp;p)) is a monad <lb/>constructor, mapping a monad into a new monad. I <lb/>think that this factoring usefully structures and simpli-<lb/>es the necessary proofs that a composed monad will <lb/>satisfy the monad laws. <lb/>18 Conclusions and Future Work <lb/>The title of this paper slyly plays on an ambiguity in <lb/>the use of the English verb \to compose&quot;: the object of <lb/>the verb may indicate either the inputs or the outputs <lb/>of the composition operation. Indeed, you can&apos;t really <lb/>compose (i.e., combine) two monads and get a monad as <lb/>the result. But you can compose (i.e., produce) a monad <lb/>from two other things (not both of which are monads). <lb/>Our technique does compose monads in this sense by <lb/>applying a composition operator to pseudomonads. <lb/>An important lesson from this work is that the com-<lb/>position operation is associative but in general not com-<lb/>mutative. The practical result is that it really matters <lb/>in what order you combine the building blocks. Two in-<lb/>terpreters built from the same building blocks combined <lb/>in di erent orders may have di erent (perhaps mysteri-<lb/>ously di erent) behaviors. <lb/>It should be clear that, even using only the small set <lb/>of building blocks presented here, we can automatically <lb/>construct more interpreters than you can shake a stick <lb/>at. (I was sorely tempted to title this paper \Inter-<lb/>preters for Free!&quot; 17] but thought better of it.) I have <lb/>constructed many more interpreters than I have shown <lb/>here and am working on other building blocks, for state, <lb/>output, and string data, for example. <lb/>The building blocks shown here transform the value <lb/>type in a variety of ways but all do the same thing to the <lb/>term type, adding a few alternatives to one big disjunc-<lb/>tion. What if some pseudomonad did some nontrivial <lb/>computation on terms? Presto! We have macros. There <lb/>should be a macros building block. It would leave the <lb/>value type alone but transform the term data type, per-<lb/>haps according to some macro environment. <lb/>How about error messages with positions? Wadler 16] <lb/>remarks, \The parser will produce At] terms as suit-<lb/>able.&quot; So the term type must be extended, but it turns <lb/>out that it is easiest to modify the parser so that its in-<lb/>put data type is not merely a string but a pair of a string <lb/>(remaining to be parsed) and a position (of the start of <lb/>that remaining string). So it is useful to have more than <lb/>two type towers. We should have left a hook 8] so that <lb/>the input type to the parser could be changed. <lb/>Indeed, it is unsatisfactory that the interp func-<lb/>tions shown here must always accept an extra envi-<lb/>ronment argument env. Environments are irrelevant <lb/>in the numbers building block, for example, or in the <lb/>nondeterministic building block; they ought to be in-<lb/>troduced explicitly by the cbv and cbn building blocks, <lb/>for only they are explicitly concerned with environ-<lb/>ments. An interpreter ought to be purely a mapping <lb/>from terms to values, with no extraneous arguments. <lb/>However, it does not su ce simply to work within the <lb/>value tower, extending it so that the call-by-value build-<lb/>ing block lifts the value type v to env -&gt; v. The prob-<lb/>lem is that if further building blocks are composed, such <lb/>as nondeterministic, the environments will not be \in-<lb/>herited&quot; properly. One solution seems to be to introduce <lb/>an additional hook in the form of a second term type <lb/>tower, so that one term type represents the parser out-<lb/>put, the second represents the interpreter input, and the <lb/>main driver calls a small function (initially the identity <lb/>function) to map from one to the other. We suspect <lb/>that a full-blown, truly modular Lisp interpreter coded <lb/>in this style would need a fairly large number of types <lb/>with corresponding towers. <lb/>The techniques presented here are quite general and <lb/>need not be limited to the construction of interpreters; <lb/>interpreters are merely a good subject for exposition <lb/>in academic papers because their behavior is relatviely <lb/>complex relative to the size of code needed to express <lb/>it. Monads (and pseudomonads) are likely to be useful <lb/>in any software system that requires easy and exible <lb/>extensibility. <lb/>The use of a monad is a hook, a powerful hook, a <lb/>hook with type discipline. A monad has an eye; when <lb/>you hang a monad on the hook, it uses up the hook. <lb/>A pseudomonad has an eye on one end and a hook on <lb/>the other. You can chain them. (Hm. I&apos;m mixing my <lb/>metaphors. First towers, now chains.) When you hang a <lb/>pseudomonad on a hook, there&apos;s still a hook left to use. <lb/>I wonder whether the Macintosh toolbox 1] could be <lb/>de ned in terms of a large set of pseudomonads, lending <lb/>some structure to the games played by various add-on <lb/>software packages to intercept system calls? <lb/></body>

			<div type="acknowledgement">19 Acknowledgments <lb/>I wish to thank Philip Wadler, Mark Jones, Olivier <lb/>Danvy, Paul Hudak, and the conference referees for <lb/>their helpful remarks. Paul Hudak, Phil Wadler, Si-<lb/>mon Peyton Jones, and Lennart Augustsson provided <lb/>helpful advice on the use of Haskell. I am grateful <lb/>for access to four di erent implementations of Haskell: <lb/>Yale Haskell, Glasgow Haskell, Chalmers Haskell, and <lb/>Jones&apos; Gofer system. Jonathan Rees, Dan Friedman, <lb/>and Mitch Wand also provided useful information and <lb/>encouragement. <lb/></div>

			<listBibl>References <lb/>1] Apple Computer, Inc. Inside Macintosh ( ve vol-<lb/>umes). Addison-Wesley (Reading, Massachusetts, <lb/>1985{86). <lb/>2] Hudak, Paul, Peyton Jones, Simon, and Wadler, <lb/>Philip, editors. Report on the Programming Lan-<lb/>guage Haskell: A Non-Strict, Purely Functional <lb/>Language (Version 1.1). Technical Report. Yale <lb/>University and Glasgow University (New Haven <lb/>and Glasgow (respectively), August 1991). <lb/>3] Jones, Mark P. Personal communication to Guy <lb/>Steele, September 1993. <lb/>4] Jones, Mark P. A system of constructor classes: <lb/>Overloading and implicit higher-order polymor-<lb/>phism. In Proc. FPCA &apos;93: The Sixth Interna-<lb/>tional Conference on Functional Programming Lan-<lb/>guages and Computer Architecture. ACM SIG-<lb/>PLAN/SIGARCH and IFIP (London, September <lb/>1993). <lb/>5] King, David J., and Wadler, Philip. Combining <lb/>monads. In Functional Programming, Glasgow &apos;92. <lb/>Springer Verlag (Berlin, 1992). <lb/>6] Moggi, Eugenio. An Abstract View of Program-<lb/>ming Languages. Technical Report ECS-LFCS-90-<lb/>113. Laboratory for Foundations of Computer Sci-<lb/>ence, University of Edinburgh (Edinburgh, Scot-<lb/>land, April 1990). Lecture notes for a course taught <lb/>at Stanford University, Spring 1989. <lb/>7] Peyton Jones, Simon L., and Wadler, Philip. Im-<lb/>perative functional programming. In Proc. Twenti-<lb/>eth Annual ACM Symposium on Principles of Pro-<lb/>gramming Languages. Association for Computing <lb/>Machinery (Charleston, South Carolina, January <lb/>1993), 1{14. <lb/>8] Raymond, Eric, editor. The New Hacker&apos;s Dic-<lb/>tionary. MIT Press (Cambridge, Massachusetts, <lb/>1991). <lb/>9] Rees, Jonathan. Personal communication to Guy <lb/>Steele, October 1993. <lb/>10] Reynolds, John C. De nitional interpreters for <lb/>higher order programming languages. In Proc. <lb/>ACM National Conference. Association for Com-<lb/>puting Machinery (Boston, August 1972), 717{740. <lb/>11] Steele, Guy L., Jr. How to Compose Monads. <lb/>Technical Report. Thinking Machines Corporation <lb/>(Cambridge, Massachusetts, July 1993). Unpub-<lb/>lished. <lb/>12] Steele, Guy L., Jr., Fahlman, Scott E., Gabriel, <lb/>Richard P., Moon, David A., Weinreb, Daniel L., <lb/>Bobrow, Daniel G., DeMichiel, Linda G., Keene, <lb/>Sonya E., Kiczales, Gregor, Perdue, Crispin, Pit-<lb/>man, Kent M., Waters, Richard C., and White, <lb/>Jon L. Common Lisp: The Language (Second <lb/>Edition). Digital Press (Bedford, Massachusetts, <lb/>1990). <lb/>13] Steele, Guy Lewis, Jr., and Sussman, Gerald Jay. <lb/>The Art of the Interpreter; or, The Modular-<lb/>ity Complex (Parts Zero, One, and Two). AI <lb/>Memo 453. MIT Arti cial Intelligence Laboratory <lb/>(Cambridge, Massachusetts, May 1978). <lb/>14] Sussman, Gerald Jay, and Steele, Guy Lewis, Jr. <lb/>SCHEME: An Interpreter for Extended Lambda <lb/>Calculus. AI Memo 349. MIT Arti cial Intelligence <lb/>Laboratory (Cambridge, Massachusetts, December <lb/>1975). <lb/>15] Wadler, Philip. Comprehending monads. In <lb/>Proc. 1990 ACM Symposium on Lisp and Func-<lb/>tional Programming. ACM SIGPLAN/SIGACT/ <lb/>SIGART (Nice, France, June 1990), 61{77. To <lb/>appear in the journal Mathematical Structures in <lb/>Computer Science. <lb/>16] Wadler, Philip. The essence of functional program-<lb/>ming. In Proc. Nineteenth Annual ACM Sympo-<lb/>sium on Principles of Programming Languages. As-<lb/>sociation for Computing Machinery (Albuquerque, <lb/>New Mexico, January 1992), 1{14. <lb/>17] Wadler, Philip. Theorems for free! In Proc. <lb/>FPCA &apos;89: The Fourth International Conference <lb/>on Functional Programming Languages and Com-<lb/>puter Architecture. ACM SIGPLAN/SIGARCH <lb/>and IFIP (London, September 1989), 347{359. <lb/>18] Waters, Richard C. XP: A Common Lisp Pretty <lb/>Printing System. AI Memo 1102. MIT Arti cial In-<lb/>telligence Laboratory (Cambridge, Massachusetts, <lb/>March 1989). <lb/>19] Wegbreit, Ben, Holloway, Glenn, Spitzen, Jay, and <lb/>Townley, Judy. ECL Programmer&apos;s Manual. Tech-<lb/>nical Report 23-74. Harvard University Center for <lb/>Research in Computing Technology (Cambridge, <lb/>Massachusetts, December 1974). </listBibl>


	</text>
</tei>
