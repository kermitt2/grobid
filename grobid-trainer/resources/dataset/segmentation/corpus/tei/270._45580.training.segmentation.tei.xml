<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>Incremental Cryptography and Application to Virus <lb/>Protection <lb/>Mihir Bellare Oded Goldreich y Shafi Goldwasser z <lb/>Abstract <lb/>The goal of incremental cryptography is to design cryp-<lb/>tographic algorithms with the property that having ap-<lb/>plied the algorithm to a document, it is possible to <lb/>quickly update the result of the algorithm for a mod-<lb/>i ed document, rather than having to re-compute it <lb/>from scratch. In settings where cryptographic algo-<lb/>rithms such as encryption or signatures are frequently <lb/>applied to changing documents, dramatic e ciency im-<lb/>provements can be achieved. One such setting is the use <lb/>of authentication tags for virus protection. <lb/>We consider documents that can be modi ed by <lb/>powerful (and realistic) document modi cation opera-<lb/>tions such as insertion and deletion of character-strings <lb/>(or equivalently cut and paste of text). We provide e -<lb/>cient incremental signature and message authentication <lb/>schemes supporting the above document modi cation <lb/>operations. They meet a strong notion of tamper-proof <lb/>security which is appropriate for the virus protection <lb/>setting. We initiate a study of incremental encryption, <lb/>providing de nitions as well as solutions. Finally, we <lb/>raise the novel issue of \privacy&quot; of incremental authen-<lb/>tication schemes. <lb/>Abstract appearing in Proceedings of the 27th ACM Symposium on the Theory of Computing, May 1995. <lb/></front>

			<body>1 Introduction <lb/>Basic cryptographic primitives such as encryption and <lb/>signatures (private or public key) have received thor-<lb/>ough theoretical treatment. In various works strong <lb/>de nitions of security have been proposed and achieved <lb/></body>

			<front>Department of Computer Science &amp; Engineering, Mail Code <lb/>0114, University of California at San Diego, 9500 Gilman Drive, <lb/>La Jolla, CA 92093. E-mail: mihir@cs.ucsd.edu <lb/>y Department of Applied Mathematics and Computer Sci-<lb/>ence, Weizmann Institute of Science, Rehovot, Israel. e-mail: <lb/>oded@wisdom.weizmann.ac.il. <lb/>Partially supported by grant <lb/>No. 92-00226 from the US{Israel Binational Science Foundation <lb/>(BSF), Jerusalem, Israel. <lb/>z Laboratory of Computer Science, MIT and Department of <lb/>Applied Mathematics and Computer Science, Weizmann Institute <lb/>of Science, Rehovot, Israel. e-mail: shafi@theory.lcs.mit.edu . <lb/></front>

			<body>under general complexity assumptions. The main prob-<lb/>lem that remains and which to a large extent prevents <lb/>more widespread use of strong cryptography is the inef-<lb/>ciency of existing schemes. <lb/>Incrementality is a new measure of e ciency which <lb/>is relevant in a large number of di erent settings. We <lb/>provide a comprehensive treatment of incremental cryp-<lb/>tography. We begin by identifying and stressing con-<lb/>ceptual issues, providing de nitions for the security and <lb/>e ciency of incremental primitives. We follow this up <lb/>by presenting concrete, secure schemes for various tasks <lb/>which (in several cases) are e cient enough to be prac-<lb/>tical, and demonstrate this by attention to issues like <lb/>appropriate instantiation of abstract primitives and ex-<lb/>act security analyses. <lb/>1.1 The Setting <lb/>A document undergoing a cryptographic transformation <lb/>often does not exist in isolation: the document D that is <lb/>being transformed (eg. signed or encrypted) is a modi -<lb/>cation of previous versions of the same document which <lb/>have already undergone the same cryptographic trans-<lb/>formation, or is constructed out of several other already <lb/>transformed documents in some simple way. Moreover, <lb/>the amount of modi cation that the document under-<lb/>goes is often small in comparison with the total size of <lb/>the document. <lb/>Examples of such settings abound; here are some. <lb/>The sending of documents which are slight variations of <lb/>one another to di erent recipients, such as a standard <lb/>contract or o er being sent by a corporation; exchanges <lb/>between di erent parties of drafts of the same document <lb/>where each draft is only slightly di erent from the pre-<lb/>vious one; remote editing of texts or programs which <lb/>must be authenticated at every change; video transmis-<lb/>sion of images which have not changed much between <lb/>frames. <lb/>A particularly good example is the use of authenti-<lb/>cation tags for virus protection. Consider a tamper-proof <lb/>processor with limited amount of secure local memory. <lb/>It accesses les stored on a (possibly insecure) remote <lb/>medium (e.g. a host machine or a WWW server). A <lb/>virus may attack the remote host, and inspect and al-<lb/>ter the contents of the remote medium (but it does not <lb/>have access to the processor&apos;s protected local memory). <lb/></body>

			<page>1 <lb/></page>

			<body>To protect his les against such viruses, the processor <lb/>computes for each le an authentication tag, depend-<lb/>ing on a key which is kept in the (safe) local memory. <lb/>A virus tampering with the le can&apos;t re-compute the <lb/>tag, and veri cation of the tag will thus detect tam-<lb/>pering. Now note that for this to work, the processor <lb/>must re-authenticate his les when he modi es them. <lb/>Clearly, it is desirable to be able to update the authen-<lb/>tication tag rather than always having to re-compute it <lb/>from scratch. This problem is especially complex when <lb/>the local memory is not large enough to hold (even tem-<lb/>porarily) a single le or when it is too expensive to bring <lb/>in the entire le. We note that les in this virus setting <lb/>can grow very large and be subject to frequent updates; <lb/>eg. consider a database being periodically altered. <lb/>The idea of incremental cryptography, as we out-<lb/>lined in BGG], is to take advantage of such settings, <lb/>and nd ways to compute the cryptographic transfor-<lb/>mation on a document D not from scratch, but rather, <lb/>somehow, as a fast function of the values of the cryp-<lb/>tographic transformation on the documents from which <lb/>D was constructed. When the \changes&quot; are small, the <lb/>incremental method may be anticipated to yield consid-<lb/>erable advantages in e ciency. <lb/>1.2 The Issues <lb/>One quickly sees that incremental cryptography is a vast <lb/>subject. Let us outline some important issues and our <lb/>contributions in this regard. <lb/>Primitives. One can consider incrementality for any <lb/>cryptographic primitive. The ones we focus on are sig-<lb/>natures (private and public key) and encryption (pri-<lb/>vate and public key). We focus on incrementality for <lb/>the transformations themselves, namely the signing or <lb/>encrypting, but discuss also incrementality of the \con-<lb/>jugate&quot; transformations, namely verifying and decrypt-<lb/>ing. <lb/>Text modification operators. We discuss the <lb/>modi cation to a document in terms of applications of <lb/>a xed set of underlying document modi cation opera-<lb/>tors. For example: replace a block in the document by <lb/>another; insert a new block; delete an old one. We then <lb/>focus on the design of incremental algorithms for each <lb/>such operator. <lb/>Operators should be powerful enough to re ect re-<lb/>alistic document changes: replace, insert and delete <lb/>taken together are a good choice from this point of view. <lb/>In settings such as text editing, one often pulls text from <lb/>one document into another. Accordingly we also con-<lb/>sider cut and paste operations, the rst cutting a single <lb/>document into two, and the second pasting two docu-<lb/>ments into one. We stress that the more powerful the <lb/>text modi cation operators are the more challenging it <lb/>is to design fast incremental algorithms with respect to <lb/>them. See discussion of speed below. <lb/>Incremental algorithms. Fix an underlying crypto-<lb/>graphic transformation T (eg. signing under some key). <lb/>To each elementary text modi cation operation (eg. in-<lb/>sert) there will correspond an incremental algorithm. <lb/>This algorithm takes an existing document or docu-<lb/>ments; the values of T on them; a description of the <lb/>modi cation (here a block d to insert and an index into <lb/>the document for where to insert it); and possibly un-<lb/>derlying keys or other inputs. It must compute the value <lb/>of T on the resulting document. We are interested in <lb/>designing schemes possessing e cient incremental algo-<lb/>rithms. <lb/>History-free is better. A trivial way of achiev-<lb/>ing incrementality should at once spring to mind. Take <lb/>signatures as an example, although similar issues arise <lb/>with encryption. Say I have the signature old of D old <lb/>and modify D old by inserting a block. I can update the <lb/>signature by signing the string consisting of old and <lb/>the description of the modi cation. This is a history <lb/>dependent scheme. There may be settings in which this <lb/>is acceptable, but typically it is not desirable. It gets <lb/>prohibitive as one makes lots of changes: veri cation <lb/>cost is proportional to the number of changes. It re-<lb/>quires parties to store state, and signature sizes grow <lb/>with time. History free schemes are better. Our de ni-<lb/>tions mandate history freeness and our schemes are all <lb/>history free. <lb/>Speed. The basic goal, of course, is that the incremen-<lb/>tal algorithm should run faster than re-computing the <lb/>transformation from scratch; the faster the better. The <lb/>requirement of our de nition is that the incremental al-<lb/>gorithm run in time proportional only to the \number <lb/>of modi cation&quot; and not proportional to the document <lb/>length. For example, if s denotes the block size then <lb/>updating the cryptographic form for one modi cation <lb/>should take poly(s)-time regardless of the number of <lb/>blocks in the modi ed document. 1 (In addition as dis-<lb/>cussed above the algorithm should be history free.) This <lb/>seems an elegant requirement, and schemes achieving it <lb/>are referred to as ideal. 2 For e ciency, of course, <lb/>the polynomial in s should be small, and incrementality <lb/>should not be at the cost of too much increase in the <lb/>time to transform from scratch. <lb/>We stress that the e ciency condition becomes <lb/>more challenging as more powerful modi cation oper-<lb/>ations are being considered. For example, the cut and <lb/>paste operators allow to omit a large chunk of text from <lb/>the middle of the le by three modi cations, and a <lb/>fast incremental signing algorithm should be able to up-<lb/>date the signature to t this di erent-looking le within <lb/>poly(s)-time and independently of the size of the le and <lb/></body>

			<note place="footnote">1 There are technical issues about how the input is accessed, <lb/>but using a RAM model these things work out. <lb/></note>

			<note place="footnote">2 Other kinds of complexities may certainly be interesting: for <lb/>example, if the from scratch transformation takes O(n 2 s) time to <lb/>compute (where n is the number of blocks in the message) then an <lb/>incremental algorithm achieving O(ns) would be very nice. For <lb/>simplicity however we stick to our de nition of ideality. <lb/></note>

			<page>2 <lb/></page>

			<body>the length of the omitted chunk of text. <lb/>Security. Probably the single most important concep-<lb/>tual issue is security. O hand, one might say there is <lb/>no new issue in security, because we are considering ex-<lb/>isting primitives (signatures, encryption) and security <lb/>has already been satisfactorily de ned for them. But <lb/>incrementality brings in new concerns and gives rise to <lb/>new de nitions. <lb/>Consider the case of digital signatures / authentica-<lb/>tion schemes. It is reasonable to assume that the adver-<lb/>sary not only has available to it previous signed versions <lb/>of documents but is also able to issue text modi cation <lb/>commands to existing documents and obtain incremen-<lb/>tal signatures of the modi ed ones. Such a chosen-<lb/>message-attack on the incremental signing algorithm <lb/>may lead to breaking a signature system that cannot be <lb/>broken by restricted attacks which don&apos;t use the incre-<lb/>mental algorithm. Furthermore, in some scenarios such <lb/>as virus attacks it is in addition prudent to assume that <lb/>the adversary may be able to tamper with the contents <lb/>of existing documents and signatures/authentication-<lb/>tags. Accordingly we will consider two notions of se-<lb/>curity; a basic one, and a stronger notion of tamper <lb/>proof security which is relevant in the virus protection <lb/>setting. <lb/>Consider the case of encryption schemes. The usage <lb/>of incremental encryption algorithms may leak informa-<lb/>tion that is kept secret when using a traditional encryp-<lb/>tion scheme. For example, take an encryption scheme <lb/>which breaks the message into blocks and encrypts each <lb/>block using a secure probabilistic encryption. An in-<lb/>cremental encryption, with respect to (single block) re-<lb/>placement, may operate by merely encrypting the new <lb/>contents of the block and keeping all other (block) en-<lb/>cryptions unchanged; but this enables an adversary to <lb/>tell which blocks have has been changed. The encryp-<lb/>tion of a message together with the encryption of the <lb/>slightly modi ed message, leaks knowledge. It seems <lb/>that we cannot hope for e cient incremental encryp-<lb/>tion algorithms which hide the amount of di erence be-<lb/>tween the two documents. Yet, it is possible to have <lb/>e cient incremental encryption which hides everything <lb/>besides. <lb/>The privacy of incremental schemes. Here is a <lb/>novel issue raised in the incremental setting: the \pri-<lb/>vacy&quot; of di erent versions of a document. Suppose <lb/>is a signature of document M and 0 is a signature of <lb/>slightly modi ed document M 0 . Then, it may be de-<lb/>sirable for 0 to yields as little information as possible <lb/>about the original M. What is tolerable for one appli-<lb/>cation may be di erent than another. For example, it <lb/>may be acceptable for 0 to yield the fact that M and <lb/>M 0 di er in a single block, as long as the identity of the <lb/>block is kept secret. <lb/>1.3 The schemes <lb/>We present two signature schemes and one encryption <lb/>scheme. <lb/>XOR schemes. We present a particularly fast message <lb/>authentication (ie. private key signature) scheme based <lb/>on a pseudorandom function (PRF) GGM]. It has in-<lb/>cremental algorithms for (single block) insert and delete <lb/>which require only four applications of the underlying <lb/>PRF. It achieves basic security, and it also achieves pri-<lb/>vacy. It builds on some schemes of BGR] which were <lb/>incremental for replacement. <lb/>Tree schemes. The second signature scheme pro-<lb/>vides tamper proof security, and hence is applicable to <lb/>virus protection. It works in both the private and the <lb/>public key cases| a regular (ie. not incremental) mes-<lb/>sage authentication (resp. digital signature) scheme is <lb/>transformed into an incremental message authentication <lb/>(resp. digital signature) scheme. The scheme supports <lb/>not only insert and delete but also cut and paste. The <lb/>updates require a logarithmic (in the message length) <lb/>number of applications of the given (non incremental) <lb/>scheme. It uses 2{3 trees. <lb/>Encryption. We extend ideas on software protection <lb/>Go, Os] to provide the rst incremental encryption <lb/>scheme. The e ciency here is however not as good as <lb/>for our signature schemes. <lb/>1.4 From theory to practice <lb/>Instantiation. The schemes speci ed above are de-<lb/>ned in terms of \abstract&quot; primitives: the XOR scheme <lb/>can use any PRF and the tree scheme can use any stan-<lb/>dard signature scheme. Key to achieving practicality is <lb/>appropriate instantiation of these abstract primitives by <lb/>concrete ones. In particular, suitable \pseudorandom in <lb/>practice&quot; functions can be derived from DES, MD5 Ri] <lb/>and other such primitives as described for example in <lb/>BR]. The resulting XOR schemes can run within 1.05 <lb/>times the speed of the most popular message authenti-<lb/>cation scheme in practice, namely the CBC MAC, with <lb/>the added advantage of incrementality that the CBC <lb/>MAC does not possess. Similarly, the private key ver-<lb/>sion of the tree scheme can be instantiated with the <lb/>CBC MAC itself as underlying message authentication <lb/>code and runs commensurately fast. <lb/>Instantiation is an important issue which may merit <lb/>more discussion. As indicated above, schemes (ours <lb/>in particular) are typically designed in terms of ab-<lb/>stract primitives like one-way functions or pseudoran-<lb/>dom functions. While many abstract primitives are <lb/>equivalent in theory, the right choice, when one is inter-<lb/>ested in a nal practical outcome, is a primitive which <lb/>combines convenience of use with the property of pos-<lb/>sessing an e cient instantiation. In particular, nite <lb/>pseudorandom functions (ie. PRFs on xed input and <lb/>output lengths) are good starting points because they <lb/></body>

			<page>3 <lb/></page>

			<body>can be e ciently instantiated with block ciphers like <lb/>DES or via hash functions like MD5 BR]. This is the <lb/>reason we discuss our XOR scheme directly in terms of <lb/>PRFs, and our tree scheme directly in terms of MACs, <lb/>rather than say they are \based on a one-way function.&quot; <lb/>(The latter is true, but not useful from the point of view <lb/>of e cient instantiation.) <lb/>The central dividing line in e cient instantiation is <lb/>between number theoretic or algebraic functions (factor-<lb/>ing, discrete log) and DES or MD5 type constructions. <lb/>Instantiating PRFs (or MACs) via factoring or discrete <lb/>log based constructions will result in schemes orders of <lb/>magnitude less e cient than schemes using block ci-<lb/>phers (DES) or MD5 type hash functions. Whenever <lb/>possible (ie. in a private key setting) one is better of <lb/>with the second kind of instantiation. (One might sug-<lb/>gest that number theory based schemes are more secure. <lb/>But in truth the two are incomparable, and some re-<lb/>searchers familiar with both types of objects even favor <lb/>the block ciphers in this regard.) <lb/>Exact security. The user of a scheme needs to know <lb/>more than just that \no polynomial time adversary can <lb/>break the scheme except with negligible advantage.&quot; He <lb/>needs to know, for given security or other parameters, <lb/>what kind of success is achieved by an adversary with <lb/>particular resources such as time and queries. (This <lb/>a ects e ciency, because if, for a particular security <lb/>level, the security parameter must be high, then the <lb/>e ciency is less.) We take these concerns into account <lb/>by providing exact security reductions: our theorems <lb/>quantify the success of an adversary in breaking the <lb/>underlying assumption as a function of her success in <lb/>breaking the constructed scheme. <lb/>1.5 Previous work and comparison with <lb/>ours <lb/>The study of incremental cryptography was initiated by <lb/>the current authors in BGG]. The primitives considered <lb/>there were collision free hashing and digital (public key) <lb/>signatures. The text modi cation operation considered <lb/>was replacement (of one message block by another). In-<lb/>cremental schemes based on the hardness of discrete log <lb/>were provided. The signature scheme met the notion <lb/>of basic security. Tamper proof security was pinpointed <lb/>and de ned, and to provide solutions for it was left as <lb/>an open problem. <lb/>We have here expanded the scope in primitives to <lb/>include encryption and also the private-key versions of <lb/>all primitives, which are more important in practice. We <lb/>are considering more realistic and powerful text modi -<lb/>cation operations like insert, delete, cut and paste. We <lb/>consider multi-document settings, not only single doc-<lb/>ument ones, and extend the de nitions to this case. In <lb/>addition, we introduce new concerns such as history-<lb/>freeness and privacy. We provide the rst solutions <lb/>for message authentication achieving tamper-proof se-<lb/>curity, and hence for virus protection. Our schemes can <lb/>be instantiated with DES and MD5 type primitives and <lb/>thus are considerably more e cient than those of BGG] <lb/>which use the discrete log. <lb/>For the problem of virus protection when the virus <lb/>cannot see any authentication tags of les, the work <lb/>of Karp and Rabin KR] on ngerprints can be used. 3 <lb/>Their ngerprint scheme is incremental with respect to <lb/>single character replacement, but does not provide fast <lb/>update for single character insert/delete. <lb/>2 De nitions <lb/>In order to de ne incremental cryptographic algorithms <lb/>and discuss their complexity and security, we introduce <lb/>a setting which we call a multi-document system. The <lb/>latter is de ned with respect to a cryptographic scheme <lb/>and a set of text-modi cation operations. <lb/>Cryptographic schemes and the documents <lb/>they process. The documents to which cryptographic <lb/>transformations will apply are sequences of blocks; for-<lb/>mally, they are strings over an alphabet = f0; 1g·∫Å <lb/>here`is a parameter called the block size. We let D i] <lb/>denote the i th symbol of the document D. Our complex-<lb/>ity estimates are in terms of elementary operations over <lb/>this alphabet , and translating them to bit operations <lb/>requires multiplication by a poly(`) factor. Documents <lb/>may also be called texts, messages or les and we will <lb/>switch irrationally back and forth in nomenclature. <lb/>Incrementality is a very general notion in that it <lb/>applies to a wide variety of primitives (encryption, sig-<lb/>natures, message authentication and ngerprinting to <lb/>name a few). To avoid providing a plurality of similar <lb/>de nitions, we formulate below a general notion of a <lb/>cryptographic scheme which captures all the primitives <lb/>we know. Later we will de ne incrementality for any <lb/>cryptographic scheme. Below s is the security parame-<lb/>ter. <lb/>De nition 2.1 A cryptographic scheme is speci ed by a <lb/>triple S = (Gen; T; C) of probabilistic, polynomial time <lb/>algorithms. <lb/>Algorithm Gen is called the key generator. It takes <lb/>as input two parameters: 1 s and j j. It outputs a <lb/>pair (K 0 ; K 00 ) of keys called the transformation key <lb/>and the conjugate key, respectively. <lb/>Both the transformation T and its conjugate C act <lb/>on , using the corresponding key as additional in-<lb/>put. We write T K 0 (D) (resp., C K 00 (D)) to indicate <lb/>the output of algorithm T (resp., C) on input D and <lb/>key K 0 (resp., key K 00 ). We call T K 0 (D) a crypto-<lb/>graphic form of D. For every D 2 and every pair <lb/>of keys, (K 0 ; K 00 ), possibly produced by Gen(1 s ; j j), <lb/>it is the case that C K 00 (T K 0 (D)) = D. <lb/></body>

			<note place="footnote">3 This was observed by Rabin (Ben-Or, private <lb/>communication). <lb/></note>

			<page>4 <lb/></page>

			<body>We&apos;ll assume for simplicity that s and j j are recover-<lb/>able from each of the keys K 0 ; K 00 output by the gen-<lb/>erator on input (1 s ; j j). The above de nition does not <lb/>address security, which is more primitive-speci c. <lb/>Two kinds of generators are of particular interest. <lb/>A generator Gen is called symmetric if K 0 = K 00 . This <lb/>corresponds to a private key setting | the legitimate <lb/>parties share a key K 0 = K 00 . In discussing security <lb/>this key will be denied to the adversary. A generator <lb/>Gen is asymmetric if K 0 6 = K 00 . This corresponds to the <lb/>public key setting | one of the two keys (i.e., either K 0 <lb/>or K 00 ) can be made public keeping the other secret. In <lb/>discussing security, the public key, but not the secret <lb/>one, will be made available to the adversary. <lb/>Encryption is a canonical example, with the trans-<lb/>formation used to encrypt and the conjugate to de-<lb/>crypt. For signatures or other forms of authentication, <lb/>the transformation is used to signing or authenticate <lb/>while the conjugate is used to verify, under the (non-<lb/>standard) convention that the signature contains the <lb/>document and successful veri cation retrieves the doc-<lb/>ument rather than yield the bit 1. <lb/>Text modification operations. We consider sev-<lb/>eral text modi cation operations. Firstly, there are the <lb/>single-symbol update operations which take as input a <lb/>single text and modify it according to some parameter. <lb/>For example, the replacement operation, given a text <lb/>T = T 1] T `] and parameter (i; ) so that i `and <lb/>2 , returns the text unchanged expect for the i th <lb/>symbol which is set to . Similarly, insertion with pa-<lb/>rameters (i; ) inserts in between the i th and i + 1 st <lb/>position of the text, making it one symbol longer. The <lb/>deletion operator, with parameter i, omits the i th symbol <lb/>of the text, making it one symbol shorter. More power-<lb/>ful update operations operate on substrings of a given <lb/>text. Typical operations are delete-subtext (i.e., delet-<lb/>ing a sequence of consecutive symbols from the text) <lb/>and move-subtext (which moves a sequence of symbols <lb/>from one location in the text to another). Some op-<lb/>erations can operate on many texts at once or yield a <lb/>multi-text result. For example, insertion of a subtext <lb/>from one text into another. <lb/>All these operations, as well as many other nat-<lb/>ural operations, can be expressed by a constant num-<lb/>ber of cut and paste operations. 4 The latter operations <lb/>take and/or produce several texts (rather than taking <lb/>and producing a single text). Applying cut with argu-<lb/>ment i to a text T = T 1] T `] results in two texts, <lb/>T 0 def = T 1] T i] and T 00 def = T i + 1] T `]. Simi-<lb/>larly, applying paste to two texts, T 0 = T 0 1] T 0 `0] <lb/></body>

			<note place="footnote">4 For example, the move-subtext operation is easily expressed <lb/>in terms of (upto six) cut and paste operations. To move l symbols <lb/>from start-location i + 1 to start-location j + 1 &gt; i + l in the <lb/>text T = T 1] T `], we cut the text at locations i, i + l and j, <lb/>producing the subtexts T 0 = T 1] T i], T 00 = T i+1] T i+l], <lb/>T 000 = T i + l + 1] T j] and T 0000 = T j + 1] T `]. Next, we <lb/>paste together T 0 , T 000 , T 00 and T 000 . <lb/></note>

			<body>and T 00 = T 00 1] T 00 `0 0 ], results in the text T = <lb/>T 1] T `0 +`0 0 ], where T j] def = T 0 j] for j `0 and <lb/>T j] def = T 00 j ?`0] for j &gt;`0. <lb/>The multi-document setting. In a simple setting <lb/>for incremental cryptography one maintains a single <lb/>document together with its cryptographic (transformed) <lb/>form while the document undergoes text modi cations. <lb/>For applications in which the only text modi cations <lb/>are single symbol ones (e.g., symbol insert/delete), this <lb/>setting seems adequate. In this paper we consider more <lb/>powerful text modi cations which may deal with more <lb/>than one document at a time, for example inserting a <lb/>part of one document into another document. For this <lb/>purpose, we present the following multi-document set-<lb/>ting in which several documents are maintained, along <lb/>with their cryptographic (transformed) forms. A moti-<lb/>vating application is a text editor, where the documents <lb/>are les, several of them being simultaneously manipu-<lb/>lated by operations like cut and paste. <lb/>In order to de ne security it will be necessary to <lb/>specify documents by names| thinking of the editing <lb/>setting, these are the le names. <lb/>De nition 2.2 Let S = (Gen; T; C) be a cryptographic <lb/>scheme as in De nition 2.1, and let M be a set of <lb/>text modi cation operations (e.g., M = fcut; pasteg). <lb/>A document system which maintains cryptographic forms <lb/>(wrt S) under M is an interactive machine operating as <lb/>follows. <lb/>The system is initialized with a transformation key <lb/>K 0 , obtained by running Gen(1 s ; j j), where s and <lb/>j j are parameters. <lb/>In response to a create document command, with <lb/>parameters 2 f0; 1g and D 2 , the system cre-<lb/>ates a new document 5 with name , sets its contents <lb/>to D, and its (corresponding) cryptographic form to <lb/>T K 0 (D). We stress that this is done by applying al-<lb/>gorithm T to the document D, using the key K 0 . In <lb/>addition 6 , the system associates a counter, initial-<lb/>ized to 1, with the document . <lb/>In response to a document pasting command, with <lb/>parameters (document names) ; ; 2 f0; 1g , the <lb/>system acts as follows <lb/>{ increments the counter of document ; <lb/>{ replaces the contents of document with the <lb/>text which results by pasting of the texts cur-<lb/>rently in documents and , <lb/>{ updates the cryptographic form of to t the <lb/></body>

			<note place="footnote">5 In case a document with name existed before, it is deleted <lb/>before performing this command. We may assume, without loss <lb/>of generality, that this never happens. <lb/></note>

			<note place="footnote">6 This counter is not needed in settings in which only basic <lb/>security (as de ned below) is required. It seems that the counter, <lb/>or some other tamper-proof register associated with each docu-<lb/>ment is required in order to achieve ideal tamper-proof incremen-<lb/>tal systems. <lb/></note>

			<page>5 <lb/></page>

			<body>new contents of document . <lb/>The updating of the cryptographic form of docu-<lb/>ment is done by applying an incremental algorithm, <lb/>denoted IncT, associated with the transformation <lb/>T and the text modi cation paste. When invoked <lb/>by the system, IncT is given as input the current <lb/>contents of the documents and , the contents <lb/>of their cryptographic forms, and the transforma-<lb/>tion key K 0 . Thus, algorithm IncT takes as input a <lb/>pair of documents and a corresponding pair of cryp-<lb/>tographic forms, as well as the transformation key <lb/>(and possibly the document name and its counter <lb/>value). The output of IncT satis es <lb/>C K 00 (IncT K 0 ((D 0 ; D 00 ); ( 0 ; 00 ))) = D 0 D 00 <lb/>for every D 0 ; D 00 ; 0 ; 00 so that C K 00 ( 0 ) = D 0 and <lb/>C K 00 ( 00 ) = D 00 . <lb/>Other document modi cation commands are processed <lb/>similarly. <lb/>The above de nition has made a simpli cation in <lb/>one regard. Thinking of an editing setting, there ought <lb/>to be an explicit write operation with the semantics that <lb/>the cryptographic form of a document is created (and <lb/>becomes available to the adversary) only once such a <lb/>command is issued. In an authentication setting, for <lb/>example, this would increase the power of the adver-<lb/>sary since unwritten documents are not considered to <lb/>have been authenticated by the user and so the adver-<lb/>sary is considered successful also in case it can authen-<lb/>ticate these (intermediate) unwritten document. We <lb/>stress, however, that our schemes maintain their secu-<lb/>rity also in the more stringent setting (i.e., with explicit <lb/>write/authenticate operation), but due to space limi-<lb/>tations, we stick with the simpler model presented in <lb/>De nition 2.2. The above de nition does not address <lb/>security which is more primitive-speci c; such de ni-<lb/>tions are outlined in the two following sections. <lb/>The complexity of incremental algorithms. We <lb/>are interested in the complexity of implementing docu-<lb/>ment systems such as the above. We ignore the cost of <lb/>implementing the text modi cation operations as well <lb/>as the cost of copying a constant number of crypto-<lb/>graphic forms: these are system operations of predeter-<lb/>mined cost. Our concern is the cost of updating the <lb/>cryptographic forms that is incurred in running the in-<lb/>cremental algorithms. <lb/>First, as discussed in the Introduction, we want <lb/>schemes to be history-free. We ask that the length of <lb/>the cryptographic form maintained for each document <lb/>is a function of the current length of the document and <lb/>(s; j j), but is independent of the number of modi ca-<lb/>tions the document has undergone. <lb/>Second, as ask that the running time of IncT is a <lb/>xed polynomial in the security parameter s, denoted <lb/>p(s), independent of the length of the document. We <lb/>use a RAM, rather than TM, model of computation so <lb/>that sublinear time algorithms make sense: in this model <lb/>any algorithm A(x; y; ) has direct access to each of <lb/>its inputs x; y; and can address an input bit with a <lb/>logarithmic size address. Furthermore, for simplicity, we <lb/>assume that all documents presented to the system have <lb/>length bounded by 2 s , where s is the security parameter. <lb/>Third, it is required that the complexity of e ect-<lb/>ing the conjugate transformation on the cryptographic <lb/>form of a document D kept by the system, should be <lb/>the same as the complexity of e ecting the conjugate <lb/>transformation on T K 0 (D) (ie., the cryptographic form <lb/>obtained by directly applying T to D). <lb/>Finally, we call a multi-document system maintain-<lb/>ing cryptographic forms ideal if the incremental algo-<lb/>rithms satisfy all of the above. <lb/>Incrementality for the conjugate. Our treat-<lb/>ment captures the operation of incremental algorithms <lb/>for the cryptographic transformation T (e.g., encryption <lb/>or signing/authentication). A similar treatment can be <lb/>provided for incremental algorithms for the conjugate <lb/>transformation C (e.g., decryption or veri cation), ex-<lb/>cept that there is no (natural) analogue to rst and <lb/>third concerns discussed above (i.e., history-freeness and <lb/>maintaining the complexity of the conjugate operation). <lb/>Speci cally, an incremental algorithm for the conjugate <lb/>operation is given the cryptographic form of a document <lb/>D, together with a previous document D 0 , its crypto-<lb/>graphic form C 0 , and a description of the modi cation <lb/>M, by which D has been obtained from D 0 , and returns <lb/>D. <lb/>3 Incremental authentication <lb/>Here we propose incremental schemes for various forms <lb/>of authentication: signatures, message authentication <lb/>and ngerprinting. We will present two incomparable <lb/>schemes which are both \ideal&quot; in e ciency according to <lb/>our discussions of Section 2. The rst is an incremental <lb/>scheme for message authentication which is very simple <lb/>and (when properly instantiated) fast in practice, but is <lb/>secure only in the basic sense. It supports inserts and <lb/>deletes, but not cut. The second scheme is presented <lb/>again for message authentication but is extendible to <lb/>digital signatures as well. Although not as fast as the <lb/>rst scheme, it is very e cient, and achieves tamper <lb/>proof security. It supports not only insert and delete <lb/>but also cut and paste. It can be used for the virus <lb/>protection application. We begin with the de nitions of <lb/>security underlying these schemes. <lb/>3.1 De nitions of security <lb/>The introduction of incremental authentication raises <lb/>new security issues. We distinguish two settings, or re-<lb/>quirements, in security: basic security and the stronger <lb/>notion of tamper proof security. De nitions of basic <lb/>and tamper proof security, in the single-document set-<lb/>ting, were provided in our previous work BGG]. Here <lb/></body>

			<page>6 <lb/></page>

			<body>we extend both de nitions to the multi-document set-<lb/>ting. <lb/>Basic security. Basic security addresses a setting in <lb/>which a user applying the incremental algorithm is as-<lb/>sured of the authenticity of the document and authen-<lb/>tication tag to which the algorithm is applied| this is <lb/>the natural case in which, for example, old documents <lb/>and their authentication tags are stored securely on the <lb/>user&apos;s machine, and the de nition of GMR] extends in <lb/>the natural way. Speci cally, the adversary may obtain <lb/>signatures to documents of its choice by issuing corre-<lb/>sponding create-document commands. In addition, it is <lb/>natural and certainly safer to assume that the adversary <lb/>can also issue document-modi cation commands and so <lb/>obtain the e ect of the incremental signing algorithm <lb/>on previously formed signatures. <lb/>A basic attack on a document system which main-<lb/>tains cryptographic forms (wrt S under M) consists <lb/>of using the system as suggested in De nition 2.2. In <lb/>course of such an attack, the adversary can create ar-<lb/>bitrary documents of its choice and obtain the corre-<lb/>sponding signatures (produced by the ordinary signing <lb/>algorithm). In addition, the adversary can issue doc-<lb/>ument modi cation commands with document-names <lb/>and parameters of its choice and obtain the correspond-<lb/>ing signatures (produced by the incremental signing al-<lb/>gorithm). These signatures are associated with the doc-<lb/>uments which result from the corresponding modi ca-<lb/>tion commands. To be deemed successful, the adversary <lb/>must produce a signature to a document di erent from <lb/>all the above (i.e., the documents appearing during the <lb/>attack). A de nition can be easily produced following <lb/>the standard paradigms. <lb/>We remark that incremental signing queries may <lb/>supply the adversary with information it cannot obtain <lb/>by an ordinary attack (i.e., using only ordinary signing <lb/>queries). This may be the case even if the adversary only <lb/>uses the incremental queries as a shortcut to making or-<lb/>dinary signing queries (since the two signing algorithms <lb/>may produce di erent distributions). However, the ef-<lb/>fect of incremental signing queries is more dramatic in <lb/>case the adversary may tamper with documents as in <lb/>the stronger de nition presented below. <lb/>Tamper-proof security. In some settings it is also <lb/>natural to allow the adversary to tamper with the docu-<lb/>ments and signatures stored in the system and so obtain <lb/>the e ect of the incremental signing algorithm on arbi-<lb/>trarily chosen pairs of strings, which are not necessarily <lb/>valid (document,signature) pairs. Thus, the second se-<lb/>curity notion, called tamper-proof security, arises. <lb/>A tampering attack is similar to the basic attack de-<lb/>scribed above, except that the adversary may alter the <lb/>context of documents and cryptographic forms stored <lb/>by the system. Alternatively, we may describe the ad-<lb/>versary as issuing, in addition to the above document-<lb/>creation and document-modi cation commands, also <lb/>\tampering&quot; commands of the form alter( ; D; C), for <lb/>2 f0; 1g and D; C 2 of its choice. The e ect of <lb/>such a tampering command is that the system changes <lb/>the contents of the document named into D and the <lb/>contents of its cryptographic form into C. <lb/>A tampering attack is natural in some settings (e.g., <lb/>ngerprinting for virus protection). We stress that the <lb/>incremental signing algorithm does not necessarily check <lb/>that the old signature is valid before modifying it ac-<lb/>cording to the required update. (Typically, the incre-<lb/>mental signing algorithm may not have enough time to <lb/>verify the validity of the old signature.) <lb/>Tampering not only provides the adversary with <lb/>more power, it also raises a de nitional problem. Sup-<lb/>pose that the adversary obtains a signature by e ecting <lb/>the incremental signing algorithm on an invalid (doc-<lb/>ument,signature) pair. The question is to which doc-<lb/>ument do we associate the \signature&quot; produced this <lb/>way (which may not be a valid signature to any docu-<lb/>ment). Before proceeding, we remark that this question <lb/>is important since forgery is de ned as ability to pro-<lb/>duce signatures to documents not encountered so far <lb/>(and thus it is crucial to properly de ne which docu-<lb/>ments have appeared so far). Our convention, by which <lb/>documents are accessed by their name, plays a major <lb/>rule in resolving this question. <lb/>As discussed above, once signatures are produced <lb/>for tampered documents (via the incremental signing al-<lb/>gorithm) it is not clear to which document-contents to <lb/>associate them. Our convention, justi ed below, is to <lb/>associate these signatures to the contents which would <lb/>have resided in these documents (document-names) if <lb/>they were not tampered with. Namely, although the <lb/>adversary may tamper with the documents and alter <lb/>their contents, the signatures that it obtained are asso-<lb/>ciated with the untempered documents (thus ignoring <lb/>the tampering). Thus, we associate with a tampering-<lb/>attack two sequences of documents. One is the actual <lb/>sequence of strings appearing as contents of the various <lb/>documents, in various times. The second sequence is the <lb/>sequence of virtual documents de ned as follows. The <lb/>virtual document at the moment of issuing a document-<lb/>creation command is the document speci ed in the com-<lb/>mand (for which a signature is obtained via the ordi-<lb/>nary signing algorithm). The virtual document at the <lb/>moment of issuing a document-modi cation command <lb/>is the document resulting by applying the command to <lb/>the virtual documents the names of which are speci ed <lb/>in the command. We stress that virtual documents are <lb/>not a ected by tampering commands (although the ac-<lb/>tual documents are e ected). To be deemed successful, <lb/>the adversary must produce a signature to a document <lb/>di erent from any virtual document de ned by the at-<lb/>tack. <lb/>Our justi cation for de ning forgery with respect <lb/>to the virtual documents is that the decision to sign <lb/>a requested document is made by the application level <lb/></body>

			<page>7 <lb/></page>

			<body>which is likely to relate to these (virtual) documents <lb/>rather than to the actual documents (handled by the <lb/>cryptographic system level). Our choice is particu-<lb/>larly justi ed in the context of ngerprinting for virus-<lb/>protection { see below. We conclude this subsection <lb/>by remarking that in this context (i.e., ngerprinting <lb/>for virus-protection) the adversary is deemed successful <lb/>if it can produce a document di erent from the current <lb/>virtual document so that the ngerprint for the two doc-<lb/>uments are the same. Note that in this context, it is not <lb/>required that the produced document did not appear as <lb/>a virtual document in the past. <lb/>3.2 The XOR schemes <lb/>Background. Some existing message authentication <lb/>schemes o er a natural incremental algorithm for the <lb/>replacement operation such that basic security is en-<lb/>sured. 7 Supporting insertion and deletion is harder, <lb/>even just for basic security, and no existing scheme of <lb/>which we are aware achieves it. We introduce simple <lb/>schemes supporting insertion and deletion. They extend <lb/>the XOR schemes of BGR] which were incremental for <lb/>replacement. The chaining technique we introduce is <lb/>quite general. <lb/>The scheme. The key, denoted a, held by the parties <lb/>is a pair (a 1 ; a 2 ) of random strings; the rst speci es <lb/>a pseudorandom function f 1 = f a1 chosen from a xed <lb/>underlying collection of PRFs GGM], and the second <lb/>speci es a pseudorandom permutation f 2 = f a2 , also <lb/>chosen from some xed unerlying family LR]. (Given <lb/>a 2 it is possible to compute both f a2 and its inverse.) <lb/>We let rand denote the algorithm which given a string <lb/>picks a random k bit string r, called a randomizer, <lb/>and returns : r. To authenticate message D 1] : : :D `] <lb/>begin by pre xing it with a special start symbol D 0] <lb/>and post xing it with a special end symbol D `+1]. The <lb/>authentication-tag of D = D 0] : : :D `+ 1] is computed <lb/>in three steps: <lb/>(1) Randomize: For each i = 0; : : :;`+ 1 let R i] = <lb/>rand(D i]). We call R = R 0] : : :R `+ 1] the ran-<lb/>domized version of D. <lb/>(2) Chain and hash: Let h = `i <lb/>=0 f 1 (R i]; R i+1]), and <lb/>call this value the hash of D. <lb/>(3) Tag: Let T = f 2 (h) be the tag of D. This is output. <lb/>Note that formally the authentication-tag consists of all <lb/>the randomizers together with the nal tag. Informally, <lb/>however, the randomizers are thought of as part of an <lb/>extended message, and only the nal tag is thought of <lb/>as \the tag.&quot; <lb/>It is worth noting that the nal step is necessary; if <lb/>we output h as the tag of D, the scheme can be broken, <lb/></body>

			<note place="footnote">7 For example, hashing under linear universal-2 hash functions <lb/>CW] yields an incremental ngerprinting scheme. A message <lb/>authenticationscheme can be derived by appropriatelyencrypting <lb/>the ngerprint. <lb/></note>

			<body>by xor-ing together some legitimately obtained tags. 8 <lb/>How to increment. Now we specify how increments <lb/>are performed. Suppose we want to compute the tag for <lb/>the document D 0 = insert(D; i; ) where 0 i `. Let <lb/>R 0 = rand( ). The randomized version of D 0 is taken <lb/>to be R 0] : : :R i] : R 0 : R i + 1] : : :R `+ 1]. The hash h <lb/>is rst recovered from the tag via h = f ?1 <lb/>2 (T) and then <lb/>updated by <lb/>h 0 = h f 1 (R i]; R i+1]) f 1 (R i]; R 0 ) f 1 (R 0 ; R i+1]) : <lb/>The new tag is T 0 = f 2 (h 0 ). If we want to compute the <lb/>tag for the document D 0 = delete(D; i) where 1 i `, <lb/>then we let R 0 = rand(D i?1]). The randomized version <lb/>of D 0 is taken to be R 0] : : :R i?2] : R 0 : R i+1] : : :R `+ <lb/>1], and the hash is updated to h 0 = <lb/>h f 1 (R i?1]; R i]) f 1 (R i]; R i+1]) f 1 (R 0 ; R i+1]) d ; <lb/>where d = f 1 (R i ? 2]; R i? 1]) f 1 (R i ? 2]; R 0 ) if i 2 <lb/>and 0 if i = 1. Again the tag is just T 0 = f 2 (h 0 ). <lb/>Notice that incrementing requires ve/seven com-<lb/>putations of a PRF together with some XORs and other <lb/>simple operations. It is this considerably faster than re-<lb/>computing the tag from scratch. <lb/>Security. The adversary is allowed document create <lb/>operations and insert or delete operations. A corollary <lb/>of Theorem 3.1 below is that if f 1 ; f 2 are chosen uni-<lb/>formly from a family of pseudorandom functions, then <lb/>the document system presented above is secure in the <lb/>basic sense. <lb/>For applications it is important to have more in-<lb/>formation on how the strength of the underlying PRFs <lb/>translates into the strength of the scheme. Thus, the <lb/>theorem itself speci es our ability to break the underly-<lb/>ing PRFs as a function of the adversary&apos;s success prob-<lb/>ability. The proof is omitted from this abstract. <lb/>Theorem 3.1 Let f 1 ; f 2 have outputs of n bits and be <lb/>chosen from a PRF family. Suppose the randomizing al-<lb/>gorithm randomizes its input by appending a k bit random <lb/>string. Suppose that the document system can be broken <lb/>with probability p in an attack which runs in time t, makes <lb/>m c document create requests, and m i incremental re-<lb/>quests (insert or delete). Let m = m c +m i and let L be the <lb/>maximum length of any document involved. Then, the un-<lb/>derlying pseudorandom function family can be broken with <lb/>probability p <lb/>2 ?O(m 2 2 ?n )?O((m c L+m i ) 2 2 ?k ), in time <lb/>O(t+(Lm c +m i )(k +s+n)), and making O(m c L+m i ) <lb/>oracle queries. <lb/>We remark that the above document system is not <lb/>tamper-proof secure. For example, the adversary can <lb/>rst ask to create and tag a document abcde. Next it <lb/>tampers with this document converting its contents to <lb/></body>

			<note place="footnote">8 For example, xor-ing together the hash value of D and the <lb/>hash values obtained (as below) by two di erent modi cations <lb/>to D, e.g., delete(D;i) and delete(D; j) for suitably chosen i; j, <lb/>yields a hash value for the document delete(delete(D; i); j). <lb/></note>

			<page>8 <lb/></page>

			<body>cde and ask to modify it by deleting the second symbol. <lb/>It obtains a valid tag for abce although this document <lb/>did not appear in the attack. A tamper-proof secure <lb/>scheme for message authentication is presented in the <lb/>next subsection. <lb/>Instantiation and efficiency. As discussed in the <lb/>Introduction, the PRFs are instantiated via DES or <lb/>MD5, individually or in combination. One would typ-<lb/>ically choose a fairly large block size so that the extra <lb/>memory required to store the randomizers is small in <lb/>comparison to the document size: say 5% of the origi-<lb/>nal. Now several instantiations are possible. To discuss <lb/>them let b denote the size of a block in the randomized <lb/>document. We focus here on f 1 ; the permutation f 2 can <lb/>be done similarly. <lb/>One example is to use only DES, assumed to be a <lb/>PRF. For a 56 bit DES key a let the PRF f a , taking <lb/>b-bit inputs, be de ned by cipher block chaining| this <lb/>is still a PRF BKR]. Now note that the number of DES <lb/>computations to compute the tag in our scheme is es-<lb/>sentially just 5% more than that for doing DES CBC <lb/>of the entire message. Thus we run at essentially the <lb/>same speed as the most widely used existing message <lb/>authentication scheme with the added advantage of in-<lb/>crementality. <lb/>As an aside we note that the XOR schemes of <lb/>BGR] require at least 25% more DES operations than <lb/>the CBC. The fact that we have only a 5% overhead is <lb/>due to the chaining and exhibits another advantage of <lb/>this idea. <lb/>Another good instantiation is via composition. <lb/>Again let a be a DES key. Let the PRF f a be de ned <lb/>by f a (x) = DES a (DES a (MD5 1 (x)) MD5 2 (x)), where <lb/>MD5 1 (resp. MD5 2 ) is the rst (resp. second) half of <lb/>the output of MD5| this is shown by BR] to be a PRF <lb/>assuming MD5 is a collision-free hash function and DES <lb/>is a PRF. In software this may be faster than the above. <lb/>Note that the scheme has additional e ciency prop-<lb/>erties. For example, MAC computation can be paral-<lb/>lelized because the f 1 computations can be made in par-<lb/>allel. <lb/>Finally note keeping storage to within 5% of docu-<lb/>ment size is just an example| it could go lower. <lb/>3.3 The search tree schemes <lb/>In this subsection we present a document system main-<lb/>taining message-authentication tags, via fast incremen-<lb/>tal algorithms for tagging and verifying, with respect to <lb/>powerful text-modi cation operations such as cut and <lb/>paste. Our construction utilizes any ordinary message-<lb/>authentication scheme. Assuming that the basic scheme <lb/>is secure in the ordinary sense (i.e., withstands a chosen-<lb/>message-attack), we show that the incremental system <lb/>is tamper-proof secure. <lb/>Let MA be an ordinary message authentication al-<lb/>gorithm and MA a the tagging function induce by MA <lb/>with the authentication-key a (e.g., MA a = f a , where <lb/>f a is taken from a family of pseudorandom functions { <lb/>see GGM]). Let VMA be the corresponding veri cation <lb/>algorithm (e.g., VMA a (m; t) may merely consist of com-<lb/>puting MA a (m) and checking whether it equals t). We <lb/>stress that these primitives are not incremental ones; <lb/>yet, we will build incremental schemes out of them. <lb/>The main idea in our construction of an incremen-<lb/>tal tagging algorithm is to \keep the adversary under <lb/>control&quot; by virtue of partial veri cation. Speci cally, <lb/>before modifying a part of the tag, the incremental tag-<lb/>ging algorithm checks that this part is \locally&quot; valid. A <lb/>standard construction, namely tree authentication a la <lb/>Merkle Me1, Me2], can be used to provide the rst im-<lb/>plementation of this idea. However, this only works for <lb/>replacement. To handle the more complex operations <lb/>discussed above we use 2-3 trees AHU]. <lb/>The binary tree scheme. To help the reader un-<lb/>derstand what follows the binary tree scheme is now <lb/>presented. The construction may be standard, but the <lb/>proof that it achieves tamper resistance is not trivial; <lb/>however we&apos;ll omit it because we present and prove cor-<lb/>rect a more general scheme below. Assume for con-<lb/>venience that`= 2 h is a power of two. The (incre-<lb/>mentable) tag of a document D = D 1] : : :D `] is a bal-<lb/>anced binary tree of MA-tags. More formally, let V h <lb/>denote the set of all strings of length at most h asso-<lb/>ciated in the obvious manner with the vertices of the <lb/>balanced binary tree of height h. The tree of tags can <lb/>be seen as a function Tag: V h ! f0; 1g which assigns a <lb/>tag to each node. This function is computed bottom-up <lb/>as follows: <lb/>For each i, let Tag(w) = MA a (D i]), where w is the <lb/>i th leaf. <lb/>For each non-leaf node w, let Tag(w) = <lb/>MA a (Tag(w0); Tag(w1)). <lb/>Note that Tag( ) is the tag of the root of the tree. In <lb/>order to prevent replacement of one document by an-<lb/>other (or by an old version of the same document), <lb/>we rede ne the tag of the root to be Tag( ) def = <lb/>MA a (Tag(0); Tag(1); ; cnt), where is the name of the <lb/>document and cnt is the current counter value (associ-<lb/>ated with this document). <lb/>The incremental tagging algorithm works as fol-<lb/>lows. Suppose Tag( ) is the function describing the tag <lb/>of D, and that the j th symbol of D is to be replaced by <lb/>the symbol 2 . We rst check that the path from <lb/>the claimed current value to the root of the tree is valid. <lb/>Then we perform the update. Details follow. <lb/>Let u 0 ; : : :; u h be the path from the root u 0 = to <lb/>the j th leaf, denoted u h . Then <lb/>check that VMA a accepts Tag( ) as a valid authen-<lb/>tication tag of (Tag(0); Tag(1); ; cnt), where is <lb/>the name of the document and cnt is the current <lb/>counter value (associated with this document). <lb/></body>

			<page>9 <lb/></page>

			<body>for i = 1; :::; h?1: check that VMA a accepts Tag(u i ) <lb/>as a valid authentication tag of (Tag(u i 0); Tag(u i 1)). <lb/>check that VMA a accepts Tag(u h ) as a valid authen-<lb/>tication tag of D j]. <lb/>If these checks succeed then update Tag as follows: <lb/>set Tag(u h ) MA a ( ) <lb/>for i = h ? 1; : : :; 1: set Tag(u i ) MA a (Tag(u i 0); <lb/>Tag(u i 1)). <lb/>set Tag( ) MA a (Tag(0); Tag(1); ; cnt + 1). <lb/>We stress that the values of Tag on all other nodes (i.e., <lb/>those not on the path u 0 ; : : :; u h ) remain unchanged. <lb/>The search tree scheme. Recall that a 2-3 tree has <lb/>all leaves at the same level/height (as in case of bal-<lb/>anced binary trees) and each internal node has either <lb/>2 or 3 children (rather than 2 as in binary trees). We <lb/>stress that a 2-3 tree, alike a binary tree, is an ordered <lb/>tree and thus its leaves are in order. Thus, storing a <lb/>single symbol in each leaf of the tree de nes a string <lb/>over . It is well-known that such trees support insert <lb/>and delete (of a single symbol/leaf) in logarithmically <lb/>many operations 9 , where basic operations consist of any <lb/>single change in the topology of the tree (i.e., adding or <lb/>omitting a vertex or an edge). It is also easy to verify <lb/>that a paste operation (merging two trees so that the <lb/>leaves of the resulting tree represent the concatenation <lb/>of the leaves of the two trees) can also be implemented <lb/>in logarithmically many operations. A simple imple-<lb/>mentation of the cut operation results in at most log-<lb/>square operations (which correspond to the truncation <lb/>of logarithmically many subtrees). A more careful im-<lb/>plementation enables to repair the \damages&quot; created <lb/>by a cut operation using only logarithmically many op-<lb/>erations. Finally, we note that in order to allow fast <lb/>search (i.e., locating the i th leaf, given i) it is useful to <lb/>append a counter to each vertex specifying the number <lb/>of leaves in the subtree rooted at it. Clearly, these coun-<lb/>ters can be updated within the stated complexity. The <lb/>two types of counters in the following description should <lb/>not be confused: one counter, used above, representing <lb/>the number of modi cations to the document (hereafter <lb/>referred to as version counter), while the other counter <lb/>(termed size below), represents the number of symbols <lb/>in a subtext rooted at a vertex of the tag-tree. <lb/>Now, the (incrementable) tag of a document D = <lb/>D 1] : : :D `] is a 2-3 tree of MA-tags, hereafter referred <lb/>to as a tag-tree. Each node w is associated a label which <lb/></body>

			<note place="footnote">9 To insert a leaf, add it as a child to the suitable level h ? 1 <lb/> vertex. In case the resulting children-degree of this vertex is 4, <lb/>split it into two vertices so that both are children of its parent. <lb/>The parent may be split so too, and so on until one gets to the <lb/>root. If the root needs to be split then the height of the tree is <lb/>incremented. To delete a leaf, we apply an analogous procedure. <lb/>Namely, if the resulting parent and its siblings have total children-<lb/>degree at least 4 then we rearrange these children so that each of <lb/>the resulting parent nodes has children-degree either 2 or 3. In <lb/>case the total children-degree is at most 3, we merge the parent <lb/>and its sibling to one vertex and turn to its parent. <lb/></note>

			<body>consists of a tag (authenticating the children) and a <lb/>counter representing the number of leaves in the subtree <lb/>rooted at w. The tag of w is formed by authenticating <lb/>(using MA a ) the labels the children of w, in the natural <lb/>generalization of the above. Namely, the label of an in-<lb/>ternal vertex w is a pair (MA a (L 1 ; L 2 ; L 3 ); size), where <lb/>L i is the label of the i th child of w (in case w has only <lb/>two children, L 3 = ) and size is the number of leaves <lb/>in the subtree rooted at w. The tag of the root is formed <lb/>as the other tags, except that the information to which <lb/>MA a is applied contains also the document name and <lb/>the version-counter. Veri cation is done analogously to <lb/>the way it was conducted in the binary-tree scheme (i.e., <lb/>for each vertex we check that VMA a accepts its tag as <lb/>valid authentication of the labels of its children) except <lb/>that we also check that the subtree-counters of the chil-<lb/>dren sum-up to the subtree-counter of their parent. <lb/>The incremental tagging algorithm proceeds as fol-<lb/>lows. Suppose that a document, so tagged, is to be cut <lb/>at location j. We rst locate the j th leaf (using the <lb/>subtree counters contained in the nodes). This takes <lb/>O(log`) time. Then, we perform a partial validity check <lb/>analogously to the way it was conducted in the binary-<lb/>tree scheme except that we also check that the subtree-<lb/>counters of the children sum-up to the subtree-counter <lb/>of their parent. Again, we check only the validity of <lb/>the tags for vertices on the path from the leaf to the <lb/>root. (Note that these vertices are the parents and an-<lb/>cestors of all vertices which are to undergo topological <lb/>changes.) When checking the tagging of the root, we use <lb/>the corresponding document-name and current version-<lb/>counter. If this check succeeds then we go ahead and <lb/>implement these topological changes, creating new tags <lb/>for the corresponding vertices. The tagging of the root <lb/>is treated taking into account its slightly di erent struc-<lb/>ture (i.e., MA is applied here to information containing <lb/>also the document name and the incremented version-<lb/>counter). Incremental tagging for the paste operation <lb/>is performed analogously. In both cases, incremental <lb/>veri cation is similar. <lb/>A sketch of the proof of the following theorem is <lb/>in Appendix A. We assuming for simplicity that s = <lb/>log 2 j j. <lb/>Theorem 3.2 Suppose that the document system can <lb/>be broken with probability p(s) in an attack which runs in <lb/>time t(s), making document-create operations for docu-<lb/>ments of total length L(s) and at most m(s) document-<lb/>modi cation operations, each producing a document of <lb/>length at most`(s). Then, the underlying message authen-<lb/>tication system can be broken with probability p(s)=q(s) <lb/>via a chosen-message-attack which runs in time O(t(s)) <lb/>and makes at most q(s) def = O(L(s) + m(s) log`(s)) <lb/>queries. <lb/>The adaptation to signature schemes is immediate by <lb/>substituting each reference to an (ordinary) authenti-<lb/>cation scheme by referring to an (ordinary) signature <lb/></body>

			<page>10 <lb/></page>

			<body>scheme. <lb/>Application to Virus Protection. The setting for <lb/>virus protection by authentication was discussed in the <lb/>Introduction. Our tamper-proof incremental message <lb/>authentication scheme yields a virus-protection system <lb/>in the sense discussed there. This is done as follows. <lb/>Each le is stored on the insecure media together with <lb/>its tag-tree. By a suitable choice of parameters the stor-<lb/>age overhead can be negligible with respect to the le it-<lb/>self. For example, we can partition the le into blocks of <lb/>length s 2 , where s is the length of the tags (and the key) <lb/>in the basic message-authentication scheme MA. For an <lb/>L-bit-long le, we get a tag-tree that has L <lb/>s 2 leaves and <lb/>can be encoded as a binary string of length O(L=s). For <lb/>each le, the user only needs to keep O(s) bits (in local <lb/>secure memory); these bits are used to store the key of <lb/>the authentication-scheme, the le-name and its current <lb/>version-counter. Whenever the le is modi ed the tag-<lb/>tree (residing in the insecure media) and the version-<lb/>counter (kept in the secure local memory) are modi ed <lb/>as described in the incremental scheme (above). When-<lb/>ever the user wishes to verify the integrity of its le, it <lb/>veri es the validity of the tag-tree in the obvious man-<lb/>ner. <lb/>The underlying message authentication scheme can <lb/>be taken to be any of the standard ones. For exam-<lb/>ple, the CBC MAC, or just one of the PRFs discussed <lb/>above. (Any PRF is a MAC GGM]). Our scheme has <lb/>the additional property that it is secure even in face of <lb/>an adversary who can see the authentication tags and <lb/>even tamper with them. In contrast, the ngerprinting <lb/>method of Karp-Rabin KR] is secure only if the adver-<lb/>sary cannot see the ngerprint. <lb/>4 Incremental encryption <lb/>4.1 The security of incremental encryp-<lb/>tion <lb/>As discussed in the Introduction, the usage of incremen-<lb/>tal encryption algorithms may leak information that is <lb/>kept secret when using a traditional encryption scheme. <lb/>Below, we outline a de nition for the special case of <lb/>incremental encryption with respect to single symbol <lb/>replacement. <lb/>Loosely speaking, we say that an incremental en-<lb/>cryption, with respect to single symbol replacement, is <lb/>secure if given a sequence of encryptions E 1 ; :::; E t , pro-<lb/>duced by encrypting D 1 as E 1 and deriving each sub-<lb/>sequence E i by incrementing the previous E i?1 , it is <lb/>infeasible to derive any information about the original <lb/>document D 1 as well as its modi cations D 2 ; :::; D t (ex-<lb/>cept the fact that D i is obtained by replacing a single <lb/>symbol in D i?1 ). Equivalently, consider any two se-<lb/>quences, A = (A 1 ; :::; A t ) and B = (B 1 ; :::; B t ), so that <lb/>A 1 ; B 1 2 `a nd A i (resp., B i ) is obtained by replac-<lb/>ing a single symbol in A i?1 (resp., B i?1 ). Then, it is <lb/>infeasible to distinguish the sequence of encryptions pro-<lb/>duced by the document system when handling a create-<lb/>command for A 1 and the corresponding replacement-<lb/>commands of A from the sequence of encryptions pro-<lb/>duced by the document system when handling a create-<lb/>command for B 1 and the corresponding replacement-<lb/>commands of B. <lb/>4.2 Schemes for incremental encryption <lb/>If we allow incremental schemes which are e cient in <lb/>the amortized sense then there exist trivial solutions. <lb/>Namely, the encryption of the document can be aug-<lb/>mented by an encryption of the description of the mod-<lb/>i cation, until the number of modi cations equals the <lb/>length of the document, at which point one can re-<lb/>encrypt the document. This might be acceptable in <lb/>some settings, but a non-amortized solution is worth <lb/>seeking. <lb/>Another approach to incremental encryption is to <lb/>use the idea of \software protection&quot; as de ned in Go]. <lb/>(The setting consists of a processor, having only a lim-<lb/>ited amount of local memory, to store and access in-<lb/>formation on an insecure remote memory. The sim-<lb/>ulation should be oblivious in the sense that the ac-<lb/>tual access pattern does not leak information about the <lb/>original/simulated access pattern. The translation from <lb/>oblivious simulation of RAM to an incremental encryp-<lb/>tion scheme is quite obvious: the role of the processor <lb/>is played by the user, whereas the remote memory is <lb/>associated with the encryption.) A software protection <lb/>scheme with polylogarithmic overhead exists Os], but <lb/>is also amortized, and using this results in an incremen-<lb/>tal encryption scheme whose e ciency is in the end not <lb/>better than that of the trivial solution above. <lb/>However the ideas of the software protection <lb/>schemes of Go, Os] can be adapted to derive an in-<lb/>cremental encryption scheme for (single symbol) in-<lb/>sert/delete that is e cient in the strict sense (i.e., num-<lb/>ber of simulation steps per original operation) rather <lb/>than in the amortized sense (as presented there). The <lb/>adaptation is achieved by \pipelining.&quot; A brief descrip-<lb/>tion follows. <lb/>The scheme maintains secure encryptions of doc-<lb/>uments which undergo a sequence of (single symbol) <lb/>replacements. (The scheme is presented in terms of <lb/>private-key encryption, but can be easily converted into <lb/>a public-key setting.) <lb/>In our solution we use an arbitrary (private-key) <lb/>semantically-secure (probabilistic) encryption scheme E <lb/>(the key is implicit in the notation). We assume that E <lb/>can be used to encrypt symbols in as well as pairs <lb/>(i; ), where 2 and i is an integer not greater <lb/>than the length of documents in our system. Using <lb/>E, we rst present an obvious algorithm that main-<lb/>tains encrypted versions of documents which undergo <lb/>symbol-replacement. The encrypted versions consist of <lb/>two sequences of encryption values, denoted E 1 and E 2 . <lb/></body>

			<page>11 <lb/></page>

			<body>The rst sequence, E 1 , is a block-by-block encryption <lb/>of some reference document D = D 1] D `]; whereas <lb/>the second sequence, E 2 , encodes the sequence of modi-<lb/>cations, denoted M = M 1] M t], by which the cur-<lb/>rent document has been obtained from D. The obvious <lb/>algorithm increments the encryption of a modi ed doc-<lb/>ument by appending the encryption of the modi cation <lb/>to E 2 . Every`steps the algorithm recovers the modi-<lb/>ed document and re-encrypts it using a block-by-block <lb/>encryption, thus forming a new encryption sequence E 1 <lb/>(and setting E 2 to be empty). The amortized complex-<lb/>ity of this algorithm amounts to two block encryptions <lb/>per each modi cation. <lb/>An important observation is that one may`pipeline&apos; <lb/>the expensive actions of the above algorithm. Suppose <lb/>rst that we are allowed to keep intermediate results in <lb/>some secure location (invisible by the adversary). Then, <lb/>once the length of E 2 reaches`, we can start preparing <lb/>the new encryption of the document, denoted D 0 , which <lb/>results from D by applying the ( rst`) modi cations in <lb/>M. We perform all required computation along with the <lb/>next`modi cations, while allowing M to grow upto a <lb/>total length of 2`. At this point, we have the encryp-<lb/>tion, denoted E 0 , of the document D 0 (yet, indeed, now <lb/>the current document is di erent). Replacing E 1 by <lb/>E 0 and omitting the rst`modi cations in M, we ob-<lb/>tain the encrypted form of the current document. We <lb/>stress that, within our (realistic) model of computation, <lb/>these operations (switching les and runcating a le) <lb/>can be performed in constant time. To summarize, the <lb/>algorithm works in epochs, each consisting of`mod-<lb/>i cations. In each epoch, the algorithm updates the <lb/>encryption to match the modi cations performed in the <lb/>previous epoch. <lb/>In the above description, we have assumed that the <lb/>user can store its intermediate results (which require <lb/>O(`) space) in a location invisible by the adversary. <lb/>This assumption is unrealistic in some settings and is <lb/>inconsistent with our de nitions as presented in Sub-<lb/>section 4.1. We thus turn to implement the above ideas <lb/>without making this assumption 10 . To this end, we en-<lb/>crypt documents using three sequences of encryption <lb/>values, denoted E 1 , E 2 and E 3 . The rst two sequence, <lb/>E 1 and E 2 , are as above and su ce for decrypting the <lb/>document. The additional sequence E 3 is an encryption <lb/>of a \work area&quot;, denoted W = W 1] W 2`], used to <lb/>implement the above procedure. <lb/>Following is a description of what is being done in <lb/>one epoch. (In our description, we do not mention ex-<lb/>plicitly the encryption operations, thus whenever we say <lb/>that we set a symbol of W it is to be understood that <lb/>the corresponding encryption is computed and stored.) <lb/>First, we set W to hold the relevant information; i.e., <lb/>W i] (i; D i]) for i `and W i] M i ?`] for <lb/>+ 1 i 2`. (Here we assume that the modi cation <lb/></body>

			<note place="footnote">10 Here is where we use the ideas of Go, Os]. <lb/></note>

			<body>records have the form (i; ), where i is a location and a <lb/>symbol to be placed in that location.) Next, we sort the <lb/>pairs in W by their left element, hereafter referred to as <lb/>their sorting-keys, so that if two sorting-keys are equal <lb/>then the corresponding pairs are kept in order. It is <lb/>crucial that the sorting is performed by an e cient and <lb/>oblivious sorting network such as Batcher&apos;s sorting net-<lb/>work Ba]. We stress that whenever two pairs are com-<lb/>pared and switched/unswitched they are re-encrypted <lb/>by E (and so the adversary cannot tell if they were <lb/>switched or not). This guarantees that the entire sort-<lb/>ing procedure does not leak any information to the ad-<lb/>versary. Once the sorting is completed, W is scanned <lb/>while setting all occurences with the same sorting-key, <lb/>save the last one (which is the`newest&apos; one), to a large <lb/>dummy value (i.e., (`+ 1; )). Now, we sort the pairs <lb/>in W (by the sort-key) again, and obtain a sequence in <lb/>which the rst`entries hold the updated document D 0 . <lb/>Finally, we set E 1 to hold the encryption of D 0 and drop <lb/>the rst`elements of E 2 . <lb/>Using the AKS sorting network AKS], our im-<lb/>plementation of one epoch requires O(`log`) steps <lb/>(whereas if we use Batcher&apos;s network we get a total of <lb/>O(`) +`(log 2`) steps). These steps can be partitioned <lb/>evenly among the`modi cation actions yielding the <lb/>desired complexity. <lb/>As stated above, each of the schemes presented in <lb/>Go, Os] can be adopted to yield an incremental en-<lb/>cryption scheme for (single symbol) insert/delete that <lb/>is e cient in the strict sense. This is done analogously <lb/>to the above, provided hat the document length stays <lb/>within some predetermined bounds (e.g., between`=2 <lb/>and 2`). Namely, the encryption of a document con-<lb/>sists of three sequences of encrypted values, E 1 , E 2 and <lb/>E 3 , where E 1 and E 2 are as above and E 3 is an en-<lb/>cryption of the workspace of some oblivious simulator. <lb/>As above, the algorithm works in epochs consisting of <lb/>modi cations each. In each epoch, the incremental <lb/>algorithm performs the`modi cations of the previous <lb/>epoch. This is done by simulating a RAM which main-<lb/>tains a data structure enabling fast performance of in-<lb/>sert/delete (e.g., a 2-3 tree). <lb/>5 The privacy issue <lb/>Privacy is an interesting new issue in incremental cryp-<lb/>tography to which we provide a brief introduction here. <lb/>Security, as de ned for signature and encryp-<lb/>tion schemes, is concerned with what an illegiti-<lb/>mate/outsider party which does not know the private <lb/>key can do or learn. For example, in signature schemes <lb/>it was required that this outsider (called the adversary) <lb/>cannot forge signatures. We now consider the informa-<lb/>tion regarding previous versions of the document which <lb/>can be inferred by the legitimate party when inspecting <lb/>the current document together with the current crypto-<lb/>graphic form. That is, suppose, for example, that we are <lb/></body>

			<page>12 <lb/></page>

			<body>given a document D together with its (updated) crypto-<lb/>graphic form and we are told that D was obtained from <lb/>some other document, called D 0 , by a deleting a single <lb/>symbol. Perfect privacy would mean that we cannot <lb/>tell the location of the deleted symbol. Partial privacy <lb/>may mean that we cannot tell the identity of the deleted <lb/>character (but we may have some information regarding <lb/>its location). <lb/>Perfect privacy is a natural concern in the context <lb/>of signatures. Suppose that one uses an incremental <lb/>signature scheme to produce signatures to related com-<lb/>mitments given to various parties. It is desirable that <lb/>none of these parties can learn from the signature given <lb/>to it something concerning commitments given to other <lb/>parties. Partial privacy may be useful too. Suppose Al-<lb/>ice has a standard commitment form in which she only <lb/>lls-up some very few spaces before signing (many such <lb/>forms do exist in the business world). Clearly, Alice <lb/>should not care if Bob, to him she gave such an in-<lb/>cremental commitment, learns that she have signed the <lb/>commitment (given to him) by incrementing a signature <lb/>to a di erent instance of this commitment, as long as <lb/>Bob cannot nd out any details concerning this previous <lb/>commitment. <lb/>A de nition of perfect privacy can be easily pro-<lb/>duced following the standard paradigms. Speci cally, <lb/>given a document D and a signature to it, it should be <lb/>infeasible to distinguish whether the signature was by <lb/>the document system in response to a create command <lb/>or in response to a text modi cation command. Def-<lb/>initions of partial privacy may vary for ones in which <lb/>the amount of modi cation is the only information be-<lb/>ing leaked to ones in which only the secrecy of re-<lb/>placed/deleted symbols is preserved. <lb/>Our rst message authentication scheme (i.e., the <lb/>XOR-scheme of Section 3.1) satis es perfect privacy; <lb/>whereas the second scheme (i.e., the tree scheme ) sat-<lb/>is es only partial privacy. <lb/></body>

			<div type="acknowledgement">Acknowledgements <lb/>We are grateful to Nir Shavit for pointing out several <lb/>important applications of incremental cryptography. <lb/>Work done while the rst author was at the IBM <lb/>T.J. Watson Research Center, New York. <lb/></div>

			<listBibl>References <lb/>AHU] A. Aho, J. Ullman, and J. Hopcroft. The <lb/>design and analysis of computer algorithms. <lb/>Addison-Wesley, 1974. <lb/>AKS] M. Ajtai, J. Koml os and E. Szemer edi. An <lb/>O(n logn) sorting network. STOC 83. <lb/>Ba] K. Batcher. Sorting networks and their ap-<lb/>plications. AFIPS Spring Joint Computer Con-<lb/>ference 32, 1968. <lb/>BGG] M. Bellare, O. Goldreich and S. Gold-<lb/>wasser. Incremental cryptography: The case <lb/>of hashing and signing. Crypto 94. <lb/>BGR] M. Bellare, R. Gu erin and P. Rogaway. <lb/>XOR MACs: New methods for message authen-<lb/>tication using block ciphers. Manuscript, March <lb/>1994. <lb/>BKR] M. Bellare, J. Kilian and P. Rog-<lb/>away. The security of cipher block chaining. <lb/>Crypto 94. <lb/>BR] M. Bellare and P. Rogaway. Entity au-<lb/>thentication and key distribution. Crypto 93. <lb/>CW] L. Carter and M. Wegman. Universal <lb/>Classes of Hash Functions. J. Computer and <lb/>System Sciences 18, 143{154, 1979. <lb/>Go] O. Goldreich. Towards a Theory of Software <lb/>Protection and Simulation by Oblivious RAMs. <lb/>STOC 87. <lb/>GGM] O. Goldreich, S. Goldwasser and S. Mi-<lb/>cali. How to construct random functions. Jour-<lb/>nal of the ACM, Vol. 33, No. 4, 210{217, 1986. <lb/>GM] S. Goldwasser and S. Micali. Probabilis-<lb/>tic encryption. J. of Computer and System Sci-<lb/>ences 28, 270{299, April 1984. <lb/>GMR] S. Goldwasser, S. Micali and R. Rivest. <lb/>A digital signature scheme secure against adap-<lb/>tive chosen-message attacks. SIAM Journal of <lb/>Computing, 17(2):281{308, April 1988. <lb/>KR] R. Karp and M. Rabin. E cient random-<lb/>ized pattern matching algorithms.IBM J. of Re-<lb/>search and Development Vol. 31, No. 2, March <lb/>1987. <lb/>LR] M. Luby and C. Rackoff. How to construct <lb/>pseudorandom permutations from pseudoran-<lb/>dom functions. SIAM J. Computation, Vol. 17, <lb/>No. 2, April 1988. <lb/>Me1] R. Merkle. A certi ed digital signature <lb/>scheme. Crypto 89. <lb/>Me2] R. Merkle. Protocols for public key cryp-<lb/>tosystems. Proceedings of the 1980 Symposium <lb/>on Security and Privacy. <lb/>Os] R. Ostrovsky. E cient Computations on <lb/>Oblivious RAMs. STOC 90. <lb/>Ri] R. Rivest. The MD5 message-digest al-<lb/>gorithm. IETF Network Working Group, <lb/>RFC 1321, April 1992. <lb/></listBibl>

			<div type="annex">A Sketch of proof of <lb/>Theorem 3.2 <lb/>A key observation regarding the incremental tagging al-<lb/>gorithm follows. <lb/>Proposition A.1 Suppose that Tag is a valid tag-tree <lb/>for the text T, stored as version cnt of document (name) <lb/></div>

			<page>13 <lb/></page>

			<div type="annex">. Then the tag-trees produced by the system in response <lb/>to a cut-operation, with parameters ; ; , are valid tag-<lb/>trees for the resulting texts (when stored as new versions <lb/>of documents (names) and ). Similarly, for pasting. <lb/>We stress that the term \validity&quot; used in the above <lb/>proposition and below includes the requirement that <lb/>the document-name and version-counter authenticated <lb/>by the root match the actual document-name and the <lb/>corresponding current version-counter. <lb/>We show that attacks on our tree tagging system <lb/>cannot be too successful since they would yield success-<lb/>ful attacks on the basic message authentication scheme <lb/>MA. <lb/>Consider an arbitrary adversary that attacks the <lb/>tagging system using commands of all three types (i.e., <lb/>create&apos;,`modify&apos; and`tamper&apos;). Note that both tag-<lb/>ging algorithms employed (for`create&apos; and`modify&apos;) use <lb/>an oracle to MA a (and VMA a ), for a randomly gener-<lb/>ated authentication-key a. We assume for simplicity <lb/>that the adversary always halts outputting a properly <lb/>tagged document (i.e., a pair (D; ) where is an MA a -<lb/>valid authentication tree for D). We stress that this <lb/>(document,tag)-pair is not necessarily one which has <lb/>not \appeared before&quot; (i.e., D may have appeared as <lb/>a previous virtual message). Actually, our task is to <lb/>show that it is most likely that the document D has ap-<lb/>peared previously as a virtual document (see Section 3.1 <lb/>for terminology). <lb/>We now consider two events de ned over the prob-<lb/>ability space of all possible executions of the above at-<lb/>tack. The rst event is that the adversary has produced <lb/>(either as part of a tampering command or as part of <lb/>its output) a tree-tag containing an MA a -tag for a string <lb/>for which an MA a -tag did not appear as part of some <lb/>tag-tree created by the system (in response to some`cre-<lb/>ate&apos; or`modify&apos; command). The second event is that the <lb/>same MA a -tag appears as the tag of two di erent strings <lb/>in either two di erent tag-trees or in the same tag-tree, <lb/>produced by the system (in response to some`create&apos; or <lb/>modify&apos; command). Both events may occur only with <lb/>negligible probability, since each of them constitutes a <lb/>breach of the security of the basic message authentica-<lb/>tion scheme MA. If none of the events occur, we call the <lb/>execution good. <lb/>From this point on, we assume that the execution <lb/>is good and show that (in this case) the tag-tree output <lb/>by the adversary is for a document, denoted D, which <lb/>has appeared before as a virtual document. Since the <lb/>tag-tree output by the adversary is valid, it follows that <lb/>all the MA-tags appearing in it are valid. By the as-<lb/>sumption that the execution is good, it follows that all <lb/>these tags, and in particular the tag of the root, have <lb/>appeared in some previous tag-tree (produced by the <lb/>system). Consider the earliest time t in which there <lb/>exists a document name with a cryptographic form <lb/>having a vertex v with the same MA a -tag as the root of <lb/>D (i.e., the document output by the adversary). Since <lb/>roots have a special form, the node v must be the root <lb/>of the tag-tree. Let V t be the virtual document associ-<lb/>ated with document-name at that time t. Note that <lb/>V t was de ned in time t by either a create or a modi -<lb/>cation command. <lb/>If V t was de ned by a document-creation command <lb/>then the tag-tree of document at time t must be valid <lb/>(as it was produced in response to a create command). <lb/>By the assumption that the execution is good, it fol-<lb/>lows that this (valid) tag-tree is identical to the (valid) <lb/>tag-tree of D (since otherwise two di erent valid tag-<lb/>trees, with an identical root, have appeared in the ex-<lb/>ecution implying that the execution contains two dif-<lb/>ferent strings with the same MA a -tag). It follows that <lb/>V t = D. <lb/>We are left with the case where V t was de ned by <lb/>a document-modi cation command. For each virtual <lb/>document, we de ne a virtual tag-tree (associated with <lb/>it). The de nition mimics the one of a virtual document <lb/>(i.e., it ignores the possible tampering of the tag-trees <lb/>associated to document-names). Namely, <lb/>The virtual tag-tree associated with a creation com-<lb/>mand (and with the virtual document de ned by <lb/>this command) is the actual tag-tree produced by the <lb/>system. Thus, in this case, the virtual tag-tree is <lb/>a valid tag-tree of the corresponding virtual docu-<lb/>ment. <lb/>The virtual tag-tree associated with a modi cation <lb/>command (and with the virtual document de ned <lb/>by this command) consists of a tree of MA-tags in <lb/>which the new tags (produced at this stage by the <lb/>system) are the actual ones but the tags of the other <lb/>vertices are as in the virtual tag-tree of the corre-<lb/>sponding virtual documents. <lb/>An important observation, proven by induction on the <lb/>recursive de nition of a virtual tag-tree, is that every <lb/>virtual tag-tree consists of MA a -tags which were pro-<lb/>duced by the system. Combining the same type of in-<lb/>duction with Proposition A.1, we prove the following <lb/>Lemma A.2 At any time, the virtual tag-tree associated <lb/>with each document is a valid tag-tree for the correspond-<lb/>ing virtual document. <lb/>We stress that the assertion of the lemma does not nec-<lb/>essarily hold with respect to the actual tag-trees that <lb/>may even contain illegal MA a -tags. <lb/>Proof: First, we observe that the lemma holds for a <lb/>virtual tag-tree de ned by a create operation. Now, <lb/>consider a virtual tag-tree de ned by pasting documents <lb/>(names) and . By de nition, this virtual tag-tree <lb/>consists of the MA a -tags of the corresponding virtual <lb/>tag-trees and the actual tags produced for the vertices <lb/>along the path from the topological change to the root. <lb/>We claim that if a path from some vertex in the actual <lb/>tag-tree of (resp., ) to its root is valid then the labels <lb/>of the children of the vertices on this path equal the <lb/>corresponding labels in the virtual tree of (resp., ). <lb/></div>

			<page>14 <lb/></page>

			<div type="annex">Once this claim is proven we are done (since then we are <lb/>guaranteed that the newly formed MA a -tags are tags for <lb/>the correct values). <lb/>The claim is proven by induction from the root of this <lb/>path, using the hypothesis that the execution is good, <lb/>the fact that the virtual tag-tree of consists of MA a -<lb/>tags produced by the system, and the hypothesis that <lb/>the virtual tag-tree of is a valid tag-tree (for the cor-<lb/>responding virtual document). Firstly, if the tag of the <lb/>root of the actual tag-tree for document having cur-<lb/>rent version-counter cnt is valid then it must have been <lb/>produced by the system for document at the time its <lb/>counter was incremented to the value cnt. Thus, the <lb/>root of the actual tag-tree equals the root of the virtual <lb/>tag-tree of . It follows that the labels of the children <lb/>of root of the actual tag-tree are as in the correspond-<lb/>ing virtual tag-tree. In particular, the subtree counters <lb/>of the corresponding children in the two tag-trees are <lb/>equal and thus the locations of the corresponding sub-<lb/>texts are the same. Similarly, if the tag of a vertex, v, <lb/>of the actual tag-tree is both valid and equals the cor-<lb/>responding tag in the virtual tag-tree then the labels of <lb/>v&apos;s children are as in the corresponding virtual tag-tree. <lb/>The claim follows and so does the lemma. <lb/>We now claim that the virtual tag-tree of V t equals <lb/>the tag-tree produced by the adversay (for D). First, we <lb/>observe that the actual tag-tree of V t at time t contains <lb/>as its root an MA a -tag of a string containing the docu-<lb/>ment name and a counter-version denoted cnt. How-<lb/>ever, by validity of the virtual tag-tree of V t it follows <lb/>that also the virtual tag-tree contains as its root an au-<lb/>thentication of the document name and the counter-<lb/>version cnt. Combining this with the de nition of the <lb/>incremental algorithm and the fact that each MA-tag in <lb/>the virtual tag-tree has appeared in an actual tag-tree, <lb/>we infer that the roots of both the actual and virtual <lb/>tag-trees of V t are identical. Thus, the virtual tag-tree <lb/>of V t and the output tag-tree of D have identical roots <lb/>(recall that by de nition the root of the actual tag-tree <lb/>of V t equals the root of the tag-tree of D). By the as-<lb/>sumption that the execution is good and the fact that <lb/>the virtual tag-tree consists of MA a -tags produced by <lb/>the system, we conclude again that these two (valid) <lb/>tag-trees (ie., the virtual tag-tree of V t and the tag-tree <lb/>of D) must be identical, and again V t = D follows. This <lb/>concludes the proof that in every good execution the <lb/>authenticated document output by the adversary (ie., <lb/>D) is a virtual document which has appeared before. <lb/></div>

			<page>15 </page>


	</text>
</tei>
