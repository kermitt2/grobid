<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="_0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>07/17/97 10:13 <lb/>1 of 8 <lb/>The Abstract Class Pattern <lb/>Bobby Woolf <lb/>Knowledge Systems Corp. <lb/>4001 Weston Pkwy, Cary, NC 27513-2303 <lb/>919-677-1119 x541, bwoolf@ksccary.com <lb/>ABSTRACT CLASS <lb/>Class Behavioral <lb/>Intent <lb/>Define the interface for a hierarchy of classes while deferring the implementation to subclasses. <lb/>Abstract Class lets subclasses redefine the implementation of an interface while preserving the <lb/>polymorphism of those classes. <lb/>Also Known As <lb/>Liskov Substitution Principle [LW93], Design by Contract [Meyer91], Base Class [Auer95] , <lb/>Template Class [Woolf97] <lb/>Motivation <lb/>Consider the need to perform simple arithmetic. Every application needs to use simple numbers like <lb/>integers and floats and to perform simple arithmetic such as addition, subtraction, multiplication, and <lb/>division. <lb/>One obvious way to perform this simple math is to let the CPU do it. Any modern CPU has built in <lb/>commands to perform simple arithmetic with integers and floats. This is the most efficient way to <lb/>perform such calculations. <lb/>The problem is that not all numerical quantities can be adequately represented as the CPU&apos;s integers <lb/>and floats. Integers have a limited range. Floats have limited precision and loose precision converting <lb/>between decimal and binary. <lb/>The number framework in a robust object-oriented system should take advantage of the CPU&apos;s <lb/>efficiency whenever possible. However, to make the system more robust, the framework should <lb/>overcome the CPU&apos;s limitations whenever possible. It should be able to represent a virtually limitless <lb/>range of numbers, both really huge numbers and really tiny ones. It should be able to represent a <lb/>decimal number with complete precision, at least to a specified number of decimal places. It should be <lb/>able to perform simple arithmetic without any loss of precision. It could even compute complex <lb/>equations by simplifying them first. <lb/>A robust number framework employs various classes to meet these goals: Integer and Float for <lb/>CPU numbers, LargePositiveInteger and LargeNegativeInteger for huge integer <lb/>values, FixedPoint for complete precision, Fraction for division without round off, and so on. <lb/>This way, the framework performs as much computation as possible using the CPU, but also uses <lb/>other classes to represent numbers that that the CPU cannot. The diagram below shows the classes for <lb/>this framework. <lb/></front>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>2 of 8 <lb/></page>

			<body>The problem with all of these number classes is that the rest of the system does not want to be aware <lb/>of them. To the rest of the system, there are just number objects and they know how to perform <lb/>arithmetic. When code somewhere in the system has a statement like &quot;x + y,&quot; it does not care whether <lb/>x is a Float or y is a Fraction. The code just knows that x and y are numbers and that numbers <lb/>know how to perform addition. The implication is that since some numbers know how to perform <lb/>addition, all numbers must be able to. <lb/>Thus the number framework requires more than just these various number classes. It also needs to <lb/>clearly show which classes are part of the framework. It needs to require that all classes in the <lb/>framework be able to perform a certain minimal amount of functionality, such as addition. And the <lb/>framework needs to provide all of this number functionality in a polymorphic way to hide the <lb/>complexity of the various subclasses from the rest of the system. <lb/>The framework will accomplish all of this by using a generalized superclass called Number. A <lb/>Number represents any kind of number, be it an integer, float, or whatever. It defines the minimal <lb/>functionality that any number must provide, such as addition. It does not define a number&apos;s structure, <lb/>nor does it define the implementation of the functionality. Those details are deferred to subclasses like <lb/>Integer, Float, and so on. Applying Number as a superclass, and implementing Integer in a <lb/>similar manner, leads to the framework of classes shown below. <lb/>Object <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>LargePositiveInteger <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>Integer <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>Float <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>LargeNegativeInteger <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>FixedPoint <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>Fraction <lb/>Object <lb/>+ <lb/>-<lb/>* <lb/>/ <lb/>Number <lb/>Float <lb/>Integer <lb/>Fraction <lb/>FixedPoint <lb/>LargePositiveInteger <lb/>SmallInteger <lb/>LargeNegativeInteger <lb/></body>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>3 of 8 <lb/></page>

			<body>All number classes are now subclasses of Number. They are defined to provide basic arithmetic. A <lb/>client using a couple of number objects knows that numbers can perform basic arithmetic regardless <lb/>of which subclasses the objects are. <lb/>Number is an example of the Abstract Class pattern. As described in Design Patterns, &quot;An abstract <lb/>class is one whose main purpose is to define a common interface for its subclasses.&quot; [GHJV95, page <lb/>15] Number defines a type that can be implemented several different ways, but all of these <lb/>implementations will have the same interface so that clients can use them interchangeably. This <lb/>simplifies client code by causing the code to describe what it wants done without specifying how it <lb/>should be done. The client code will even work with unknown, future implementations, as long as <lb/>those implementations fulfill the interface. <lb/>The key to the Abstract Class pattern is a superclass that defines the type for its hierarchy and <lb/>subclasses that provide various implementations of the type. An abstract class can be implemented as <lb/>pure interface such that its subclasses must implement all of its messages, but it is more useful still if <lb/>it also provides a partial implementation suitable for all of the subclasses. In this way, a subclass <lb/>inherits the partial implementation and only needs to complete it. <lb/>The superclass is called &quot;abstract&quot; because its implementation is incomplete so clients do not create <lb/>instances of it. The subclasses that a client can create instances of are referred to as &quot;concrete.&quot; <lb/>[WWW90, page 27] <lb/>Keys <lb/>A framework that incorporates the Abstract Class pattern has the following features: <lb/>N A superclass that defines a type. <lb/>N One or more subclasses that implement the type. <lb/>N Polymorphism between the subclasses because they share the interface defined by the superclass. <lb/>The framework may also include these variations on the pattern: <lb/>N The superclass may provide a partial but incomplete implementation. <lb/>N The superclass may provide a complete implementation that is a default or minimal <lb/>implementation. <lb/>N The superclass may define state as well as interface. <lb/>N The subclasses may expand the interface defined by the superclass to include additional <lb/>functionality. However, that extended interface will not be polymorphic with the other classes. <lb/>Applicability <lb/>Use the Abstract Class pattern when: <lb/>N a framework requires several classes that have the same interface or whose interfaces overlap to <lb/>form a common, core interface. <lb/>N the common interface should be defined in one place so that all of the classes know they should <lb/>adhere to this interface and so that clients know what interface they can expect. <lb/>N a hierarchy should be extensible so that future subclasses can easily be added without having to <lb/>change the existing superclass or the existing client code. <lb/></body>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>4 of 8 <lb/></page>

			<body>Structure <lb/>Participants <lb/>N AbstractClass (Number, Integer) <lb/>defines the interface that all of the ConcreteClasses share. <lb/>does not define state and implementation unless it is common to all concrete classes, <lb/>including future ones. <lb/>may itself be a more specific subclass of another AbstractClass. <lb/>N ConcreteClass (FixedPoint, Float, Fraction, LargeNegativeInteger, <lb/>LargePositiveInteger, SmallInteger) <lb/>is a direct or indirect subclass of its AbstractClass. <lb/>implements the interface inherited from AbstractClass. <lb/>declares state necessary to implement interface. <lb/>N Client <lb/>collaborates with ConcreteClass instances through the AbstractClass interface. <lb/>Collaborations <lb/>N Clients use the AbstractClass interface to interact with objects that may be any ConcreteClass. <lb/>N ConcreteClass relies on AbstractClass to provide the default implementations common to all <lb/>ConcreteClasses. <lb/>Consequences <lb/>The advantages of the Abstract Class pattern are: <lb/>N Class polymorphism. The ConcreteClasses are polymorphic with each other because they all <lb/>support the common interface defined by the AbstractClass. This means that a client can use any <lb/>of the ConcreteClasses without regard to which ConcreteClass it is using. Such common <lb/>interfaces make extensibility easier because client code will be able to use future ConcreteClasses <lb/>that haven&apos;t even been written yet, as long as those future classes adhere to the interface. <lb/>N Algorithm reuse. If the AbstractClass does contain any implementation, it is usually in the form <lb/>of Template Methods [GHJV95, page 325]. This is implementation (and in some cases even <lb/>state) that is common to all of the ConcreteClasses, present and future, and so can be reused by <lb/>implementing it once in the AbstractClass. <lb/>The disadvantages of the Abstract Class pattern are: <lb/>Client <lb/>operation1 <lb/>operation2 <lb/>AbstractClass <lb/>operation1 <lb/>operation2 <lb/>ConcreteClassA <lb/>operation1 <lb/>operation2 <lb/>ConcreteClassB <lb/></body>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>5 of 8 <lb/></page>

			<body>N Abstract vs. concrete. Clients generally assume that they can create an instance of any class, but <lb/>this is not the case with abstract classes. Clients should not attempt to instantiate instances of <lb/>abstract classes, only concrete ones. The superclass is said to be &quot;abstract&quot; because it has an <lb/>incomplete implementation, so the client cannot or should create instances of it. Each subclass is <lb/>said to be because its implementation is complete, so the client can create instances of <lb/>it. <lb/>N Single hierarchy. The pattern forces all of the ConcreteClasses to be gathered together into a <lb/>single class hierarchy with one common superclass, the AbstractClass. Sometimes a class seems <lb/>to belong in one hierarchy because of its type but in another hierarchy so that it can inherit some <lb/>of its implementation. In such a case, it is better to implement the class in its type hierarchy and <lb/>let it delegate to an instance from its implementation hierarchy. <lb/>Another way this problem can occur is when disparate classes need to implement the same <lb/>operation. The default implementation for this operation is usually defined in the first superclass <lb/>they all have in common. This in effect makes that superclass an AbstractClass for those <lb/>subclasses. However, it also makes the class an AbstractClass for all of the other subclasses, even <lb/>though they don&apos;t need the operation. Thus it becomes clear that inheritance is not the best way <lb/>to define this operation and reuse its implementation. The classes that need the operation would <lb/>be better of delegating to an object that has the operation. <lb/>N Overly specific interface. Sometimes a ConcreteClass is not prepared to implement all of the <lb/>operations that an AbstractClass specifies. For example, the Collection abstract class in <lb/>Smalltalk specifies add: and remove: operations, but the Array subclass cannot implement <lb/>them. When possible, the AbstractClass should not specify an operation unless all of its <lb/>ConcreteClasses will be able to implement it. When this cannot be avoided, the ConcreteClass <lb/>must implement the operation anyway, usually to issue an error. <lb/>Implementation <lb/>There are several issues to consider when implementing the Abstract Class pattern: <lb/>1. Separate classes. A object is often implemented using a single class that defines both the object&apos;s <lb/>interface and its implementation. This makes the abstraction that the class represents difficult to <lb/>reuse. The Abstract Class pattern suggests that the object should be implemented with two <lb/>classes, an abstract one that defines its interface and a concrete one that implements the interface. <lb/>2. No state. The AbstractClass usually does not declare any state variables. If it did, all of its <lb/>ConcreteClasses would be forced to inherit those variables. This would be inefficient for a <lb/>ConcreteClass whose implementation did not require those variables. However, if all of the <lb/>ConcreteClasses require a variable, and if future ConcreteClasses would also probably require <lb/>that variable, then it can be declared in the AbstractClass. <lb/>3. Implementation through Template Methods. An AbstractClass is usually implemented as a <lb/>collection of Template Methods [GHJV95, page 325]. An AbstractClass is said to define an <lb/>interface but leave its implementation to the ConcreteClasses. However, when a message has a <lb/>default implementation that is appropriate for all ConcreteClasses, that implementation can be <lb/>made in the AbstractClass. Such an implementation is often either a template method or a <lb/>primitive operation method. <lb/>4. No private messages. The AbstractClass defines the hierarchy&apos;s interface. These are the public <lb/>messages that the subclasses will implement. The AbstractClass does not need to define private <lb/>messages and usually does not do so. However, it may define private messages that are primitive <lb/>operations of the class&apos; template methods. <lb/></body>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>6 of 8 <lb/></page>

			<body>Sample Code <lb/>The Magnitude hierarchy in Smalltalk is an excellent example of the Abstract Class pattern. It <lb/>includes the Number hierarchy discussed in the Motivation because numbers are magnitudes. <lb/>A Magnitude understands six main messages: equal-to (=), not-equal-to (~=), less-than (&lt;), <lb/>greater-than (&gt;), less-than-or-equal-to (&lt;=), and greater-than-or-equal-to (&gt;=). Some examples of <lb/>Magnitudes include Number, Timestamp, and Character. All of these are subclasses of <lb/>Magnitude and understand the Magnitude messages, as shown below. <lb/>Four of the messages are implemented as Template Methods: not-equal-to, greater-than, less-than-or-<lb/>equal-to, and greater-than-or-equal-to. They are implemented in terms of two primitive <lb/>equal-to and less-than. The primitive operations are deferred to subclasses. <lb/>Magnitude&gt;&gt;= aMagnitude <lb/>^self subclassResponsibility <lb/>Magnitude&gt;&gt;~= aMagnitude <lb/>^(self = aMagnitude) not <lb/>Magnitude&gt;&gt;&lt; aMagnitude <lb/>^self subclassResponsibility <lb/>Magnitude&gt;&gt;&gt; aMagnitude <lb/>^(self &lt;= aMagnitude) not <lb/>Magnitude&gt;&gt;&lt;= aMagnitude <lb/>^(self = aMagnitude) or: [self &lt; aMagnitude] <lb/>Magnitude&gt;&gt;&gt;= aMagnitude <lb/>^(self &lt; aMagnitude) not <lb/>So a subclass of Magnitude need only implement the two primitive operations and it gets the other <lb/>four operations for free. For example, Character assumes that characters are ASCII and so sorts <lb/>them into ASCII order. To do this, it uses a message that returns a character&apos;s ASCII value, such as <lb/>asciiValue. <lb/>Character&gt;&gt;= aCharacter <lb/>^(self asciiValue) = (aCharacter asciiValue) <lb/>Character&gt;&gt;&lt; aCharacter <lb/>^(self asciiValue) &lt; (aCharacter asciiValue) <lb/>Character <lb/>Object <lb/>= <lb/>~= &lt; <lb/>&gt; <lb/>&lt;= <lb/>&gt;= <lb/>Magnitude <lb/>Timestamp <lb/>Number <lb/></body>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>7 of 8 <lb/></page>

			<body>Thus the AbstractClass, Magnitude, greatly simplifies the implementation of the various <lb/>ConcreteClasses. In the sample operations shown here, implementing two messages gives the class <lb/>four more messages for free. <lb/>The AbstractClass also simplifies the interface that client code must understand. The client must <lb/>know that it is comparing two objects of the same subtype: two Characters or two Numbers, etc. <lb/>However, it need not care which subtype they are, because they all behave same. They all understand <lb/>the same six comparison messages. <lb/>One example of why this is useful is the way SortedCollection works. A Sorted-<lb/>Collection is a Collection that sorts its elements into order. By default, it assumes that its <lb/>elements are Magnitudes (of the same subtype) and it uses &lt;= to sort them into order. Thus it does <lb/>not care whether the elements are Characters, Numbers, or Timestamps; since they are all <lb/>Magnitudes, they will all work correctly. <lb/>Known Uses <lb/>Abstract Classes are so fundamental that they can be found in almost any multilevel class hierarchy. <lb/>In such a hierarchy, the superclasses are usually abstract; the leaf classes must be concrete. Object, <lb/>the root class for the entire Smalltalk hierarchy, is the ultimate Abstract Class in that language. In <lb/>Java, java.lang.Object serves the same purpose. When a class hierarchy is known by the class <lb/>at the root of the hierarchy (such as Number, Collection, Stream, Window, etc.), that class is almost <lb/>always an abstract class. <lb/>Almost every documented design pattern, such as those in Design Patterns [GHJV95], features one or <lb/>more Abstract Classes. Often the pattern suggests the creation of an Abstract Class if there isn&apos;t one <lb/>already. For example, Composite [GHJV95, page 163] uses the Component abstract class to define <lb/>the interface for both the Leaf and Composite classes. To apply Proxy [GHJV95, page 207] to a <lb/>RealSubject class, the developer should use the abstract class Subject to define the interface that the <lb/>RealSubject and its Proxy will share. When a pattern talks about a participant that &quot;defines an <lb/>interface&quot; [&quot;State,&quot; GHJV95, page 306] or &quot;declares an interface&quot; [&quot;Strategy,&quot; GHJV95, page 317] <lb/>for several subclasses, it is describing an Abstract Class. <lb/>Auer discusses how to develop class hierarchies that are reusable and extensible [Auer95]. He <lb/>suggests using a base class to define and interface and subclasses to implement state. <lb/>Related Patterns <lb/>Most design-level patterns employ abstract classes. Of the twenty-three patterns in Design Patterns, <lb/>twenty of them suggest implementing abstract classes (Singleton, Facade, and Memento do not). <lb/>[GHJV95] <lb/>An Abstract Class is usually implemented using Template Methods [GHJV95, page 325]. <lb/>Auer walks the reader through the process of developing a hierarchy whose interface is defined by an <lb/>abstract class. [Auer95] <lb/></body>

			<listBibl>References <lb/>[Auer95] Ken Auer. &quot;Reusability Through Self-Encapsulation.&quot; Pattern Languages of Program <lb/>Design. Edited by James Coplien and Douglas Schmidt. Addison-Wesley, 1995. <lb/>[GHJV95] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: <lb/>Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995. <lb/>[LW93] Barbara Liskov and Jeannette Wing. &quot;A New Definition of the Subtype Relation.&quot; <lb/>ECOOP &apos;93, Lecture Notes on Computer Science 707. Berlin, Heidelberg: Springer-<lb/>Verlag, 1993, pp. 118-141. <lb/></listBibl>

			<note place="headnote">The Abstract Class Pattern <lb/>Bobby Woolf <lb/></note>

			<note place="footnote">07/17/97 10:13 <lb/></note>

			<page>8 of 8 <lb/></page>

			<listBibl>[Meyer91] Bertrand Meyer. &quot;Design by Contract.&quot; Advances in Object-Oriented Software <lb/>Engineering. Edited by Dino Mandrioli and Bertrand Meyer. Prentice-Hall, 1991, pp. <lb/>1-50. <lb/>[WWW90] Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. Designing Object-<lb/>Oriented Software. Prentice Hall, 1990. <lb/>[Woolf97] Bobby Woolf. &quot;Polymorphic Hierarchy.&quot; The Smalltalk Report. January, 1997. 6(4). <lb/></listBibl>

			<div type="acknowledgement">Acknowledgments <lb/>I would like to thank Dana Anthony and Steve Berzcuk for their help in improving this paper. </div>


	</text>
</tei>
