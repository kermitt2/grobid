<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="_0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>On Hybrid Synthesis for Hierarchical Structured Petri Nets <lb/>Hong Liu Jun-Cheol Park Raymond E. Miller <lb/>Department of Computer Science <lb/>University of Maryland, College Park, MD 20742 <lb/>flhong, jcpark, millerg@cs.umd.edu <lb/>April 23, 1996 <lb/>Abstract <lb/>We propose a hybrid method for synthesis of hierarchical structured Petri nets. In a top-<lb/>down manner, we decompose a system into a set of subsystems at each level of abstraction, each <lb/>of these is speci ed as a blackbox Petri net that has multiple inputs and outputs. We stipulate <lb/>that each subsystem satis es the following I/O constraints: (1) At any instance of time, at <lb/>most one of the inputs can be activated; and (2) If one input is activated, then the subsystem <lb/>must consume the input and produce exactly one output within a nite length of time. We <lb/>give a stepwise re nement procedure which starts from the initial high-level abstraction of the <lb/>system and expands an internal place of a blackbox Petri net into a more detailed subnet at <lb/>each step. By enforcing the I/O constraints of each subsystem in each intermediate abstraction, <lb/>our re nement maintains the sequencing of transitions prescribed by the initial abstraction of <lb/>the system. Next, for the bottom-up synthesis, we present interconnection rules for sequential, <lb/>parallel, and loop structures and prove that each rule maintains the I/O constraints. Thus, by <lb/>incorporating these interconnection rules into our re nement formulation, our approach can be <lb/>regarded as a hybrid Petri net synthesis technique that employs both top-down and bottom-up <lb/>methods. The major advantage of the method is that the modeling details can be introduced <lb/>incrementally and naturally, while the important logical properties of the resulting Petri net are <lb/>guaranteed. <lb/>This research was supported by NASA Grant No. NAG 5-2648. <lb/>1 <lb/></front>

			<body>1 Introduction <lb/>Petri nets have been proposed for modeling and analyzing concurrent systems 3, 4, 6]. But, most <lb/>systems that arise from practical applications are very complex and practically unmanageable. <lb/>For this reason, modular construction methods provide a mechanism to manage the complexities <lb/>of a large system that can be built out of well understood smaller subsystems. One way to do <lb/>this is through Petri net synthesis based on some prescribed construction rules which preserve <lb/>certain logical properties as the construction progresses. Petri nets can be constructed in either <lb/>a top-down or a bottom-up manner. Top-down synthesis 7, 8, 10] usually begins with an initial <lb/>model of the system. Then, by expanding places or transitions, re nement is done in a stepwise <lb/>manner to incorporate a more detailed description of the system into the model. In the bottom-up <lb/>approaches 1, 2, 5, 9], a system is treated as the composition of independent subsystems which <lb/>satisfy certain properties. Each subsystem is modeled separately while ignoring interactions with <lb/>other subsystems. These subsystems are then combined through common places and/or transitions <lb/>into a larger subsystem at each synthesis step. The reader may refer to 11] for a detailed summary <lb/>with synthesis examples for such methods. <lb/>In this paper, a (sub)system at the current abstraction level is viewed as a blackbox with <lb/>multiple inputs and outputs that transforms input data into output data. For this purpose the set <lb/>of places of a net is divided into input places, output places, and internal places. The internal places <lb/>and the transitions are hidden from the outside. The only requirements for a net with multiple <lb/>inputs and outputs are the following I/O constraints: (1) At any instance of time, at most one of <lb/>the inputs can be activated; and (2) If one input is activated, then the subsystem must consume the <lb/>input and produce exactly one output within a nite length of time. Another implicit assumption <lb/>involves the initial state of a subsystem or module in which an input satisfying condition (1) is <lb/>applied. We call this condition (0): A subsystem is said to be in its quiescent state i no inputs are <lb/>activated, no outputs are produced, and no internal actions are enabled. The inputs to a subsystem <lb/>can be activated only when the subsystem is in its quiescent state. What we assume, then, is that <lb/>the subsystem is in a quiescent state initially. Then an input is applied. This causes some internal <lb/>actions in the subsystem which produces an output and a return of the subsystem to a quiescent <lb/>state. <lb/>We propose a hierarchical structuring technique for hybrid synthesis of Petri nets which model <lb/>subsystems with the above system behavior. The synthesis process is divided into two major phases <lb/>: (1) the top-down phase where designers decompose a system by using stepwise re nement of an <lb/>internal place at each step to introduce more detail until the desired level is reached, and (2) the <lb/>bottom-up phase where the appropriate interconnection among the decomposed subnets is added <lb/></body>

			<page>2 <lb/></page>

			<body>to the net at each decomposition step. Starting from the initial high-level abstraction of the system, <lb/>we show how stepwise re nement can be made so that the I/O constraints are enforced in a lower <lb/>level abstraction of the system. Using this approach, each intermediate abstraction maintains the <lb/>sequencing of transitions with respect to(w.r.t for short) the initial high-level description. For the <lb/>bottom-up synthesis, we propose a set of interconnection rules for the subsystems so that the I/O <lb/>constraints can be guaranteed when they are interconnected into a Petri net to represent sequence, <lb/>fork-join, and loop structures. As a result, our hybrid approach preserves logical properties such <lb/>as deadlock freedom, liveness, and boundedness while making it possible to represent several useful <lb/>structures among the subnets. <lb/>The paper is organized as follows. Section 2 brie y describes Petri net models, including some <lb/>basic de nitions and notation. Section 3 formalizes the stepwise re nement process and provides <lb/>properties of the Petri net for a given level of abstraction of the system. In section 4, we show how <lb/>incremental analysis can be performed and why logical properties are preserved during the stepwise <lb/>re nement process. In section 5, we present a set of interconnection rules with which we can <lb/>maintain the I/O constraints. In section 6, we present our hybrid procedure for Petri net synthesis. <lb/>In section 7, we give an automated manufacturing system to demonstrate the applicability of our <lb/>synthesis method. Section 8 gives a conclusion and future direction. The proofs of most lemmas <lb/>and theorems in section 4 are given in the appendix. <lb/>2 The Petri Net Model <lb/>We give the basic de nitions and notation to be used throughout the paper. The reader may refer <lb/>to 6] for a complete treatment of the subject. <lb/>A Petri net structure is a 3-tuple N = (P; T; F), where P is a nite set of places, T is a nite <lb/>set of transitions, and F (P T) (T P) is a set of arcs ( ow relations). Throughout the <lb/>paper, we assume that N is ordinary, i.e., the weight associated with each arc is one. The number <lb/>of places (transitions) in N is denoted as jPj (jTj). When N is given and F is known, we also <lb/>denote N = (P; T). As a convention, we use p for a place and t for a transition. We denote <lb/>t = fpj(p; t) 2 Fg as the set of input places of transition t and t = fpj(t; p) 2 Fg as the set of <lb/>output places of transition t. Let t = t t . <lb/>Let T be the re exive, transitive closure of T under concatenation. Given 2 T , denote j j <lb/>as the length of sequence . When is empty, = and j j = 0. Given T 0 T, we use #T 0 for <lb/>the projection of onto T 0 . <lb/>A marking M for N is a jPj-tuple which is an assignment of non-negative integers to places in <lb/>P. Given p 2 P and M, M(p) denotes the value assigned to p in M, meaning the number of tokens <lb/></body>

			<page>3 <lb/></page>

			<body>in place p in marking M. There is a special marking called the initial marking of N, denoted as <lb/>M 0 , indicating the initial assignment of tokens in each place. A Petri net N with the given initial <lb/>marking is denoted as PN = (N; M 0 ). Given P 0 P, we also use M(P 0 ) to denote the sub-vector <lb/>where each of its elements is the token count for a place in P 0 . <lb/>A Petri net can be drawn as a directed graph in which a place is represented by a circle, a <lb/>transition by a bar, and a token in a place as a bullet in the corresponding circle. <lb/>Given a marking M, a transition t is enabled in M i M(p) 6 = 0 for each p 2 t. t is red in <lb/>M i it is enabled in M and M is transformed into M 0 such that (i) 8 p 2 t : M 0 (p) = M(p) 1, <lb/>(ii) 8 p 2 t : M 0 (p) = M(p) + 1, and (iii) 8 p 6 2 t : M 0 (p) = M(p). In this case, M 0 is <lb/>directly reachable from M via t, denoted as M t &gt; M 0 . M 0 is directly reachable from M, denoted <lb/>as M &gt; M 0 , i M t &gt; M 0 for some t 2 T. Given 2 T , M 0 is reachable from M via , denoted <lb/>as M &gt; M 0 , i (i) M 0 = M when j j = 0, or (ii) = t 1 t 2 : : :t k ; k &gt; 0 and there exists a <lb/>sequence M 0 t 1 &gt; M 1 t 2 &gt; M k 1 t k &gt; M k such that M 0 = M and M k = M 0 . In this case, <lb/>is called a ring sequence from M to M 0 . M 0 is reachable from M, denoted as M &gt; M 0 , i <lb/>9 2 T : M &gt; M 0 . When M = M 0 , M 0 is reachable and is said to be a reachable marking in <lb/>(N; M 0 ), and is called a ring sequence of M. The set of reachable markings in (N; M 0 ) is denoted <lb/>as RM(N; M 0 ). The corresponding reachability graph is denoted as RG(N; M 0 ). In the following, <lb/>we will use a reachable marking M and the node labeled as M in RG(N; M 0 ) interchangeably. <lb/>Given a Petri net PN = (N; M 0 ), PN is bounded i RG(N; M 0 ) is nite, i.e., 9 K 0 such <lb/>that 8 M 2 RG(N; M 0 ) 8 p 2 P : M(p) K. In this case, we also say PN is K-bounded. PN is <lb/>safe i it is 1-bounded. PN is live (or M 0 is a live marking) i 8 M 2 RM(N; M 0 ) 8 t 2 T 9 M 0 2 <lb/>RM(N; M 0 ) : M &gt; M 0 and t is enabled in M 0 . A reachable marking M is a deadlock marking i <lb/>no transitions are enabled in M. <lb/>3 Modeling Systems via Petri Nets <lb/>In this section, we discuss a top-down decomposition approach where the behavior of a subsystem is <lb/>regarded as a black box with certain inputs and outputs. The notions of abstraction and re nement <lb/>are formalized. Then we show how Petri nets can be used to model the system at each abstraction <lb/>level. <lb/>3.1 System Decomposition <lb/>A system can be modeled from top-down: the system is decomposed into subsystems; then each <lb/>subsystem is further decomposed into sub-subsystems, etc. Depending on the complexity of the <lb/>system under study and the level of detail desired for the analysis, this process may continue for <lb/></body>

			<page>4 <lb/></page>

			<body>several iterations until no further decompositions are necessary. The hierarchical structure of the <lb/>system can be depicted by a tree, called a structure tree of the system, denoted as ST. Each node <lb/>in ST has a label J, standing for a subsystem of the system. In particular, the root of ST (labeled <lb/>as R) represents the whole system, while a leaf node in ST stands for a subsystem without further <lb/>decompositions. Figure 1 shows a hierarchical decomposition of a system and the corresponding <lb/>structure tree. For each nonleaf node in ST, its children are its component subsystems through one <lb/>step decomposition. Depending on how a system is decomposed during the modeling process, the <lb/>corresponding ST might not be unique. In the following discussion, we assume one such tree has <lb/>been constructed. For simplicity, when we talk about a structure tree, we mean it is a structure <lb/>tree of the system under study, unless otherwise explicitly speci ed. <lb/> System <lb/>Subsys1 <lb/>Subsys2 <lb/>Subsys11 Subsys12 Subsys13 <lb/>Subsys121 <lb/>Subsys122 <lb/>J <lb/>J <lb/>J 2 <lb/>13 <lb/>J <lb/>J <lb/>J <lb/>122 <lb/>121 <lb/>12 <lb/> J 1 <lb/>11 <lb/>R <lb/>Figure 1: A Hierarchical Decomposition of a System and its Structure Tree <lb/>The set of leaf nodes in ST, denoted as LN, represents the level of abstraction at which we view <lb/>the system under study. Hence, LN is called an abstraction of the system. Each J 2 LN stands for <lb/>a subsystem at the current level of abstraction. We start modeling the system at a relatively high <lb/>level of abstraction, i.e., the system consists of only a few subsystems. Then we specify the set of <lb/>properties the overall system is supposed to have as the speci cation of the system&apos;s behavior. The <lb/>set of properties includes deadlock freedom, liveness, observational equivalence, and nite duration. <lb/>The initial structure tree is denoted as ST 0 . The corresponding set of leaf nodes is called the initial <lb/>abstraction of the system, denoted as LN 0 . From now on, we will be working with abstractions <lb/>only. It should be clear, however, when we refer to an abstraction LN, we mean that it is the set <lb/>of leaf nodes w.r.t some structure tree for the system under study. <lb/>Given two abstractions LN and LN 0 , LN 0 is called a one-step re nement of LN, denoted as <lb/>LN LN 0 , i LN 0 = (LN n fJg) fJ 1 ; J 2 ; : : :; J k g; k 2, where fJ 1 ; J 2 ; : : :; J k g is the set of <lb/>component subsystems of J via one step decomposition. In other words, let ST and ST 0 be the <lb/>corresponding structure trees of LN and LN 0 , respectively. ST is expanded into ST 0 by appending <lb/></body>

			<page>5 <lb/></page>

			<body>to a leaf node J in ST with k 2 new leaf nodes J 1 ; J 2 ; : : :; J k . Denote as the re exive, <lb/>transitive closure of . LN 0 is a re nement of LN i LN <lb/>LN 0 . When LN = LN 0 , we <lb/>simply say LN 0 is a re nement. Denote RF as the set of abstractions that are re nements, i.e., <lb/>RF = fLNjLN 0 LNg. In the rest of the paper, we will be working with abstractions in <lb/>RF only. Unless otherwise speci ed, when we refer to an abstraction LN, we mean that it is a <lb/>re nement of the initial abstraction LN 0 . <lb/>Note that the high level of sequencing that exists among the leaf nodes in LN 0 is an essential <lb/>part of the system speci cation that we are interested in. As re nements are made, we desire, in <lb/>some sense, to maintain this basic sequencing as speci ed in LN 0 , even though more details unfold <lb/>and considerable parallelism may arise in a lower level of abstraction represented as LN. <lb/>Given an abstraction LN, a subsystem J in LN is speci ed as a black box with m 1 inputs and <lb/>n 1 outputs, as depicted in Figure 2. We stipulate that J satis es the following I/O conditions: <lb/>A1: At any instance of time, at most one of the m inputs can be activated. <lb/>A2: At any instance of time, at most one of the n outputs can be produced. <lb/>A3: Given an input, J must produce exactly one of the n outputs within a nite length of time. <lb/>Since we assume the quiescent state of J as the prerequisite before an input satisfying A1 is applied, <lb/>we say that J satis es the I/O conditions A1 through A3 if A1 implies A2 and A3. <lb/>n outputs <lb/>m inputs <lb/>Subsystem J <lb/>---<lb/>---<lb/>p out <lb/>n <lb/>p in <lb/>1 <lb/>out <lb/>1 <lb/>out <lb/>n <lb/>out <lb/>m <lb/>p in <lb/>p <lb/>---<lb/>p out <lb/>out <lb/>t <lb/>t <lb/>in <lb/>---<lb/>1 <lb/>t <lb/>t <lb/>int <lb/>t <lb/>in <lb/>2 <lb/>t <lb/>p <lb/>in <lb/>p <lb/>m <lb/>2 <lb/>in <lb/>in <lb/>2 <lb/>1 <lb/>2 <lb/>Figure 2: Subsystem I/O Interface and Blackbox Petri Net Model <lb/>3.2 Petri Nets for Abstractions <lb/>We model the system behavior w.r.t abstraction LN by a Petri net N = (P; T) as follows. Each sub-<lb/>system J 2 LN is modeled as a subnet BN J = (BP J ; BT J ) of N, called the blackbox Petri net of J. <lb/>See Figure 2. Suppose J has m inputs and n outputs, the corresponding BN J consists of ve parts: <lb/></body>

			<page>6 <lb/></page>

			<body>(1) m input places BP in <lb/>J = fp 1 in ; p 2 in ; : : :; p m in g, (2) m input transitions BT in <lb/>J = ft 1 in ; t 2 in ; : : :; t m in g, (3) <lb/>one internal place p int J , (4) n output transitions BT out <lb/>J = ft 1 out ; t 2 out ; : : :; t n out g, and (5) n output places <lb/>BP out <lb/>J = fp 1 out ; p 2 out ; : : :; p n out g. Hence BP J = BP in <lb/>J <lb/>fp int J g BP out <lb/>J and BT J = BT in <lb/>J <lb/>BT out <lb/>J . The <lb/>interactions among subsystems in LN are modeled by interconnecting the blackbox Petri nets of <lb/>the subsystems via additional places and transitions in N, denoted as XP and XT, respectively. <lb/>As a result, for Petri net N, we have P = ( S <lb/>J 2LN BP J ) XP and T = ( S <lb/>J 2LN BT J ) XT. When <lb/>J is known and no confusion arises, we drop J from the above notations. <lb/>Speci cally, the Petri net for LN 0 is denoted as N 0 = (P 0 ; T 0 ), called the initial Petri net of <lb/>the system under study. A marking in N 0 is denoted as M0. The initial marking of N 0 is denoted <lb/>as M0 0 . <lb/> Note that since we are modeling a subsystem as a Petri net, the phrase \at any instance of <lb/>time&quot; in A1{A2 becomes \in each reachable marking&quot;, while the phrase \within a nite length of <lb/>time&quot; in A3 becomes \within a nite number of steps&quot; (from the current marking). <lb/>Given an abstraction LN, let N be the corresponding Petri net. We conduct reachability <lb/>analysis for N based on some initial marking M 0 . Denote RG(N; M 0 ) as the resulting reachability <lb/>graph. We check that the following conditions hold for RG(N; M 0 ): <lb/>B1: RG(N; M 0 ) is nite. <lb/>B2: M 0 (p int ) = 0 for each BN in N. <lb/>B3: For each reachable marking M, for each blackbox Petri net BN in N with m inputs <lb/>and n outputs, the following two conditions hold: (1) 8 i 2 1::m] : M(p i in ) 1. (2) If <lb/>9 i 2 1::m] : M(p i in ) = 1, then 8 j 2 1::m]; j 6 = i : M(p j in ) = 0. <lb/>In the analysis of N, by enforcing B2{B3, we make sure that the precondition A1 is satis ed for <lb/>each subsystem J 2 LN. By construction of BN, it is straightforward that conditions A2{A3 hold <lb/>for J at abstraction level LN provided that B2{B3 hold in RG(N; M 0 ). <lb/>In the rest of this section, we study the properties of RG(N; M 0 ). Unless otherwise speci ed, <lb/>we assume that RG(N; M 0 ) satis es conditions B1{B3 in the rest of this paper. <lb/>Lemma 3.1 Suppose M 1 &gt; M 2 in RG(N; M 0 ). The following statements are true: (1) If j #BTj = <lb/>0, then M 2 (p int ) = M 1 (p int ). (2) Suppose = t i in 0 , where j 0 #BTj = 0. Then each transition in 0 <lb/>is independent of t i in . (3) If j #BT out j = 0, then j #BT in j 1. (4) If j #BT out j = 0, then j #BT in j = 0 i <lb/>M 2 (p int ) = M 1 (p int ). <lb/>Lemma 3.2 Suppose M 2 is reachable from M 1 via in RG(N; M 0 ), where M 1 (p int ) = 0. Let <lb/>k = j #BT out j. Then k j #BT in j k + 1. Furthermore, M 2 is reachable from M 1 in RG(N; M 0 ) via <lb/>= 0 1 k k+1 such that the following four conditions hold: (1) j 0 #BTj = 0. (2) 8 l 2 1::k] : <lb/>l = 0 <lb/>l x l y l , where x l is the l-th transition from BT in in , y l is the l-th transition from BT out in , <lb/></body>

			<page>7 <lb/></page>

			<body>and j 0 <lb/>l #BTj = 0. (3) j k+1 #BT out j = 0. (4) #(T nBT) = #(T nBT). <lb/> An execution sequence from M 1 to M 2 is called a canonical execution sequence w.r.t BN i <lb/>it satis es conditions (1){(4) in Lemma 3.2. When M 1 = M 0 , it is called a canonical execution <lb/>sequence for reachable marking M 2 w.r.t BN. Since M 0 (p int ) = 0, any execution sequence for a <lb/>reachable marking M can be rewritten into its canonical form w.r.t BN. As a result, we have the <lb/>following theorem: <lb/>Theorem 3.1 Let M be a marking in RG(N; M 0 ). The following statements are true for each <lb/>J 2 LN: <lb/>(1) M is reachable in RG(N; M 0 ) via a canonical execution sequence w.r.t BN J . <lb/>(2) For each execution sequence of M, j #BT out <lb/>J j j #BT in <lb/>J j j #BT out <lb/>J j + 1. <lb/>(3) M(p int J ) = 0 i there is an execution sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j. <lb/>(4) M(p int J ) = 1 i there is an execution sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j + 1. <lb/>(5) M(p int J ) 1. <lb/>(6) 8 p2BP out <lb/>J :M(p) 1. If 9 p2BP out <lb/>J :M(p) = 1, then 8 p 0 2BP out <lb/>J ; p 0 6 = p:M(p 0 ) = 0. <lb/>In fact, we can prove the following more general result. <lb/>Lemma 3.3 Suppose M 1 &gt; M 2 in RG(N; M 0 ). Then the following statements are true: <lb/>(1) Assume M 1 (p int ) = 0. M 2 (p int ) = 0 i j #BT in j = j #BT out j. <lb/>(2) Assume M 1 (p int ) = 0. M 2 (p int ) = 1 i j #BT in j = j #BT out j + 1. <lb/>(3) M 2 (p int ) = M 1 (p int ) i j #BT in j = j #BT out j. <lb/>4 Incremental Analysis of Petri Nets <lb/>Given two abstractions LN and LN 0 . Let N = (P; T) and N 0 = (P 0 ; T 0 ) be the Petri nets of <lb/>N and N 0 , respectively. Suppose LN LN 0 by decomposing J 2 LN into k 2 components <lb/>J 1 ; J 2 ; : : :; J k . Assume that J has m inputs and n outputs, and J l ; l 2 1::k], has m l input and n l <lb/>output. Let BN be the blackbox Petri net for J, and BN J l be the blackbox Petri net for J J l . We <lb/>show how N 0 can be constructed from N so that the properties that hold for N will be preserved <lb/>in N 0 . The construction of N 0 from N takes two steps. We rst construct a detailed Petri net for <lb/>J, then we expand N into N 0 by replacing p int of BN in N with the detailed Petri net for J. <lb/>4.1 Petri Net Expansion <lb/>The detailed Petri net for J is called the whitebox Petri net for J, denoted as WN J = (WP J ; WT J ). <lb/>Speci cally, WN J consists of three parts: (1) m input places, denoted as WP in <lb/>J = fq 1 <lb/>in ; q 2 <lb/>in ; : : :; q m <lb/>in g. <lb/></body>

			<page>8 <lb/></page>

			<body>(2) An internal Petri net IN J = (IP J ; IT J ) constructed by interconnecting the blackbox Petri nets <lb/>BN J 1 ; BN J 2 ; : : :; BN J k via some additional places and transitions. (3) n output places, denoted <lb/>as WP out <lb/>J = fq 1 <lb/>out ; q 2 <lb/>out ; : : :; q n <lb/>out g. Denote EP J and ET J as the set of additional places and the set <lb/>of additional transitions in IN J , respectively. For IN J , we have IP J = ( S k l=1 BP J l ) EP J and <lb/>IT J = ( S k l=1 BT J l ) ET J . For WN J , we have WP J = WP in <lb/>J IP J WP out <lb/>J and WT J = IT J . When <lb/>J is known and no confusion arises, we drop J from the above notations. <lb/>Given the whitebox Petri net WN of J, a quiescent marking IQ of IN is an assigment of <lb/>tokens to IP such that no transition in IT is enabled in IQ. Given a quiescent marking IQ, <lb/>the null marking of WN, denoted as WM 0 <lb/>0 IQ] is an assignment of tokens to WP such that <lb/>8p 2 WP in WP out : WM 0 <lb/>0 (p) = 0 and WM 0 <lb/>0 IQ](IP) = IQ, and the i-th initial marking of <lb/>WN w.r.t IQ, denoted as WM i <lb/>0 IQ]; i 2 1::m], is an assignment of tokens to WP satisfying the <lb/>following three conditions: (1) 8 l 2 1::m] : WM i <lb/>0 IQ](q l <lb/>in ) = 1 if l = i; WM i <lb/>0 IQ](q l <lb/>in ) = 0 <lb/>otherwise. (2) WM i <lb/>0 IQ](IP) = IQ. (3) 8 l 2 1::n] : WM i <lb/>0 IQ](q l <lb/>out ) = 0. A j-th exit marking of <lb/>WN w.r.t IQ, denoted as WM j <lb/>ext IQ], is an assignment of tokens to WP satisfying the following <lb/>three conditions: (1) 8 l 2 1::m] : WM j <lb/>ext IQ](q l <lb/>in ) = 0. (2) 8 l 2 1::n] : WM j <lb/>ext IQ](q l <lb/>out ) = 1 if <lb/>l = j; WM j <lb/>ext IQ](q l <lb/>out ) = 0 otherwise. (3) WM j <lb/>ext IQ](IP) = IQ 0 , where IQ 0 is also a quiescent <lb/>state of IN. Note that there might be more than one exit marking satisfying condition (1){(3), <lb/>each of which has a di erent IQ 0 . <lb/>Let S be a nonempty set of quiescent markings of IN. S is closed i 8 IQ 2 S : 8 i 2 1::m] : <lb/>8 j 2 1::n] : 9 IQ 0 2 S : WM i <lb/>0 IQ] &gt; WM j <lb/>ext IQ 0 ]. A quiescent marking IQ is closed i it belongs <lb/>to some closed quiescent marking set. <lb/>Gniven a closed quiescent marking IQ of IN, the analysis for WN takes m phases. In the i-th <lb/>phase, we construct the reachability graph RG(WN; WM i <lb/>0 ) based on the i-th initial marking WM i <lb/>0 <lb/>w.r.t IQ. (In the rest of this section, we omit IQ from the notation when no confusion arises, for <lb/>the sake of brevity.) We check that the following properties hold in RG(WN; WM i <lb/>0 ): <lb/>W1: 8 j 2 1::n]: there exists at least one reachable j-th exit marking of WN, and for each exit <lb/>marking WM j <lb/>ext , WM j <lb/>ext (IP) is also a closed quiescent marking of IN. <lb/>W2: RG(WN; WM i <lb/>0 ) is nite and there is no reachable marking that is not an exit marking <lb/>and has no outgoing transitions in RG(WN; WM i <lb/>0 ). <lb/>W3: Each reachable marking WM in RG(WN; WM i <lb/>0 ) satis es the following two conditions <lb/>for each BN J l ; l 2 1::k], in WM: (1) 8 i 2 1::m l ] : WM(p i in l ) 1. (2) if 9 i 2 1::m l ] : <lb/>WM(p i in l ) = 1, then 8 j 2 1::m l ]; j 6 = i : WM(p j in l ) = 0. <lb/>By de nition, we have WM i <lb/>0 (p int J l ) = 0 for each l 2 1::k]. By W2, RG(WN; WM i <lb/>0 ) is nite. <lb/>W3 ensures that A1 is preserved in each subsystem BN J l . Therefore, RG(WN; WM i <lb/>0 ) also satis es <lb/>properties B1{B3. As a result, properties in Theorem 3.1 also hold for RG(WN; WM i <lb/>0 ). For ease <lb/></body>

			<page>9 <lb/></page>

			<body>of reference, we list them as a theorem below: <lb/>Theorem 4.1 For each i 2 1::m], let WM i be a marking in RG(WN; WM i <lb/> 0 ). The following <lb/>statements are true for each BN J l ; l 2 1::k]: <lb/>(1) WM i is reachable in RG(WN; WM i <lb/>0 ) via a canonical ring sequence w.r.t BN J l . <lb/>(2) For each ring sequence of WM i , j #BT out <lb/>J l j j #BT in <lb/>J l j j #BT out <lb/>J l j + 1. <lb/>(3) WM i (p int J l ) = 0 i there is a ring sequence for WM i such that j #BT in <lb/>J l j = j #BT out <lb/>J l j. <lb/>(4) WM i (p int J l ) = 1 i there is a ring sequence for WM i such that j #BT in <lb/>J l j = j #BT out <lb/>J l j + 1. <lb/>(5) WM i (p int J l ) 1. <lb/>(6) 8 p 2 BP out <lb/>J l : WM i (p) 1. If 9 p 2 BP out <lb/>J l : WM i (p) = 1, then 8 p 0 2 BP out <lb/>J l ; p 0 6 = p : <lb/>WM i (p 0 ) = 0. <lb/> We remark that the setting of IQ for IN in WN is not as simple as just setting all the places <lb/>in IN to have zero tokens. Rather, it depends on the interconnections of the k blackbox Petri nets <lb/>in IN, where the real test is to check that whether IQ is a closed quiescent marking of IN. Note <lb/>that IQ being a closed quiescent marking of IN implies that WM j <lb/>ext (IP) is also a closed quiescent <lb/>marking of IN for each exit marking WM j <lb/>ext in RG(WN; WM i <lb/>0 ). Note also that there might exist <lb/>a cycle in RG(WN; WM i <lb/>0 ). To preserve A3 in WN, we also need to assume that the system will <lb/>not stay in a cycle inde nitely. <lb/>Once WN is built and analyzed, we plug in WN for p int of BN in N to construct N 0 via the <lb/>following steps: <lb/>Step 1: Initially, set N 0 as N. <lb/>Step 2: Delete p int and all its input and output transitions from N 0 . <lb/>Step 3: For each input place q i <lb/>in ; i 2 1::m], of WN, direct an edge from t i in to q i <lb/>in . <lb/>Step 4: For each output place q i <lb/>out ; i 2 1::n], of WN, direct an edge from q i <lb/>out to t i out . <lb/>Step 5: Output N 0 . End of procedure. <lb/>Figure 3 shows the portion of N 0 resulting from substituting WN for p int in BN of Figure 2. <lb/>By construction, we have P 0 = (P n fp int g) WP and T 0 = T WT in N 0 . The initial marking <lb/>of N 0 , denoted as M 0 <lb/>0 , is an assignment of tokens to P 0 such that (1) M 0 <lb/>0 (P nfp int g) = M 0 (P nfp int g), <lb/>(2) 8 i 2 1::m] : M 0 <lb/>0 (q i <lb/>in ) = 0, (3) M 0 <lb/>0 (IP) is a closed quiescent marking in IN, and (4) 8 j 2 1::n] : <lb/>M 0 <lb/>0 (q j <lb/>out ) = 0. Hence 8 J 0 2 LN 0 : M 0 <lb/>0 (p int J 0 ) = 0. Hence no transition of WT is enabled in M 0 <lb/>0 . The <lb/>reachability graph for N 0 and M 0 <lb/>0 is denoted as RG(N 0 ; M 0 <lb/>0 ). <lb/>N 0 is called the one-step re nement of N (via the expansion of J in N), denoted as N N 0 . <lb/>N 00 is a re nement of N i N N 00 . The set of Petri nets that are re nements of N 0 is denoted <lb/>as PN, i.e., PN = fNjN 0 Ng. As for abstractions, we are only interested in Petri nets that <lb/></body>

			<page>10 <lb/></page>

			<body>(detailed PN for J) <lb/>Whitebox Petri Net <lb/>p <lb/>in <lb/>1 <lb/>p <lb/>in <lb/>2 <lb/>p <lb/>in <lb/>m <lb/>p <lb/>out <lb/>1 <lb/>p <lb/>out <lb/>2 <lb/>p <lb/>out <lb/>n <lb/>in <lb/>1 <lb/>q <lb/>in <lb/>2 <lb/>q <lb/>in <lb/>m <lb/>q <lb/>out <lb/>1 <lb/>q <lb/>out <lb/>2 <lb/>q <lb/>out <lb/>n <lb/>q <lb/>t 1 <lb/>out <lb/>t out <lb/>2 <lb/>t out <lb/>n <lb/>t 1 <lb/>in <lb/>t in <lb/>2 <lb/>t in <lb/>m <lb/>J <lb/>J 2 <lb/>J <lb/>J <lb/>1 <lb/>k <lb/>---<lb/>Internal Petri Net <lb/>Figure 3: One-Step Decomposition of J and its corresponding Petri Net Expansion <lb/>are re nements of N 0 . From now on, when we refer to a Petri net N, we mean N 2 PN, unless <lb/>otherwise speci ed. <lb/>In the following subsection, we are going to study the set of properties in RG(N; M 0 ) that are <lb/>preserved in RG(N 0 ; M 0 <lb/>0 ). Unless otherwise speci ed, we assume RG(WN; WM i <lb/>0 ) satis es W1{W3 <lb/>for each i 2 1::m] and WM i <lb/>0 (IP) is a closed quiescent marking of IN. <lb/>4.2 Property Preservation <lb/>Lemma 4.1 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) and j #(BT WT)j =0. Then M 0 <lb/>2 (WP) = M 0 <lb/>1 (WP). <lb/>If 9 M 1 2 RG(N; M 0 ) : M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g), then 9 M 2 2 RG(N; M 0 ) : M 1 &gt; M 2 such <lb/>that M 2 (P nfp int g)=M 0 <lb/>2 (P nfp int g) and M 2 (p int )=M 1 (p int ). <lb/>Lemma 4.2 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 , M 0 <lb/>0 ) such that j #BT out j = 0. If 9 M 1 2 RG(N; M 0 ) : <lb/>M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g), then 9 M 2 2 RG(N; M 0 ) such that M 1 #T &gt; M 2 and M 2 (P nfp int g) = <lb/>M 0 <lb/>2 (P nfp int g). Hence j #BT in j 1. <lb/>Lemma 4.3 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) such that the following conditions hold: (a) <lb/>M 0 <lb/>1 (WP) = WM 0 <lb/>0 . (b) 9 M 1 2 RG(N; M 0 ) : M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g). (c) = t i in 0 t j out , <lb/>where t i in 2 BT in , t j out 2 BT out , and j 0 #BT out j = 0. Then the following statements are true: (1) <lb/></body>

			<page>11 <lb/></page>

			<body>j 0 #BT in j = 0. (2) M 0 <lb/>1 <lb/>t i in t j out &gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where = 0 #WT is a ring sequence from WM i <lb/>0 <lb/>to WM j <lb/>ext and = 0 n = 0 #(T 0 n (BT WT)). (3) M 0 <lb/>2 (WP) = WM 0 <lb/>0 . (4) 9 M 2 2 RG(N; M 0 ) such <lb/>that M 1 #T &gt; M 2 , M 2 (P nfp int g) = M 1 (P nfp int g), and M 2 (p int ) = M 1 (p int ). <lb/>We show that each ring sequence in RG(N 0 ; M 0 <lb/>0 ) has a corresponding canonical sequence similar <lb/>to the one in Lemma 3.2. <lb/>Lemma 4.4 Suppose M 0 <lb/>2 is reachable from M 0 <lb/>1 via in RG(N 0 ; M 0 <lb/>0 ) such that M 0 <lb/>1 (WP) = WM 0 <lb/>0 . <lb/>Suppose also that 9 M 1 2 RG(N; M 0 ) such that M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g). Let k = j #BT out j. <lb/>Then k j #BT in j k + 1. Furthermore, M 0 <lb/>2 is reachable from M 0 <lb/>1 in RG(N 0 ; M 0 <lb/>0 ) via = <lb/>0 1 <lb/>k k+1 such that the following four conditions are satis ed: (1) j 0 #(BT WT)j = 0. (2) <lb/>8 l 2 1::k] : l = x l l y l 0 <lb/>l , where (a) x l is the l-th transition from BT in in , denoted as x l = t i in ; i 2 <lb/>1::m]; (b) y l is the l-th transition from BT out in , denoted as y l = t j out ; j 2 1::n]; (c) l is a ring <lb/>sequence from WM i <lb/>0 to WM j <lb/>ext in RG(WN; M i <lb/>0 ); and (d) j 0 <lb/>l #(T 0 n (BT WT))j = 0. (3) k+1 #BT out = . <lb/>(4) #(T 0 n(BT WT)) = #(T 0 n(BT WT)). <lb/>Lemma 4.5 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where M 0 <lb/>1 (WP) = WM 0 <lb/>0 . Then M 0 <lb/>2 (WP) = <lb/>WM 0 <lb/>0 i j #BT in j = j #BT out j. <lb/>A ring sequence from M 0 <lb/>1 to M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) is called a canonical ring sequence w.r.t <lb/>WN i M 0 <lb/>1 (WP) = WM 0 <lb/>0 and conditions (1){(4) in Lemma 4.4 hold for . When M 0 <lb/>1 = M 0 <lb/>0 , <lb/>is called a canonical ring sequence for reachable marking M 0 <lb/>2 . Since M 0 <lb/>0 (WP) = WM 0 <lb/>0 , the <lb/>above Lemma 4.4 and Lemma 4.5 hold for any ring sequence for any reachable marking M 0 in <lb/>RG(N 0 ; M 0 <lb/>0 ). As a result, we have the following theorem: <lb/>Theorem 4.2 Let M 0 be a marking in RG(N 0 ; M 0 <lb/>0 ). The following statements are true: <lb/>(1) M 0 is reachable in RG(N 0 ; M 0 <lb/>0 ) via a canonical ring sequence w.r.t WN. <lb/>(2) j #BT out j j #BT in j j #BT out j + 1 for each ring sequence of M 0 . <lb/>(3) M 0 (P nfp int g) = WM 0 <lb/>0 i there is a ring sequence of M 0 such that j 0 #BT in j = j 0 #BT out j <lb/>We rst show that RG(N 0 ; M 0 <lb/>0 ) does not introduce any \extra&quot; ring sequences whose projec-<lb/>tions onto T are not in RG(N; M 0 ). <lb/>Lemma 4.6 Suppose M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where M 0 <lb/>1 (WP) = WM 0 <lb/>0 . If 9 M 1 2 RG(N; M 0 ) <lb/>such that M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g) and M 1 (p int ) = 0, then 9 M 2 2 RG(N; M 0 ) : M 1 &gt; M 2 <lb/>such that M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g) and = 0 #T. <lb/>Next, we show RG(N 0 ; M 0 <lb/>0 ) preserves all the ring sequences in RG(N; M 0 ). <lb/></body>

			<page>12 <lb/></page>

			<body>Lemma 4.7 Suppose M 1 &gt; M 2 in RG(N; M 0 ), where M 1 (p int ) = 0. If 9 M 0 <lb/>1 2RG(N 0 ; M 0 <lb/>0 ) such <lb/>that M 0 <lb/>1 (P nfp int g) = M 1 (P nfp int g) and M 0 <lb/>1 (WP) = WM 0 <lb/>0 , then 9 M 0 <lb/>2 2RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>2 <lb/>such that M 0 <lb/>2 (P nfp int g) = M 2 (P nfp int g) and 0 #T = . <lb/>Notice that M 0 (P nfp int g) = M 0 <lb/>0 (P nfp int g), M 0 (p int ) = 0, and M 0 <lb/>0 (IP) = IM 0 . Denote ES = <lb/>f j9 M 2 RG(N; M 0 ) : M 0 &gt; Mg, ES 0 = f 0 j9 M 0 2 RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/>0 <lb/>0 &gt; M 0 g, and ES 0 #T = <lb/>f 0 #Tj 0 2 ES 0 g. By Lemma 4.6 and Lemma 4.7, we obtain the most important result of the <lb/>re nement process : the Sequence Preservation Theorem. <lb/>Theorem 4.3 (Sequence Preservation) Suppose M is reachable in RG(N; M 0 ) via , then there <lb/>is an M 0 reachable via 0 in RG(N 0 ; M 0 <lb/>0 ) such that M 0 (P nfp int g) = M(P nfp int g) and 0 #T = . <lb/>Conversely, suppose M 0 is reachable via 0 in RG(N 0 ; M 0 <lb/>0 ), then there is an M reachable via in <lb/>RG(N; M 0 ) such that M(P nfp int g) = M 0 (P nfp int g) and = 0 #T. As a result, ES = ES 0 #T. <lb/>By this powerful theorem, we can show that RG(N 0 ; M 0 <lb/>0 ) maintains the set of properties in <lb/>RG(N; M 0 ) as stated in the following theorem: <lb/>Theorem 4.4 Given Petri nets N N 0 . Let RG(N; M 0 ) and RG(N 0 ; M 0 <lb/>0 ) be the corresponding <lb/>reachability graphs of N and N 0 , respectively. The following statements are true: <lb/>Deadlock: RG(N; M 0 ) is deadlock free i RG(N 0 ; M 0 <lb/>0 ) is deadlock free. <lb/>Liveness: A transition t 2 T is live in RG(N; M 0 ) i it is live in RG(N 0 ; M 0 <lb/>0 ). <lb/>Input Constraint: RG(N 0 ; M 0 <lb/>0 ) satis es B3. <lb/>Boundedness: RG(N 0 ; M 0 <lb/>0 ) is bounded i RG(N; M 0 ) is bounded. <lb/>Since RG(N; M 0 ) satis es B1{B3, by de nition of M 0 <lb/>0 , RG(N 0 ; M 0 <lb/>0 ) satis es B2. From the above <lb/>theorem, we know that B2{B3 are also true for RG(N 0 ; M 0 <lb/>0 ). As a result, RG(N 0 ; M 0 <lb/>0 ) maintains <lb/>conditions B1{B3 of RG(N; M 0 ) after the re nement of N into N 0 . Therefore, Theorem 3.1 is also <lb/>true for RG(N 0 ; M 0 <lb/> 0 ). <lb/>Theorem 4.5 Let M be a marking in RG(N 0 ; M 0 <lb/>0 ). The following statements are true for each <lb/>J 0 2 LN 0 : <lb/>(1) M 0 is reachable in RG(N 0 ; M 0 <lb/>0 ) via a canonical ring sequence w.r.t BN J 0. <lb/>(2) For each ring sequence of M 0 , j #BT out <lb/>J 0 j j #BT in <lb/>J 0 j j #BT out <lb/>J 0 j + 1. <lb/>(3) M 0 (p int J 0 ) = 0 i there is a ring sequence for M 0 such that j #BT in <lb/>J 0 j = j #BT out <lb/>J 0 j. <lb/>(4) M 0 (p int J 0 ) = 1 i there is a ring sequence for M 0 such that j #BT in <lb/>J 0 j = j #BT out <lb/>J 0 j + 1. <lb/>(5) M 0 (p int J 0 ) 1. <lb/>(6) 8 p2BP out <lb/>J 0 :M(p) 1. If 9 p2BP out <lb/>J 0 :M 0 (p)=1, then 8 p 0 2BP out <lb/>J 0 ; p 0 6 = p:M(p 0 )=0. <lb/></body>

			<page>13 <lb/></page>

			<body>Recall that N 0 is the initial Petri net for the system under study and M0 0 is the initial marking <lb/>of N 0 . Assume RG(N 0 ; M0 0 ) satis es B1{B3. Based on the results established so far, by induction <lb/>on the number of re nement steps, we are able to show that 8 N 2 PN : RG(N; M 0 ) preserves the <lb/>set of properties of RG(N 0 ; M0 0 ) as stated by the following theorem. <lb/>Theorem 4.6 8 N : N 0 N, the following statements are true: <lb/>Firing Sequence: ES 0 = ES#T 0 . <lb/>Deadlock: RG(N; M 0 ) is deadlock free i RG(N 0 ; M0 0 ) is deadlock free. <lb/>Liveness: A transition t 2 T 0 is live in RG(N; M 0 ) i it is live in RG(N 0 ; M0 0 ). <lb/>Input Constraint: RG(N; M 0 ) satis es B3. <lb/>Boundedness: RG(N; M 0 ) is bounded i RG(N 0 ; M0 0 ) is bounded. <lb/>Therefore, RG(N; M 0 ) also satis es conditions B1{B3. As a result, Theorem 4.5 also hold for <lb/>RG(N; M 0 ). <lb/>Theorem 4.7 8 N : N 0 N, let M be a marking in RG(N 0 ; M 0 <lb/>0 ). The following statements are <lb/>true for each J 2 LN: <lb/>(1) M is reachable in RG(N; M 0 ) via a canonical ring sequence w.r.t BN J . <lb/>(2) For each ring sequence of M, j #BT out <lb/>J j j #BT in <lb/>J j j #BT out <lb/>J j + 1. <lb/>(3) M(p int J ) = 0 i there is a ring sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j. <lb/>(4) M(p int J ) = 1 i there is a ring sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j + 1. <lb/>(5) M(p int J ) 1. <lb/>(6) 8 p2BP out <lb/>J :M(p) 1. If 9 p2BP out <lb/>J :M 0 (p)=1, then 8 p 0 2BP out <lb/>J ; p 0 6 = p:M(p 0 )=0. <lb/> 5 Interconnection Rules <lb/>We discuss a set of interconnection rules with which we can provide substantial parallelism while <lb/>maintaining the I/O constraints A1 through A3. These are for sequential, parallel, and loop <lb/>structures. For each structure, we provide or specify the inputs and outputs of the interconnected <lb/>system and a procedure to connect the subsystems. Note that each structure is also a subsystem <lb/>itself in the sense that it has multiple inputs and outputs and can be used as a building block when <lb/>we construct a larger structure. <lb/> De nition 5.1 Given an interconnected system J = fJ 1 ; : : :; J k g; k 1, each input or output of <lb/>J m 2 J is said to be either bounded w.r.t J i it is connected to some input or output of J n 2 J or <lb/>free w.r.t J i it is not bounded w.r.t J, i.e., it is not connected to any input or output of J. Note <lb/>that each place in a Petri net N i can be classi ed as either bounded or free with respect to N, since <lb/></body>

			<page>14 <lb/></page>

			<body>we are modeling a subsystem J i as a Petri net N i . Let P Xin <lb/>i <lb/>be the set of free input places of N i <lb/>and P Xout <lb/>i <lb/>be the set of free output places of N i . <lb/>5.1 Sequential Structure <lb/>Assume there are k 2 subsystems J i , modeled by N i = (P i ; T i ) , 1 i k, with m i inputs and <lb/>n i outputs, respectively. We interconnect these subsystems in sequential order such that the ring <lb/>sequence for the interconnected system J = J 1 J 2 : : : J k should be of the form J l ; : : :; J m , where <lb/>1 l m k. Let a Petri net modeling the system be N = (P; T), where P = ( k i=1 P i ) S XP and <lb/>T = ( k i=1 T i ) S XT. The ring sequence for J = J 1 J 2 : : : J k should be of the form J l ; : : :; J m , <lb/>where 1 l m k. For example, the possible ring sequences for the execution ow diagrams <lb/>in Figure 4 are J i 1 ; (J i 1 ; J i ); (J i 1 ; J i ; J i+1 ); J i , and (J i ; J i+1 ) for (a) and (J i 1 ; J i ; J i+1 ) for (b), <lb/>respectively. <lb/>J i-1 <lb/>J i <lb/>J i+1 <lb/>J i-1 <lb/>J i <lb/>J i+1 <lb/>(a) <lb/>--<lb/>--<lb/>--<lb/>--<lb/>(b) <lb/>--<lb/>--<lb/>--<lb/>--<lb/>Figure 4: Sequential Execution Flow Diagrams <lb/>Let Q be the nonempty set of bounded output places in N i and R be the nonempty set of <lb/>bounded input places in N i+1 . To associate Q with R, we need a set of transitions T. The arcs <lb/>from Q to T and from T to R are generated by the following two mappings: <lb/>De nition 5.2 A pair of mappings (f; g) is C(concatenation)-applicable with respect to (Q; R) i <lb/>there exists a nonempty set of transitions T such that f : Q ! T and g : T ! R satisfy the <lb/>properties : (i) domain(f) = Q, range(g) = R, (ii) if f(q i ) = t and f(q j ) = t, then q i = q j , and <lb/>(iii) if g(t) = p i and g(t) = p j , then p i = p j . <lb/></body>

			<page>15 <lb/></page>

			<body>N <lb/>N <lb/>i <lb/>i+1 <lb/>N 1 <lb/>N k <lb/>N <lb/>N j <lb/>i <lb/>: <lb/>: <lb/>: <lb/>Inputs <lb/>Outputs <lb/>--<lb/>---<lb/>--<lb/>--<lb/>---<lb/>Figure 5: A Concatenation using a C-applicable pair and a Sequential Structure <lb/>Now, we give a sequential construction procedure based on C-applicable pairs: <lb/>Sequential(J 1 ; : : :; J k ) : <lb/>1. (Input) Let the input places of N be P in <lb/>1 S ( k i=2 P Xin <lb/>i ). <lb/>2. For each i; 1 i &lt; k, do the following: <lb/>Devise a set of transitions T i;i+1 such that there exists a C-applicable pair (f i ; g i ) with <lb/>respect to (P out <lb/>i nP Xout <lb/>i <lb/>; P in <lb/>i+1 nP Xin <lb/>i+1 ). <lb/>Generate arcs from P out <lb/>i nP Xout <lb/>i <lb/>to T i;i+1 and from T i;i+1 to P in <lb/>i+1 nP Xin <lb/>i+1 according to <lb/>(f i ; g i ). <lb/>3. (Output) Let the output places of N be P out <lb/>k <lb/>S ( k 1 <lb/>i=1 P Xout <lb/>i <lb/>). <lb/>De nition 5.3 A set of places P 0 = fp 1 ; : : :; p n g; P 0 P, is singly-activated in a reachable marking <lb/>M in N = (P; T) i there exists a place p i 2 P 0 such that M(p i ) = 1 and M(p j ) = 0 for all <lb/>p j 6 = p i ; p j 2 P 0 . <lb/>Lemma 5.1 Let J = J i J i+1 , where the bounded output places of N i are associated with the <lb/>bounded input places of N i+1 by a transition set T and a C-applicable pair (f; g). If the bounded <lb/>output places of N i , Q = fq 1 ; : : :; q n g, is singly-activated in a reachable marking M in N = N i N i+1 , <lb/>then there exists one and only one enabled transition t in T, and furthermore, by ring t, the <lb/>bounded input places of N i+1 , P = fp 1 ; : : :; p m g, becomes a singly-activated set of places in M 0 , <lb/>where M t &gt; M 0 . <lb/></body>

			<page>16 <lb/></page>

			<body>Proof. Let t = f(q i ), where M(q i ) = 1. Note that f(q i ) should be de ned by (i). Then, by our <lb/>construction, there is an arc from q i to t and no arc goes to t from other than q i in Q by (ii). Since <lb/>q i is the only input place to the transition t and M(q i ) = 1, t is the only enabled transition in T in <lb/>M. By ring t, we have the marking M 0 , i.e., M t &gt; M 0 . Now, by (iii), we can guarantee that P <lb/>is singly-activated in M 0 . <lb/>Theorem 5.1 Any sequential structure J = J 1 : : : J k resulting from the procedure Sequential <lb/>preserves A1 through A3 provided that each of the subsystems J 1 ; : : :; J k satis es A1 through A3. <lb/>Proof. It su ces to show that two subsystems J i and J i+1 are interconnected into J = J i J i+1 <lb/>by Sequential(J i ; J i+1 ) while preserving the properties A1 through A3. Then the theorem easily <lb/>follows from the induction on k. By our construction, the inputs and the outputs of J would be <lb/>P in <lb/>i P Xin <lb/>i+1 and P Xout <lb/>i <lb/>P out <lb/>i+1 , respectively. Assume that at most one of the input places P in <lb/>i P Xin <lb/>i+1 <lb/>can be activated at any instance of time. We deal with A2 rst. Suppose P Xin <lb/>i+1 and P Xout <lb/>i <lb/>are <lb/>empty, then J preserves the property since J i+1 satis es A2 under the assumption that J i+1 guar-<lb/>antees A1, which is clear from Lemma 5.1. If P Xout <lb/>i <lb/>is nonempty, then either (i) at most one of the <lb/>P out <lb/>i+1 places is produced by the same argument as above or (ii) at most one of the P Xout <lb/>i <lb/>places is <lb/>produced. By A2 of J i , it is clear that (i) and (ii) are exhaustive and mutually exclusive. Suppose <lb/>P Xin <lb/>i+1 is nonempty. Then, by A1 of J and Lemma 5.1, A1 of J i+1 is preserved. Thus A2 of J i+1 <lb/>establish A2 of J. For A3, we know that J should produce an output within at most j i j+j i+1 j+1 <lb/>steps, where j k j; k = i; i + 1 is the maximum number of steps required for N k to reach a marking <lb/>in which one and only one output of N k is produced from an initial marking in which one of the <lb/>inputs of N k is activated. <lb/>5.2 Parallel Structure <lb/>Assume there are k 2 subsystems J i , modeled by N i = (P i ; T i ) , 1 i k, with m i inputs and n i <lb/>outputs, respectively. We interconnect these subsystems in parallel such that J i &apos;s can be executed <lb/>concurrently. Denote the interconnected system J = J 1 kJ 2 k : : :kJ k and a Petri net modeling the <lb/>system N = (P; T), where P = ( S k i=1 P i ) S XP and T = ( S k i=1 T i ) S XT. It should be clear that <lb/>a parallel structure can be regarded as a set of subsystems whose inputs and outputs are all free. <lb/>Therefore we only have to provide selectors for inputs and outputs to enforce A1, A2, and A3 of <lb/>the interconnected system. <lb/>We give a parallel construction procedure with which we can preserve A1 through A3. <lb/>Parallel(J 1 ; : : :; J k ) : <lb/></body>

			<page>17 <lb/></page>

			<body>1. (Input/Output) Generate input places Q = fq 1 ; : : :; q m i g of N. Also, generate corresponding <lb/>transitions T in = ft 1 in ; : : :; t m i <lb/>in g and arcs A = f(q i ; t i in )j1 i Q k i=1 m i g connecting Q <lb/>to T in . Generate output places Q 0 = fq 0 <lb/>1 ; : : :; q 0 <lb/>n i g of N. Also, generate corresponding <lb/>transitions T out = ft 1 out ; : : :; t n i <lb/>out g and arcs A 0 = f(t i out ; q 0 <lb/>i )j1 i Q k i=1 n i g connecting T out <lb/>to Q 0 . <lb/>2. Let (p i;1 <lb/>in ; : : :; p i;m i <lb/>in ) and (p i;1 <lb/>out ; : : :; p i;n i <lb/>out ) be the input places and the output places of J i , 1 <lb/>i k, respectively. Let X = f(p 1;x(1) <lb/>in ; : : :; p k;x(k) <lb/>in )j1 x(i) m(i); 1 i kg and Y = <lb/>f(p 1;y(1) out ; : : :; p k;y(k) out )j1 y(i) n(i); 1 i kg be their input and output combinations, <lb/>respectively. <lb/>Devise a bijection f : T in ! X. <lb/>For each t i in 2 T in , generate k arcs (t i in ; p 1; in ); (t i in ; p 2; in ); : : :; (t i in ; p k; in ) ,where f(t i in ) = <lb/>(p 1; <lb/>in ; p 2; <lb/>in ; : : :; p k; <lb/>in ). <lb/>Devise a bijection g : Y ! T out . <lb/>For each t i out 2 T out , generate k arcs (p 1; out ; t i out ); (p 2; out ; t i out ); : : :; (p k; out ; t i out ) ,where g((p 1; out , <lb/>p 2; <lb/>out ; : : :; p k; <lb/>out )) = t i out . <lb/>---<lb/>---<lb/>N <lb/>N <lb/>N <lb/>1 <lb/>2 <lb/>k <lb/>---<lb/>---<lb/>---<lb/>Inputs <lb/>Outputs <lb/>--<lb/>--<lb/>--<lb/>--<lb/>--<lb/>--<lb/>Figure 6: Parallel Structure <lb/>Theorem 5.2 Any parallel construction J = J 1 k : : :kJ k resulting from the procedure Parallel <lb/>preserves A1 through A3 provided that each of the subsystems J 1 ; : : :; J k satis es A1 through A3. <lb/></body>

			<page>18 <lb/></page>

			<body>Proof. Suppose two input places of N are activated at a certain marking of N. Then, by our <lb/>construction step 2, there exists at least one subnet, say N i , which has more than one activated <lb/>thread by ring the two transitions associated with the two input places of N. For A2, J preserves <lb/>it by our construction of g and the assumption that J 1 ; ; J k satisfy A2. For A3, we know that J <lb/>should produce an output within P k i=1 j i j+2 steps, where j i j; 1 i k, is the maximum number <lb/>of steps required for N i to reach a marking in which one and only one output of N i is produced <lb/>from an initial marking in which one of the inputs of N i is activated. <lb/>5.3 Loop Structure <lb/>Assume there are k 2 subsystems J i , modeled by N i = (P i ; T i ) , 1 i k, with m i inputs <lb/>and n i outputs, respectively. We interconnect these subsystems to generate a loop which simulates <lb/>the repeated executions of the subsystem(s). Denote the interconnected system J = (J 1 J 2 <lb/>: : : J k ) and a Petri net modeling the system N = (P; T), where P = ( S k i=1 P i ) S XP and <lb/>T = ( S k i=1 T i ) S XT. <lb/>De nition 5.4 Given a set of subsystems J = fJ 1 ; : : :; J k g; k 1, and a subsystem J i in J, J i is <lb/>said to be an exit w.r.t J i some outputs of J i are free w.r.t J. Note that a Petri net N i is an exit <lb/>w.r.t N i there are some free output places in P i w.r.t N, since we are modeling a subsystem as <lb/>a Petri net. <lb/>Since an in nite looping does not make sense, we assume that a loop has the following property <lb/>to enforce a nite number of repetitions of it. <lb/>Proposition 5.1 A loop structure J is said to have the fairness property i it has at least one <lb/>exit J i such that after a nite number of transition rings, J i produces a free output w.r.t. J. <lb/>We give a loop construction procedure with which we can preserve A1 through A3. The con-<lb/>struction is based on the sequential construction in section 5.1. <lb/>Loop(J 1 ; : : :; J k ) : <lb/>1. (Input) Generate input places Q = fq 1 ; : : :; q jP in <lb/>1 S ( k i=2 P Xin <lb/>i )j g of N. Also, generate cor-<lb/>responding transitions T in = ft 1 in ; : : :; t jP in <lb/>1 S ( k i=2 P Xin <lb/>i )j <lb/>in <lb/>g and arcs A = f(q i ; t i in )j1 i <lb/>jP in <lb/>1 S ( k i=2 P Xin <lb/>i )jg connecting Q to T in . To trigger the execution of N initially, we need the <lb/>arcs A trigger connecting T in to the places P in <lb/>1 <lb/>S ( k i=2 P Xin <lb/>i ) in one-to-one manner. <lb/>2. Call Sequential(J 1 ; : : :; J k ). <lb/></body>

			<page>19 <lb/></page>

			<body>---<lb/>---<lb/>--<lb/>N <lb/>N <lb/>N <lb/>1 <lb/>i <lb/>j <lb/>k <lb/>N <lb/>: <lb/>: <lb/>Inputs <lb/>Outputs <lb/>---<lb/>---<lb/>--<lb/>: <lb/>--<lb/>Figure 7: Loop Structure <lb/>3. Generate arcs connecting some of the outputs of J 1 : : : J k to N 1 as follow: <lb/>Let the output places of the sequential structure J 1 : : : J k resulting from the step 2 <lb/>be P out <lb/>seq . Choose a set of places P back P out <lb/>seq . Note that the places in P back , if any, will <lb/>be connected to the input places of J 1 . <lb/>if P back is empty, then goto step 4. <lb/>Devise a set of transitions T k;1 such that there exists a C-applicable pair (f k ; g k ) with <lb/>respect to (P back ; P in <lb/>1 ). <lb/>Generate arcs from P back to T k;1 and from T k;1 to P in <lb/>1 according to (f k ; g k ). <lb/>4. (Output) Let the output places of N be P out <lb/>seq nP back . <lb/>Theorem 5.3 Assume that Proposition 5.1 holds. Then any loop construction J = (J 1 J 2 <lb/>: : : J k ) resulting from the procedure Loop preserves A1 through A3 provided that each of the <lb/>subsystems J 1 ; : : :; J k satis es A1 through A3. <lb/>Proof. By our construction, the inputs J would be Q = fq 1 ; : : :; q jP in <lb/>1 S ( k i=2 P Xin <lb/>i )j g. Assume that <lb/>at most one of the input places can be activated at any instance of time. Then, by the arcs A trigger , <lb/>there are at most one activated place in P in <lb/>1 S ( k i=2 P Xin <lb/>i ) at any instance of time. Suppose the <lb/>system produces a certain output in a reachable marking of N. Then the output must be from a <lb/>certain exit, say, N x . Since the procedure Loop is based on the procedure Sequential, no concurrent <lb/></body>

			<page>20 <lb/></page>

			<body>execution of more than one stream is possible. Thus, we know that J satis es A2 provided J x does. <lb/>It should be clear that any exit with the fairness property can be used as the real exit through <lb/>which J escapes the loop. For A3, it is straightforward that J will eventually produce an output <lb/>within a nite length of time by Proposition 5.1. <lb/>6 Procedure for Petri Net Synthesis <lb/>A method for constructing a Petri in a top-down manner is given using the proposed hierarchical <lb/>structuring technique in the initial stages of construction and in a bottom-up manner by intercon-<lb/>necting the blackbox Petri nets according to the rules in section 5. <lb/>Synthesis Procedure <lb/>1. Decompose a Petri net model of a system into several subsystems. According to the method <lb/>in section 3 and 4, decompose each subsystem until further re nement is not necessary. <lb/>2. Appropriately interconnect the blackbox Petri nets at each stage of decomposition according <lb/>to the rules in section 5. <lb/>It should be noted that each decomposition and the interconnection among the subcomponents can <lb/>be applied alternately. <lb/>7 An Example <lb/>The system consists of a raw material storage, two robots, four machines, and an assembly cell. <lb/>It rst generates two parts A and B from common raw material, and then assembles these parts <lb/>pair by pair to produce a nal product. An A(B) part is rst processed by machine 1(2), then <lb/>it moves to and is processed by machine 3(4). Loading from the raw material storage to machine <lb/>1(2) is automatically executed. Machine unloading and transfer operations are done by robot 1(2). <lb/>Finally, the assembly process is conducted with the help of robot 1 and robot 2. <lb/>We assume that 1) the supply of raw material is limited and the availability of the raw material <lb/>can be determined at any time during the system execution; 2) the nished product will be taken <lb/>away immediately. <lb/>The net in Figure 9(a) is chosen as the initial abstraction of the system. It is easy to show that <lb/>the net satis es the I/O constraints and is bounded and deadlock-free. Figure 9(b), (c), (d), and (e) <lb/>describe the subsequent re nements for the generation of parts A and B, and then a nal product. <lb/>After removing meaningless places and transitions introduced during the decomposition processes, <lb/></body>

			<page>21 <lb/></page>

			<body>Machine 3 <lb/>Machine 4 <lb/>Assembly <lb/>Cell <lb/>Part A <lb/>Part B <lb/>Final Product <lb/>Exit <lb/>Machine 1 <lb/>Machine 2 <lb/>Robot 2 <lb/>Robot 1 <lb/>Storage <lb/>Raw Material <lb/>Figure 8: A Simple Automated Manufacturing System <lb/>we have the nal Petri net model of the system in Figure 10 ,which is bounded and deadlock-free <lb/>and preserves the liveness of the transitions in the initial net. <lb/>8 Conclusion <lb/>We presented a hybrid Petri net synthesis method combining top-down and bottom-up techniques. <lb/>The proposed method uses a top-down method to expand an internal place of a blackbox Petri net <lb/>at each step of abstraction, then, at each abstraction level, uses a bottom-up method to interconnect <lb/>the resulting blackbox subnets into sequential, parallel, or loop structures. Using this approach, the <lb/>resulting Petri net preserves logical properties of the initial Petri net in terms of deadlock freedom, <lb/>liveness, and boundedness. By this approach, the usual necessary costly reachability analysis for <lb/>the nal Petri net can be avoided and replaced by a much simpler reachability analysis of only the <lb/>highest level Petri net. <lb/>We are considering applications to space mission operations, where the Petri net would be used <lb/>to analyze the overall correctness of sequencing operations. A simple example of this approach, <lb/>along with an object oriented technology is given in 12]. The example in section 7 illustrates how <lb/>the approach might be useful for manufacturing systems. <lb/>We believe that this approach allows many behaviors to be modeled naturally by introducing <lb/>multiple inputs/outputs along with the I/O constraints. A generalization of the I/O constraints, <lb/>however, might be necessary to manage large and complex systems that come from practical ap-<lb/>plications. <lb/></body>

			<listBibl>References <lb/>1] T. Agerwala and Y. Choed-Amphai A Synthesis Rule for Concurrent Systems Proc. 15th <lb/></listBibl>

			<page>22 <lb/></page>

			<body>p0 <lb/>p1 <lb/>p2 <lb/>p3 <lb/>p4 <lb/>t0 <lb/>t3 <lb/>t4 <lb/>t1 <lb/>t2 <lb/>p6: processing part A and part B <lb/>p9: assembling <lb/>t5 <lb/>p13 <lb/>p14 <lb/>p15 <lb/>p16 <lb/>p17 <lb/>p19 <lb/>p21 <lb/>t10 <lb/>t12 <lb/>t13 <lb/>t6 <lb/>Box1 <lb/>p22 <lb/>p10: availability of R1 <lb/>p11: availability of R2 <lb/>t8 <lb/>t9 <lb/>p31 <lb/>p32 <lb/>p16: M1, M3, and R1 working <lb/>p19: M2, M4, and R2 working <lb/>t12 <lb/>t13 <lb/>p23 <lb/>p24 <lb/>p26 <lb/>p27 <lb/>p29 <lb/>p30 <lb/>p24: M1 machining a raw material <lb/>p25: availability of M1 <lb/>p26: R1 unloading M1 <lb/>p27: M3 machining an intermediate A-part <lb/>p28: availability of M3 <lb/>p29: R1 unloading M3 and moving the part to <lb/>p10 <lb/>p25 <lb/>p28 <lb/>p10 <lb/>p11 <lb/>p5 <lb/>t1 <lb/>p9 <lb/>t6 <lb/>t8 <lb/>t2 <lb/>p6 <lb/>p7 <lb/>p8 <lb/>p12 <lb/>t5 <lb/>t7 <lb/>t9 <lb/>p10 <lb/>p11 <lb/>Box0 <lb/>p31: R1 and R2 assembling A part and B part <lb/>p32: R1 and R2 moving the final product to the <lb/>output area <lb/>assembly <lb/>(d) After the expansion of Box1 in (c) <lb/>(e) After the expansion of Box0 in (b) <lb/>and transferring intermediate A-part <lb/>p20 <lb/>t14 <lb/>t15 <lb/>t16 <lb/>t17 <lb/>p18 <lb/>t11 <lb/>t18 <lb/>t19 <lb/>t20 <lb/>t21 <lb/>t22 <lb/>t23 <lb/>(a) Initial Abstraction (loop) <lb/>(b) 2nd Step(sequence) <lb/>(c) 3rd Step(parallel structure) <lb/>p0 : start p4: finish <lb/>p1: availability of raw material <lb/>p2: processing(to be refined) <lb/>p3: checking raw material <lb/>t3 : delivery of raw material <lb/>if there is enough to make <lb/>part A and part B <lb/>t4: complement of t3 <lb/>Figure 9: Modeling Process <lb/></body>

			<page>23 <lb/></page>

			<body>p33: M2 machining a raw material <lb/>p34: availability of M2 <lb/>p35: R2 unloading M2 and transferring <lb/>intermediate B-part <lb/>p36: M4 machining an intermediate B-part <lb/>p37 <lb/>p38: R2 unloading M4 and moving the part <lb/>to assembly <lb/>: availability of M4 <lb/>p24 <lb/>p25 <lb/>p10 p11 <lb/>p26 <lb/>p27 <lb/>p28 <lb/>p29 <lb/>p32 <lb/>p15 <lb/>p18 <lb/>p17 <lb/>p20 <lb/>p31 <lb/>p0 <lb/>p1 <lb/>p33 <lb/>p34 <lb/>p35 <lb/>p36 <lb/>p37 <lb/>p38 <lb/>All transitions represent the start or end of operations. <lb/>p4 <lb/>p3 <lb/>t3 <lb/>t4 <lb/>Figure 10: The Final Petri net Model of the System <lb/></body>

			<page>24 <lb/></page>

			<listBibl>Design Automation Conference, pp. 305-311, June 1978. <lb/>2] B. H. Krogh and C. L. Beck Synthesis of Place/Transition nets for Simulation and Control of <lb/>Manufacturing Systems Proc. IFIP Symp. Large Scale Systems, pp. 661-666, August 1986. <lb/>3] D. Y. Chao, M. C. Zhou and D. T. Wang Extending the Knitting Techniques to Petri net <lb/>Synthesis of Automated Manufacturing Systems The Computer Journal, vol. 37, no. 1, pp.67-<lb/>76, 1994. <lb/>4] T. Murata Petri nets: Properties, Analysis, and Applications Proc. IEEE, vol. 77, pp. 541-579, <lb/>April 1989. <lb/>5] I. Koh and F. DiCesare Modular Transformation Methods for Generalized Petri nets and their <lb/>Applications in Manufacturing Automation IEEE Trans. Sys.,Man,Cybern., vol. 21, pp. 963-<lb/>973, 1991. <lb/>6] J. L. Peterson Petri nets Computing Surveys, vol. 9, no. 3, pp. 223-252, September 1977. <lb/>7] R. Valette Analysis of Petri net by Stepwise Re nement J. Comput. Syst. Sci., vol. 18, pp. <lb/>35-46, 1979. <lb/>8] I. Suzuki and T. Murata A Method for Stepwise Re nement and Abstraction of Petri nets J. <lb/>Comput. Syst. Sci., vol. 27, pp. 51-76, 1983. <lb/>9] M. C. Zhou and F. DiCesare Parallel and Sequential Mutual Exclusions for Petri net Modeling <lb/>of Manufacturing Systems with Shared Resources IEEE Trans. Robotics Automat., vol. 7, pp. <lb/>515-527, 1991. <lb/>10] M. C. Zhou and F. DiCesare A Hybrid Methodology for Synthesis of Petri nets for Manufac-<lb/>turing Systems IEEE Trans. Robotics Automat., vol. 8, pp. 350-361, 1992. <lb/>11] M. D. Jeng and F. DiCesare A Review of Synthesis Techniques for Petri nets with Applications <lb/>to Automated Manufacturing Systems IEEE Trans. Sys.,Man,Cybern., vol. 23, pp. 301-312, <lb/>1993. <lb/>12] D. J. Hei, R. S. Hornstein, H. Liu, F. J. LoPinto and R. E. Miller &quot;Faster, Better, Cheaper&quot; <lb/>Mission Operations Employing a Reusable Object Methodology Proc. 9th AIAA/Utah State <lb/>Univ. Conference on Small Satellites, September 1995. <lb/></listBibl>

			<page>25 <lb/></page>

			<div type="annex">Appendix: Proofs of Lemmas and Theorems <lb/>Lemma 3.1 Suppose M 1 &gt; M 2 in RG(N; M 0 ). The following statements are true: <lb/>(1) If j #BTj = 0, then M 2 (p int ) = M 1 (p int ). <lb/>(2) Suppose = t i in 0 , where j 0 #BTj = 0. Then each transition in 0 is independent of t i in . <lb/>(3) If j #BT out j = 0, then j #BT in j 1. <lb/>(4) If j #BT out j = 0, then j #BT in j = 0 i M 2 (p int ) = M 1 (p int ). <lb/>Proof: (1): j #BTj = 0 implies that no transition in can a ect place p int during the execution. <lb/>Thus M 2 (p int ) = M 1 (p int ). <lb/>(2): We show it by induction on k = j 0 j 1. Denote t 1 = t i in . <lb/>Basis: k = 1. Let 0 = t 2 . Suppose t 1 and t 2 are not independent, then t 1 \ t 2 6 = ;. There are <lb/>four cases to consider: <lb/>t 1 \ t 2 6 = ;. In this case, we have t 1 = t 2 . This implies that M 1 (p i in ) &gt; 1, which violates <lb/>property B3 of RG(N; M 0 ). <lb/>t 1 \ t 2 6 = ;. In this case, we have t 2 = t k in . If k = i, then M 1 (p i in ) &gt; 1; otherwise M 1 (p i in ) 6 = 0 <lb/>and M 1 (p k in ) 6 = 0. Either case violates property B3 of RG(N; M 0 ). <lb/>t 1 \ t 2 6 = ;. In this case, t 2 is also executable in M 1 . Executing t 2 in M 1 will result in a <lb/>marking M 2 in which M 2 (p i in ) &gt; 1. This will violate property B3 of RG(N; M 0 ). <lb/>t 1 \ t 2 6 = ;. In this case, we have t 2 = t k out , which is impossible since j 0 #BTj = 0. <lb/>Therefore, we must have t 1 \ t 2 = ;, i.e., t 1 and t 2 are independent. <lb/>Induction: Suppose (2) is true for k = k 0 1. We want to show for k = k 0 +1. Denote 0 = t 2 00 <lb/>and M 1 t 1 &gt; M 3 t 2 &gt; M 4 00 &gt; M 2 . Then from the proof of the base case, we know that t 1 and t 2 <lb/>are independent, i.e., M 1 t 2 &gt; M 5 t 1 &gt; M 4 . Hence M 5 t 1 00 &gt; M 2 . By induction hypothesis, each <lb/>transition in 0 is independent of t 1 . Hence (2) also holds for k = k 0 + 1. <lb/>Therefore, (2) holds for all k 1. <lb/>(3): By contradiction. Without loss of generality, suppose j #BT in j = 2. Denote = 0 t i in 1 t j in 2 , <lb/>where t i in ; t j in 2 BT in . Then 8 l 2 0::2] : j l #BTj = 0. By (2), t i in is independent of any tran-<lb/>sition in 1 . As a result, M 2 is also reachable from M 1 via 0 1 t i in t j in 2 in RG(N; M 0 ). Denote <lb/>M 1 0 1 &gt; M 3 t i in &gt; M 4 t j in 2 &gt; M 2 . Then t i in is enabled in M 3 and t j in is enabled in M 4 . On the <lb/>other hand, since RG(N; M 0 ) satis es B3, we have M 3 (p i in ) = 1 and 8 l 2 1::m]; l 6 = i : M 3 (p l in ) = 0. <lb/>No matter i = j or not, we have M 4 (p j in ) = 0. In other words, t j in is disabled in M 4 . A contradiction. <lb/>Therefore, j #BT in j 1. <lb/></div>

			<page>26 <lb/></page>

			<div type="annex">(4): Suppose j #BT in j = 0. Then j #BTj = 0. From (1), we have M 2 (p int ) = M 1 (p int ). On the <lb/>other hand, suppose j #BT in j 6 <lb/>= 0. Then from (3), we have j #BT in j = 1. Let t i in ; i 2 1::m], be the <lb/>transition from BT in in . Then the execution of t i in will add one more token to p int . However, no <lb/>other transition in can delete a token from p int . As a result, we must have M 2 (p int ) = M 1 (p int )+1, <lb/>i.e., M 2 (p int ) 6 = M 1 (p int ). <lb/>Lemma 3.2 Suppose M 2 is reachable from M 1 via in RG(N; M 0 ), where M 1 (p int ) = 0. Let <lb/>k = j #BT out j. Then k j #BT in j k + 1. Furthermore, M 2 is reachable from M 1 in RG(N; M 0 ) via <lb/>= 0 1 k k+1 such that the following four conditions hold: (1) j 0 #BTj = 0. (2) 8 l 2 1::k] : <lb/>l = 0 <lb/>l x l y l , where x l is the l-th transition from BT in in , y l is the l-th transition from BT out in , <lb/>and j 0 <lb/>l #BTj = 0. (3) j k+1 #BT out j = 0. (4) #(T nBT) = #(T nBT). <lb/>Proof: Since M 1 (p int ) = 0, by the structure of BN, there must be at least k input transitions <lb/>of BN in , and for each l 2 1::k], the l-th input transition of BN must occur before the the l-th <lb/>output transition of BN in . By Lemma 3.1 (3), can be written as 0 1 k k+1 such that (1&apos;) <lb/>j 0 #BTj = 0. (2&apos;) 8 l 2 1::k] : l = x l 0 <lb/>l y l , where x l is the l-th transition from BT in in , y l is the <lb/>l-th transition from BT out in , and j 0 <lb/>l #BT out j = 0. (3&apos;) j k+1 #BT out j = 0. Let l range from 1::k]. By <lb/>Lemma 3.1 (3), j 0 <lb/>l #BTj = 0 and j k+1 #BT in j 1. Thus k j #BT in j k + 1. <lb/>Denote M 1 0 &gt; M 3 1 &gt; M 4 M k+2 k &gt; M k+3 k+1 &gt; M 2 , where 8 l 2 1::k] : M l+2 l &gt; <lb/>M l+3 . Let l = 0 <lb/>l x l y l , then by Lemma 3.1 (2), M l+2 l &gt; M l+3 in RG(N; M 0 ). Let = 0 1 k k+1 . <lb/>Then M 1 &gt; M 2 in RG(N; M 0 ). Clearly, satis es conditions (1){(4). <lb/> Theorem 3.1 Let M be a marking in RG(N; M 0 ). The following statements are true for each <lb/>J 2 LN: <lb/>(1) M is reachable in RG(N; M 0 ) via a canonical ring sequence w.r.t BN J . <lb/>(2) For each ring sequence of M, j #BT out <lb/>J j j #BT in <lb/>J j j #BT out <lb/>J j + 1. <lb/>(3) M(p int J ) = 0 i there is a ring sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j. <lb/>(4) M(p int J ) = 1 i there is a ring sequence for M such that j #BT in <lb/>J j = j #BT out <lb/>J j + 1. <lb/>(5) M(p int J ) 1. <lb/>(6) 8 p2BP out <lb/>J :M(p) 1. If 9 p2BP out <lb/>J :M(p) = 1, then 8 p 0 2BP out <lb/>J ; p 0 6 = p:M(p 0 ) = 0. <lb/>Proof: Let J be any node in LN. For simplicity, we drop the subscript J from the proof below. <lb/>Since M 0 (p int ) = 0, (1) and (2) of the theorem are true by Lemma 3.2. We only need to show <lb/>(3){(6) of theorem hold. <lb/>We rst show (3) and (4) of the theorem. From the proof of Lemma 3.2, any ring sequence <lb/>for M can be written as 0 1 k k+1 such that the following three conditions hold: (1&apos;) <lb/></div>

			<page>27 <lb/></page>

			<div type="annex"> j 0 #BTj = 0. (2&apos;) 8 l 2 1::k] : l = x l 0 <lb/>l y l , where x l is the l-th transition from BT in in , y l is the <lb/>l-th transition from BT out in , and j 0 <lb/>l #BTj = 0. (3&apos;) j k+1 #BT out j = 0. Denote 0 = 0 1 k . Then <lb/>j 0 #BT in j = j 0 #BT out j = k and j k+1 #BT in j 1. <lb/>Denote M 0 0 &gt; M 1 k+1 &gt; M. From (1) and (4) of Lemma 3.1, it is not di cult to show, by <lb/>induction on k, that M 1 (p int ) = M 0 (p int ) = 0. Thus, to show (3) of the theorem, it su ces to <lb/>show that M(p int ) = 0 i j k+1 #BT in j = 0. And this is true by (4) of Lemma 3.1. Similarly, since <lb/>j k+1 #BT in j 1, to show (4) of the theorem, it su ces to show that M(p int ) = 1 i j k+1 #BT in j = 1. <lb/>And this is obvious. As a result, we have M(p int ) 1, i.e., (5) of the theorem also holds. Note <lb/>that M 0 satis es (6). By induction on the length of a ring sequence for M, it is not di cult to <lb/>show that (6) holds for M. <lb/>Lemma 3.3 Suppose M 1 &gt; M 2 in RG(N; M 0 ). Then the following statements are true: <lb/>(1) Assume M 1 (p int ) = 0. M 2 (p int ) = 0 i j #BT in j = j #BT out j. <lb/>(2) Assume M 1 (p int ) = 0. M 2 (p int ) = 1 i j #BT in j = j #BT out j + 1. <lb/>(3) M 2 (p int ) = M 1 (p int ) i j #BT in j = j #BT out j. <lb/>Proof: We rst show (1) and (2) of the lemma. Suppose M 0 &gt; M 1 in RG(N; M 0 ). Then <lb/>by Theorem 3.1, we have j #BT in j = j #BT out j. Let = . Then M 2 is reachable from M 0 via <lb/>in RG(N; M 0 ). By Theorem 3.1, M 2 (p int ) = 0 i j #BT in j = j #BT out j. Thus, M 2 (p int ) = 0 i <lb/>j #BT in j = j #BT out j. Similarly, we can show (2) of the lemma also holds. <lb/>Now we show (3) of the lemma. From Theorem 3.1, we know that M 1 (p int ) 1. We have already <lb/>shown in (1) of the lemma that (3) holds when M 1 (p int ) = 0. For the case of M 1 (p int ) = 1, denote <lb/>= t j out , where t j out is the rst transition from BT out in . Denote M 0 0 &gt; M 1 t j out &gt; M 3 &gt; M 2 <lb/>and 00 = 0 t j out . Then by (2), we have j 0 #BT in j = j 0 #BT out j + 1. Hence we must have j #BT in j = 0, <lb/>i.e. j #BTj = 0. As a result, j 00 #BT in j = j 00 #BT out j. By (1), we have M 3 (p int ) = 0. From M 3 , by <lb/>(2), we know that M 2 (p int ) = 1 i j #BT in j = j #BT out j + 1. Therefore, (3) also holds for the case of <lb/>M 1 (p int ) = 1. <lb/>Lemma 4.1 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) and j #(BT WT)j =0. Then M 0 <lb/>2 (WP) = M 0 <lb/>1 (WP). <lb/>If 9 M 1 2 RG(N; M 0 ) : M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g), then 9 M 2 2 RG(N; M 0 ) : M 1 &gt; M 2 such <lb/>that M 2 (P nfp int g)=M 0 <lb/>2 (P nfp int g) and M 2 (p int )=M 1 (p int ). <lb/>Proof: Since j #(BT WT)j =0, it is straightforward that M 0 <lb/> 2 (WP) = M 0 <lb/>1 (WP). We show the rest <lb/>of the lemma by induction on k = j j. <lb/>Basis: k = 0. The rest of the lemma holds trivially. <lb/>Induction: Suppose the rest of the lemma holds for k = k 0 0. We want to show for k = k 0 +1. <lb/></div>

			<page>28 <lb/></page>

			<div type="annex">Denote = t 0 . Then 9 M 3 2 RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/>1 t &gt; M 0 <lb/>3 <lb/>0 &gt; M 0 <lb/>2 . Since t 6 2 BT WT, the execution <lb/>of t only a ects places in P n fp int g in M 0 <lb/>1 . As a result, let M 3 be the marking of N such that <lb/>M 3 (P nfp int g) = M 0 <lb/>3 (P nfp int g) and M 3 (p int ) = M 1 (p int ). Then M 3 is reachable from M 1 via t in <lb/>RG(N; M 0 ). Note that j 0 j = k 0 . By induction hypothesis, 9 M 2 2 RG(N; M 0 ) : M 3 &gt; 0 M 2 <lb/>such that M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g) and M 2 (p int ) = M 3 (p int ). Therefore, M 1 &gt; M 2 in <lb/>RG(N; M 0 ). The rest of the lemma holds for k = k 0 + 1. <lb/>Therefore, the rest of the lemma holds for all k 0. <lb/>Lemma 4.2 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 , M 0 <lb/>0 ) such that j #BT out j = 0. If 9 M 1 2 RG(N; M 0 ) : <lb/>M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g), then 9 M 2 2 RG(N; M 0 ) such that M 1 #T &gt; M 2 and M 2 (P nfp int g) = <lb/>M 0 <lb/>2 (P nfp int g). Hence j #BT in j 1. <lb/>Proof: We show the lemma by induction on h = j j. <lb/>Basis: h = 0. The lemma trivially holds. <lb/>Induction: Suppose the lemma holds for h = h 0 0. We want to show for h = h 0 +1. Denote = <lb/>t. Let M 0 <lb/>3 be the marking in RG(N 0 ; M 0 <lb/>0 ) such that M 0 <lb/>1 <lb/>&gt; M 0 <lb/>3 t &gt; M 0 <lb/>2 . By induction hypothesis, <lb/>there is a marking M 3 reachable from M 1 via 0 = #T in RG(N; M 0 ) such that M 3 (P nfp int g) = <lb/>M 0 <lb/>3 (P nfp int g). Note that t 6 2 BT out . Let M 2 be a marking of N such that M 2 (P nfp int g) = <lb/>M 0 <lb/>2 (P nfp int g). As for M 2 (p int ), depending on t, there are three cases to consider: (i) t 2 T n BT in . <lb/>t is also enabled in M 3 . Set M 2 (p int ) = M 3 (p int ). Then M 3 t &gt; M 2 . (ii) t 2 BT in . t is also enabled <lb/>in M 3 . Set M 2 (p int ) = M 3 (p int ) + 1. Then M 3 t &gt; M 2 . (iii) t 2 WT. t has no e ect on P. Set <lb/>M 2 (p int ) = M 3 (p int ). Then M 2 = M 3 . In all cases, we can nd a marking M 2 in RG(N; M 0 ) that is <lb/>either reachable from M 3 via t when t 2 T, or M 2 = M 3 when t 6 2 T. As a result, M 2 is reachable <lb/>from M 1 via #T in RG(N; M 0 ). Since j( #T)#BT out j = 0, by Lemma 3.1, we have j( #T)#BT in j 1, i.e., <lb/>j #BT in j 1. The lemma holds for h = h 0 + 1. <lb/> Therefore, the lemma holds for all h 0. <lb/>Lemma 4.3 Suppose M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) such that the following conditions hold: (a) <lb/>M 0 <lb/>1 (WP) = WM 0 <lb/>0 . (b) 9 M 1 2 RG(N; M 0 ) : M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g). (c) = t i in 0 t j out , <lb/>where t i in 2 BT in , t j out 2 BT out , and j 0 #BT out j = 0. Then the following statements are true: (1) <lb/>j 0 #BT in j = 0. (2) M 0 <lb/>1 <lb/>t i in t j out &gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where = 0 #WT is a ring sequence from WM i <lb/>0 <lb/>to WM j <lb/>ext and = 0 n = 0 #(T 0 n (BT WT)). (3) M 0 <lb/>2 (WP) = WM 0 <lb/>0 . (4) 9 M 2 2 RG(N; M 0 ) such <lb/>that M 1 #T &gt; M 2 , M 2 (P nfp int g) = M 1 (P nfp int g), and M 2 (p int ) = M 1 (p int ). <lb/>Proof: Denote M 0 <lb/>1 t i in &gt; M 0 <lb/>3 <lb/>0 &gt; M 0 <lb/>4 t j out &gt; M 0 <lb/>2 . Let 00 = t i in 0 . Then M 0 <lb/>1 <lb/>00 &gt; M 0 <lb/>4 in RG(N; M 0 <lb/> 0 ). <lb/>From condition (c), j 00 #BT out j = 0. By Lemma 4.2, j 00 #BT in j 1. Hence j 0 #BT in j = 0, and thus <lb/></div>

			<page>29 <lb/></page>

			<div type="annex">j 0 #BTj = 0. Denote = 0 #WT and = 0 #(T 0 n WT). Then = 0 n and j #(BT WT)j = 0. Further-<lb/>more, each transition in is independent of each transition in . Thus M 0 <lb/>3 <lb/>&gt; M 0 <lb/>4 . In addition, <lb/>t i in is also independent of any transition in . As a result, M 0 <lb/>1 <lb/>t i in t i out &gt; M 0 <lb/>2 . <lb/>Denote M 0 <lb/>1 <lb/>&gt; M 0 <lb/>5 t i in &gt; M 0 <lb/>6 <lb/>&gt; M 0 <lb/>7 t j out &gt; M 0 <lb/>2 . By Lemma 4.1, M 0 <lb/>5 (WP) = M 0 <lb/>1 (WP) = WM 0 <lb/>0 , <lb/>and 9 M 5 2 RG(N; M 0 ) such that M 1 #T &gt; M 5 , M 5 (P nfp int g) = M 0 <lb/>5 (P nfp int g), and M 5 (p int ) = <lb/>M 1 (p int ). As a result, t i in is also enabled in M 5 . Since RG(N; M 0 ) satis es B3, we have M 5 (p i in ) = 1 <lb/>and 8 l 2 1::n]; l 6 = i : M 5 (p l in ) = 0. Thus M 0 <lb/>5 (p i in ) = 1 and 8 l 2 1::n]; l 6 = i : M 0 <lb/>5 (p l in ) = 0. <lb/>Therefore, M 0 <lb/>6 (WP) = WM i <lb/>0 . <lb/>Note that = 0 #WT and t j out is enabled in M 0 <lb/>7 . Since RG(WN; WM i <lb/>0 ) satis es W1{W3, we must <lb/>have M 0 <lb/>7 (WP) = WM j <lb/>ext and must be a ring sequence from WM i <lb/>0 to WM j <lb/>ext in RG(WN; WM i <lb/>0 ). <lb/>As a result, M 0 <lb/>2 (WP) = WM 0 <lb/>0 . <lb/>Let M 6 (P nfp int g) = M 0 <lb/>6 (P nfp int g) and M 6 (p int ) = M 5 (p int ) + 1. Then M 5 t i in &gt; M 6 . Let <lb/>M 7 (P nfp int g) = M 0 <lb/>7 (P nfp int g) and M 7 (p int ) = M 6 (p int ). Since j #(T 0 n (BT WT))j = 0, we have <lb/>M 7 = M 6 . Thus t j out is also enabled in M 6 . Now let M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g) and M 2 (p int ) = <lb/>M 6 (p int ) 1. Then M 6 t j out &gt; M 2 and M 2 (p int ) = M 1 (p int ). Hence in RG(N; M 0 ), M 1 &gt; M 5 <lb/>t i in &gt; M 6 t j out &gt; M 7 . Let 00 = t i in t j out . Then 00 = #T. Therefore, 9 M 2 2 RG(N; M 0 ) such that <lb/>M 1 #T &gt; M 2 ; M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g), and M 2 (p int ) = M 1 (p int ). <lb/>Lemma 4.4 Suppose M 0 <lb/>2 is reachable from M 0 <lb/>1 via in RG(N 0 ; M 0 <lb/>0 ) such that M 0 <lb/>1 (WP) = <lb/>WM 0 <lb/>0 . Suppose also that 9 M 1 2 RG(N; M 0 ) such that M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g). Let <lb/>k = j #BT out j. Then k j #BT in j k + 1. Furthermore, M 0 <lb/>2 is reachable from M 0 <lb/>1 in RG(N 0 ; M 0 <lb/>0 ) <lb/>via = 0 1 k k+1 such that the following four conditions are satis ed: (1) j 0 #(BT WT)j = 0. <lb/>(2) 8 l 2 1::k] : l = x l l y l 0 <lb/>l , where (a) x l is the l-th transition from BT in in , denoted as <lb/>x l = t i in ; i 2 1::m]; (b) y l is the l-th transition from BT out in , denoted as y l = t j out ; j 2 1::n]; (c) <lb/>l is a ring sequence from WM i <lb/>0 to WM j <lb/>ext in RG(WN; M i <lb/>0 ); and (d) j 0 <lb/>l #(T 0 n (BT WT))j = 0. (3) <lb/>k+1 #BT out = . (4) #(T 0 n(BT WT)) = #(T 0 n(BT WT)). <lb/>Proof: We show the lemma by induction on k. <lb/>Basis: k = 0. Let 0 = and 1 = . By Lemma 4.2, j #BT in j 1. The lemma holds. <lb/>Induction: Suppose the lemma holds for k = k 0 0. We want to show for k = k 0 + 1. <lb/>Since M 0 <lb/>1 (WP) = WM 0 <lb/>0 , by construction of N 0 from BN and WN in N, the rst transition from <lb/>BT in must appear before any transition from BT out WP in . Denote = 0 t i in 1 t j out 0 , where <lb/>t i in ; i 2 1::m], is the rst transition from BT in in and t j out ; j 2 1::n], is the rst transition from <lb/>BT out in . Thus j 0 #(BT WT)j = 0 and j 1 #BT out j = 0. <lb/>Let M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>3 t i in 1 t j out &gt; M 0 <lb/>4 <lb/>0 &gt; M 0 <lb/>2 . By Lemma 4.1, we have M 0 <lb/>3 (WP) = M 0 <lb/>1 (WP) = <lb/>WM 0 <lb/>0 . Furthermore, 9 M 3 2 RG(N; M 0 ) such that M 3 (P nfp int g) = M 0 <lb/>3 (P nfp int g). By Lemma 4.3, <lb/></div>

			<page>30 <lb/></page>

			<div type="annex">M 0 <lb/>4 (WP) = M 0 <lb/>3 (WP) = WM 0 <lb/>0 . Moreover, M 0 <lb/>4 is also reachable from M 0 <lb/>3 via 0 <lb/>0 t i in 1 t j out such that <lb/>0 <lb/>0 = 1 #(T 0 n (BT WT)), 1 = 1 #WT = 1 n 0 <lb/>0 , and 1 is a ring sequence from WM i <lb/>0 to WM j <lb/>ext in <lb/>RG(WN; WM i <lb/>0 ). Let 0 = 0 0 <lb/>0 and 00 = 0 t i in 1 t j out . Then 0 = 00 #(T 0 n (BT WT)), M 0 <lb/>4 is reachable <lb/>from M 0 <lb/>1 via 0 t i in 1 t j out , and M 0 <lb/>2 is reachable from M 0 <lb/>4 via 0 in RG(N 0 ; M 0 <lb/>0 ). <lb/>Note that M 0 <lb/>4 (WP) = WM 0 <lb/>0 and j 0 #BT out j = k 0 . By induction hypothesis, M 0 <lb/>2 is also reachable <lb/>from M 0 <lb/>4 via 0 = 0 <lb/>1 2 <lb/>k k+1 such that j 0 <lb/>1 #T 0 n (BT WT))j = 0, j k+1 #BT out j = 0, and 8; l 2 2::k] : l <lb/>satis es condition (2) of the lemma. Now, let x 1 = t i in , y 1 = t j out , 1 = x 1 1 y 1 0 <lb/>1 , and = 0 1 0 . <lb/>Then 1 also satis es condition (2) of the lemma. As a result, M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ) and <lb/>satis es conditions (1){(3) of the lemma. Since 0 = 00 #(T 0 n (BT WT)), 0 = 0 #(T 0 n (BT WT)), and <lb/>= 00 0 , also satis es condition (4) of the lemma. In addition, by induction hypothesis, we have <lb/>k 0 j 0 #BT in j k 0 + 1. Hence k j #BT in j k + 1. As a result, the lemma also holds for k = k 0 + 1. <lb/>Therefore, the lemma holds for all k 0. <lb/>Lemma 4.5 Suppose M 0 <lb/>1 <lb/>&gt;M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where M 0 <lb/>1 (WP) = WM 0 <lb/>0 . Then M 0 <lb/>2 (WP) = <lb/>WM 0 <lb/>0 i j #BT in j = j #BT out j. <lb/>Proof: By Lemma 4.4, M 2 is also reachable from M 1 via = 0 1 k k+1 such that conditions <lb/>(1){(4) of Lemma 4.4 hold. Note that #BT in = #BT in and #BT out = #BT out . As a result, we only <lb/>need to show the lemma for the case when = . <lb/>Let M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>3 <lb/>1 &gt; : : : M 0 <lb/>k+2 k &gt; M 0 <lb/>k+3 k+1 &gt; M 0 <lb/>2 , where 8 l 2 1::k] : M 0 <lb/>l+2 l &gt; M 0 <lb/>l+3 . By <lb/>Lemma 4.1, we have M 0 <lb/>3 (WP) = M 0 <lb/>1 (WP). By Lemma 4.3, we have M 0 <lb/>l+2 (WP) = M 0 <lb/>l+3 (WP) <lb/>for each l 2 1::k]. By induction on k, it is obvious that M 0 <lb/>k+3 (WP) = M 0 <lb/>1 (WP) = WM 0 <lb/>0 and <lb/>9 M k+3 2 RG(N; M 0 ) : M k+3 (P nfp int g) = M 0 <lb/>k+3 (P nfp int g). Let 0 = 0 1 k . Then j 0 #BT in j = <lb/>j 0 #BT out j. In addition, we know that j k+1 #BT out j = 0. Thus to prove the lemma, it su ces to show <lb/>that M 0 <lb/>2 (WP) = WM 0 <lb/>0 i j k+1 #BT in j = 0. <lb/>Suppose j k+1 #BT in j = 0. By Lemma 4.1, we have M 0 <lb/>2 (WP) = M 0 <lb/>1 (WP) = WM 0 <lb/>0 . Suppose <lb/>j k+1 #BT in j 6 = 0. By Lemma 4.2, we have j k+1 #BT in j 1. Thus j k+1 #BT in j = 1. Denote k+1 = 0 t i in 1 , <lb/>where t i in ; i 2 1::m], is the only transition from BT in in k+1 . Then j 0 #BTj = j 1 #BTj = 0. Moreover, <lb/>since M 0 <lb/>k+3 (WP) = WM 0 <lb/>0 , we also have j 0 #WTj = 0. Let = 1 #WT and 0 = 1 n . Then <lb/>0 = 1 #(T 0 n (BT WT)). Therefore, any transition in is independent of any transition in 0 and t i in is <lb/>independent of any transition in 0 . As a result, M 0 <lb/>2 is also reachable from M 0 <lb/>k+3 via 0 0 t i in . Suppose <lb/>M 0 <lb/>k+3 0 0 &gt; M 0 <lb/>k+4 t i in &gt; M 0 <lb/>k+5 &gt; M 0 <lb/>2 . Since j( 0 0 )#(BT WT)j = 0, by Lemma 4.1, M 0 <lb/>k+4 (WP) = <lb/>M 0 <lb/>k+3 (WP) = WM 0 <lb/>0 . As a result, we have M 0 <lb/>k+5 (WP) = WM i <lb/>0 . Now that M 0 <lb/>2 (WP) = WM 0 <lb/>0 and <lb/>all transitions in are from WT, there must be a marking WM in RG(WN; WM i <lb/>0 ) that is not an <lb/>exit marking and has no outgoing transitions, contradicting the fact that RG(WN; WM i <lb/>0 ) satis es <lb/>W2. Thus M 0 <lb/>2 (WP) 6 = WM 0 <lb/>0 . Hence M 0 <lb/>2 (WP) = WM 0 <lb/>0 i j k+1 #BT in j = 0. Therefore, the lemma <lb/></div>

			<page>31 <lb/></page>

			<div type="annex">holds. <lb/>Theorem 4.2 Let M 0 be a marking in RG(N 0 ; M 0 <lb/>0 ). The following statements are true: <lb/>(1) M 0 is reachable in RG(N 0 ; M 0 <lb/>0 ) via a canonical ring sequence w.r.t WN. <lb/>(2) j #BT out j j #BT in j j #BT out j + 1 for each ring sequence of M 0 . <lb/>(3) M 0 (P nfp int g) = WM 0 <lb/>0 i there is a ring sequence of M 0 such that j 0 #BT in j = j 0 #BT out j <lb/>Lemma 4.6 Suppose M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ), where M 0 <lb/>1 (WP) = WM 0 <lb/>0 . If 9 M 1 2 RG(N; M 0 ) <lb/>such that M 1 (P nfp int g) = M 0 <lb/>1 (P nfp int g) and M 1 (p int ) = 0, then 9 M 2 2 RG(N; M 0 ) : M 1 &gt; M 2 <lb/>such that M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g) and = 0 #T. <lb/>Proof: We show the lemma by induction on h = j 0 j. <lb/>Basis: h = 0. The lemma holds trivially. <lb/>Induction: Suppose the lemma holds for h = h 0 0. We want to show for h = h 0 + 1. Denote <lb/>0 = 0 t and M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>3 t &gt; M 0 <lb/>2 . Then j 0 j = h 0 . By induction hypothesis, 9 M 3 2 RG(N; M 0 ) : <lb/>M 1 &gt; M 3 such that M 3 (P nfp int g) = M 0 <lb/>3 (P nfp int g) and = 0 #T. Let M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g). <lb/>As for M 2 (p int ), there are four cases to consider: <lb/>(i) t 2 BT in . Then t is also enabled in M 3 . Set M 2 (p int ) = M 3 (p int ) + 1. Then M 3 t &gt; M 2 <lb/>in RG(N; M 0 ). Note that in this case, M 3 (p int ) = 0. Otherwise, since M 1 (p int ) = 0, by <lb/>Lemma 3.2, j 0 #BT in j = j 0 #BT out j + 1. Then j 0 #BT in j = j 0 #BT out j + 2, contradicting Lemma 4.4. <lb/>(ii) t 2 BT out . Then t is also enabled in M 3 . As a result, we have M 3 (p int ) &gt; 0. By Theo-<lb/>rem 3.1 (3), we must have M 3 (p int ) = 1. Set M 2 (p int ) = 0. <lb/>(iii) t 2 WT. Then the execution of t has no e ect on any place in P. Set M 2 (p int ) = M 3 (p int ). <lb/>Then M 2 = M 3 . <lb/>(iv) t 2 T 0 n(BT WT). Then the execution of t has no e ect on p int . Set M 2 (p int ) = M 3 (p int ). <lb/>In all cases, 9 M 2 2 RG(N; M 0 ) such that M 3 = M 2 when t 2 WT; or M 3 t &gt; M 2 otherwise. As <lb/>a result, let = 0 #T, then M 1 &gt; M 2 and M 2 (P nfp int g) = M 0 <lb/>2 (P nfp int g). The lemma holds for <lb/>h = h 0 + 1. <lb/>Therefore, the lemma holds for all h 0. <lb/>Lemma 4.7 Suppose M 1 &gt; M 2 in RG(N; M 0 ), where M 1 (p int )= 0. If 9 M 0 <lb/>1 2RG(N 0 ; M 0 <lb/>0 ) such <lb/>that M 0 <lb/>1 (P nfp int g) = M 1 (P nfp int g) and M 0 <lb/>1 (WP) = WM 0 <lb/>0 , then 9 M 0 <lb/>2 2RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/> 1 <lb/>0 &gt; M 0 <lb/>2 <lb/>such that M 0 <lb/>2 (P nfp int g) = M 2 (P nfp int g) and 0 #T = . <lb/></div>

			<page>32 <lb/></page>

			<div type="annex">Proof: We show the lemma by induction on k = j #BT out j. <lb/>Basis: k = 0. We claim, by induction on h = j j, that 9 M 0 <lb/>2 2 RG(N 0 ; M 0 <lb/>0 ) such that M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 <lb/>and M 0 <lb/>2 (P nfp int g) = M 2 (P nfp int g). <lb/>Basis: h = 0. The claim holds trivially. <lb/>Induction: Suppose the claim holds for h = h 0 0. We want to show for h = h 0 + 1. <lb/>Denote = t and M 1 &gt; M 3 t &gt; M 2 . By induction hypothesis, 9 M 0 <lb/>3 2 RG(N 0 ; M 0 <lb/>0 ) <lb/>such that M 0 <lb/>1 <lb/>&gt; M 0 <lb/>3 and M 0 <lb/>3 (P nfp int g) = M 3 (P nfp int g). Thus t is also enabled in <lb/>M 0 <lb/>3 . Let M 0 <lb/>2 (P nfp int g) = M 2 (P nfp int g). There are two cases to consider: (i) t 2 BT in . <lb/>Then j #(BT WT)j = 0. By Lemma 4.1, we have M 0 <lb/>3 (WP) = M 0 <lb/>1 (WP) = WM 0 <lb/>0 . Let <lb/>M 0 <lb/>2 (WP) = WM i <lb/>0 . (ii) t 6 2 BT in . Then t has no e ect on places in WP. Let M 0 <lb/>2 (WP) = <lb/>M 0 <lb/>3 (WP). In both cases, M 0 <lb/>1 <lb/>&gt; M 0 <lb/>2 in RG(N 0 ; M 0 <lb/>0 ). The claim holds for h = h 0 + 1. <lb/>Therefore the claim holds for all h 0. <lb/>Let 0 = . Then 0 = #T. The lemma holds for k = 0. <lb/>Induction: Suppose the lemma holds for k = k 0 0. We want to show for k = k 0 + 1. From <lb/>the proof of Lemma 3.2, can be written as 0 t i in 1 t j out , where (a) t i in ; i 2 1::m], is the rst <lb/>transition from BT in in , (b) t j out ; j 2 1::n], is the rst transition from BT out in , (c) j 0 #BT out j = <lb/>j 1 #BT out j = 0, and (d) j #BT in j = j #BT out j = k 0 . Let = 0 t i in 1 t j out . Denote M 1 &gt; M 3 &gt; M 2 . Let <lb/>0 = 0 1 t i in t j out . Since t i in is independent of any transition in 1 , we also have M 1 0 &gt; M 3 &gt; M 2 <lb/> in RG(N; M 0 ). <lb/>Denote M 1 0 &gt; M 4 1 &gt; M 5 t i in &gt; M 6 t j out &gt; M 3 . By the result established in the base case, <lb/>9 M 0 <lb/>4 2 RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>4 and M 0 <lb/>4 (P nfp int g) = M 4 (P nfp int g). By Lemma 4.5, M 0 <lb/>4 (WP) = <lb/>WM 0 <lb/>0 . By Theorem 3.1, M 4 (p int ) = 0. Similarly, we have M 5 (p int ) = 0 and 9 M 0 <lb/>5 2 RG(N 0 ; M 0 <lb/>0 ) : <lb/>M 0 <lb/>4 <lb/>1 &gt; M 0 <lb/>5 such that M 0 <lb/>5 (P nfp int g) = M 5 (P nfp int g) and M 0 <lb/>5 (WP) = WM 0 <lb/>0 . <lb/>Note that t i in being enabled in M 5 implies that it is also enabled in M 0 <lb/>5 . Let M 0 <lb/>6 be a marking in N 0 <lb/>such that M 0 <lb/>6 (P nfp int g) = M 6 (P nfp int g) and M 0 <lb/>6 (WP) = WM i <lb/>0 . Then M 0 <lb/>5 t i in &gt; M 0 <lb/>6 in RG(N 0 ; M 0 <lb/>0 ). <lb/>Let M 0 <lb/>7 be a marking in N 0 such that M 0 <lb/>7 (WP) = WM j <lb/>ext , M 0 <lb/>7 (P nfp int g) = M 0 <lb/>6 (P nfp int g), and 2 <lb/>be a ring sequence from WM i <lb/>0 to WM j <lb/>ext in RG(WN; WM i <lb/>0 ). Then M 0 <lb/>6 <lb/>2 &gt; M 0 <lb/>7 in RG(N 0 ; M 0 <lb/>0 ). <lb/>Let M 0 <lb/>3 be a marking in N 0 such that M 0 <lb/>3 (P nfp int g) = M 3 (P nfp int g) and M 0 <lb/>3 (WP) = WM 0 <lb/>0 , then <lb/>M 0 <lb/>6 t j out &gt; M 0 <lb/>3 in RG(N; M 0 <lb/>0 ). Moreover, M 5 (p int ) = 0 implies that M 3 (p int ) = 0. As a result, <lb/>M 0 <lb/>1 <lb/>0 1 t i in 2 t j out &gt; M 0 <lb/>3 in RG(N 0 ; M 0 <lb/>0 ). Let 00 = 0 t i in 1 2 t j out . Since any transition in 1 is indepen-<lb/>dent of t i in , we also have M 0 <lb/>1 <lb/>00 &gt; M 0 <lb/>3 in RG(N 0 ; M 0 <lb/>0 ). Clearly, 00 #T = . <lb/>Now we have M 3 2 RG(N; M 0 ) such that M 3 &gt; M 2 , M 3 (p int ) = 0, and j #BT in j = j #BT out j = <lb/>k 0 . In addition, 9 M 0 <lb/>3 2 RG(N 0 ; M 0 <lb/>0 ) such that M 0 <lb/>3 (P nfp int g) = M 3 (P nfp int g) and M 0 <lb/>3 (WP) = <lb/>WM 0 <lb/>0 . By induction hypothesis, 9 M 0 <lb/>2 2 RG(N 0 ; M 0 <lb/>0 ) : M 0 <lb/>3 <lb/>0 &gt; M 0 <lb/>2 such that M 0 <lb/>2 (P nfp int g) = <lb/></div>

			<page>33 <lb/></page>

			<div type="annex">M 2 (P nfp int g) and 0 #T = . Let 0 = 00 0 . Then M 0 <lb/>1 <lb/>0 &gt; M 0 <lb/>3 in RG(N 0 ; M 0 <lb/>0 ) and 0 #T = . Hence <lb/>the lemma holds for k = k 0 + 1. <lb/>Therefore, the lemma holds for all k 0. <lb/>Theorem 4.4 Given Petri nets N N 0 . Let RG(N; M 0 ) and RG(N 0 ; M 0 <lb/>0 ) be the corresponding <lb/>reachability graphs of N and N 0 , respectively. The following statements are true: <lb/>Deadlock: RG(N; M 0 ) is deadlock free i RG(N 0 ; M 0 <lb/>0 ) is deadlock free. <lb/>Liveness: A transition t 2 T is live in RG(N; M 0 ) i it is live in RG(N 0 ; M 0 <lb/>0 ). <lb/>Input Constraint: RG(N 0 ; M 0 <lb/>0 ) satis es B3. <lb/>Boundedness: RG(N 0 ; M 0 <lb/>0 ) is bounded i RG(N; M 0 ) is bounded. <lb/>Proof: Deadlock: Suppose M is a deadlock marking in RG(N; M 0 ). Let be a ring sequence <lb/>for M. Then no transition in T is enabled in M. In particular, M(p int ) = 0. By Theorem 3.1, <lb/>j #BT in j = j #BT out j. By Theorem 4.3, there is a marking M 0 in RG(N 0 ; M 0 <lb/>0 ) reachable via 0 such <lb/>that M 0 (P nfp int g) = M(P nfp int g) and 0 #T = . Thus no transition from T n BT out is enabled <lb/>in M 0 . Moreover, j 0 #BT in j = j 0 #BT out j. By Lemma 4.5, M 0 (WP) = WM 0 <lb/>0 . Thus no transition <lb/>from BT out WT is enabled in M 0 either. Hence, M 0 is a deadlock marking in RG(N 0 ; M 0 <lb/>0 ). On <lb/>the other hand, suppose M 0 is a deadlock marking in RG(N 0 ; M 0 <lb/>0 ). Let M be a marking of N <lb/>such that M(P nfp int g) = M 0 (P nfp int g) and M(p int ) = 0. By similar argument, we can also show <lb/>M 2 RG(N; M 0 ). <lb/>Liveness: Suppose a transition t 2 T is enabled in M 2 RG(N; M 0 ). Let M t &gt; M 1 in <lb/>RG(N; M 0 ) and be a ring sequence for M. Then t is a ring sequence for M 1 . By Theo-<lb/>rem 4.3, there is a marking M 0 <lb/>1 2 RG(N 0 ; M 0 <lb/>0 ) reachable via 0 such that 0 #T = . As a result, t <lb/>is also enabled in some marking M 0 in RG(N 0 ; M 0 <lb/>0 ) in the path 0 from M 0 <lb/>0 to M 0 <lb/>1 . On the other <lb/>hand, suppose t 2 T is enabled in M 0 2 RG(N 0 ; M 0 <lb/>0 ). By similar argument, we can also show that <lb/>t is enabled in some M 2 RG(N; M 0 ). As a result, a transition t 2 T is enabled in RG(N; M 0 ) i <lb/>it is enabled in RG(N 0 ; M 0 <lb/>0 ). <lb/>Input Constraint: Note that B3 holds for each J 0 2 LN n fJg in RG(N 0 ; M 0 <lb/>0 ). Otherwise, by <lb/>Theorem 4.3, B3 will not hold in RG(N; M 0 ). By the same argument, we observe that B3 is also <lb/>true for places in BP in . Hence it is also true for places in WP in . By Theorem 4.1, it follows B3 <lb/>also holds for places in BP in <lb/>J 0 for each BN J 0 2 WN. Therefore, B3 is true for RG(N 0 ; M 0 <lb/>0 ). <lb/>Boundedness: Note that although we assume B1{B3 hold for RG(N; M 0 ), the proofs of lemmas <lb/>and theorems in Section 3 does not depend on B1 being true. Suppose RG(N; M 0 ) is bounded. Then <lb/>the token count of each place p 2 (P n fp int g) must be bounded in RG(N 0 ; M 0 <lb/>0 ) by Theorem 4.3. <lb/></div>

			<page>34 <lb/></page>

			<div type="annex">Moreover, B3 being true for places in BP in implies that it is also true for places in WP in . By <lb/>Theorem 4.1, each place in WP is also bounded since RG(WN; WM i <lb/>0 ) satis es W1{W3. Thus, <lb/>each place in P 0 is bounded in RG(N 0 ; M 0 <lb/>0 ). Similarly, we can also show that the boundedness of <lb/>RG(N 0 ; M 0 <lb/>0 ) implies the boundedness of RG(N; M 0 ). <lb/></div>

			<page>35 </page>


	</text>
</tei>
