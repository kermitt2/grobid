<?xml version="1.0" ?>
<tei>
	<teiHeader>
		<fileDesc xml:id="__RR-8661"/>
	</teiHeader>
	<text xml:lang="en">
			<titlePage>ISSN  0249-6399 <lb/> ISRN INRIA/RR--8661--FR+ENG <lb/> RESEARCH <lb/> REPORT <lb/>N° 8661 <lb/> January 2015 <lb/>Project-Teams Hipercom2 <lb/> Wave: a Distributed <lb/>Scheduling Algorithm for <lb/>Convergecast in <lb/>IEEE 802.15.4e Networks <lb/>(Extended Version) <lb/> Ridha Soua, Pascale Minet, Erwan Livolant <lb/></titlePage> 
			
			<front>RESEARCH CENTRE <lb/>PARIS – ROCQUENCOURT <lb/> Domaine de Voluceau, -Rocquencourt <lb/>B.P. 105 -78153 Le Chesnay Cedex <lb/> Wave: a Distributed Scheduling Algorithm for <lb/>Convergecast in IEEE 802.15.4e Networks <lb/>(Extended Version) <lb/> Ridha Soua, Pascale Minet, Erwan Livolant <lb/> Project-Teams Hipercom2 <lb/>Research Report n° 8661 — January 2015 — 32 pages <lb/> Abstract: Wireless sensor networks (WSNs) play a major role in industrial environments for <lb/>data gathering (convergecast). Among the industrial requirements, we can name a few like 1) <lb/>determinism and bounded convergecast latencies, 2) throughput and 3) robustness against inter-<lb/>ferences. The classical IEEE 802.15.4 that has been designed for low power lossy networks (LLNs) <lb/>partially meets these requirements. That is why the IEEE 802.15.4e MAC amendment has been <lb/>proposed recently. This amendment combines a slotted medium access with a channel hopping <lb/>(i.e. Time Slotted Channel Hopping TSCH). The MAC layer orchestrates the medium accesses <lb/>of nodes according to a given schedule. Nevertheless, this amendment does not specify how this <lb/>schedule is computed. The purpose of this paper is to propose a distributed joint time slot and <lb/>channel assignment, called W ave for data gathering in LLNs. This schedule targets minimized <lb/>data convergecast delays by reducing the number of slots assigned to nodes. Moreover, W ave <lb/> ensures the absence of conflicting transmissions in the schedule provided. In such a schedule, a <lb/>node is awake only during its slots and the slots of its children in the convergecast routing graph. <lb/>Thus, energy efficiency is ensured. In this paper, we describe in details the functioning of W ave, <lb/> highlighting its features (e.g. support of heterogeneous traffic, support of a sink equipped with <lb/>multiple interfaces) and properties in terms of worst case delays and buffer size. We discuss its <lb/>features with regard to a centralized scheduling algorithm like T MCP and a distributed one like <lb/> DeT AS. Simulation results show the good performance of W ave compared to T MCP . Since in <lb/>an industrial environment, several routing graphs can coexist, we study how W ave supports this <lb/>coexistence. <lb/> Key-words: Wireless sensor network, IEEE 802.15.4e, conflict-free schedule, convergecast, sched-<lb/>uled access, multichannel, time slot, channel allocation, multiple interfaces, data gathering <lb/>

			Wave : un Algorithme d&apos;Ordonnancement Distribué pour la <lb/>Collecte de Données dans les Réseaux IEEE 802.15.4e <lb/>(Version Etendue) <lb/> Résumé : Les réseaux de capteurs sans fil jouent un rôle majeur pour la collecte de données <lb/>dans les environnements industriels. Parmi les exigences industrielles visées, nous pouvons citer <lb/>1) le déterminisme et les latences de collecte bornées, 2) le débit et 3) la robustesse vis-à-vis des <lb/>interférences. La norme IEEE 802.15.4 classique, qui a été conçue pour les réseaux avec pertes <lb/>et contraintes énergétiques (ou Low power Lossy Networks, LLNs), ne répond que partiellement <lb/>à ces exigences. C&apos;est pourquoi l&apos;amendement IEEE 802.15.4e a été proposé récemment. Cet <lb/>amendement propose un mode d&apos;utilisation TSCH (Time Slotted Channel Hopping) combinant <lb/>l&apos;accès au médium par slots temporels et le saut de fréquence. La couche MAC orchestre les accès <lb/>au médium des noeuds du réseau selon un ordonnancement donné. Néanmoins, l&apos;amendement <lb/>ne spécifie pas comment cet ordonnancement est calculé. Le propos de ce papier est d&apos;offrir un <lb/>algorithme distribué d&apos;assignation conjointe de fréquences et de slots temporels pour la collecte <lb/>dans les LLNs, dénommé W ave. Cet ordonnancement vise à minimiser le temps de collecte en <lb/>réduisant le nombre de slots temporels assignés à l&apos;ensemble des noeuds du réseau. De plus, <lb/> W ave assure l&apos;absence de transmissions conflictelles dans l&apos;ordonnancement fourni. Dans un tel <lb/>ordonnancement, un noeud est réveillé uniquement pendant ses slots de transmissions et ceux de <lb/>ses enfants dans le graphe de routage de la collecte. Ainsi, l&apos;efficacité énergétique est assurée. <lb/>Dans ce papier, nous décrivons en détails le fonctionnement de W ave, mettant en exergue ses <lb/>caractéristiques (support du trafic hétérogène, support d&apos;un puits de données avec de multiples <lb/>interfaces de communication) et ses propriétés en terme de délais et de la taille des buffers. Nous <lb/>discutons ses caractéristiques en regard d&apos;un algorithme d&apos;ordonnancement centralisé tel que <lb/> T MCP et d&apos;un autre distribué tel que DeT AS. Les résultats de simulations démontrent une <lb/>meilleure performance de W ave par rapport à T MCP . Enfin, puisque dans un environnement <lb/>industriel plusieurs graphes de routage peuvent cohabiter, nous étudions comment W ave assure <lb/>cette coexistence. <lb/> Mots-clés : Réseau de capteurs sans fil, IEEE 802.15.4e, ordonnancement sans conflit, col-<lb/>lecte de données, accès ordonnancé, multicanal, slot temporel, allocation de canaux, interfaces <lb/>multiples <lb/></front>

			<note place="headnote">Wave <lb/></note>

			<page> 3 <lb/></page>

			<div type="toc"> Contents <lb/> 1 Introduction <lb/>4 <lb/> 1.1 Low power Lossy Networks (LLNs) . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>1.2 Raw Data Convergecast problem . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>1.3 IEEE 802.15.4e TSCH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>1.4 Industrial use cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>5 <lb/> 2 State of the art <lb/>6 <lb/> 2.1 Theoretical work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>6 <lb/>2.2 Scheduling algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>7 <lb/>2.2.1 Centralized algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>7 <lb/>2.2.2 Distributed algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/> 3 Network model and preliminaries <lb/>9 <lb/> 3.1 Network model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.2 Routing graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.3 Acknowledgment policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.4 Conflict model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.5 Traffic model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 <lb/> 4 The Wave scheduling algorithm <lb/>11 <lb/> 4.1 Principles and algorithm of W ave . . . . . . . . . . . . . . . . . . . . . . . . . . 11 <lb/>4.1.1 Illustrative example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 <lb/>4.1.2 Computation of the first wave . . . . . . . . . . . . . . . . . . . . . . . . . 13 <lb/>4.1.3 Local computation of the slots assigned in the next waves . . . . . . . . . 14 <lb/>4.1.4 Algorithm of W ave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 <lb/>4.2 Properties of W ave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 <lb/>4.3 Analytical results: delays, buffer size and messages . . . . . . . . . . . . . . . . . 16 <lb/>4.3.1 Computation of the worst case data gathering delays . . . . . . . . . . . . 16 <lb/>4.3.2 Computation of the buffer size . . . . . . . . . . . . . . . . . . . . . . . . 16 <lb/>4.3.3 Messages exchanged by Wave and by a centralized algorithm . . . . . . . 17 <lb/>4.3.4 Computational complexity of Wave . . . . . . . . . . . . . . . . . . . . . . 18 <lb/> 5 Evaluation of the flexibility of W ave <lb/> 19 <lb/> 5.1 Simulation parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 <lb/>5.2 Homogeneous traffic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 <lb/>5.3 Support of additional links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 <lb/>5.4 Support of heterogeneous traffic demands . . . . . . . . . . . . . . . . . . . . . . 20 <lb/>5.5 Support of a sink with multiple radio interfaces . . . . . . . . . . . . . . . . . . . 21 <lb/>5.6 Support of different acknowledgment policies . . . . . . . . . . . . . . . . . . . . 22 <lb/>5.7 Support of service differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 <lb/> 6 Impact of dynamic changes on the conflict-free schedule <lb/>24 <lb/> 6.1 Impact of retransmissions or changes in application needs . . . . . . . . . . . . . 24 <lb/>6.2 Impact of a change in the routing graph or in the topology . . . . . . . . . . . . 26 <lb/> </div>
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 4 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			<div type="toc">7 Support of multiple routing graphs <lb/>26 <lb/> 7.1 Independent routing graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 <lb/>7.2 Dependent routing graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 <lb/>7.2.1 General principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 <lb/>7.2.2 Illustrative example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 <lb/> 8 Conclusion <lb/>29 <lb/></div>
			
			<note place="footnote">Inria <lb/></note>

			<note place="headnote">Wave <lb/></note>

			<page>5 <lb/></page>

			<body>1 Introduction <lb/> 1.1 Low power Lossy Networks (LLNs) <lb/> The spectacular interest for the Internet of Things has boosted the deployment of Low power <lb/>Lossy Networks (LLNs). LLNs are composed of many tiny low-cost low-power on-chip devices. <lb/>These latter have limited memory and processing resources. They are interconnected by a variety <lb/>of technologies, such as IEEE 802.15.4, WiFi or Bluetooth. Short communication ranges and <lb/>limited bandwidth of nodes lead to multi-hop communications and low data rates. LLNs use <lb/>medium access (MAC) protocols with restricted frame size. Therefore, scheduling techniques <lb/>should be specifically adapted for such MAC layers. <lb/>LLNs have gained widespread usage in many applications, including target tracking, envi-<lb/>ronmental monitoring, health monitoring, smart homes, industrial monitoring. This can be <lb/>explained by the easy deployment of wireless sensor networks. These networks are a typical <lb/>example of LLNs. <lb/> 1.2 Raw Data Convergecast problem <lb/> Data collection represents a significant fraction of network traffic in many industrial applications. <lb/>The individual devices sense their surrounding environment and send their data, directly or via <lb/>multiple hops, to a central device, namely the sink, for processing. Every node plays the role of <lb/>data source and/or router node through a routing graph to deliver packets to the sink without <lb/>agregation by intermediate routers. This data collection is called raw data convergecast. Raw <lb/>data convergecast is particularly well suited for applications with low correlation level between <lb/>the data gathered and/or for LLNs with a reduced payload at the MAC level. In this context, <lb/>nodes that are near the sink should forward more packets than sensors far away. Hence, the <lb/>scheduling of transmissions should be traffic-aware. Nevertheless, data convergecast raises two <lb/>challenges: 1) time efficiency and 2) energy efficiency. <lb/>The former challenge is crucial in industrial environment that generally requires small delays <lb/>and time consistency of data gathered. This time consistency is usually achieved by a small <lb/>gathering period. In fact, minimized end-to-end delays ensure freshness of collected data. As <lb/>argued in [1], using multichannel techniques ensures parallel transmissions and higher capacity. <lb/>Therefore, the data gathering delays can be reduced drastically. Moreover, limiting factors for <lb/>a fast data collection are interferences. To mitigate this problem, authors in [1] argued that <lb/>resorting to multichannel communications is more efficient than varying transmission power. <lb/>Meanwhile, the new standard IEEE 802.15.4e [2] uses channel hopping to minimize interferences. <lb/>In addition, when two or more nodes send their data to a common parent at the same time, <lb/>the messages collide at the common parent. Hence, the parent will not receive data from any <lb/>senders. This situation is more challenging in convergecast applications because a large number <lb/>of nodes, that may transmit simultaneously, is involved. Thus, collisions represent a major <lb/>challenge for bounded latencies and deterministic packet delivery times. <lb/>Energy efficiency, the latter issue, is challenging in LLNs because nodes are battery operated. <lb/>The heavy traffic drastically increases the probability of collisions and retransmissions. Therefore, <lb/>contention-based medium access protocols are inefficient for periodic data collection. In contrast, <lb/>contention-free protocols schedule interfering nodes in different slots. Each node transmits data <lb/>in its allocated slots. Contention-free protocols are the preferred access scheme for applications <lb/>that require energy efficiency and bounded end-to-end delays. On the one hand, these protocols <lb/>remove idle listening and overhearing, which are the main sources of energy drain in contention-<lb/>based protocols. Thus, the provided schedule is appropriate for low power devices since nodes <lb/>turn off their radio in non scheduled time slots. This contributes to energy efficiency and network <lb/>

			<note place="footnote"> RR n° 8661 <lb/></note>

			<page> 6 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			lifetime prolongation. On the second hand, contention-free protocols have the ability to deliver <lb/>packets with deterministic delay bounds by eliminating collisions and retransmissions. Indeed, <lb/>WirelessHART [3], a standard for control applications, uses a TDMA data link layer to control <lb/>medium access. <lb/> 1.3 IEEE 802.15.4e TSCH <lb/> The IEEE 802.15.4 standard does not meet all requirements of industrial applications supported <lb/>by LLNs, more particularly in terms of robustness against interferences and throughput. For <lb/>instance, the use of a single channel does not solve the problem of interferences in a deterministic <lb/>way and may not meet the throughput required by such applications. The MAC amendment, <lb/>IEEE 802.15.4e Time Slotted Channel Hopping (TSCH) [2] was proposed in 2011 to better meet <lb/>industrial markets requirements. This amendment extends the classical IEEE 802.15.4e standard <lb/>to make it suitable for low-power multi-hop networks: the TSCH mode ensures robustness and <lb/>high reliability against interferences by channel hopping. A given node sends subsequent packets <lb/>on different channels. Hence, interferences and multipath fading are mitigated. In the TSCH <lb/>mode, nodes are synchronized and follow a schedule using a slotframe structure. A slotframe is <lb/>a group of time slots which repeats over time, as depicted in Figure 1. The number of time slots <lb/>per slotframe is tunable. <lb/>Figure 1: IEEE 802.15.4e TSCH slotframe <lb/>Each node accesses the medium following a communication schedule. This latter is a matrix <lb/>of cells, each of them is indexed by a slot offset and a channel offset. Each cell can be assigned to <lb/>a link defined by its transmitting and receiving nodes. A scheduled cell can be shared between <lb/>multiple links or dedicated to only one link. As illustrated by Figure 2, the blue cells are <lb/>dedicated cells while the purple cell (darker cell) depicts a shared cell. A single slot is long <lb/>enough for the transmitter to send a maximum length packet and for the receiver to send back <lb/>an acknowledgment. <lb/>However, the IEEE 802.15.4e TSCH standard does not propose a mechanism to build the <lb/>schedule but defines only how the MAC layer executes it. In this paper, we cover this gap by <lb/>proposing W ave, a distributed scheduling algorithm that jointly optimizes the channel and time <lb/>slot assignment in LLNs. This algorithm is tailored for convergecast applications and ensures <lb/>minimized data gathering delays. <lb/> 1.4 Industrial use cases <lb/> The technology of wireless sensor networks is now able to provide multichannel and determinism <lb/>support. Determinism will support 1) bounded delays for data gathering and 2) energy efficiency <lb/>because the medium accesses are done without collision and since each node knows when it <lb/>will transmit and receive data, it sleeps the remaining time to save energy. 3) Throughput <lb/>and 4) robustness against interferences are supported mainly by multichannel and partly by <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>7 <lb/></page> 
			
			Figure 2: IEEE 802.15.4e TSCH schedule <lb/>determinism. These four application requirements are declined in the following six use cases in <lb/>industrial applications, as illustrated by Table 1 where M stands for Mandatory, O for Optional <lb/>(it depends on the application) and N for No. <lb/>Table 1: Industrial use cases <lb/> Use cases <lb/>Robustness <lb/>Throughput <lb/>Low cost <lb/>Bounded delays <lb/>Energy efficiency <lb/>Temporary worksite monitoring <lb/>M <lb/>O <lb/>O <lb/>M <lb/>M <lb/>Detection of fire, pollutant or leak <lb/>M <lb/>N <lb/>M <lb/>M <lb/>O <lb/>Industrial process optimization <lb/>O <lb/>M <lb/>M <lb/>O <lb/>O <lb/>Predictive maintenance <lb/>M <lb/>O <lb/>M <lb/>O <lb/>O <lb/>Intruder detection <lb/>M <lb/>O <lb/>O <lb/>M <lb/>N <lb/>Aerospace application <lb/>M <lb/>O <lb/>N <lb/>M <lb/>M <lb/> The remaining of this paper is organized as follows. In Section 2, we present relevant work that <lb/>focuses on theoretical bounds for convergecast, centralized and distributed scheduling algorithms. <lb/>In Section 3, we give the network, traffic and conflict models. Section 4 describes the behavior <lb/>of W ave. A performance evaluation is conducted in Section 5 to compare W ave with T MCP . <lb/>In Section 6, we study the impact of changes in traffic or in the routing graph. The support <lb/>of multiple routing graphs is discussed in Section 7. Finally, Section 8 concludes the paper and <lb/>gives some perspectives. <lb/> 2 State of the art <lb/> 2.1 Theoretical work <lb/> The following fundamental question: &quot; what is the minimum number of slots we need to collect raw <lb/>data from a LLN organized in a tree?  &quot; has been investigated in many studies. Nevertheless, they <lb/>have specifically targeted the simple case where sensors generate only one packet. In [4], authors <lb/>address jointly the link scheduling and channel assignment for convergecast in networks operating <lb/>according to the WirelessHART standard. Authors have proved that for linear networks with N <lb/> single buffer devices, the minimum schedule length obtained is (2N 񮽙 1) time slots with dN/2e <lb/> channels. <lb/>Incel et al. [1] have proved that if all interfering links except those belonging to the routing <lb/>tree are removed (with the required number of channels), the schedule length for raw-data con-<lb/>vergecast is lower bounded by max(2n  k  񮽙 1, N) where n  k  is the maximum number of nodes in <lb/>any top-subtree of the routing tree and N is the number of source nodes. Our results given in [5] <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 8 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			extend this work by considering the case where the sink is equipped with multiple radio inter-<lb/>faces and nodes generate heterogeneous traffic. Indeed, in any linear LLN with heterogeneous <lb/>demands of nodes, where each node has nchannel &gt; 1, the minimum number of slots for a raw <lb/>data convergecast is Gen(ch1) + 2 <lb/> P <lb/> u6 =sink,u6 =ch1  Gen(u), whatever the number of interfaces that <lb/>the sink has, where Gen(u) is the number of slots needed by node u to transmit its own data to <lb/>its parent and ch1 is the most transmitting child of the sink. <lb/>In multilines or tree networks with heterogeneous demands of nodes, a lower bound on the <lb/>number of slots for a raw data convergecast is Max(S  n  ,S  t  ), where: <lb/> • S  n  = d <lb/> P <lb/> u6 =sink  Gen(u) <lb/>g <lb/> e, where g = min(nchild, nchannel, ninterf ). <lb/> • S  t  = Gen(ch1) + 2 <lb/> P <lb/> v2 Subtree(ch1),v6 =ch1  (Gen(v)) + 񮽙, where ch1 is the most transmitting <lb/>child of the sink and 񮽙 = 1 if the (g + 1)  th  child of the sink requires the same number of <lb/>transmissions as the first one, and 񮽙 = 0 otherwise. <lb/>We define two types of configurations: <lb/> • T  t  configurations where the optimal number of slots is imposed by the most demanding <lb/>subtree rooted at a sink child, i. Its demand is equal to Gen(i)+2 <lb/> P <lb/> v6 =i,v2subtree(i)  Gen(v). <lb/> The T  t  configurations are dominated by the subtree requiring the highest number of trans-<lb/>missions. <lb/> • T  n  configurations where the optimal number of slots depends only on the total number of <lb/>demands and g. It is equal to d <lb/> P <lb/> u6 =sink  Gen(u) <lb/>g <lb/> e. The T  n  configurations are traffic-balanced. <lb/>Notice that a T  n  configuration corresponds to a Capacitated Minimal Spanning Tree [6], <lb/>where each branch has a total demand for slots less than or equal to d <lb/> P <lb/> u6 =sink  Gen(u) <lb/>g <lb/> e. <lb/> 2.2 Scheduling algorithms <lb/> To schedule nodes in multichannel context, two approaches can be distinguished. The first ap-<lb/>proach starts with a channel allocation. Channels are usually allocated to receivers or links. <lb/>Then, the time slot assignment is triggered. Interferences, that are not removed by channel allo-<lb/>cation, are avoided by assigning different time slots to concurrent senders. The second approach <lb/>jointly allocates channels and slots. Hereafter, we will detail the most relevant centralized and <lb/>distributed scheduling algorithms for data gathering in multichannel context. <lb/> 2.2.1 Centralized algorithms <lb/> TMCP [7] is designed to support data collection traffic. It begins by partitioning the network into <lb/>multiple subtrees and then assigns different channels to nodes belonging to different subtrees. <lb/>Hence, it minimizes interferences between subtrees. After the channel assignment, time slots <lb/>are assigned to nodes. However, TMCP does not eliminate contention inside the branches of a <lb/>subtree since nodes that belong to the same branch communicate on the same channel. <lb/>Incel et al. [1] propose a convergecast scheduling algorithm, called JFTSS, that achieves <lb/>optimal bound on any network topology where the routing tree has an equal number of nodes <lb/>on each branch and each node generates the same amount of traffic (i.e. all nodes have the same <lb/>sampling rate). <lb/>Authors of [8] propose TASA, a centralized traffic-aware scheduling algorithm for networks <lb/>based on IEEE 802.15.4e. TASA proceeds in two steps: 1) a matching step where links eligible <lb/>to be scheduled in the same time slot are selected 2) a coloring step where each link selected for <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>9 <lb/></page> 
			
			transmission is assigned a channel offset. The channel offset is translated into a frequency using <lb/>a translation function. However, TASA does not take into account queue congestion in sensor <lb/>nodes, leading to large buffer size at these nodes. <lb/>In [9], authors design MODESA, a Multichannel Optimized DElay time Slot Assignment. This <lb/>latter is a centralized collision-free algorithm that takes advantages from multiple channels to <lb/>allow parallel transmissions and improve communication reliability. Authors prove the optimality <lb/>of MODESA in many multichannel topologies of wireless sensor networks. In addition, MODESA <lb/>reduces buffer congestion by scheduling first the nodes that have more packets in their buffers. <lb/>Although in distributed scheduling strategies it is difficult for each node to find an optimal <lb/>schedule because global information is unavailable, these solutions are considered more attractive <lb/>in large scale networks and more reliable than a centralized one. We will detail most relevant <lb/>distributed solutions in the next section. <lb/> 2.2.2 Distributed algorithms <lb/> In [10], Incel et al. derive a TDMA schedule that minimizes the number of slots required for <lb/>convergecast. They extend the distributed algorithm proposed by Ghandam et al. [11] to the <lb/>context of multichannel wireless sensor networks. Their approach includes two steps: 1) A <lb/>receiver based channel assignment: it removes all the interference links in an arbitrary network. <lb/>2) A distributed slot assignment: where each node is assigned an initial state (i.e. transmit T  x  , <lb/>receive R  x  or idle) based on its hop-count to the sink and the state of its branch. If the branch <lb/>is active (i.e. the sink child located in the top of the branch transmits), a node with hop-count <lb/> h is assigned state T  x  if h mod 2 = 1 and state R  x  otherwise. If the branch is not active, it is <lb/>assigned state T  x  if h mod 2 = 0 and R  x  otherwise. In the next slot, nodes switch to the opposite <lb/>state. <lb/>The algorithm does not specify how slots are assigned to brothers. Besides, the authors <lb/>assume that after channel allocation, the only remaining conflicts are inside the convergecast <lb/>tree. They also show that this algorithm is optimal when all interferences are removed using the <lb/>necessary number of channels and a suitable balanced routing tree is built. <lb/>Accettura et al. [12] propose DeTAS, a distributed traffic aware scheduling solution for <lb/>IEEE 802.15.4e TSCH networks. This solution is the distributed mode of TASA proposed in [8]. <lb/>In DeTAS, all nodes follow a common schedule, called macro-schedule, that is the combination of <lb/>micro-schedules of each routing graph. Each micro-schedule is computed in distributed manner. <lb/>DeTAS avoids buffer overflow by alternating the sequence of transmit/receive slots for each node. <lb/>However, if other links exist in addition to the convergecast links, collisions may occur. <lb/>Authors of [17] propose W ave, an algorithm that schedules nodes in successive waves. In <lb/>each wave, each node having a packet to transmit is assigned a time slot and a channel. The first <lb/>wave constitutes the (slot, channel) pattern. Each next wave is an optimized subset of the first <lb/>wave: only the slots that will contain transmissions are repeated and they always occur in the <lb/>same order as in the first wave. To know its next scheduled slots, a node applies a simple rule. <lb/>As a result, the joint channel and time slot assignment produced by W ave contains for each time <lb/>slot and for each available channel, a list of sender nodes, such that their transmissions to their <lb/>parent do not conflict. <lb/>Morel et al. [13] map multiprotocol label switching to constrained LLN to provide distributed <lb/>scheduling for IEEE 802.15.4e networks. Indeed, nodes request bandwidth in terms of time <lb/>slots. The RSVP-TE over GMPLS protocol ensures that reserved network resources match the <lb/>requirements of nodes. Their solution, CFDS, has two components: (1) a time slot mechanism <lb/>that prevents a node to be involved either in two simultaneous transmission and reception, or two <lb/>simultaneous receptions; this mechanism is the request and the grant procedure; (2) a channel <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 10 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			offset selection mechanism that mitigates internal and external interferences. <lb/> 3 Network model and preliminaries <lb/> 3.1 Network model <lb/> We focus on raw data gathering in LLNs based on the IEEE 802.15.4e standard. The data <lb/>gathered are transmitted by nodes different from the sink in the slotframe according to the <lb/>schedule provided by the W ave scheduling algorithm that we will present in the next section. <lb/>Furthermore, we assume that any node u 6 = sink receiving a packet in slot t is able to forward <lb/>it in the slot t + 1 if required by the schedule. A slot contains one packet. If the immediate <lb/>acknowledgment policy is used (see Subsection 3.3), a slot also contains the acknowledgment <lb/>of the data packet sent. In all cases, the slotframe is dimensionned to enable the transfer of <lb/>all packets generated during the slotframe. The problem is to minimize the number of slots <lb/>composing the slotframe. <lb/> 3.2 Routing graph <lb/> Network connectivity is assumed. For any data gathering considered, the associated routing <lb/>graph is given. It can be a DODAG provided by RPL [14] or a routing tree provided by a <lb/>gradient method such as EOLSR [15] or [16]. The root of this routing graph is the sink in charge <lb/>of gathering data produced by sensor nodes. Each node u 6 = sink has a unique preferred parent <lb/>that is abusively called parent in this paper. <lb/> 3.3 Acknowledgment policy <lb/> Two acknowledgment policies are studied: <lb/> • either there is no acknowledgment: since we consider a lossy network, the probability of <lb/>packet loss is not neglectable. This policy can be adopted only if the packet loss rate is <lb/>acceptable for the application. <lb/> • or there is an immediate acknowledgment: each data packet is acknowledged in the same <lb/>time slot and on the same frequency it has been sent. If the immediate acknowledgment <lb/>policy is used, the routing tree consists only of symmetric links. <lb/> 3.4 Conflict model <lb/> Two nodes u and v are said to conflict if and only if they cannot transmit in the same time <lb/>slot and on the same channel frequency without preventing: 1) either a destination node to <lb/>correctly receive its data packet 2) or a sending node to receive the acknowledgment of its data <lb/>packet. Notice that this definition depends on the acknowledgment policy used. If there is no <lb/>acknowledgment, only the item 1) is relevant. <lb/>In the literature, there are two types of conflict models: those based on the topology graph, <lb/>also called protocol-based and those based on a physical model (e.g. SINR measures). With both <lb/>types of models, a conflict graph is built. This graph is more accurate if it takes into account <lb/>the feedback provided by physical measures (e.g. SINR, LQI, RSSI). It is important to notice <lb/>that W ave takes the conflict relation as an input, provided that this relation is symmetric. If a <lb/>physical model is adopted, W ave must know for each conflicting node a path to reach it. In the <lb/>following of this paper, we adopt a protocol-based model of conflicts. <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>11 <lb/></page> 
			
			In a protocol-based model of conflicts, the conflict relation is built from the one-hop neighbor <lb/>relation. Two nodes are said one-hop neighbors if and only if they hear each other. We can <lb/>now recursively define the h-hop neighbor relation, with h &gt; 1. Two nodes u and v are h-hop <lb/>neighbors, with h &gt; 1, if and only if there exists a one-hop neighbor of u that is (h-1)-hop <lb/>neighbor of v. <lb/> In the absence of acknowledgment, the only possible conflicts are caused by the simultaneous <lb/>transmissions of two data packets as depicted in Figure 3. In this figure, links used for data <lb/>gathering are the tree links and are depicted in black plain line, whereas blue dotted lines <lb/>represent links between one-hop neighbors that are not used in the routing tree. It is worth <lb/>noting that such links may cause collisions. For instance, when node 3 is transmitting data to <lb/>its parent, node 2 that is a one-hop neighbor of node 1 = parent(3) cannot transmit: it would <lb/>prevent node 1 to receive correctly, even if link (2,1) does not belong to the tree. All circled <lb/>nodes are conflicting nodes. <lb/>Figure 3: Conflicting nodes of node 3 without acknowledgment. <lb/> Property 1 In this graph-based model and in the absence of acknowledgment, the nodes con-<lb/>flicting with any node u are: <lb/>-the node u itself, <lb/>-its parent P arent(u), <lb/> -its children, <lb/>-the nodes that are 1-hop away from P arent(u), <lb/> -the nodes whose parent is 1-hop away from u. <lb/> When the immediate acknowledgment policy is chosen, there are additional conflicts. They <lb/>are caused by the simultaneous transmissions of a data packet and an acknowledgment, as de-<lb/>picted in Figure 4. In this figure, a black arrow represents the transmission of a data packet, <lb/>whereas a red arrow denotes the transmission of an acknowledgment packet. A dotted line <lb/>represents a link without intended transmission. <lb/> Property 2 In this graph-based conflict model, the nodes conflicting with any node u are for the <lb/>immediate acknowledgment policy: <lb/>-the node u itself, <lb/>-its parent P arent(u), <lb/> -the nodes that are 1-hop away from u or P arent(u), <lb/> -the nodes whose parent is 1-hop away from u or P arent(u). <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 12 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			Figure 4: Conflicting nodes with the immediate acknowledgment. <lb/>In the absence of acknowledgment, the set of conflicting nodes, defined by Property 1, is <lb/>included in the two-hop neighbors set. With the immediate acknowledgment, the set of conflicting <lb/>nodes, defined by Property 2, is included in the three-hop neighbors set. <lb/> Property 3 In the graph-based conflict model, the nodes conflicting with any node u with the <lb/>immediate acknowledgment are those without acknowledgment, in addition to: <lb/>-the nodes that are 1-hop away from u but are not its children, <lb/>-the nodes whose parent is 1-hop away from P arent(u). <lb/> 3.5 Traffic model <lb/> Any node u 6 = sink generates Gen(u) 񮽙 1 packets in each slotframe. These packets contain <lb/>the own data of u. They are assumed to be present when the data gathering is started and <lb/>are renewed in each slotframe. Two nodes u and v may generate different traffic loads (i.e. <lb/> Gen(u) 6 = Gen(v)). Furthermore, T rans(u) denotes the total number of packets transmitted by <lb/> u in a slotframe. This corresponds to the own packets of u and the packets transmitted by its <lb/>children. Consequently, we have T rans(u) = Gen(u) + <lb/> P <lb/> v2Child(u)  T rans(v). <lb/> 4 The Wave scheduling algorithm <lb/> In this section, we detail W ave a simple distributed conflict-free scheduling algorithm in networks <lb/>based on IEEE 802.15.4e. W ave supports a sink with multiple radio interfaces, heterogeneous <lb/>traffic and additional links to the convergecast tree. It can be extended as shown in Section 7 to <lb/>support several routing graphs. <lb/>A schedule is said valid if and only if two conflicting nodes do not transmit in the same time <lb/>slot and on the same channel frequency. <lb/>The goal of W ave is to compute a valid schedule that minimizes the number of slots allocated <lb/>while ensuring that: <lb/> • each node has the number of slots needed to forward any packet received from its children <lb/>and to send its own packets; <lb/> • and each packet transmitted in a slotframe reaches the sink in the same slotframe. <lb/> 4.1 Principles and algorithm of W ave <lb/> In W ave, any node u 6 = sink needs to know its parent and its children in the routing graph consid-<lb/>ered, the acknowledgment policy, the nodes conflicting with u whose set is denoted Conf lict(u), <lb/> the traffic demand of u and all nodes in Conf lict(u). <lb/> Inria <lb/> Wave <lb/> 13 <lb/> W ave proceeds in successive waves: the i  th  wave schedules the i  th  transmission of any node <lb/>having at least i packets to transmit. In the first wave, each node is assigned a time slot and a <lb/>channel frequency to transmit one packet. This first wave is computed in order to minimize the <lb/>total number of slots needed. Next, this wave is reproduced but in an optimized way: only the <lb/>slots that are needed by at least one node are reproduced in the next wave. The total number <lb/>of waves in the schedule is equal to W = max  u6 =sink  T rans(u). <lb/> 4.1.1 Illustrative example <lb/> Figure 5a depicts a routing graph including nine nodes, where node 1, the sink, is equipped with <lb/>a single interface. The number in the bullet denotes the number of packets transmitted by the <lb/>node in a data gathering cycle. The schedule provided by W ave is depicted in Figure 5b. It <lb/>consists of four waves, since max  u6 =sink  T rans(u) = 4. <lb/> a Routing graph <lb/>b Associated schedule <lb/> Figure 5: Wave on an example. <lb/>The first wave comprising 3 slots allows each node to transmit one packet without collision. <lb/>It is built considering nodes in the decreasing order of their number of transmissions: in this <lb/>example, the order is 2, 5, 3, 4, 8, 6, 7, 9. A node is assigned the first time slot and channel where <lb/>itself and its parent have an available interface and it does not conflict with the nodes already <lb/>scheduled in this slot and on this channel. The second wave comprises 3 slots too, but nodes <lb/> 6, 7 and 9 that had only one packet to transmit are no longer scheduled. In other words, the <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 14 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			second wave reproduces the first wave eliminating nodes that have strictly less than 2 packets to <lb/>transmit. In the third wave, the third slot would be empty (node 4 has already transmitted all <lb/>its packets), this slot is eliminated. Hence the size of the third wave is equal to 2 slots. And so <lb/>on, until the fourth wave that contains only one slot used by node 2. In Figure 5b, we represent <lb/>under each wave, the part of the routing graph that is scheduled in this wave. It appears that <lb/>nodes having only one remaining packet to transmit in the current wave are eliminated in the <lb/>next wave (e.g. node 5 present in the third wave is eliminated in the fourth wave). <lb/> 4.1.2 Computation of the first wave <lb/> The sink sends a Start message down the routing graph to trigger the computation of the schedule <lb/>for this routing graph. More specifically, in the first wave, each node computes its time slot and <lb/>channel frequency according to the following rules R1 and R2. <lb/> Rule R1 : Any node u 6 = sink having received the Start message and having the highest <lb/>priority (i.e. the highest number of transmissions) among its conflicting nodes not yet scheduled, <lb/>assigns itself a time slot and a channel frequency. The slot selected by u is the first available <lb/>time slot where: <lb/>-both u and its parent have an available interface, <lb/>-there is a channel frequency where u does not conflict with the nodes already scheduled in <lb/>this time slot and on this channel frequency. <lb/> Rule R2 : As soon as node u is assigned a time slot and a channel frequency, it notifies this <lb/>assignment to its conflicting nodes by the Assign message. <lb/>The Assign message is forwarded according to the following property. <lb/> Property 4 Any node u receiving the Assign message originated from node v forwards it if and <lb/>only if: <lb/> • in the absence of acknowledgment, u is a parent and u is one-hop away from v; <lb/> • in the presence of the immediate acknowledgment, u is a parent and u is one-hop away <lb/>from v or P arent(v). <lb/> Proof: When v is scheduled, it sends its Assign message. This message in the absence of <lb/>loss is received by any one-hop neighbor of v, in particularly by its parent and its children. Any <lb/>node that receives it and is a parent forwards it. Hence, in the absence of acknowledgment and <lb/>message loss, all nodes that conflict with v that are defined in Property 1 know the slot and <lb/>channel assignment of v. Hence, the first part of the property. <lb/>With the immediate acknowledgment policy, there are other nodes that forward the Assign <lb/> message originated from v. These other nodes are parent nodes one-hop away from P arent(v), <lb/> which have received the message from P arent(v). Hence, all nodes defined in Property 2 know <lb/>the slot and channel assignment of v. Hence, the second part of the property. <lb/>To compute the next waves, it is needed to know the number of slots of the first wave, as well as <lb/>the repetition factor of each slot. To this end, the following rule R3 is applied. <lb/> Rule R3 : Any node that has no child and knows the slots and channel frequency of its <lb/>conflicting nodes sends a Notify message to its parent, containing for each time slot t that it <lb/>knows its repetition factor Maxtrans(t). Upon receipt of the Notify message from each of its <lb/>children, a node u 6 = sink sends its Notify message to its parent. The sink sends back down the <lb/>routing graph a Repeat message including T the number of slots composing the first wave and <lb/>for each slot 1  t  T its repetition factor Maxtrans(t). <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>15 <lb/></page> 
			
			4.1.3 Local computation of the slots assigned in the next waves <lb/> Upon receipt of the Repeat message, any node is able to compute locally its slot and the slot <lb/>assigned to each conflicting node in any wave w &gt; 1, by applying rule R4. <lb/> Rule R4 : Any node u 6 = sink being assigned the slot t in the first wave is also assigned the slot <lb/> s(t, w) in any wave w with 1 &lt; w  T rans(u), with s(t, w) = <lb/> P  w񮽙1 <lb/> w  0  =1 <lb/> P  T <lb/>t  0  =1  񮽙  t  0  ,w  0  + <lb/> P  t <lb/>t  0  =1  񮽙  t  0  ,w  , <lb/>where 񮽙  t  0  ,w  0  = 1 if and only if Maxtrans(t  0  ) 񮽙 w  0  and 0 otherwise, where Maxtrans(t  0  ) is the <lb/>maximum number of transmissions of any node transmitting in the time slot t  0  . <lb/> 4.1.4 Algorithm of W ave <lb/> The algorithm for the computation of the first wave is given in Algorithm 1. After some initial-<lb/>izations, the local node u starts by sorting its conflicting nodes according to the decreasing order <lb/>of their number of transmissions (see line 6). Then node u enters a loop (lines 8 to 40) until all <lb/>conflicting nodes are scheduled. This loop consists of two parts: <lb/> • the processing of the Assign message received that notifies the time slot and channel <lb/>assigned to node v (line 11). If v is a conflicting node of u, u updates different variables <lb/>such as the list of conflicting nodes to schedule, the number of available interfaces of its <lb/>parent, etc. In any case, u forwards the Assign message according to Property 4 in order <lb/>to notify all nodes conflicting with v. <lb/> • the scheduling of node u as soon as it has the highest priority among its conflicting nodes <lb/>not yet scheduled (lines 13 to 39). Node u is assigned the smallest time slot where u and its <lb/>parent have an available interface (lines 19 to 21) and then the smallest channel on which <lb/> u does not conflict with the nodes already scheduled (lines 22 to 37). <lb/> 4.2 Properties of W ave <lb/> With the assumptions given previously, we have the following properties: <lb/> Property 5 The distributed W ave algorithm is equivalent to a centralized algorithm using the <lb/>same node priority and the same rules for the time slot and channel frequency assignment. <lb/>Proof: Both algorithms provide the same time slot and channel frequency schedule, whatever <lb/>the routing graph, the conflicting nodes, the acknowledgment policy given and the traffic injected <lb/>by the nodes. See [17] for the detailed proof. <lb/> Property 6 W ave is efficient: in the absence of message loss, no slot allocated is empty and <lb/>any packet transmitted in a slotframe is delivered to the sink in the same slotframe. <lb/>Proof: According to our assumptions, any node u 6 = sink has at least one packet to transmit <lb/>in the first wave. By construction of the schedule, a slot exists in the first wave only if there is <lb/>a node having a packet to transmit in this slot. Hence, no slot of the first wave is empty. We <lb/>can prove by induction that for any wave w, with 1 &lt; w  T rans(u), any node u receives one <lb/>packet per child v with T rans(v) 񮽙 w and sends only one packet. Hence, node u has packets to <lb/>transmit up to the wave T rans(u). In any next wave w, with 1 &lt; w  max  u6 =sink  T rans(u), a <lb/>slot is reproduced if and only if there is a node u with T rans(u) 񮽙 w. Hence, no slot is empty <lb/>in the next waves. Furthermore, the schedule is built in such a way, that any node u is assigned <lb/>a number of slots equal to T rans(u). Hence, each node can transmit all its own packets and all <lb/>the packets received from its children in a single slotframe. Moreover, in each wave any packet <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 16 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			Algorithm 1 Computation of the first wave <lb/> 1:  Input: nchannel channels; u the local node; Conf lict(u) its set of conflicting nodes; <lb/> Interf (u) available radio interfaces; T rans(u)=number of packets that node u has to trans-<lb/>mit. <lb/> 2:  Output: ScheduledN odes: Channel &amp; slot for u &amp; Conf lict(u) <lb/> 3:  Initialization: <lb/> 4:  T rans(u) <lb/> the number of packets that u has to transmit <lb/> 5:  Scheduled <lb/>false /*node u is not yet scheduled*/ <lb/> 6:  T oSchedule <lb/> the set Conf lict(u) sorted by decreasing T rans <lb/> 7:  ScheduledN odes(t, ch) <lb/> ; for any slot t and channel ch <lb/> 8:  repeat <lb/> 9: <lb/> if receipt of the Assign message (node v is scheduled in slot t on channel ch) then <lb/> 10: <lb/> /*Process the Assign message received*/ <lb/> 11: <lb/> processAssignMsg Procedure (Assign) /* see Algorithm 2 */ <lb/> 12: <lb/> end if <lb/> 13: <lb/> if (u = first(T oSchedule)) then <lb/> 14: <lb/> /*u with the highest priority is scheduled*/ <lb/> 15: <lb/> ch <lb/> 1 /*first channel*/ <lb/> 16: <lb/> /*find the first time slot with an available interface for u &amp; P arent(u)*/ <lb/> 17: <lb/> t <lb/> 1 /*first time slot*/ <lb/> 18: <lb/> repeat <lb/> 19: <lb/> while (Interf (u, t) = 0)&amp; (Interf (P arent(u), t) = 0) do <lb/> 20: <lb/> t <lb/>t + 1 <lb/> 21: <lb/> end while <lb/> 22: <lb/> if (Conf lict(u) <lb/> T <lb/> ScheduledN odes(t, ch) = ;) then <lb/> 23: <lb/> /*Node u can be scheduled in slot t on channel ch*/ <lb/> 24: <lb/> Scheduled <lb/>true; <lb/> 25: <lb/> Node u transmits the Assign message to its neighbors <lb/> 26: <lb/> Interf (u, t) <lb/>Interf (u, t) 񮽙 1 <lb/> 27: <lb/> Interf (P arent(u), t) <lb/>Interf (P arent(u), t) 񮽙 1 <lb/> 28: <lb/> ScheduledN odes(t, ch) <lb/>ScheduledN odes(t, ch) [ {u} <lb/> 29: <lb/> T oSchedule <lb/>T oSchedule \{u} <lb/> 30: <lb/> else <lb/> 31: <lb/> if (ch &lt; nchannel) then <lb/> 32: <lb/> ch <lb/>ch + 1 /* try the next channel*/ <lb/> 33: <lb/> else <lb/> 34: <lb/> t <lb/>t + 1 /* try the next slot*/ <lb/> 35: <lb/> ch <lb/> 1 /* try the first channel*/ <lb/> 36: <lb/> end if <lb/> 37: <lb/> end if <lb/> 38: <lb/> until Scheduled /*u is scheduled*/ <lb/> 39: <lb/> end if <lb/> 40:  until (T oSchedule = ;) /*all nodes 2 Conf lict(u) scheduled*/ <lb/>sent progresses at least one hop toward the sink. The reproduction of the wave ensures that any <lb/>packet transmitted in the slotframe reaches the sink in this slotframe in the absence of message <lb/>loss. Hence, the property. <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>17 <lb/></page> 
			
			Algorithm 2 processAssignMsg Procedure (Assign) <lb/> 1:  Input: message Assign(v, P arent(v), slot, ch) <lb/> 2:  if v 2 Conf lict(u) then <lb/> 3: <lb/> /*update the nodes already scheduled*/ <lb/> 4: <lb/> ScheduledN odes(t, ch) <lb/>ScheduledN odes(t, ch) <lb/> S {v} <lb/> 5: <lb/> T oSchedule <lb/>T oSchedule \ {v} <lb/> 6: <lb/> if v = Child(u) then <lb/> 7: <lb/> Interf (u, t) <lb/>Interf (u, t) 񮽙 1 <lb/> 8: <lb/> else <lb/> 9: <lb/> if (v = P arent(u)) || (P arent(v) = P arent(u)) then <lb/> 10: <lb/> Interf (P arent(u), t) <lb/>Interf (P arent(u), t) 񮽙 1 <lb/> 11: <lb/> end if <lb/> 12: <lb/> end if <lb/> 13:  end if <lb/> 14:  /*Forward the message received if needed*/ <lb/> 15:  if N o Ack then <lb/> 16: <lb/> if (u has child) &amp; (u is 1-hop away from node v) then <lb/> 17: <lb/> forward the Assign message <lb/> 18: <lb/> end if <lb/> 19:  else <lb/> 20: <lb/> if Immediate Ack then <lb/> 21: <lb/> if (u has child) &amp; (is 1-hop away from v or P arent(v)) then <lb/> 22: <lb/> forward the Assign message <lb/> 23: <lb/> end if <lb/> 24: <lb/> end if <lb/> 25:  end if <lb/> 4.3 Analytical results: delays, buffer size and messages <lb/> 4.3.1 Computation of the worst case data gathering delays <lb/>Property 7 For any node u 6 = sink, assuming that packets are ordered FIFO, the worst delivery <lb/>time for a packet generated by u is bounded by the period of the slotframe plus the duration of <lb/>the slots allocated to the data gathering. <lb/>Proof: In the worst case, node u generates its packet just after the last slot granted to it. <lb/>Hence, this packet has to wait the next slotframe, hence a duration of the period of the slotframe. <lb/>Since according to the previous property, any packet transmitted in a slotframe reaches the sink <lb/>in this slotframe, the packet of u is delivered in the worst case at the end of the last slot allocated <lb/>in the second slotframe. Hence, the property. <lb/> 4.3.2 Computation of the buffer size <lb/>Property 8 For any node u 6 = sink involved in a raw data gathering, the maximum buffer size <lb/>is equal to MaxBuf(u) = <lb/> P <lb/> v2Child  ⇤  (u)  T rans(v) +Gen(u) + 1, where Child  ⇤  (u) is the set of <lb/>children of u, except the child transmitting the highest number of packets (if several such children <lb/>exist, the child with the smallest identifier is chosen). For the sink, the maximum buffer size is <lb/>equal to MaxBuf(sink) = <lb/> P <lb/> v6 =sink  Gen(v). <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 18 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note>
			
			Proof: In a raw data gathering, the sink does not send any packet but receives all the packets <lb/>transmitted by its children, namely <lb/> P <lb/> v6 =sink  Gen(v) that dimensions its maximum buffer size. <lb/>For any node u 6 = sink, Gen(u) packets are initially present in its buffer. Then, in each wave, <lb/>node u receives one packet from each child v having not yet transmitted its T rans(v) packets, <lb/>but transmits only one. Hence, the number of packets in the buffer of u increases as long as the <lb/>number of packets received by u in a wave is strictly higher than one (the number of packets <lb/>transmitted by u). Notice, that the maximum is reached when u has received the packets of its <lb/>children in the wave but has not yet sent its own packet. Hence, the term +1 in the formula. <lb/> 4.3.3 Messages exchanged by Wave and by a centralized algorithm <lb/> We compare any centralized scheduling algorithm with the distributed W ave algorithm in terms <lb/>of number of messages needed to establish a collision-free schedule. Any centralized scheduling <lb/>algorithm needs to know the topology, the routing graph and the traffic demand of each node. <lb/>This information is collected by the sink that is in charge of computing the schedule. This conflict-<lb/>free schedule is then broadcast to the nodes in the LLN in order to be applied by the MAC layer. <lb/>For each node u, we denote by depth(u) its depth in the routing tree and by AverageDepth <lb/> the average depth in the routing tree. Moreover, let V denote the average number of one-hop <lb/>neighbors of a node. In addition, MaxDepth denotes the depth of the routing graph. Let N be <lb/>the number of nodes in the routing graph. Notice that if the size of a message is not compatible <lb/>with the maximum size allowed by the IEEE 802.15.4 MAC protocol, this message is fragmented. <lb/> Property 9 The distributed W ave algorithm needs less messages than any centralized schedule <lb/>if and only if AverageDepth 񮽙 2V + 2. <lb/> Proof: <lb/> • In any centralized scheduling algorithm: <lb/> a) Each node u 6 = sink, whose depth is depth(u) transmits the list of its neighbors and its <lb/>traffic demand Gen(u) to the sink. This message needs depth(u) hops to reach the sink. <lb/>The total number of transmissions is <lb/> P <lb/> u6 =sink  depth(u) = AverageDepth ⇤ (N 񮽙 1). <lb/> b) The sink computes the schedule and broadcasts it to sensor nodes. This message is <lb/>broadcast to MaxDepth hops. <lb/>c) Thus, the total number of messages required to establish the schedule in the centralized <lb/>mode is: AverageDepth ⇤ (N 񮽙 1) transmissions + the schedule message broadcast to <lb/> MaxDepth hops. <lb/> • In the distributed W ave algorithm: <lb/> a) Computation of the priority of node u, i.e. T rans(u): <lb/> Each node u 6 = sink transmits to its P arent(u) the value of T rans(u). So we have (N 񮽙 1) <lb/> transmitted messages for a LLN of N nodes. <lb/>b) Assignment of time slot and channel to conflicting nodes for the first wave: <lb/>If the immediate acknowledgement policy is adopted, each node u 6 = sink should notify its <lb/>priority to nodes that are one hop away from u and nodes that are one hop away from <lb/> P arent(u). We assume that the priority of node u and its one-hop neighbors is included in <lb/>the Hello message, used for neighborhood discovery (see for instance the NHDP protocol <lb/>[18]). Hence, no additional message is needed to let the conflicting nodes know the priority <lb/>of each other. After that, node u needs to notify its slot to its conflicting nodes. Therefore, <lb/>we need 1 + V + (V 񮽙 1) = 2V messages. Since we have (N 񮽙 1) nodes 6 = sink, we need a <lb/>total of 2V ⇤ (N 񮽙 1) messages in this phase. <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>19 <lb/></page> 
			
			c) Computation of the number of slots in the first wave: <lb/>Each node u 6 = sink transmits to its P arent(u) the list of MaxT rans(t) for each slot t <lb/> known by u or its descendants. So this requires (N 񮽙 1) messages. <lb/>Next, the sink computes the MaxT rans(t) for each slot t and broadcasts a message that <lb/>includes T , the number of slots in the first wave and MaxT rans(t), the repetition factor <lb/>of each slot t with 1  t  T . This schedule message is broadcast to MaxDepth hops. <lb/>d) Computation of the number of slots in each wave: <lb/>Each node computes locally its slots for transmission and its slots for reception from its <lb/>children. No additional message is needed. <lb/>e) Thus, the total number of messages required to establish the schedule in the distributed <lb/>mode is (2V + 2) ⇤ (N 񮽙 1) messages + one schedule message broadcast to MaxDepth hops. <lb/>Example 1: Let us consider a tree topology with 121 nodes, a maximum depth of 4 and each <lb/>node except the leaves has exactly 3 children. <lb/>We have V = 1.983, AverageDepth = 3.52. Since 3.52  (2 ⇤ 1.983 + 1), the distributed W ave <lb/> algorithm needs more messages than any centralized scheduling algorithm. <lb/>Example 2: Let us consider a tree topology with 511 nodes, a maximum depth of 8 and each <lb/>node except the leaves has exactly 2 children. <lb/>We have V = 1.996, AverageDepth = 7. Since 7 &gt; (2 ⇤ 1.996 + 1), the distributed W ave algo-<lb/>rithm needs less messages than any centralized scheduling algorithm. <lb/> 4.3.4 Computational complexity of Wave <lb/>Property 10 The worst case computational complexity of the W ave algorithm is in O(ClogC), <lb/> where C is the number of nodes conflicting with the local node u. <lb/> Proof: The complexity of the W ave algorithm is given by the complexity of the time slot and <lb/>channel assignment in Algorithm 1. This algorithm includes a sort of the set of conflicting nodes <lb/>(see line 6), which has a complexity of O(ClogC) where C is the number of nodes conflicting <lb/>with the local node u. Let us consider the worst case where u has the smallest priority among <lb/>its conflicting nodes, except its children. Hence, u is scheduled before its children, because they <lb/>have a smaller priority than u. W ave will find a slot where u and its parent have an available <lb/>interface: in the worst case, it is the (1 + T rans(P arent(u)) + <lb/> P <lb/> v2Brother(u)  T rans(v))  th  slot. <lb/>To find an available channel, we distinguish two cases: <lb/>1. if nchannel 񮽙 C, W ave will find an available channel in this slot; <lb/>2. if nchannel &lt; C, because the children of u are not yet scheduled, W ave will find an <lb/>available channel in the worst case in the (1 + <lb/> P <lb/> v2Conf lict(u)\Children(u)  T rans(v))  th  slot. <lb/>Hence, in both cases, the complexity of the slot and channel assigment to node u is bounded by <lb/> O(C). Finally, the complexity is in O(ClogC). <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 20 <lb/></page>

			<note place="footnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			5 Evaluation of the flexibility of W ave <lb/> 5.1 Simulation parameters <lb/> In this section, we conduct a comparative performance evaluation of W ave with a well-known <lb/>centralized scheduling algorithm T MCP [7] and DeT AS [12] a distributed scheduling algorithm. <lb/>This evaluation is qualitative for DeTAS and is quantitative for TMCP. For the quantitative <lb/>evaluation, we use our simulation tool based on GNU Octave [19] to evaluate the number of slots <lb/>required by these conflict-free scheduling algorithms. The number of nodes varies from 10 to 100. <lb/>To generate routing graphs, we use the Galton-Watson process as a branching stochastic process: <lb/>the maximum number of children per node is 3. We suppose that all the nodes except the sink <lb/>have a single radio interface and we vary the number of sink radio interfaces from 1 to 3. The <lb/>number of available channels varies from 2 to 3. We consider both cases: 1) homogeneous traffic <lb/>demands, where each node different from the sink generates one packet and 2) heterogeneous <lb/>traffic demands where the number of packets locally generated on a node is randomly chosen <lb/>between 1 and 5. In the following, each result depicted in a curve is the average of 20 simulation <lb/>runs for topologies with a number of nodes  30 and 100 runs for larger topologies. <lb/>Furthermore, when it is needed, we distinguish two types of configurations: <lb/>1. T  t  configurations for which the most demanding child of the sink imposes the number of <lb/>slots needed by the schedule. <lb/>2. T  n  configurations for which the number of slots needed is more balanced between nodes. <lb/>In this section, we assume that the only topology links are the tree links, unless otherwise stated. <lb/>This assumption is not required by the W ave algorithm. We see in Subsection 5.3 how this <lb/>assumption can be relaxed. <lb/> 5.2 Homogeneous traffic <lb/> The trend as illustrated in Figure 6 shows that T  t  configurations are more greedy in terms <lb/>of number of slots to complete convergecast. Balanced routing graphs ensure smaller delays. <lb/>Indeed, while W ave needs 170 slots to complete convergecast for 100 nodes in T  t  configurations, <lb/>it requires only 118 slots in T  n  configurations. This result illustrates the good impact of a traffic-<lb/>balanced routing tree on the convergecast delays. In T  t  configurations of 100 nodes, W ave is at <lb/>18% from the optimal whereas TMCP is at 42% from the optimal. Moreover, in T  n  configurations <lb/>of 100 nodes, W ave is at 17 % from the optimal whereas TMCP is at 41% from the optimal. <lb/>This is due to the fact that TMCP partitions the network in disjoint subtrees and schedules all <lb/>subtrees in parallel, each subtree on a different channel. That is why TMCP requires a number <lb/>of channels and a number of sink interfaces equal or higher to the number of subtrees. W ave <lb/> adapts itself to both the number of channels and the number of sink interfaces available. <lb/>Notice however that in the comparative performance evaluation, the number of available <lb/>channels and the number of sink interfaces are always higher than or equal to the number of sink <lb/>children. In other words, we are always in a favorable context for TMCP. <lb/> 5.3 Support of additional links <lb/> An assumption generally made for the computation of a conflict-free schedule is that there exists <lb/>no additional links except those in the routing tree. Unfortunately, this does not match real <lb/>deployments where additional links exist. The existence of additional links is not taken into <lb/>account in DeT AS and hence may cause collisions: in the same time slot and on the same <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>21 <lb/></page> 
			
			0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave <lb/>TMCP <lb/>Optimal <lb/> a in Tt configurations <lb/> 0 <lb/> 20 <lb/>40 <lb/>60 <lb/>80 <lb/>100 <lb/>120 <lb/>140 <lb/>160 <lb/>180 <lb/>200 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave <lb/>TMCP <lb/>Optimal <lb/> b in Tn configurations <lb/> Figure 6: W ave versus optimal schedule and TMCP: homogeneous traffic <lb/>channel frequency, two conflicting transmitters may be scheduled, leading to a collision. This <lb/>is due to the simple flip-flop schedule adopted, alternating between transmit and receive slots <lb/>for each active subtree. That is why DeT AS is not suitable in such a case because it fails to <lb/>ensure deterministic medium access and bounded delays. In T MCP and W ave, additional links <lb/>are taken into account and conflicts are prevented to occur. A quantitative evaluation is done, <lb/>where 60% of existing links are added in the routing graph. <lb/>Figure 7 depicts the number of slots obtained by T MCP and W ave. The number of slots <lb/>needed is increased. This happens because additional links create more conflicts. Thus, spatial <lb/>and frequency reuse is reduced. Nevertheless, the gap between W ave with additional links and <lb/> W ave without additional links is not large. As illustrated in Figure 7, the number of slots is <lb/>increased by 8% in T  t  configurations (respectively 11% in T  n  configurations). This is due to our <lb/>accurate definition of conflicting nodes detailed in Section 3. In both types of configurations, <lb/> W ave outperforms T MCP in terms of slots even if additional links exist in the topology. For <lb/>instance, for 100 nodes, T MCP requires 15.5% (respectively 14%) additional slots compared <lb/>with W ave in T  t  configurations (respectively T  n  configurations), leading to higher data gathering <lb/>delays. <lb/> 5.4 Support of heterogeneous traffic demands <lb/> In real data gathering applications, sensor nodes have different sampling rates. Hence, sensor <lb/>nodes have heterogeneous traffic demands. <lb/>Even, if DeT AS has not been presented in [12] with heterogeneous traffic demands per node, it <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 22 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			0 <lb/> 20 <lb/>40 <lb/>60 <lb/>80 <lb/>100 <lb/>120 <lb/>140 <lb/>160 <lb/>180 <lb/>200 <lb/>220 <lb/>240 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave without additional links <lb/>Wave with additional links <lb/>TMCP without additional links <lb/>TMCP with additional links <lb/> a in Tt configurations <lb/> 0 <lb/> 20 <lb/>40 <lb/>60 <lb/>80 <lb/>100 <lb/>120 <lb/>140 <lb/>160 <lb/>180 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave without additional links <lb/>Wave with additional links <lb/>TMCP without additional links <lb/>TMCP with additional links <lb/> b in Tn configurations <lb/> Figure 7: Impact of additional links on convergecast schedule length <lb/>can be extended to support heterogeneous traffic demands. <lb/>Figure 8 depicts the number of slots obtained by T MCP and W ave, when each sensor node <lb/>generates a number of packets randomly chosen in the interval [1, 5]. T  n  configurations, which are <lb/>balanced topologies in terms of traffic, require less slots than T  t  configurations where a subtree <lb/>imposes the schedule length. As depicted in Figure 8 heterogeneous traffic results in longer <lb/>delivery times of packets (because of a higher number of needed slots). Furthermore, we observe <lb/>the same behavior of curves: W ave outperforms clearly T MCP . Indeed, the difference between <lb/> W ave and T MCP , in topologies with 100 nodes, is 50 slots in T  t  configurations (respectively 27 <lb/>slots in T  n  configurations). <lb/> 5.5 Support of a sink with multiple radio interfaces <lb/> Since a sink is a powerful entity in charge of processing data gathered without energy con-<lb/>straints, it is reasonable to equip it with multiple radio interfaces. In such conditions, the sink <lb/>equipped with ninterf radio interfaces will be able to receive in parallel from g children, with <lb/> g = min(ninterf, nchild, nchannel). This increase in communication parallelism will decrease <lb/>the data gathering delays, as shown by the simulations depicted in Figure 9. In this experiment, <lb/>the number of channels and the number of radio interfaces of the sink are equal to the number <lb/>of sink children: this is a favorable context for T MCP . <lb/>In Figure 9, a sink, equipped with three radio interfaces, reduces by 6% the convergecast <lb/>schedule length obtained by W ave in T  t  configurations (respectively 13% in T  n  configurations) <lb/>when compared to single radio sink. Indeed, in T  t  configurations, W ave schedules in the last <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>23 <lb/></page> 
			
			0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>250 <lb/>300 <lb/>350 <lb/>400 <lb/>450 <lb/>500 <lb/>550 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave: homogeneous traffic <lb/>Wave: heterogeneous traffic <lb/>TMCP: homogeneous traffic <lb/>TMCP: heterogeneous traffic <lb/> a in Tt configurations <lb/> 0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>250 <lb/>300 <lb/>350 <lb/>400 <lb/>450 <lb/>500 <lb/>550 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave: homogeneous traffic <lb/>Wave: heterogeneous traffic <lb/>TMCP: homogeneous traffic <lb/>TMCP: heterogeneous traffic <lb/> b in Tn configurations <lb/> Figure 8: W ave versus TMCP: heterogeneous traffic <lb/>time slots only the subtree rooted at the child having the highest number of transmissions. The <lb/>remaining radio interfaces are kept unused. Paradoxically, in T  n  configurations where the traffic <lb/>is balanced between all subtrees rooted at the sink children, all the radio interfaces are used <lb/>simultaneously even in the last time slots. <lb/>We can notice also that T MCP provides schedules longer than W ave even when the sink is <lb/>equipped by multiple radio interfaces. This is because T MCP schedules all nodes in the same <lb/>subtree on the same channel, unlike W ave. <lb/> Authors of DeT AS do not provide any detail how their solution could support multiple radio <lb/>interfaces for the sink. To the best of our knowledge, we are the first to propose a distributed <lb/>scheduling algorithm for IEEE 802.15.4e based networks, able to support a sink equipped with <lb/>multiple radio interfaces. <lb/> 5.6 Support of different acknowledgment policies <lb/> We first compare T MCP , DeT AS and W ave in the absence of acknowledgment. This compari-<lb/>son shows the merit of W ave in minimizing the data gathering delay. Moreover, some industrial <lb/>applications robustness requirement. This latter can be met through the immediate acknowledge-<lb/>ments of packet delivery. Obviously, immediate acknowledgements create additional conflicts as <lb/>was illustrated in Section 3. In this subsection, we assume again that the only existing topology <lb/>links are those in the routing tree and study the impact of the acknowledgment policy on the <lb/>number of slots needed. <lb/> T MCP can be extended to support the immediate acknowledgment. However, since all the <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 24 <lb/></page>

			<note place="footnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>250 <lb/>300 <lb/>350 <lb/>400 <lb/>450 <lb/>500 <lb/>550 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave <lb/>TMCP <lb/> a in Tt configurations <lb/> 0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>250 <lb/>300 <lb/>350 <lb/>400 <lb/>450 <lb/>500 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave <lb/>TMCP <lb/> b in Tn configurations <lb/> Figure 9: Impact of multiple radio interfaces on convergecast schedule length <lb/>nodes of a subtree operate on the same channel, the immediate acknowledgment policy will <lb/>induce a number of conflicts larger than W ave. Indeed, W ave takes advantage of the flexibility <lb/>of channel selection. <lb/>Figure 10 depicts the number of slots obtained by W ave without and with immediate ac-<lb/>knowledgement. The immediate acknowledgement leads to a higher number of slots. However, <lb/>the gap between the two curves is tiny (e.g. less than 3% of additional slots). This is due to our <lb/>accurate conflict definition given in Section 3. <lb/> 5.7 Support of service differentiation <lb/> In a data gathering, we can distinguish several types of traffic: regular traffic for instance cor-<lb/>responding to periodic sampling and alarm traffic corresponding to abnormal situations (e.g. <lb/>a threshold value is exceeded). To meet the application requirements, the alarm traffic has a <lb/>higher priority and is transmitted before the regular one. More generally, several classes of traffic <lb/>can be defined. Each traffic class is associated with a priority and has its own waiting queue. <lb/>These priorities are taken into account locally in each node for the selection of the next packet <lb/>to transmit at the MAC level. In the simplest way, classes are ordered by decreasing priority, <lb/>a packet of class i is scheduled if and only if there is no packet of class j &gt; i waiting to be <lb/>transmitted. If additional slots are needed to transfer the traffic of class i, node u may take them <lb/>if allowed by Properties 11 and 12, as shown in Section 6.1. Otherwise, a recomputation of the <lb/>first wave is done taking into account the new traffic demand. <lb/>In some cases, the different traffic classes are destinated to different sinks, each sink having <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>25 <lb/></page> 
			
			0 <lb/> 50 <lb/>100 <lb/>150 <lb/>200 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave with ACK <lb/>Wave without ACK <lb/> a in Tt configurations <lb/> 0 <lb/> 20 <lb/>40 <lb/>60 <lb/>80 <lb/>100 <lb/>120 <lb/>140 <lb/>160 <lb/>180 <lb/>200 <lb/>10 <lb/>20 <lb/>30 <lb/>40 <lb/>50 <lb/>60 <lb/>70 <lb/>80 <lb/>90 <lb/>100 <lb/> Number of slots <lb/> Number of nodes <lb/>Wave with ACK <lb/>Wave without ACK <lb/> b in Tn configurations <lb/> Figure 10: Impact of acknowledgment policy on convergecast schedule length <lb/>its own routing graph. Hence, several routing graphs coexist in the same LLN. This is the object <lb/>of Section 7. <lb/> 6 Impact of dynamic changes on the conflict-free schedule <lb/> In this section we study the behavior of the W ave algorithm when dynamic changes occur while <lb/>the conflict-free schedule is orchestrating the medium accesses. <lb/> 6.1 Impact of retransmissions or changes in application needs <lb/> In this subsection, we will show how the scheduling algorithm can adapt to varying traffic de-<lb/>mands. First, we notice that if the traffic is decreasing, the current schedule is still valid, even <lb/>if it could be optimized by suppressing slots that have become useless. The problem is how to <lb/>cope with demands for increasing traffic. <lb/>We distinguish two causes for higher traffic demands: <lb/> • Since we consider a lossy network, packets may be lost. In the presence of immediate <lb/>acknowledgment policy, this packet loss is detected by the sender that retransmits its <lb/>packet. These retransmissions are the first reason why the traffic demand previously done <lb/>has to be updated. <lb/> • Another reason for an update of the traffic demand is due to changes in application re-<lb/>quirements. For instance, a new traffic is created upon detection of a specific event. This <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 26 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			leads to an increased traffic demand. <lb/>In both cases, the conflict-free schedule provided by the scheduling algorithms should take <lb/>into account these new demands. <lb/>Let top subtree(u) denote the subtree rooted at a sink child that contains node u that requires <lb/>more slots to cope with a change in the application needs. <lb/> • With DeT AS, the macroschedule is a juxtaposition in time and/or frequency of microsched-<lb/>ules, each microschedule schedules a top subtree. The micro-schedule corresponding to the <lb/> top subtree(u) has to be redone. For the macroschedule, we distinguish two cases: <lb/> – if the new microschedule of top subtree(u) is the last one for its channel frequency <lb/>band in the slotframe, a valid macroschedule is obtained by just replacing the current <lb/>microschedule of the top subtree(u) by the new one, provided that it does not exceed <lb/>the slotframe. <lb/> – otherwise, the macroschedule has to be computed again. <lb/> • With T MCP , authors do not deal with retransmissions or changes in application needs. <lb/>As T MCP is a centralized solution, a new schedule has to be computed. <lb/> • W ave is able to adapt itself to take into account changes in the traffic demand of a node, <lb/>taking advantage of the following two properties: <lb/> Property 11 Any node u 6 = sink being assigned slot t in the first wave uses any slot s(t, w) in <lb/>any wave w with 1  w  T rans(u). If needed, u may also use any slot s(t, w  0  ) in any wave w  0 <lb/> with T rans(u) &lt; w  0   Maxtrans(t) provided that u transmitted in any wave w  00  with T rans(u) &lt; <lb/>w  00  &lt; w  0  . Its parent should be awake in these slots w  0  . Indeed, for energy efficiency, the parent <lb/>does not wake up systematically at every wave &gt; T rans(u) but only if its child transmitted in the <lb/>previous wave &gt; T rans(u). <lb/> Proof: Let us focus on the slot t assigned to u in the first wave. The current schedule has <lb/>taken into account exactly T rans(u) transmissions for u; hence node u uses only the T rans(u) <lb/> first reproductions of slot t that has been reproduced exactly Maxtrans(t) times. Since the <lb/>allocation of slots in the first wave takes into account the conflicts between all nodes and since <lb/>each next wave is an optimized reproduction of the first wave, there is no new conflict introduced <lb/>by the fact that u transmits in the slots T rans(u) + 1 up to Maxtrans(t). The only limitation <lb/>is that its parent should be awake. <lb/> Property 12 The sink child c being assigned slot t in the first wave and the last slot in the last <lb/>wave uses any slot s(t, w) in any wave w with 1  w  T rans(c). If needed, c may also use any <lb/>slot s(t, w  0  ) in any wave w  0  with T rans(c) &lt; w  0   Slotf ramelength+T rans(c)񮽙Schedulelength <lb/> provided that c transmitted in any wave w  00  with T rans(u) &lt; w  00  &lt; w  0  . The sink should be awake <lb/>in these slots w  0  . <lb/>Proof: The proof is similar to the previous one, except that the schedule of the last slot may <lb/>be reproduced at the end of the current schedule without compromizing the validity of this new <lb/>schedule, provided that the slots appended are compatible with the length of the slotframe. <lb/> Corollary 1 Any node u 6 = sink being assigned slot t in the first wave with T rans(u) = <lb/> Maxtrans(t) &lt; max  v6 =sink  T rans(v) that requires additional slots leads to a recomputation of <lb/>the first wave and the next ones. <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>27 <lb/></page> 
			
			6.2 Impact of a change in the routing graph or in the topology <lb/> Let us study the impact of a change in the topology or in the routing graph while the conflict-free <lb/>schedule is in use. T MCP and DeT AS do not tackle such a change. That is why this subsection <lb/>is limited to W ave. <lb/> We first notice that the breakage of a link taken into account in the computation of the <lb/>conflict-free schedule can never cause collisions. In other words, the schedule remains conflict-<lb/>free. However, if this link was the link with the preferred parent, a new preferred parent is <lb/>selected. <lb/>If now we focus on the appearance of a new link, this new link may add new conflicting nodes. <lb/>If these new conflicting nodes were scheduled in the same time slot and on the same channel, <lb/>collisions will occur. Hence, the schedule must be entirely redone. The following rule summarizes <lb/>the behavior of W ave. <lb/>Rule R5 : With W ave any node u detecting the appearance of a new link with a node v <lb/> distinguishes two cases <lb/> • v is not the new preferred parent of u, u computes its new conflicting nodes applying <lb/>Property 1 in the absence of acknowledgment and Property 2 in the presence of immediate <lb/>ackowledgment. Node u checks whether it is scheduled in the same time slot and on the <lb/>same channel as them. If so, u asks the sink for a recomputation of the first wave, which <lb/>will be followed by a local computation on all nodes of the next waves. Otherwise, the <lb/>current schedule is kept. <lb/> • v is the new preferred parent of u, W ave must recompute the first wave and then each <lb/>node will locally compute the slots granted to itself and its children in the next waves. <lb/> 7 Support of multiple routing graphs <lb/> In this section, we study the coexistence of several routing graphs in the same LLN. Two routing <lb/>graphs RG1 and RG2 are said independent if and only if no node of RG1 conflicts with a node <lb/>of RG2. <lb/> Property 13 Two routing graphs RG1 and RG2 are not independent if and only if there is a <lb/>common node belonging to both RG1 and RG2 or there is a common link between a node of RG1 <lb/> and a node of RG2. <lb/> Proof: We first prove that two routing graphs RG1 and RG2 are not independent if and only <lb/>if there exists a path of length h, with 0  h  1 between them. We proceed by contradiction, <lb/>if there exists no path between the two routing graphs, no node of RG1 would conflict with a <lb/>node of RG2. Hence the two routing graphs are independent. Consequently, there is a path <lb/>between them. Let h be the length of this path and let us assume h 񮽙 2. In the presence of <lb/>immediate acknowledgment, it is not possible to find a conflict between a node of RG1 and a <lb/>node of RG2 using the conflicts described in Property 2. Similarly, in the absence of immediate <lb/>acknowledgment, it is not possible to find a conflict between a node of RG1 and a node of RG2 <lb/> using the conflicts described in Property 1. Hence h &lt; 2. <lb/> It follows that there exists a path of length h  1. If h = 0: there is a common node belonging <lb/>to both RG1 and RG2. If h = 1: there is a common link between a node of RG1 and a node of <lb/> RG2. <lb/> Since the sink is in charge of triggering the schedule of its routing graph RG, it must know <lb/>whether RG is dependent on any other routing graph. That is why Rule R6 is applied. <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 28 <lb/></page>

			<note place="footnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			Rule R6 : Any node belonging to any routing graph RG1 that also belongs to a routing <lb/>graph RG2 sends a message to the sink of RG1 as well as the sink of RG2. Similarly, any node <lb/>belonging to any routing graph RG that has a link to a node in another routing graph sends a <lb/>message to the sink of RG. <lb/> In the following, we distinguish two cases: the routing graphs are independent or not. <lb/> 7.1 Independent routing graphs <lb/> Two independent routing graphs can be scheduled independently. Their schedule is always <lb/>conflict-free. <lb/> Property 14 If the coexisting routing graphs are all independent two-to-two, they can share the <lb/>same time slots and frequencies. The number of slots needed to schedule these routing graphs <lb/>is equal to the maximum of the number of slots needed by each of them taken separately. The <lb/>number of channels is equal to the maximum of channels needed by each of them taken separately. <lb/> Figure 11 depicts a frameslot scheduling three routing graphs RG1, RG2 and RG3. These <lb/>routing graphs are independent two-by-two. Consequently, they are all scheduled on the same <lb/>channel frequencies and in the same time slots. The number of slots needed to schedule them all <lb/>is equal to 5, which is also the number of slots needed to schedule RG1 alone. <lb/>Figure 11: Schedule of independent routing graphs. <lb/> 7.2 Dependent routing graphs <lb/> If the coexisting routing graphs are not independent, they cannot be scheduled independently: <lb/>collisions may occur during data gathering. These collisions will prevent either a receiving node <lb/>to correctly receive a data packet destinated to it, or a transmitting node to correctly receive the <lb/>acknowledgment of its data packet. Hence, such collisions must be avoided to ensure the quality <lb/>of service required by data gathering. <lb/>To prevent the occurrence of conflicts at runtime, W ave uses a coarse granularity approach. <lb/> 7.2.1 General principles <lb/> This approach prevents conflicts to occur at a coarse granularity level by applying first Rule R7 <lb/> and then Rule R8: <lb/>Rule R7 : If there exists at least one node belonging to two routing graphs RG1 and RG2, <lb/> then these routing graphs should be scheduled in different time slots (i.e. time exclusion). <lb/> Rule R8 : If there exists at least one link between a node of routing graph RG1 and a node <lb/>of routing graph RG2, then these routing graphs should be scheduled on different frequencies <lb/>(i.e. channel frequency exclusion). If this is impossible, then they are scheduled in different time <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>29 <lb/></page> 
			
			slots (i.e. time exclusion). <lb/>To apply such rules, the conflicting routing graphs have to know the time slots and the chan-<lb/>nel frequencies used by the conflicting routing graphs already scheduled. <lb/> Rule R9 : When a routing graph RG having conflicting routing graphs is scheduled, its sink <lb/>must know which time slots and which channel frequencies are used by the conflicting routing <lb/>graphs already scheduled. <lb/>We can upper bound the number of slots needed by the coexistence of dependent routing <lb/>graphs as follows. <lb/> Property 15 If RG1 and RG2 are two routing graphs such there exists at least one common <lb/>node, then the number of slots needed to schedule both graphs is given by S  1  + S  2  , where S  i  is <lb/>the number of slots required by RGi taken alone, with i = 1 or 2. The number of channels is <lb/>given by max(Ch  1  , Ch  2  ), where Ch  i  is the number of channels required by RGi taken alone, with <lb/> i = 1 or 2. <lb/> Proof: This is deduced from Rule R7. <lb/> Property 16 If RG1 and RG2 are two routing graphs such there exists at least one link between <lb/>a node in RG1 and a node in RG2 and there is no common node, then the number of slots needed <lb/>to schedule both graphs is given by max(S  1  , S  2  ), where S  i  is the number of slots required by RGi <lb/> taken alone, with i = 1 or 2. The number of channels is given by Ch  1  + Ch  2  , where Ch  i  is the <lb/>number of channels required by RGi taken alone, with i = 1 or 2. <lb/> Proof: This is deduced from Rule R8. <lb/> Figure 12 depicts a frameslot scheduling three routing graphs RG1, RG2 and RG3. These <lb/>routing graphs are such that RG1 and RG2 share a common link, RG2 and RG3 share a common <lb/>node, whereas RG1 and RG3 share a common link. Consequently, RG2 and RG3 are scheduled <lb/>one after the other (i.e. time exclusion), whereas RG1 and RG2 are scheduled simultaneously, <lb/>but on different channel frequencies, similarly for RG1 and RG3. Indeed, according to Rule R8, <lb/> the sink of RG2 has to know that the channel frequencies f  1  to f  3  are already used by RG1 and <lb/>schedules itself in frequencies f  4  and f  5  . Similarly, according to rules R7 and R8, the sink of <lb/> RG3 has to know that the slots 1 to 3 are used by RG2 and the frequencies f  1  to f  3  are already <lb/>used by RG1. Hence, RG3 schedules itself in frequencies f  4  and f  5  after the slots used by RG2. <lb/> Figure 12: Schedule of dependent routing graphs. <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 30 <lb/></page>

			<note place="headnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			7.2.2 Illustrative example <lb/> We illustrate these properties with two routing graphs RG1 and RG2 depicted in Figure 13. The <lb/>corresponding schedules without acknowledgement of each routing graph taken separately are <lb/>given in Table 2 and Table 3. Each of them taken separately needs 7 slots to complete its raw <lb/>data convergecast. In addition, RG1 requires one channel whereas RG2 needs two channels. <lb/> a Routing graph RG1 <lb/>b Routing graph RG2 <lb/> Figure 13: The two routing graphs RG1 and RG2 <lb/>Table 2: Schedule of the first routing graph RG1 taken separately <lb/> Ch\S <lb/> 1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2! 1 <lb/> 7!3 <lb/>5!2 <lb/>6!2 <lb/>8!4 <lb/> Table 3: Schedule of the second routing graph RG2 taken separately <lb/> Ch\S <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>1 <lb/>12!10 <lb/>11!10 <lb/>14!11 <lb/>12!10 <lb/>11!10 <lb/>12!10 <lb/>11!10 <lb/>13!11 <lb/>15!12 <lb/>15!12 <lb/>2 <lb/>16!15 <lb/> Figure 14 depicts RG1 and RG2 having a common node: node 4 = node 12. Table 4 illustrates <lb/>the schedules of RG1 and RG2 with common node 4. Nodes activities belonging to RG1 are <lb/>scheduled in the first 7 slots whereas nodes that belong to RG2 are scheduled in the next 7 slots, <lb/>leading to a total number of 14 slots. <lb/>Figure 15 depicts RG1 and RG2 having a common link between node 4 and node 12. Table 5 <lb/>depicts the schedules of RG1 and RG2 in case of common link. W ave schedules nodes in RG1 <lb/>on channel 1 while nodes that belong to RG2 are scheduled on channel 2 and channel 3. Hence, <lb/>the number of channels needed is 1 + 2 = 3. Frequency exclusion is applied. <lb/> 8 Conclusion <lb/> In this paper, we have presented W ave a distributed conflict-free scheduling algorithm for raw <lb/>data convergecast in IEEE 802.15.4e based networks. This algorithm provides a schedule based <lb/>on waves. The i  th  wave schedules the i  th  transmission of nodes having at least i packets to <lb/>transmit. As a consequence, the size of wave decreases progressively because nodes complete <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>31 <lb/></page> 
			
			Figure 14: RG1 and RG2 having a common node. <lb/>Table 4: Schedule of RG1 and RG2 having a common node <lb/> Ch\S <lb/> 1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>8 <lb/>9 <lb/>10 <lb/>... <lb/>1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2!1 <lb/>4!10 <lb/>11!10 <lb/>14!11 <lb/>7!3 <lb/>5!2 <lb/>6!2 <lb/>13!11 <lb/>15!4 <lb/>... <lb/>8!4 <lb/>2 <lb/>16!15 <lb/>... <lb/>Ch\S <lb/>... <lb/>11 <lb/>12 <lb/>13 <lb/>14 <lb/>1 <lb/>4!10 <lb/>11!10 <lb/>4!10 <lb/>11!10 <lb/>... <lb/>15!4 <lb/>2 <lb/>... <lb/> Figure 15: RG1 and RG2 having a common link. <lb/>Table 5: Schedule of RG1 and RG2 having a common link. <lb/> Ch\S <lb/>1 <lb/>2 <lb/>3 <lb/>4 <lb/>5 <lb/>6 <lb/>7 <lb/>1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2!1 <lb/>3!1 <lb/>4!1 <lb/>2!1 <lb/>7!3 <lb/>5!2 <lb/>6!2 <lb/>8!4 <lb/>2 <lb/>12!10 <lb/>11!10 <lb/>14!11 <lb/>12!10 <lb/>11!10 <lb/>12!10 <lb/>11!10 <lb/>13!11 <lb/>15!12 <lb/>15!12 <lb/>3 <lb/>16!15 <lb/> their transmissions gradually. The complexity of the algorithm lies in the computation of the <lb/>first wave. For the next waves, each node is able to determine locally its slots and the slots <lb/>assigned to its children. <lb/>Like in any medium access based on a conflict-free schedule, a node is awake only in its slots <lb/>to transmit its packets and in the slots of its children to receive their packets. It sleeps the <lb/> 
			
			<note place="footnote">RR n° 8661 <lb/></note>

			<page> 32 <lb/></page>

			<note place="footnote">Soua &amp; Minet &amp; Livolant <lb/></note> 
			
			remaining time to save energy. <lb/>Like in any medium access based on channel hopping, the robustness against interferences <lb/>is increased: interferences are mitigated over time and bad channels can be blacklisted and <lb/>excluded from the channel hopping. The multichannel communication paradigm contributes to <lb/>increase the parallelism and the efficiency of the slots assigned, leading to a higher throughput. <lb/>Since W ave targets a minimum number of slots taking advantage of an accurate definition of <lb/>conflicting transmissions, the data gathering delays are minimized. <lb/>Furthermore, in an industrial environment, it is usual to find: <lb/> • topology links in addition to those belonging to the routing graph. <lb/> • heterogeneous traffic demands: since sensor nodes usually have different sampling rates, <lb/>they generate different numbers of packets in a data gathering cycle. <lb/> • different acknowledgment policies: without acknowledgment or with immediate acknowl-<lb/>edgment. <lb/> • a sink equipped with multiple radio interfaces. <lb/> • coexistence of several routing graphs. <lb/> W ave is designed to support these features, as shown by simulation results comparing its <lb/>performances with these of T MCP . We studied how W ave can cope with dynamic changes <lb/>while the conflict-free schedule is orchestrating the medium accesses. Concerning the support of <lb/>multiple routing graphs, we show how W ave is easily extended to prevent conflicts. <lb/>In a further work, we will consider that some intermediate nodes are able to aggregate data <lb/>packets and extend W ave to support raw and aggregated convergecasts. <lb/></body>

			<listBibl> References <lb/> [1] O. D. Incel, A. Gosh, B. Krishnamachari, K. Chintalapudi, Fast data Collection in Tree-<lb/>Based Wireless Sensor Networks, IEEE Transactions on Mobile computing, vol. 1, pp. 86-99, <lb/>2012. <lb/>[2] Institute of Electrical and Electronics Engineers (IEEE). 802.15.4e-2012: IEEE Standard for <lb/>Local and Metropolitan Area Networks-Part 15.4: Low Rate Wireless Personal Area Networks <lb/>(LR-WPANs) Amendment 1: MAC Sublayer, April 16, 2012. <lb/>[3] J. Song, S. Han, A. K. Mok, D. Chen, M. Lucas, M. Nixon, WirelessHART: Applying Wireless <lb/>Technology in Real-Time Industrial Process Control, RTAS&apos;08, MO, United States, April, <lb/>2008. <lb/>[4] H. Zhang, P. Soldati, M. Johansson, Optimal Link scheduling and channel Assignment for <lb/>convergecast in linear WirelessHART Networks, In. Proc. international conference on Model-<lb/>ing and Optimization in Mobile, Ad Hoc, and Wireless Networks (WiOPT&apos;09), Seoul, Korea, <lb/>June, 2009. <lb/>[5] R. Soua, E. Livolant, P. Minet, Adaptive Strategy for an Optimized Collision-Free Slot Assign-<lb/>ment in Multichannel Wireless Sensor Networks, Journal of Sensor and Actuator Networks, <lb/>Special Issue on Advances in Sensor Network Operating Systems, July 2013. <lb/>[6] C. H. Papadimitriou, The complexity of the capacitated tree problem, Networks, vol. 8, no. 3, <lb/>pp. 217-230, 1978. <lb/> 
			
			<note place="footnote">Inria <lb/></note> 
			
			<note place="headnote">Wave <lb/></note> 
			
			<page>33 <lb/></page> 
			
			[7] Y. Wu, J. Stankovic, T. He, S. Lin, Realistic and efficient multi-channel communications in <lb/>wireless sensor networks, In. Proc. INFOCOM&apos;08, Phoenix, AZ, USA, 2008. <lb/>[8] M. Rita, N. Accettura, M. Dohler, L. A. Grieco, and G. Boggia, Traffic Aware Scheduling <lb/>Algorithm for reliable low-power multi-hop IEEE 802.15.4e networks, PIMRC&apos;12, Sydney, <lb/>Australia, 2012. <lb/>[9] R. Soua, P. Minet, E. Livolant, MODESA: an Optimized Multichannel Slot Assignment for <lb/>Raw Data Convergecast in Wireless Sensor Networks, IPCCC 2012, Austin, Texas, December <lb/>2012. <lb/>[10] O.D. Incel, A. Gosh, B. Krishnamachari, K. Chintalapudi, Multi-Channel Scheduling for <lb/>Fast Convergecasst in Wireless Sensor Networks, USC CENG Technical report CENG-2008-<lb/>9. <lb/>[11] S. Ghandham, Y. Zhang, and Q. Huang, Distributed Time-Optimal Scheduling for Con-<lb/>vergescast in Wireless Sensors Networks, Computing Network, vol. 52, no. 3, pp. 610-629, <lb/>2008. <lb/>[12] N. Accettura, M. R. Palattela, G. Boggia, L. A. Grieco, M. Dohler, Decentralized Traf-<lb/>fic Aware Scheduling for Multi-hop Low Power Lossy Networks in the Internet of Things, <lb/>WoWMoM&apos;13, Madrid, Spain, 2013. <lb/>[13] A. Morell, X. Vilajosana, J. L. Vicario, T. Watteyne, Label switching over IEEE802.15.4e <lb/>networks. Transactions on Emerging Telecommunications Technologies 24(5), 2013. <lb/>[14] T. Winter, P. Thubert, A. Brandt, T. Clausen, J. K. Hui, P. Levis, K. Pister, R. Struik, <lb/>JP. Vasseur, RPL: IPv6 Routing Protocol for Low power and Lossy networks, IETF ROLL <lb/>Working Group draft, September 2011. <lb/>[15] S. Mahfoudh, P. Minet, I. Amdouni, Energy efficient routing and node activity scheduling <lb/>in the OCARI wireless sensor network, Future Internet 2010, 2(3), 308-340, August 2010. <lb/>[16] J. Faruque, K. Psounis, A. Helmy, Analysis of Gradient-Based Routing Protocols in Sensor <lb/>Networks, IEEE/ACM DCOSS 2005, Marina del Rey, CA, June 2005. <lb/>[17] R. Soua, P. Minet, E. Livolant, A distributed joint channel and slot assignment for con-<lb/>vergecast in wireless sensor networks, NTMS 2014, Dubai, United Arab Emirates, March <lb/>2014. <lb/>[18] IETF, Mobile Ad Hoc Network (MANET) Neighborhood Discovery Protocol (NHDP), RFC <lb/>6130, IETF, April 2011. <lb/>[19] http://www.gnu.org/software/octave/ <lb/> </listBibl>
			
			<note place="footnote">RR n° 8661 <lb/></note> 
			
			<note place="footnote">RESEARCH CENTRE <lb/>PARIS – ROCQUENCOURT <lb/> Domaine de Voluceau, -Rocquencourt <lb/>B.P. 105 -78153 Le Chesnay Cedex <lb/></note>
			
			<note place="footnote">Publisher <lb/>Inria <lb/>Domaine de Voluceau -Rocquencourt <lb/>BP 105 -78153 Le Chesnay Cedex <lb/>inria.fr <lb/>ISSN 0249-6399</note> 


	</text>
</tei>
