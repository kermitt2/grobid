<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>server date 20190710; downloaded by EPO on 20190711 <lb/>Internet Engineering Task Force (IETF) <lb/>G. Selander <lb/>Request for Comments: 8613 <lb/>J. Mattsson <lb/>Updates: 7252 <lb/>F. Palombini <lb/>Category: Standards Track <lb/>Ericsson AB <lb/>ISSN: 2070-1721 <lb/>L. Seitz <lb/>RISE <lb/>July 2019 <lb/>Object Security for Constrained RESTful Environments (OSCORE) <lb/>Abstract <lb/>This document defines Object Security for Constrained RESTful <lb/>Environments (OSCORE), a method for application-layer protection of <lb/>the Constrained Application Protocol (CoAP), using CBOR Object <lb/>Signing and Encryption (COSE). OSCORE provides end-to-end protection <lb/>between endpoints communicating using CoAP or CoAP-mappable HTTP. <lb/>OSCORE is designed for constrained nodes and networks supporting a <lb/>range of proxy operations, including translation between different <lb/>transport protocols. <lb/>Although an optional functionality of CoAP, OSCORE alters CoAP <lb/>options processing and IANA registration. Therefore, this document <lb/>updates RFC 7252. <lb/>Status of This Memo <lb/>This is an Internet Standards Track document. <lb/>This document is a product of the Internet Engineering Task Force <lb/>(IETF). It represents the consensus of the IETF community. It has <lb/>received public review and has been approved for publication by the <lb/>Internet Engineering Steering Group (IESG). Further information on <lb/>Internet Standards is available in Section 2 of RFC 7841. <lb/>Information about the current status of this document, any errata, <lb/>and how to provide feedback on it may be obtained at <lb/>https://www.rfc-editor.org/info/rfc8613. <lb/>Selander, et al. <lb/>Standards Track <lb/>[Page 1] <lb/>RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/>Copyright Notice <lb/>Copyright (c) 2019 IETF Trust and the persons identified as the <lb/>document authors. All rights reserved. <lb/>This document is subject to BCP 78 and the IETF Trust&apos;s Legal <lb/>Provisions Relating to IETF Documents <lb/>(https://trustee.ietf.org/license-info) in effect on the date of <lb/>publication of this document. Please review these documents <lb/>carefully, as they describe your rights and restrictions with respect <lb/>to this document. Code Components extracted from this document must <lb/>include Simplified BSD License text as described in Section 4.e of <lb/>the Trust Legal Provisions and are provided without warranty as <lb/>described in the Simplified BSD License. <lb/></front>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 2] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<div type="toc">Table of Contents <lb/>1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>1.1. Terminology . . . . . . . . . . . . . . . . . . . . . . . <lb/>7 <lb/>2. The OSCORE Option . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>3. The Security Context . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>3.1. Security Context Definition . . . . . . . . . . . . . . . <lb/>9 <lb/>3.2. Establishment of Security Context Parameters . . . . . . 11 <lb/>3.3. Requirements on the Security Context Parameters . . . . . 14 <lb/>4. Protected Message Fields . . . . . . . . . . . . . . . . . . 15 <lb/>4.1. CoAP Options . . . . . . . . . . . . . . . . . . . . . . 16 <lb/>4.2. CoAP Header Fields and Payload . . . . . . . . . . . . . 24 <lb/>4.3. Signaling Messages . . . . . . . . . . . . . . . . . . . 25 <lb/>5. The COSE Object . . . . . . . . . . . . . . . . . . . . . . . 26 <lb/>5.1. ID Context and &apos;kid context&apos; . . . . . . . . . . . . . . 27 <lb/>5.2. AEAD Nonce . . . . . . . . . . . . . . . . . . . . . . . 28 <lb/>5.3. Plaintext . . . . . . . . . . . . . . . . . . . . . . . . 29 <lb/>5.4. Additional Authenticated Data . . . . . . . . . . . . . . 30 <lb/>6. OSCORE Header Compression . . . . . . . . . . . . . . . . . . 31 <lb/>6.1. Encoding of the OSCORE Option Value . . . . . . . . . . . 32 <lb/>6.2. Encoding of the OSCORE Payload . . . . . . . . . . . . . 33 <lb/>6.3. Examples of Compressed COSE Objects . . . . . . . . . . . 33 <lb/>7. Message Binding, Sequence Numbers, Freshness, and Replay <lb/>Protection . . . . . . . . . . . . . . . . . . . . . . . . . 36 <lb/>7.1. Message Binding . . . . . . . . . . . . . . . . . . . . . 36 <lb/>7.2. Sequence Numbers . . . . . . . . . . . . . . . . . . . . 36 <lb/>7.3. Freshness . . . . . . . . . . . . . . . . . . . . . . . . 36 <lb/>7.4. Replay Protection . . . . . . . . . . . . . . . . . . . . 37 <lb/>7.5. Losing Part of the Context State . . . . . . . . . . . . 38 <lb/>8. Processing . . . . . . . . . . . . . . . . . . . . . . . . . 39 <lb/>8.1. Protecting the Request . . . . . . . . . . . . . . . . . 39 <lb/>8.2. Verifying the Request . . . . . . . . . . . . . . . . . . 40 <lb/>8.3. Protecting the Response . . . . . . . . . . . . . . . . . 41 <lb/>8.4. Verifying the Response . . . . . . . . . . . . . . . . . 43 <lb/>9. Web Linking . . . . . . . . . . . . . . . . . . . . . . . . . 44 <lb/>10. CoAP-to-CoAP Forwarding Proxy . . . . . . . . . . . . . . . . 45 <lb/>11. HTTP Operations . . . . . . . . . . . . . . . . . . . . . . . 46 <lb/>11.1. The HTTP OSCORE Header Field . . . . . . . . . . . . . . 46 <lb/>11.2. CoAP-to-HTTP Mapping . . . . . . . . . . . . . . . . . . 47 <lb/>11.3. HTTP-to-CoAP Mapping . . . . . . . . . . . . . . . . . . 48 <lb/>11.4. HTTP Endpoints . . . . . . . . . . . . . . . . . . . . . 48 <lb/>11.5. Example: HTTP Client and CoAP Server . . . . . . . . . . 48 <lb/>11.6. Example: CoAP Client and HTTP Server . . . . . . . . . . 50 <lb/>12. Security Considerations . . . . . . . . . . . . . . . . . . . 51 <lb/>12.1. End-to-end Protection . . . . . . . . . . . . . . . . . 51 <lb/>12.2. Security Context Establishment . . . . . . . . . . . . . 52 <lb/>12.3. Master Secret . . . . . . . . . . . . . . . . . . . . . 52 <lb/>12.4. Replay Protection . . . . . . . . . . . . . . . . . . . 53 <lb/></div>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 3] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<div type="toc">12.5. Client Aliveness . . . . . . . . . . . . . . . . . . . . 53 <lb/>12.6. Cryptographic Considerations . . . . . . . . . . . . . . 53 <lb/>12.7. Message Segmentation . . . . . . . . . . . . . . . . . . 54 <lb/>12.8. Privacy Considerations . . . . . . . . . . . . . . . . . 54 <lb/>13. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 55 <lb/>13.1. COSE Header Parameters Registry . . . . . . . . . . . . 55 <lb/>13.2. CoAP Option Numbers Registry . . . . . . . . . . . . . . 55 <lb/>13.3. CoAP Signaling Option Numbers Registry . . . . . . . . . 56 <lb/>13.4. Header Field Registrations . . . . . . . . . . . . . . . 57 <lb/>13.5. Media Type Registration . . . . . . . . . . . . . . . . 57 <lb/>13.6. CoAP Content-Formats Registry . . . . . . . . . . . . . 58 <lb/>13.7. OSCORE Flag Bits Registry . . . . . . . . . . . . . . . 58 <lb/>13.8. Expert Review Instructions . . . . . . . . . . . . . . . 59 <lb/>14. References . . . . . . . . . . . . . . . . . . . . . . . . . 60 <lb/>14.1. Normative References . . . . . . . . . . . . . . . . . . 60 <lb/>14.2. Informative References . . . . . . . . . . . . . . . . . 62 <lb/>Appendix A. Scenario Examples . . . . . . . . . . . . . . . . . 65 <lb/>A.1. Secure Access to Sensor . . . . . . . . . . . . . . . . . 65 <lb/>A.2. Secure Subscribe to Sensor . . . . . . . . . . . . . . . 66 <lb/>Appendix B. Deployment Examples . . . . . . . . . . . . . . . . 68 <lb/>B.1. Security Context Derived Once . . . . . . . . . . . . . . 68 <lb/>B.2. Security Context Derived Multiple Times . . . . . . . . . 70 <lb/>Appendix C. Test Vectors . . . . . . . . . . . . . . . . . . . . 75 <lb/>C.1. Test Vector 1: Key Derivation with Master Salt . . . . . 75 <lb/>C.2. Test Vector 2: Key Derivation without Master Salt . . . . 77 <lb/>C.3. Test Vector 3: Key Derivation with ID Context . . . . . . 78 <lb/>C.4. Test Vector 4: OSCORE Request, Client . . . . . . . . . . 80 <lb/>C.5. Test Vector 5: OSCORE Request, Client . . . . . . . . . . 81 <lb/>C.6. Test Vector 6: OSCORE Request, Client . . . . . . . . . . 82 <lb/>C.7. Test Vector 7: OSCORE Response, Server . . . . . . . . . 84 <lb/>C.8. Test Vector 8: OSCORE Response with Partial IV, Server . 85 <lb/>Appendix D. Overview of Security Properties . . . . . . . . . . 86 <lb/>D.1. Threat Model . . . . . . . . . . . . . . . . . . . . . . 86 <lb/>D.2. Supporting Proxy Operations . . . . . . . . . . . . . . . 87 <lb/>D.3. Protected Message Fields . . . . . . . . . . . . . . . . 87 <lb/>D.4. Uniqueness of (key, nonce) . . . . . . . . . . . . . . . 88 <lb/>D.5. Unprotected Message Fields . . . . . . . . . . . . . . . 89 <lb/>Appendix E. CDDL Summary . . . . . . . . . . . . . . . . . . . . 93 <lb/>Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . 94 <lb/>Authors&apos; Addresses . . . . . . . . . . . . . . . . . . . . . . . 94 <lb/></div>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 4] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>1. Introduction <lb/>The Constrained Application Protocol (CoAP) [RFC7252] is a web <lb/>transfer protocol designed for constrained nodes and networks <lb/>[RFC7228]; CoAP may be mapped from HTTP [RFC8075]. CoAP specifies <lb/>the use of proxies for scalability and efficiency and references DTLS <lb/>[RFC6347] for security. CoAP-to-CoAP, HTTP-to-CoAP, and CoAP-to-HTTP <lb/>proxies require DTLS or TLS [RFC8446] to be terminated at the proxy. <lb/>Therefore, the proxy not only has access to the data required for <lb/>performing the intended proxy functionality, but is also able to <lb/>eavesdrop on, or manipulate any part of, the message payload and <lb/>metadata in transit between the endpoints. The proxy can also <lb/>inject, delete, or reorder packets since they are no longer protected <lb/>by (D)TLS. <lb/>This document defines the Object Security for Constrained RESTful <lb/>Environments (OSCORE) security protocol, protecting CoAP and CoAP-<lb/>mappable HTTP requests and responses end-to-end across intermediary <lb/>nodes such as CoAP forward proxies and cross-protocol translators <lb/>including HTTP-to-CoAP proxies [RFC8075]. In addition to the core <lb/>CoAP features defined in [RFC7252], OSCORE supports the Observe <lb/>[RFC7641], Block-wise [RFC7959], and No-Response [RFC7967] options, <lb/>as well as the PATCH and FETCH methods [RFC8132]. An analysis of <lb/>end-to-end security for CoAP messages through some types of <lb/>intermediary nodes is performed in [CoAP-E2E-Sec]. OSCORE <lb/>essentially protects the RESTful interactions: the request method, <lb/>the requested resource, the message payload, etc. (see Section 4), <lb/>where &quot;RESTful&quot; refers to the Representational State Transfer (REST) <lb/>Architecture [REST]. OSCORE protects neither the CoAP messaging <lb/>layer nor the CoAP Token, which may change between the endpoints; <lb/>therefore, those are processed as defined in [RFC7252]. <lb/>Additionally, since the message formats for CoAP over unreliable <lb/>transport [RFC7252] and for CoAP over reliable transport [RFC8323] <lb/>differ only in terms of CoAP messaging layer, OSCORE can be applied <lb/>to both unreliable and reliable transports (see Figure 1). <lb/>OSCORE works in very constrained nodes and networks, thanks to its <lb/>small message size and the restricted code and memory requirements in <lb/>addition to what is required by CoAP. Examples of the use of OSCORE <lb/>are given in Appendix A. OSCORE may be used over any underlying <lb/>layer, such as UDP or TCP, and with non-IP transports (e.g., <lb/>[CoAP-802.15.4]). OSCORE may also be used in different ways with <lb/>HTTP. OSCORE messages may be transported in HTTP, and OSCORE may <lb/>also be used to protect CoAP-mappable HTTP messages, as described <lb/>below. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 5] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>+-----------------------------------+ <lb/>| <lb/>Application <lb/>| <lb/>+-----------------------------------+ <lb/>+-----------------------------------+ \ <lb/>| Requests / Responses / Signaling | | <lb/>|-----------------------------------| | <lb/>| <lb/>OSCORE <lb/>| | CoAP <lb/>|-----------------------------------| | <lb/>| Messaging Layer / Message Framing | | <lb/>+-----------------------------------+ / <lb/>+-----------------------------------+ <lb/>| <lb/>UDP / TCP / ... <lb/>| <lb/>+-----------------------------------+ <lb/>Figure 1: Abstract Layering of CoAP with OSCORE <lb/>OSCORE is designed to protect as much information as possible while <lb/>still allowing CoAP proxy operations (Section 10). It works with <lb/>existing CoAP-to-CoAP forward proxies [RFC7252], but an OSCORE-aware <lb/>proxy will be more efficient. HTTP-to-CoAP proxies [RFC8075] and <lb/>CoAP-to-HTTP proxies can also be used with OSCORE, as specified in <lb/>Section 11. OSCORE may be used together with TLS or DTLS over one or <lb/>more hops in the end-to-end path, e.g., transported with HTTPS in one <lb/>hop and with plain CoAP in another hop. The use of OSCORE does not <lb/>affect the URI scheme; therefore, OSCORE can be used with any URI <lb/>scheme defined for CoAP or HTTP. The application decides the <lb/>conditions for which OSCORE is required. <lb/>OSCORE uses pre-shared keys that may have been established out-of-<lb/>band or with a key establishment protocol (see Section 3.2). The <lb/>technical solution builds on CBOR Object Signing and Encryption <lb/>(COSE) [RFC8152], providing end-to-end encryption, integrity, replay <lb/>protection, and binding of response to request. A compressed version <lb/>of COSE is used, as specified in Section 6. The use of OSCORE is <lb/>signaled in CoAP with a new option (Section 2), and in HTTP with a <lb/>new header field (Section 11.1) and content type (Section 13.5). The <lb/>solution transforms a CoAP/HTTP message into an &quot;OSCORE message&quot; <lb/>before sending, and vice versa after receiving. The OSCORE message <lb/>is a CoAP/HTTP message related to the original message in the <lb/>following way: the original CoAP/HTTP message is translated to CoAP <lb/>(if not already in CoAP) and protected in a COSE object. The <lb/>encrypted message fields of this COSE object are transported in the <lb/>CoAP payload/HTTP body of the OSCORE message, and the OSCORE option/ <lb/>header field is included in the message. A sketch of an exchange of <lb/>OSCORE messages, in the case of the original message being CoAP, is <lb/>provided in Figure 2. The use of OSCORE with HTTP is detailed in <lb/>Section 11. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 6] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Client <lb/>Server <lb/>| <lb/>OSCORE request -POST example.com: <lb/>| <lb/>| <lb/>Header, Token, <lb/>| <lb/>| <lb/>Options: OSCORE, ..., <lb/>| <lb/>| <lb/>Payload: COSE ciphertext <lb/>| <lb/>+---------------------------------------------&gt;| <lb/>| <lb/>| <lb/>|&lt;---------------------------------------------+ <lb/>| <lb/>OSCORE response -2.04 (Changed): <lb/>| <lb/>| <lb/>Header, Token, <lb/>| <lb/>| <lb/>Options: OSCORE, ..., <lb/>| <lb/>| <lb/>Payload: COSE ciphertext <lb/>| <lb/>| <lb/>| <lb/>Figure 2: Sketch of CoAP with OSCORE <lb/>An implementation supporting this specification MAY implement only <lb/>the client part, MAY implement only the server part, or MAY implement <lb/>only one of the proxy parts. <lb/>1.1. Terminology <lb/>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, <lb/>&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and <lb/>&quot;OPTIONAL&quot; in this document are to be interpreted as described in <lb/>BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all <lb/>capitals, as shown here. <lb/>Readers are expected to be familiar with the terms and concepts <lb/>described in CoAP [RFC7252], COSE [RFC8152], Concise Binary Object <lb/>Representation (CBOR) [RFC7049], Concise Data Definition Language <lb/>(CDDL) [RFC8610] as summarized in Appendix E, and constrained <lb/>environments [RFC7228]. Additional optional features include Observe <lb/>[RFC7641], Block-wise [RFC7959], No-Response [RFC7967] and CoAP over <lb/>reliable transport [RFC8323]. <lb/>The term &quot;hop&quot; is used to denote a particular leg in the end-to-end <lb/>path. The concept &quot;hop-by-hop&quot; (as in &quot;hop-by-hop encryption&quot; or <lb/>&quot;hop-by-hop fragmentation&quot;) opposed to &quot;end-to-end&quot;, is used in this <lb/>document to indicate that the messages are processed accordingly in <lb/>the intermediaries, rather than just forwarded to the next node. <lb/>The term &quot;stop processing&quot; is used throughout the document to denote <lb/>that the message is not passed up to the CoAP request/response layer <lb/>(see Figure 1). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 7] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The terms Common Context, Sender Context, Recipient Context, Master <lb/>Secret, Master Salt, Sender ID, Sender Key, Recipient ID, Recipient <lb/>Key, ID Context, and Common IV are defined in Section 3.1. <lb/>2. The OSCORE Option <lb/>The OSCORE option defined in this section (see Figure 3, which <lb/>extends &quot;Table 4: Options&quot; of [RFC7252]) indicates that the CoAP <lb/>message is an OSCORE message and that it contains a compressed COSE <lb/>object (see Sections 5 and 6). The OSCORE option is critical, safe <lb/>to forward, part of the cache key, and not repeatable. <lb/>+------+---+---+---+---+----------------+--------+--------+---------+ <lb/>| No. | C | U | N | R | Name <lb/>| Format | Length | Default | <lb/>+------+---+---+---+---+----------------+--------+--------+---------+ <lb/>| <lb/>9 | x | <lb/>| <lb/>| <lb/>| OSCORE <lb/>| (*) <lb/>| 0-255 | (none) | <lb/>+------+---+---+---+---+----------------+--------+--------+---------+ <lb/>C = Critical, <lb/>U = Unsafe, <lb/>N = NoCacheKey, <lb/>R = Repeatable <lb/>(*) See below. <lb/>Figure 3: The OSCORE Option <lb/>The OSCORE option includes the OSCORE flag bits (Section 6), the <lb/>Sender Sequence Number, the Sender ID, and the ID Context when these <lb/>fields are present (Section 3). The detailed format and length is <lb/>specified in Section 6. If the OSCORE flag bits are all zero (0x00), <lb/>the option value SHALL be empty (Option Length = 0). An endpoint <lb/>receiving a CoAP message without payload that also contains an OSCORE <lb/>option SHALL treat it as malformed and reject it. <lb/>A successful response to a request with the OSCORE option SHALL <lb/>contain the OSCORE option. Whether error responses contain the <lb/>OSCORE option depends on the error type (see Section 8). <lb/>For CoAP proxy operations, see Section 10. <lb/>3. The Security Context <lb/>OSCORE requires that client and server establish a shared security <lb/>context used to process the COSE objects. OSCORE uses COSE with an <lb/>Authenticated Encryption with Associated Data (AEAD, [RFC5116]) <lb/>algorithm for protecting message data between a client and a server. <lb/>In this section, we define the security context and how it is derived <lb/>in client and server based on a shared secret and a key derivation <lb/>function. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 8] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>3.1. Security Context Definition <lb/>The security context is the set of information elements necessary to <lb/>carry out the cryptographic operations in OSCORE. For each endpoint, <lb/>the security context is composed of a &quot;Common Context&quot;, a &quot;Sender <lb/>Context&quot;, and a &quot;Recipient Context&quot;. <lb/>The endpoints protect messages to send using the Sender Context and <lb/>verify messages received using the Recipient Context; both contexts <lb/>being derived from the Common Context and other data. Clients and <lb/>servers need to be able to retrieve the correct security context to <lb/>use. <lb/>An endpoint uses its Sender ID (SID) to derive its Sender Context; <lb/>the other endpoint uses the same ID, now called Recipient ID (RID), <lb/>to derive its Recipient Context. In communication between two <lb/>endpoints, the Sender Context of one endpoint matches the Recipient <lb/>Context of the other endpoint, and vice versa. Thus, the two <lb/>security contexts identified by the same IDs in the two endpoints are <lb/>not the same, but they are partly mirrored. Retrieval and use of the <lb/>security context are shown in Figure 4. <lb/>.---------------------. <lb/>.---------------------. <lb/>| <lb/>Common Context <lb/>| = | <lb/>Common Context <lb/>| <lb/>+---------------------+ <lb/>+---------------------+ <lb/>| <lb/>Sender Context <lb/>| = | Recipient Context | <lb/>+---------------------+ <lb/>+---------------------+ <lb/>| Recipient Context | = | <lb/>Sender Context <lb/>| <lb/>&apos;---------------------&apos; <lb/>&apos;---------------------&apos; <lb/>Client <lb/>Server <lb/>| <lb/>| <lb/>Retrieve context for | OSCORE request: <lb/>| <lb/>target resource <lb/>| <lb/>Token = Token1, <lb/>| <lb/>Protect request with | <lb/>kid = SID, ... <lb/>| <lb/>Sender Context <lb/>+----------------------&gt;| Retrieve context with <lb/>| <lb/>| RID = kid <lb/>| <lb/>| Verify request with <lb/>| <lb/>| Recipient Context <lb/>| OSCORE response: <lb/>| Protect response with <lb/>| <lb/>Token = Token1, ... | Sender Context <lb/>Retrieve context with |&lt;----------------------+ <lb/>Token = Token1 <lb/>| <lb/>| <lb/>Verify request with <lb/>| <lb/>| <lb/>Recipient Context <lb/>| <lb/>| <lb/>Figure 4: Retrieval and Use of the Security Context <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 9] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The Common Context contains the following parameters: <lb/>o AEAD Algorithm. The COSE AEAD algorithm to use for encryption. <lb/>o HKDF Algorithm. An HMAC-based key derivation function (HKDF, <lb/>[RFC5869]) used to derive the Sender Key, Recipient Key, and <lb/>Common IV. <lb/>o Master Secret. Variable length, random byte string (see <lb/>Section 12.3) used to derive AEAD keys and Common IV. <lb/>o Master Salt. Optional variable-length byte string containing the <lb/>salt used to derive AEAD keys and Common IV. <lb/>o ID Context. Optional variable-length byte string providing <lb/>additional information to identify the Common Context and to <lb/>derive AEAD keys and Common IV. The use of ID Context is <lb/>described in Section 5.1. <lb/>o Common IV. Byte string derived from the Master Secret, Master <lb/>Salt, and ID Context. Used to generate the AEAD nonce (see <lb/>Section 5.2). Same length as the nonce of the AEAD Algorithm. <lb/>The Sender Context contains the following parameters: <lb/>o Sender ID. Byte string used to identify the Sender Context, to <lb/>derive AEAD keys and Common IV, and to contribute to the <lb/>uniqueness of AEAD nonces. Maximum length is determined by the <lb/>AEAD Algorithm. <lb/>o Sender Key. Byte string containing the symmetric AEAD key to <lb/>protect messages to send. Derived from Common Context and Sender <lb/>ID. Length is determined by the AEAD Algorithm. <lb/>o Sender Sequence Number. Non-negative integer used by the sender <lb/>to enumerate requests and certain responses, e.g., Observe <lb/>notifications. Used as &quot;Partial IV&quot; [RFC8152] to generate unique <lb/>AEAD nonces. Maximum value is determined by the AEAD Algorithm. <lb/>Initialization is described in Section 3.2.2. <lb/>The Recipient Context contains the following parameters: <lb/>o Recipient ID. Byte string used to identify the Recipient Context, <lb/>to derive AEAD keys and Common IV, and to contribute to the <lb/>uniqueness of AEAD nonces. Maximum length is determined by the <lb/>AEAD Algorithm. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 10] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Recipient Key. Byte string containing the symmetric AEAD key to <lb/>verify messages received. Derived from Common Context and <lb/>Recipient ID. Length is determined by the AEAD Algorithm. <lb/>o Replay Window (Server only). The replay window used to verify <lb/>requests received. Replay protection is described in Section 7.4 <lb/>and Section 3.2.2. <lb/>All parameters except Sender Sequence Number and Replay Window are <lb/>immutable once the security context is established. An endpoint may <lb/>free up memory by not storing the Common IV, Sender Key, and <lb/>Recipient Key, deriving them when needed. Alternatively, an endpoint <lb/>may free up memory by not storing the Master Secret and Master Salt <lb/>after the other parameters have been derived. <lb/>Endpoints MAY operate as both client and server and use the same <lb/>security context for those roles. Independent of being client or <lb/>server, the endpoint protects messages to send using its Sender <lb/>Context, and verifies messages received using its Recipient Context. <lb/>The endpoints MUST NOT change the Sender/Recipient ID when changing <lb/>roles. In other words, changing the roles does not change the set of <lb/>AEAD keys to be used. <lb/>3.2. Establishment of Security Context Parameters <lb/>Each endpoint derives the parameters in the security context from a <lb/>small set of input parameters. The following input parameters SHALL <lb/>be preestablished: <lb/>o Master Secret <lb/>o Sender ID <lb/>o Recipient ID <lb/>The following input parameters MAY be preestablished. In case any of <lb/>these parameters is not preestablished, the default value indicated <lb/>below is used: <lb/>o AEAD Algorithm <lb/>* Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10) <lb/>o Master Salt <lb/>* Default is the empty byte string <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 11] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o HKDF Algorithm <lb/>* Default is HKDF SHA-256 <lb/>o Replay Window <lb/>* The default mechanism is an anti-replay sliding window (see <lb/>Section 4.1.2.6 of [RFC6347] with a window size of 32 <lb/>All input parameters need to be known and agreed on by both <lb/>endpoints, but the Replay Window may be different in the two <lb/>endpoints. The way the input parameters are preestablished is <lb/>application specific. Considerations of security context <lb/>establishment are given in Section 12.2 and examples of deploying <lb/>OSCORE in Appendix B. <lb/>3.2.1. Derivation of Sender Key, Recipient Key, and Common IV <lb/>The HKDF MUST be one of the HMAC-based HKDF [RFC5869] algorithms <lb/>defined for COSE [RFC8152]. HKDF SHA-256 is mandatory to implement. <lb/>The security context parameters Sender Key, Recipient Key, and Common <lb/>IV SHALL be derived from the input parameters using the HKDF, which <lb/>consists of the composition of the HKDF-Extract and HKDF-Expand steps <lb/>[RFC5869]: <lb/>output parameter = HKDF(salt, IKM, info, L) <lb/>where: <lb/>o salt is the Master Salt as defined above <lb/>o IKM is the Master Secret as defined above <lb/>o info is the serialization of a CBOR array consisting of (the <lb/>notation follows [RFC8610] as summarized in Appendix E): <lb/>info = [ <lb/>id : bstr, <lb/>id_context : bstr / nil, <lb/>alg_aead : int / tstr, <lb/>type : tstr, <lb/>L : uint, <lb/>] <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 12] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>where: <lb/>o id is the Sender ID or Recipient ID when deriving Sender Key and <lb/>Recipient Key, respectively, and the empty byte string when <lb/>deriving the Common IV. <lb/>o id_context is the ID Context, or nil if ID Context is not <lb/>provided. <lb/>o alg_aead is the AEAD Algorithm, encoded as defined in [RFC8152]. <lb/>o type is &quot;Key&quot; or &quot;IV&quot;. The label is an ASCII string and does not <lb/>include a trailing NUL byte. <lb/>o L is the size of the key/nonce for the AEAD Algorithm used, in <lb/>bytes. <lb/>For example, if the algorithm AES-CCM-16-64-128 (see Section 10.2 in <lb/>[RFC8152]) is used, the integer value for alg_aead is 10, the value <lb/>for L is 16 for keys and 13 for the Common IV. Assuming use of the <lb/>default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the extract <lb/>phase of HKDF produces a pseudorandom key (PRK) as follows: <lb/>PRK = HMAC-SHA-256(Master Salt, Master Secret) <lb/>and as L is smaller than the hash function output size, the expand <lb/>phase of HKDF consists of a single HMAC invocation; therefore, the <lb/>Sender Key, Recipient Key, and Common IV are the first 16 or 13 bytes <lb/>of <lb/>output parameter = HMAC-SHA-256(PRK, info || 0x01) <lb/>where different values of info are used for each derived parameter <lb/>and where || denotes byte string concatenation. <lb/>Note that [RFC5869] specifies that if the salt is not provided, it is <lb/>set to a string of zeros. For implementation purposes, not providing <lb/>the salt is the same as setting the salt to the empty byte string. <lb/>OSCORE sets the salt default value to empty byte string, which is <lb/>converted to a string of zeroes (see Section 2.2 of [RFC5869]). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 13] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>3.2.2. Initial Sequence Numbers and Replay Window <lb/>The Sender Sequence Number is initialized to 0. <lb/>The supported types of replay protection and replay window size is <lb/>application specific and depends on how OSCORE is transported (see <lb/>Section 7.4). The default mechanism is the anti-replay window of <lb/>received messages used by IPsec AH/ESP and DTLS (see Section 4.1.2.6 <lb/>of [RFC6347]) with a window size of 32. <lb/>3.3. Requirements on the Security Context Parameters <lb/>To ensure unique Sender Keys, the quartet (Master Secret, Master <lb/>Salt, ID Context, Sender ID) MUST be unique, i.e., the pair (ID <lb/>Context, Sender ID) SHALL be unique in the set of all security <lb/>contexts using the same Master Secret and Master Salt. This means <lb/>that Sender ID SHALL be unique in the set of all security contexts <lb/>using the same Master Secret, Master Salt, and ID Context; such a <lb/>requirement guarantees unique (key, nonce) pairs for the AEAD. <lb/>Different methods can be used to assign Sender IDs: a protocol that <lb/>allows the parties to negotiate locally unique identifiers, a trusted <lb/>third party (e.g., [ACE-OAuth]), or the identifiers can be assigned <lb/>out-of-band. The Sender IDs can be very short (note that the empty <lb/>string is a legitimate value). The maximum length of Sender ID in <lb/>bytes equals the length of the AEAD nonce minus 6, see Section 5.2. <lb/>For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes. <lb/>To simplify retrieval of the right Recipient Context, the Recipient <lb/>ID SHOULD be unique in the sets of all Recipient Contexts used by an <lb/>endpoint. If an endpoint has the same Recipient ID with different <lb/>Recipient Contexts, i.e., the Recipient Contexts are derived from <lb/>different Common Contexts, then the endpoint may need to try multiple <lb/>times before verifying the right security context associated to the <lb/>Recipient ID. <lb/>The ID Context is used to distinguish between security contexts. The <lb/>methods used for assigning Sender ID can also be used for assigning <lb/>the ID Context. Additionally, the ID Context can be used to <lb/>introduce randomness into new Sender and Recipient Contexts (see <lb/>Appendix B.2). ID Context can be arbitrarily long. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 14] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>4. Protected Message Fields <lb/>OSCORE transforms a CoAP message (which may have been generated from <lb/>an HTTP message) into an OSCORE message, and vice versa. OSCORE <lb/>protects as much of the original message as possible while still <lb/>allowing certain proxy operations (see Sections 10 and 11). This <lb/>section defines how OSCORE protects the message fields and transfers <lb/>them end-to-end between client and server (in any direction). <lb/>The remainder of this section and later sections focus on the <lb/>behavior in terms of CoAP messages. If HTTP is used for a particular <lb/>hop in the end-to-end path, then this section applies to the <lb/>conceptual CoAP message that is mappable to/from the original HTTP <lb/>message as discussed in Section 11. That is, an HTTP message is <lb/>conceptually transformed to a CoAP message and then to an OSCORE <lb/>message, and similarly in the reverse direction. An actual <lb/>implementation might translate directly from HTTP to OSCORE without <lb/>the intervening CoAP representation. <lb/>Protection of signaling messages (Section 5 of [RFC8323]) is <lb/>specified in Section 4.3. The other parts of this section target <lb/>request/response messages. <lb/>Message fields of the CoAP message may be protected end-to-end <lb/>between CoAP client and CoAP server in different ways: <lb/>o Class E: encrypted and integrity protected, <lb/>o Class I: integrity protected only, or <lb/>o Class U: unprotected. <lb/>The sending endpoint SHALL transfer Class E message fields in the <lb/>ciphertext of the COSE object in the OSCORE message. The sending <lb/>endpoint SHALL include Class I message fields in the AAD of the AEAD <lb/>algorithm, allowing the receiving endpoint to detect if the value has <lb/>changed in transfer. Class U message fields SHALL NOT be protected <lb/>in transfer. Class I and Class U message field values are <lb/>transferred in the header or options part of the OSCORE message, <lb/>which is visible to proxies. <lb/>Message fields not visible to proxies, i.e., transported in the <lb/>ciphertext of the COSE object, are called &quot;Inner&quot; (Class E). Message <lb/>fields transferred in the header or options part of the OSCORE <lb/>message, which is visible to proxies, are called &quot;Outer&quot; (Class I or <lb/>Class U). There are currently no Class I options defined. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 15] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>An OSCORE message may contain both an Inner and an Outer instance of <lb/>a certain CoAP message field. Inner message fields are intended for <lb/>the receiving endpoint, whereas Outer message fields are used to <lb/>enable proxy operations. <lb/>4.1. CoAP Options <lb/>A summary of how options are protected is shown in Figure 5. Note <lb/>that some options may have both Inner and Outer message fields, which <lb/>are protected accordingly. Certain options require special <lb/>processing as is described in Section 4.1.3. <lb/>Options that are unknown or for which OSCORE processing is not <lb/>defined SHALL be processed as Class E (and no special processing). <lb/>Specifications of new CoAP options SHOULD define how they are <lb/>processed with OSCORE. A new COAP option SHOULD be of Class E unless <lb/>it requires proxy processing. If a new CoAP option is of class U, <lb/>the potential issues with the option being unprotected SHOULD be <lb/>documented (see Appendix D.5). <lb/>4.1.1. Inner Options <lb/>Inner option message fields (Class E) are used to communicate <lb/>directly with the other endpoint. <lb/>The sending endpoint SHALL write the Inner option message fields <lb/>present in the original CoAP message into the plaintext of the COSE <lb/>object (Section 5.3) and then remove the Inner option message fields <lb/>from the OSCORE message. <lb/>The processing of Inner option message fields by the receiving <lb/>endpoint is specified in Sections 8.2 and 8.4. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 16] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>+------+-----------------+---+---+ <lb/>| No. | Name <lb/>| E | U | <lb/>+------+-----------------+---+---+ <lb/>| <lb/>1 | If-Match <lb/>| x | <lb/>| <lb/>| <lb/>3 | Uri-Host <lb/>| <lb/>| x | <lb/>| <lb/>4 | ETag <lb/>| x | <lb/>| <lb/>| <lb/>5 | If-None-Match <lb/>| x | <lb/>| <lb/>| <lb/>6 | Observe <lb/>| x | x | <lb/>| <lb/>7 | Uri-Port <lb/>| <lb/>| x | <lb/>| <lb/>8 | Location-Path <lb/>| x | <lb/>| <lb/>| <lb/>9 | OSCORE <lb/>| <lb/>| x | <lb/>| 11 | Uri-Path <lb/>| x | <lb/>| <lb/>| 12 | Content-Format | x | <lb/>| <lb/>| 14 | Max-Age <lb/>| x | x | <lb/>| 15 | Uri-Query <lb/>| x | <lb/>| <lb/>| 17 | Accept <lb/>| x | <lb/>| <lb/>| 20 | Location-Query | x | <lb/>| <lb/>| 23 | Block2 <lb/>| x | x | <lb/>| 27 | Block1 <lb/>| x | x | <lb/>| 28 | Size2 <lb/>| x | x | <lb/>| 35 | Proxy-Uri <lb/>| <lb/>| x | <lb/>| 39 | Proxy-Scheme <lb/>| <lb/>| x | <lb/>| 60 | Size1 <lb/>| x | x | <lb/>| 258 | No-Response <lb/>| x | x | <lb/>+------+-----------------+---+---+ <lb/>E = Encrypt and Integrity Protect (Inner) <lb/>U = Unprotected (Outer) <lb/>Figure 5: Protection of CoAP Options <lb/>4.1.2. Outer Options <lb/>Outer option message fields (Class U or I) are used to support proxy <lb/>operations, see Appendix D.2. <lb/>The sending endpoint SHALL include the Outer option message field <lb/>present in the original message in the options part of the OSCORE <lb/>message. All Outer option message fields, including the OSCORE <lb/>option, SHALL be encoded as described in Section 3.1 of [RFC7252], <lb/>where the delta is the difference from the previously included <lb/>instance of Outer option message field. <lb/>The processing of Outer options by the receiving endpoint is <lb/>specified in Sections 8.2 and 8.4. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 17] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>A procedure for integrity-protection-only of Class I option message <lb/>fields is specified in Section 5.4. Specifications that introduce <lb/>repeatable Class I options MUST specify that proxies MUST NOT change <lb/>the order of the instances of such an option in the CoAP message. <lb/>Note: There are currently no Class I option message fields defined. <lb/>4.1.3. Special Options <lb/>Some options require special processing as specified in this section. <lb/>4.1.3.1. Max-Age <lb/>An Inner Max-Age message field is used to indicate the maximum time a <lb/>response may be cached by the client (as defined in [RFC7252]), end-<lb/>to-end from the server to the client, taking into account that the <lb/>option is not accessible to proxies. The Inner Max-Age SHALL be <lb/>processed by OSCORE as a normal Inner option, specified in <lb/>Section 4.1.1. <lb/>An Outer Max-Age message field is used to avoid unnecessary caching <lb/>of error responses caused by OSCORE processing at OSCORE-unaware <lb/>intermediary nodes. A server MAY set a Class U Max-Age message field <lb/>with value zero to such error responses, described in Sections 7.4, <lb/>8.2, and 8.4, since these error responses are cacheable, but <lb/>subsequent OSCORE requests would never create a hit in the <lb/>intermediary node caching it. Setting the Outer Max-Age to zero <lb/>relieves the intermediary from uselessly caching responses. <lb/>Successful OSCORE responses do not need to include an Outer Max-Age <lb/>option. Except when the Observe option (see Section 4.1.3.5) is <lb/>used, responses appear to the OSCORE-unaware intermediary as 2.04 <lb/>(Changed) responses, which are non-cacheable (see Section 4.2). For <lb/>Observe responses, which are cacheable, an Outer Max-Age option with <lb/>value 0 may be used to avoid unnecessary proxy caching. <lb/>The Outer Max-Age message field is processed according to <lb/>Section 4.1.2. <lb/>4.1.3.2. Uri-Host and Uri-Port <lb/>When the Uri-Host and Uri-Port are set to their default values (see <lb/>Section 5.10.1 [RFC7252]), they are omitted from the message <lb/>(Section 5.4.4 of [RFC7252]), which is favorable both for overhead <lb/>and privacy. <lb/>In order to support forward proxy operations, Proxy-Scheme, Uri-Host, <lb/>and Uri-Port need to be Class U. For the use of Proxy-Uri, see <lb/>Section 4.1.3.3. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 18] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Manipulation of unprotected message fields (including Uri-Host, Uri-<lb/>Port, destination IP/port or request scheme) MUST NOT lead to an <lb/>OSCORE message becoming verified by an unintended server. Different <lb/>servers SHALL have different security contexts. <lb/>4.1.3.3. Proxy-Uri <lb/>When Proxy-Uri is present, the client SHALL first decompose the <lb/>Proxy-Uri value of the original CoAP message into the Proxy-Scheme, <lb/>Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according to <lb/>Section 6.4 of [RFC7252]. <lb/>Uri-Path and Uri-Query are Class E options and SHALL be protected and <lb/>processed as Inner options (Section 4.1.1). <lb/>The Proxy-Uri option of the OSCORE message SHALL be set to the <lb/>composition of Proxy-Scheme, Uri-Host, and Uri-Port options as <lb/>specified in Section 6.5 of [RFC7252] and processed as an Outer <lb/>option of Class U (Section 4.1.2). <lb/>Note that replacing the Proxy-Uri value with the Proxy-Scheme and <lb/>Uri-* options works by design for all CoAP URIs (see Section 6 of <lb/>[RFC7252]). OSCORE-aware HTTP servers should not use the userinfo <lb/>component of the HTTP URI (as defined in Section 3.2.1 of [RFC3986]), <lb/>so that this type of replacement is possible in the presence of CoAP-<lb/>to-HTTP proxies (see Section 11.2). In future specifications of <lb/>cross-protocol proxying behavior using different URI structures, it <lb/>is expected that the authors will create Uri-* options that allow <lb/>decomposing the Proxy-Uri, and specifying the OSCORE processing. <lb/>An example of how Proxy-Uri is processed is given here. Assume that <lb/>the original CoAP message contains: <lb/>o Proxy-Uri = &quot;coap://example.com/resource?q=1&quot; <lb/>During OSCORE processing, Proxy-Uri is split into: <lb/>o Proxy-Scheme = &quot;coap&quot; <lb/>o Uri-Host = &quot;example.com&quot; <lb/>o Uri-Port = &quot;5683&quot; (default) <lb/>o Uri-Path = &quot;resource&quot; <lb/>o Uri-Query = &quot;q=1&quot; <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 19] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Uri-Path and Uri-Query follow the processing defined in <lb/>Section 4.1.1; thus, they are encrypted and transported in the COSE <lb/>object: <lb/>o Uri-Path = &quot;resource&quot; <lb/>o Uri-Query = &quot;q=1&quot; <lb/>The remaining options are composed into the Proxy-Uri included in the <lb/>options part of the OSCORE message, which has value: <lb/>o Proxy-Uri = &quot;coap://example.com&quot; <lb/>See Sections 6.1 and 12.6 of [RFC7252] for more details. <lb/>4.1.3.4. The Block Options <lb/>Block-wise [RFC7959] is an optional feature. An implementation MAY <lb/>support CoAP [RFC7252] and the OSCORE option without supporting <lb/>block-wise transfers. The Block options (Block1, Block2, Size1, <lb/>Size2), when Inner message fields, provide secure message <lb/>segmentation such that each segment can be verified. The Block <lb/>options, when Outer message fields, enable hop-by-hop fragmentation <lb/>of the OSCORE message. Inner and Outer block processing may have <lb/>different performance properties depending on the underlying <lb/>transport. The end-to-end integrity of the message can be verified <lb/>both in case of Inner and Outer Block-wise transfers, provided all <lb/>blocks are received. <lb/>4.1.3.4.1. Inner Block Options <lb/>The sending CoAP endpoint MAY fragment a CoAP message as defined in <lb/>[RFC7959] before the message is processed by OSCORE. In this case, <lb/>the Block options SHALL be processed by OSCORE as normal Inner <lb/>options (Section 4.1.1). The receiving CoAP endpoint SHALL process <lb/>the OSCORE message before processing Block-wise as defined in <lb/>[RFC7959]. <lb/>4.1.3.4.2. Outer Block Options <lb/>Proxies MAY fragment an OSCORE message using [RFC7959] by introducing <lb/>Block option message fields that are Outer (Section 4.1.2). Note <lb/>that the Outer Block options are neither encrypted nor integrity <lb/>protected. As a consequence, a proxy can maliciously inject block <lb/>fragments indefinitely, since the receiving endpoint needs to receive <lb/>the last block (see [RFC7959]) to be able to compose the OSCORE <lb/>message and verify its integrity. Therefore, applications supporting <lb/>OSCORE and [RFC7959] MUST specify a security policy defining a <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 20] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE) considering <lb/>the maximum size of message that can be handled by the endpoints. <lb/>Messages exceeding this size SHOULD be fragmented by the sending <lb/>endpoint using Inner Block options (Section 4.1.3.4.1). <lb/>An endpoint receiving an OSCORE message with an Outer Block option <lb/>SHALL first process this option according to [RFC7959], until all <lb/>blocks of the OSCORE message have been received or the cumulated <lb/>message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE. In the <lb/>former case, the processing of the OSCORE message continues as <lb/>defined in this document. In the latter case, the message SHALL be <lb/>discarded. <lb/>Because of encryption of Uri-Path and Uri-Query, messages to the same <lb/>server may, from the point of view of a proxy, look like they also <lb/>target the same resource. A proxy SHOULD mitigate a potential mix-up <lb/>of blocks from concurrent requests to the same server, for example, <lb/>using the Request-Tag processing specified in Section 3.3.2 of <lb/>[CoAP-ECHO-REQ-TAG]. <lb/>4.1.3.5. Observe <lb/>Observe [RFC7641] is an optional feature. An implementation MAY <lb/>support CoAP [RFC7252] and the OSCORE option without supporting <lb/>[RFC7641], in which case the Observe-related processing can be <lb/>omitted. <lb/>The support for Observe [RFC7641] with OSCORE targets the <lb/>requirements on forwarding of Section 2.2.1 of [CoAP-E2E-Sec], i.e., <lb/>that observations go through intermediary nodes, as illustrated in <lb/>Figure 8 of [RFC7641]. <lb/>Inner Observe SHALL be used to protect the value of the Observe <lb/>option between the endpoints. Outer Observe SHALL be used to support <lb/>forwarding by intermediary nodes. <lb/>The server SHALL include a new Partial IV (see Section 5) in <lb/>responses (with or without the Observe option) to Observe <lb/>registrations, except for the first response where Partial IV MAY be <lb/>omitted. <lb/>For cancellations, Section 3.6 of [RFC7641] specifies that all <lb/>options MUST be identical to those in the registration request except <lb/>for the Observe option and the set of ETag options. For OSCORE <lb/>messages, this matching is to be done to the options in the decrypted <lb/>message. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 21] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>[RFC7252] does not specify how the server should act upon receiving <lb/>the same Token in different requests. When using OSCORE, the server <lb/>SHOULD NOT remove an active observation just because it receives a <lb/>request with the same Token. <lb/>Since POST with the Observe option is not defined, for messages with <lb/>the Observe option, the Outer Code MUST be set to 0.05 (FETCH) for <lb/>requests and to 2.05 (Content) for responses (see Section 4.2). <lb/>4.1.3.5.1. Registrations and Cancellations <lb/>The Inner and Outer Observe options in the request MUST contain the <lb/>Observe value of the original CoAP request; 0 (registration) or 1 <lb/>(cancellation). <lb/>Every time a client issues a new request with the Observe option, a <lb/>new Partial IV MUST be used (see Section 5), and so the payload and <lb/>OSCORE option are changed. The server uses the Partial IV of the new <lb/>request as the &apos;request_piv&apos; of all associated notifications (see <lb/>Section 5.4). <lb/>Intermediaries are not assumed to have access to the OSCORE security <lb/>context used by the endpoints; thus, they cannot make requests or <lb/>transform responses with the OSCORE option that pass verification (at <lb/>the receiving endpoint) as having come from the other endpoint. This <lb/>has the following consequences and limitations for Observe <lb/>operations. <lb/>o An intermediary node removing the Outer Observe 0 option does not <lb/>change the registration request to a request without the Observe <lb/>option (see Section 2 of [RFC7641]). Instead other means for <lb/>cancellation may be used as described in Section 3.6 of [RFC7641]. <lb/>o An intermediary node is not able to transform a normal response <lb/>into an OSCORE-protected Observe notification (see Figure 7 of <lb/>[RFC7641]) that verifies as coming from the server. <lb/>o An intermediary node is not able to initiate an OSCORE protected <lb/>Observe registration (Observe option with value 0) that verifies <lb/>as coming from the client. An OSCORE-aware intermediary SHALL NOT <lb/>initiate registrations of observations (see Section 10). If an <lb/>OSCORE-unaware proxy resends an old registration message from a <lb/>client, the replay protection mechanism in the server will be <lb/>triggered. To prevent this from resulting in the OSCORE-unaware <lb/>proxy canceling the registration, a server MAY respond to a <lb/>replayed registration request with a replay of a cached <lb/>notification. Alternatively, the server MAY send a new <lb/>notification. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 22] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o An intermediary node is not able to initiate an OSCORE-protected <lb/>Observe cancellation (Observe option with value 1) that verifies <lb/>as coming from the client. An application MAY decide to allow <lb/>intermediaries to cancel Observe registrations, e.g., to send the <lb/>Observe option with value 1 (see Section 3.6 of [RFC7641]); <lb/>however, that can also be done with other methods, e.g., by <lb/>sending a RST message. This is out of scope for this <lb/>specification. <lb/>4.1.3.5.2. Notifications <lb/>If the server accepts an Observe registration, a Partial IV MUST be <lb/>included in all notifications (both successful and error), except for <lb/>the first one where the Partial IV MAY be omitted. To protect <lb/>against replay, the client SHALL maintain a Notification Number for <lb/>each Observation it registers. The Notification Number is a non-<lb/>negative integer containing the largest Partial IV of the received <lb/>notifications for the associated Observe registration. Further <lb/>details of replay protection of notifications are specified in <lb/>Section 7.4.1. <lb/>For notifications, the Inner Observe option value MUST be empty (see <lb/>Section 3.2 of [RFC7252]). The Outer Observe option in a <lb/>notification is needed for intermediary nodes to allow multiple <lb/>responses to one request, and it MAY be set to the value of the <lb/>Observe option in the original CoAP message. The client performs <lb/>ordering of notifications and replay protection by comparing their <lb/>Partial IVs and SHALL ignore the Outer Observe option value. <lb/>If the client receives a response to an Observe request without an <lb/>Inner Observe option, then it verifies the response as a non-Observe <lb/>response, as specified in Section 8.4. If the client receives a <lb/>response to a non-Observe request with an Inner Observe option, then <lb/>it stops processing the message, as specified in Section 8.4. <lb/>A client MUST consider the notification with the highest Partial IV <lb/>as the freshest, regardless of the order of arrival. In order to <lb/>support existing Observe implementations, the OSCORE client <lb/>implementation MAY set the Observe option value to the three least <lb/>significant bytes of the Partial IV. Implementations need to make <lb/>sure that the notification without Partial IV is considered the <lb/>oldest. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 23] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>4.1.3.6. No-Response <lb/>No-Response [RFC7967] is an optional feature used by the client to <lb/>communicate its disinterest in certain classes of responses to a <lb/>particular request. An implementation MAY support [RFC7252] and the <lb/>OSCORE option without supporting [RFC7967]. <lb/>If used, No-Response MUST be Inner. The Inner No-Response SHALL be <lb/>processed by OSCORE as specified in Section 4.1.1. The Outer option <lb/>SHOULD NOT be present. The server SHALL ignore the Outer No-Response <lb/>option. The client MAY set the Outer No-Response value to 26 <lb/>(suppress all known codes) if the Inner value is set to 26. The <lb/>client MUST be prepared to receive and discard 5.04 (Gateway Timeout) <lb/>error messages from intermediaries potentially resulting from <lb/>destination time out due to no response. <lb/>4.1.3.7. OSCORE <lb/>The OSCORE option is only defined to be present in OSCORE messages as <lb/>an indication that OSCORE processing has been performed. The content <lb/>in the OSCORE option is neither encrypted nor integrity protected as <lb/>a whole, but some part of the content of this option is protected <lb/>(see Section 5.4). Nested use of OSCORE is not supported: If OSCORE <lb/>processing detects an OSCORE option in the original CoAP message, <lb/>then processing SHALL be stopped. <lb/>4.2. CoAP Header Fields and Payload <lb/>A summary of how the CoAP header fields and payload are protected is <lb/>shown in Figure 6, including fields specific to CoAP over UDP and <lb/>CoAP over TCP (marked accordingly in the table). <lb/>+------------------+---+---+ <lb/>| Field <lb/>| E | U | <lb/>+------------------+---+---+ <lb/>| Version (UDP) <lb/>| <lb/>| x | <lb/>| Type (UDP) <lb/>| <lb/>| x | <lb/>| Length (TCP) <lb/>| <lb/>| x | <lb/>| Token Length <lb/>| <lb/>| x | <lb/>| Code <lb/>| x | <lb/>| <lb/>| Message ID (UDP) | <lb/>| x | <lb/>| Token <lb/>| <lb/>| x | <lb/>| Payload <lb/>| x | <lb/>| <lb/>+------------------+---+---+ <lb/>E = Encrypt and Integrity Protect (Inner) <lb/>U = Unprotected (Outer) <lb/>Figure 6: Protection of CoAP Header Fields and Payload <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 24] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Most CoAP header fields (i.e., the message fields in the fixed 4-byte <lb/>header) are required to be read and/or changed by CoAP proxies; thus, <lb/>they cannot, in general, be protected end-to-end from one endpoint to <lb/>the other. As mentioned in Section 1, OSCORE protects the CoAP <lb/>request/response layer only and not the CoAP messaging layer <lb/>(Section 2 of [RFC7252]), so fields such as Type and Message ID are <lb/>not protected with OSCORE. <lb/>The CoAP header field Code is protected by OSCORE. Code SHALL be <lb/>encrypted and integrity protected (Class E) to prevent an <lb/>intermediary from eavesdropping on or manipulating it (e.g., changing <lb/>from GET to DELETE). <lb/>The sending endpoint SHALL write the Code of the original CoAP <lb/>message into the plaintext of the COSE object (see Section 5.3). <lb/>After that, the sending endpoint writes an Outer Code to the OSCORE <lb/>message. With one exception (see Section 4.1.3.5), the Outer Code <lb/>SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed) for <lb/>responses. The receiving endpoint SHALL discard the Outer Code in <lb/>the OSCORE message and write the Code of the COSE object plaintext <lb/>(Section 5.3) into the decrypted CoAP message. <lb/>The other currently defined CoAP header fields are Unprotected (Class <lb/>U). The sending endpoint SHALL write all other header fields of the <lb/>original message into the header of the OSCORE message. The <lb/>receiving endpoint SHALL write the header fields from the received <lb/>OSCORE message into the header of the decrypted CoAP message. <lb/>The CoAP Payload, if present in the original CoAP message, SHALL be <lb/>encrypted and integrity protected; thus, it is an Inner message <lb/>field. The sending endpoint writes the payload of the original CoAP <lb/>message into the plaintext (Section 5.3) input to the COSE object. <lb/>The receiving endpoint verifies and decrypts the COSE object, and it <lb/>recreates the payload of the original CoAP message. <lb/>4.3. Signaling Messages <lb/>Signaling messages (CoAP Code 7.00-7.31) were introduced to exchange <lb/>information related to an underlying transport connection in the <lb/>specific case of CoAP over reliable transports [RFC8323]. <lb/>OSCORE MAY be used to protect signaling if the endpoints for OSCORE <lb/>coincide with the endpoints for the signaling message. If OSCORE is <lb/>used to protect signaling then: <lb/>o To comply with [RFC8323], an initial empty Capabilities and <lb/>Settings Message (CSM) SHALL be sent. The subsequent signaling <lb/>message SHALL be protected. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 25] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Signaling messages SHALL be protected as CoAP request messages, <lb/>except in the case in which the signaling message is a response to <lb/>a previous signaling message; then it SHALL be protected as a CoAP <lb/>response message. For example, 7.02 (Ping) is protected as a CoAP <lb/>request and 7.03 (Pong) as a CoAP response. <lb/>o The Outer Code for signaling messages SHALL be set to 0.02 (POST), <lb/>unless it is a response to a previous signaling message, in which <lb/>case it SHALL be set to 2.04 (Changed). <lb/>o All signaling options, except the OSCORE option, SHALL be Inner <lb/>(Class E). <lb/>NOTE: Option numbers for signaling messages are specific to the CoAP <lb/>Code (see Section 5.2 of [RFC8323]). <lb/>If OSCORE is not used to protect signaling, Signaling messages SHALL <lb/>be unaltered by OSCORE. <lb/>5. The COSE Object <lb/>This section defines how to use COSE [RFC8152] to wrap and protect <lb/>data in the original message. OSCORE uses the untagged COSE_Encrypt0 <lb/>structure (see Section 5.2 of [RFC8152]) with an AEAD algorithm. The <lb/>AEAD key lengths, AEAD nonce length, and maximum Sender Sequence <lb/>Number are algorithm dependent. <lb/>The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of <lb/>[RFC8152] is mandatory to implement. For AES-CCM-16-64-128, the <lb/>length of Sender Key and Recipient Key is 128 bits; the length of <lb/>AEAD nonce and Common IV is 13 bytes. The maximum Sender Sequence <lb/>Number is specified in Section 12. <lb/>As specified in [RFC5116], plaintext denotes the data that is to be <lb/>encrypted and integrity protected, and Additional Authenticated Data <lb/>(AAD) denotes the data that is to be integrity protected only. <lb/>The COSE object SHALL be a COSE_Encrypt0 object with fields defined <lb/>as follows: <lb/>o The &apos;protected&apos; field is empty. <lb/>o The &apos;unprotected&apos; field includes: <lb/>* The &apos;Partial IV&apos; parameter. The value is set to the Sender <lb/>Sequence Number. All leading bytes of value zero SHALL be <lb/>removed when encoding the Partial IV, except in the case of <lb/>Partial IV value 0, which is encoded to the byte string 0x00. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 26] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>This parameter SHALL be present in requests and will not <lb/>typically be present in responses (for two exceptions, see <lb/>Observe notifications (Section 4.1.3.5.2) and Replay Window <lb/>synchronization (Appendix B.1.2)). <lb/>* The &apos;kid&apos; parameter. The value is set to the Sender ID. This <lb/>parameter SHALL be present in requests and will not typically <lb/>be present in responses. An example where the Sender ID is <lb/>included in a response is the extension of OSCORE to group <lb/>communication [Group-OSCORE]. <lb/>* Optionally, a &apos;kid context&apos; parameter (see Section 5.1). This <lb/>parameter MAY be present in requests and, if so, MUST contain <lb/>an ID Context (see Section 3.1). This parameter SHOULD NOT be <lb/>present in responses: an example of how &apos;kid context&apos; can be <lb/>used in responses is given in Appendix B.2. If &apos;kid context&apos; <lb/>is present in the request, then the server SHALL use a security <lb/>context with that ID Context when verifying the request. <lb/>o The &apos;ciphertext&apos; field is computed from the secret key (Sender Key <lb/>or Recipient Key), AEAD nonce (see Section 5.2), plaintext (see <lb/>Section 5.3), and the AAD (see Section 5.4) following Section 5.2 <lb/>of [RFC8152]. <lb/>The encryption process is described in Section 5.3 of [RFC8152]. <lb/>5.1. ID Context and &apos;kid context&apos; <lb/>For certain use cases, e.g., deployments where the same Sender ID is <lb/>used with multiple contexts, it is possible (and sometimes necessary, <lb/>see Section 3.3) for the client to use an ID Context to distinguish <lb/>the security contexts (see Section 3.1). For example: <lb/>o If the client has a unique identifier in some namespace, then that <lb/>identifier can be used as ID Context. <lb/>o The ID Context may be used to add randomness into new Sender and <lb/>Recipient Contexts, see Appendix B.2. <lb/>o In the case of group communication [Group-OSCORE], a group <lb/>identifier is used as ID Context to enable different security <lb/>contexts for a server belonging to multiple groups. <lb/>The Sender ID and ID Context are used to establish the necessary <lb/>input parameters and in the derivation of the security context (see <lb/>Section 3.2). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 27] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>While the &apos;kid&apos; parameter is used to transport the Sender ID, the new <lb/>COSE header parameter &apos;kid context&apos; is used to transport the ID <lb/>Context in requests, see Figure 7. <lb/>+----------+--------+------------+----------------+-----------------+ <lb/>| <lb/>Name <lb/>| Label | Value Type | Value Registry | <lb/>Description <lb/>| <lb/>+----------+--------+------------+----------------+-----------------+ <lb/>| <lb/>kid <lb/>| <lb/>10 | bstr <lb/>| <lb/>| Identifies the | <lb/>| context | <lb/>| <lb/>| <lb/>| context for the | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| key identifier | <lb/>+----------+--------+------------+----------------+-----------------+ <lb/>Figure 7: Common Header Parameter &apos;kid context&apos; for the COSE Object <lb/>If ID Context is non-empty and the client sends a request without <lb/>&apos;kid context&apos; resulting in an error indicating that the server could <lb/>not find the security context, then the client could include the ID <lb/>Context in the &apos;kid context&apos; when making another request. Note that <lb/>since the error is unprotected, it may have been spoofed and the real <lb/>response blocked by an on-path attacker. <lb/>5.2. AEAD Nonce <lb/>The high-level design of the AEAD nonce follows Section 4.4 of <lb/>[IV-GEN]. The detailed construction of the AEAD nonce is presented <lb/>here (see Figure 8): <lb/>1. left-pad the Partial IV (PIV) with zeroes to exactly 5 bytes, <lb/>2. left-pad the Sender ID of the endpoint that generated the Partial <lb/>IV (ID_PIV) with zeroes to exactly nonce length minus 6 bytes, <lb/>3. concatenate the size of the ID_PIV (a single byte S) with the <lb/>padded ID_PIV and the padded PIV, <lb/>4. and then XOR with the Common IV. <lb/>Note that in this specification, only AEAD algorithms that use nonces <lb/>equal or greater than 7 bytes are supported. The nonce construction <lb/>with S, ID_PIV, and PIV together with endpoint-unique IDs and <lb/>encryption keys makes it easy to verify that the nonces used with a <lb/>specific key will be unique, see Appendix D.4. <lb/>If the Partial IV is not present in a response, the nonce from the <lb/>request is used. For responses that are not notifications (i.e., <lb/>when there is a single response to a request), the request and the <lb/>response should typically use the same nonce to reduce message <lb/>overhead. Both alternatives provide all the required security <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 28] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>properties, see Section 7.4 and Appendix D.4. Another non-Observe <lb/>scenario where a Partial IV is included in a response is when the <lb/>server is unable to perform replay protection, see Appendix B.1.2. <lb/>For processing instructions see Section 8. <lb/>&lt;-nonce length minus 6 B -&gt; &lt;--5 bytes --&gt; <lb/>+---+-------------------+--------+---------+-----+ <lb/>| S | <lb/>padding <lb/>| ID_PIV | padding | PIV |----+ <lb/>+---+-------------------+--------+---------+-----+ <lb/>| <lb/>| <lb/>&lt;----------------nonce length ----------------&gt; <lb/>| <lb/>+------------------------------------------------+ <lb/>| <lb/>| <lb/>Common IV <lb/>|-&gt;(XOR) <lb/>+------------------------------------------------+ <lb/>| <lb/>| <lb/>&lt;----------------nonce length ----------------&gt; <lb/>| <lb/>+------------------------------------------------+ <lb/>| <lb/>| <lb/>Nonce <lb/>|&lt;---+ <lb/>+------------------------------------------------+ <lb/>Figure 8: AEAD Nonce Formation <lb/>5.3. Plaintext <lb/>The plaintext is formatted as a CoAP message with a subset of the <lb/>header (see Figure 9) consisting of: <lb/>o the Code of the original CoAP message as defined in Section 3 of <lb/>[RFC7252]; and <lb/>o all Inner option message fields (see Section 4.1.1) present in the <lb/>original CoAP message (see Section 4.1). The options are encoded <lb/>as described in Section 3.1 of [RFC7252], where the delta is the <lb/>difference from the previously included instance of Class E <lb/>option; and <lb/>o the Payload of original CoAP message, if present, and in that case <lb/>prefixed by the one-byte Payload Marker (0xff). <lb/>NOTE: The plaintext contains all CoAP data that needs to be encrypted <lb/>end-to-end between the endpoints. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 29] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>0 <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <lb/>| <lb/>Code <lb/>| <lb/>Class E options (if any) ... <lb/>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <lb/>|1 1 1 1 1 1 1 1| <lb/>Payload (if any) ... <lb/>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <lb/>(only if there is payload) <lb/>Figure 9: Plaintext <lb/>5.4. Additional Authenticated Data <lb/>The external_aad SHALL be a CBOR array wrapped in a bstr object as <lb/>defined below, following the notation of [RFC8610] as summarized in <lb/>Appendix E: <lb/>external_aad = bstr .cbor aad_array <lb/>aad_array = [ <lb/>oscore_version : uint, <lb/>algorithms : [ alg_aead : int / tstr ], <lb/>request_kid : bstr, <lb/>request_piv : bstr, <lb/>options : bstr, <lb/>] <lb/>where: <lb/>o oscore_version: contains the OSCORE version number. <lb/>Implementations of this specification MUST set this field to 1. <lb/>Other values are reserved for future versions. <lb/>o algorithms: contains (for extensibility) an array of algorithms, <lb/>according to this specification only containing alg_aead. <lb/>o alg_aead: contains the AEAD Algorithm from the security context <lb/>used for the exchange (see Section 3.1). <lb/>o request_kid: contains the value of the &apos;kid&apos; in the COSE object of <lb/>the request (see Section 5). <lb/>o request_piv: contains the value of the &apos;Partial IV&apos; in the COSE <lb/>object of the request (see Section 5). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 30] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o options: contains the Class I options (see Section 4.1.2) present <lb/>in the original CoAP message encoded as described in Section 3.1 <lb/>of [RFC7252], where the delta is the difference from the <lb/>previously included instance of class I option. <lb/>The oscore_version and algorithms parameters are established out-of-<lb/>band; thus, they are not transported in OSCORE, but the external_aad <lb/>allows to verify that they are the same in both endpoints. <lb/>NOTE: The format of the external_aad is, for simplicity, the same for <lb/>requests and responses, although some parameters, e.g., request_kid, <lb/>need not be integrity protected in all requests. <lb/>The AAD is composed from the external_aad as described in Section 5.3 <lb/>of [RFC8152] (the notation follows [RFC8610] as summarized in <lb/>Appendix E): <lb/>AAD = Enc_structure = [ &quot;Encrypt0&quot;, h&apos;&apos;, external_aad ] <lb/>The following is an example of AAD constructed using AEAD Algorithm = <lb/>AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no <lb/>Class I options: <lb/>o oscore_version: 0x01 (1 byte) <lb/>o algorithms: 0x810a (2 bytes) <lb/>o request_kid: 0x00 (1 byte) <lb/>o request_piv: 0x25 (1 byte) <lb/>o options: 0x (0 bytes) <lb/>o aad_array: 0x8501810a4100412540 (9 bytes) <lb/>o external_aad: 0x498501810a4100412540 (10 bytes) <lb/>o AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes) <lb/>Note that the AAD consists of a fixed string of 11 bytes concatenated <lb/>with the external_aad. <lb/>6. OSCORE Header Compression <lb/>The Concise Binary Object Representation (CBOR) [RFC7049] combines <lb/>very small message sizes with extensibility. The CBOR Object Signing <lb/>and Encryption (COSE) [RFC8152] uses CBOR to create compact encoding <lb/>of signed and encrypted data. However, COSE is constructed to <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 31] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>support a large number of different stateless use cases and is not <lb/>fully optimized for use as a stateful security protocol, leading to a <lb/>larger than necessary message expansion. In this section, we define <lb/>a stateless header compression mechanism, simply removing redundant <lb/>information from the COSE objects, which significantly reduces the <lb/>per-packet overhead. The result of applying this mechanism to a COSE <lb/>object is called the &quot;compressed COSE object&quot;. <lb/>The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE <lb/>option and in the Payload. The Payload contains the ciphertext of <lb/>the COSE object. The headers of the COSE object are compactly <lb/>encoded as described in the next section. <lb/>6.1. Encoding of the OSCORE Option Value <lb/>The value of the OSCORE option SHALL contain the OSCORE flag bits, <lb/>the &apos;Partial IV&apos; parameter, the &apos;kid context&apos; parameter (length and <lb/>value), and the &apos;kid&apos; parameter as follows: <lb/>0 1 2 3 4 5 6 7 &lt;-------------n bytes --------------&gt; <lb/>+-+-+-+-+-+-+-+-+--------------------------------------<lb/>|0 0 0|h|k| n | <lb/>Partial IV (if any) ... <lb/>+-+-+-+-+-+-+-+-+--------------------------------------<lb/>&lt;-1 byte -&gt; &lt;-----s bytes ------&gt; <lb/>+------------+----------------------+------------------+ <lb/>| s (if any) | kid context (if any) | kid (if any) ... | <lb/>+------------+----------------------+------------------+ <lb/>Figure 10: The OSCORE Option Value <lb/>o The first byte, containing the OSCORE flag bits, encodes the <lb/>following set of bits and the length of the &apos;Partial IV&apos; <lb/>parameter: <lb/>* The three least significant bits encode the Partial IV length <lb/>n. If n = 0, then the Partial IV is not present in the <lb/>compressed COSE object. The values n = 6 and n = 7 are <lb/>reserved. <lb/>* The fourth least significant bit is the &apos;kid&apos; flag, k. It is <lb/>set to 1 if &apos;kid&apos; is present in the compressed COSE object. <lb/>* The fifth least significant bit is the &apos;kid context&apos; flag, h. <lb/>It is set to 1 if the compressed COSE object contains a &apos;kid <lb/>context&apos; (see Section 5.1). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 32] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>* The sixth-to-eighth least significant bits are reserved for <lb/>future use. These bits SHALL be set to zero when not in use. <lb/>According to this specification, if any of these bits are set <lb/>to 1, the message is considered to be malformed and <lb/>decompression fails as specified in item 2 of Section 8.2. <lb/>The flag bits are registered in the &quot;OSCORE Flag Bits&quot; registry <lb/>specified in Section 13.7. <lb/>o The following n bytes encode the value of the Partial IV, if the <lb/>Partial IV is present (n &gt; 0). <lb/>o The following 1 byte encodes the length s of the &apos;kid context&apos; <lb/>(Section 5.1), if the &apos;kid context&apos; flag is set (h = 1). <lb/>o The following s bytes encode the &apos;kid context&apos;, if the &apos;kid <lb/>context&apos; flag is set (h = 1). <lb/>o The remaining bytes encode the value of the &apos;kid&apos;, if the &apos;kid&apos; is <lb/>present (k = 1). <lb/>Note that the &apos;kid&apos; MUST be the last field of the OSCORE option <lb/>value, even in the case in which reserved bits are used and <lb/>additional fields are added to it. <lb/>The length of the OSCORE option thus depends on the presence and <lb/>length of Partial IV, &apos;kid context&apos;, &apos;kid&apos;, as specified in this <lb/>section, and on the presence and length of additional parameters, as <lb/>defined in the future documents registering those parameters. <lb/>6.2. Encoding of the OSCORE Payload <lb/>The payload of the OSCORE message SHALL encode the ciphertext of the <lb/>COSE object. <lb/>6.3. Examples of Compressed COSE Objects <lb/>This section covers a list of OSCORE Header Compression examples for <lb/>requests and responses. The examples assume the COSE_Encrypt0 object <lb/>is set (which means the CoAP message and cryptographic material is <lb/>known). Note that the full CoAP unprotected message, as well as the <lb/>full security context, is not reported in the examples, but only the <lb/>input necessary to the compression mechanism, i.e., the COSE_Encrypt0 <lb/>object. The output is the compressed COSE object as defined in <lb/>Section 6, divided into two parts, since the object is transported in <lb/>two CoAP fields: the OSCORE option and payload. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 33] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>1. Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = <lb/>0x25, and Partial IV = 0x05 <lb/>Before compression (24 bytes): <lb/>[ <lb/>h&apos;&apos;, <lb/>{ 4:h&apos;25&apos;, 6:h&apos;05&apos; }, <lb/>h&apos;aea0155667924dff8a24e4cb35b9&apos;, <lb/>] <lb/>After compression (17 bytes): <lb/>Flag byte: 0b00001001 = 0x09 (1 byte) <lb/>Option Value: 0x090525 (3 bytes) <lb/>Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) <lb/>2. Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = <lb/>empty string, and Partial IV = 0x00 <lb/>Before compression (23 bytes): <lb/>[ <lb/>h&apos;&apos;, <lb/>{ 4:h&apos;&apos;, 6:h&apos;00&apos; }, <lb/>h&apos;aea0155667924dff8a24e4cb35b9&apos;, <lb/>] <lb/>After compression (16 bytes): <lb/>Flag byte: 0b00001001 = 0x09 (1 byte) <lb/>Option Value: 0x0900 (2 bytes) <lb/>Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) <lb/>3. Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = <lb/>empty string, Partial IV = 0x05, and kid context = 0x44616c656b <lb/>Before compression (30 bytes): <lb/>[ <lb/>h&apos;&apos;, <lb/>{ 4:h&apos;&apos;, 6:h&apos;05&apos;, 10:h&apos;44616c656b&apos; }, <lb/>h&apos;aea0155667924dff8a24e4cb35b9&apos;, <lb/>] <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 34] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>After compression (22 bytes): <lb/>Flag byte: 0b00011001 = 0x19 (1 byte) <lb/>Option Value: 0x19050544616c656b (8 bytes) <lb/>Payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes) <lb/>4. Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no <lb/>Partial IV <lb/>Before compression (18 bytes): <lb/>[ <lb/>h&apos;&apos;, <lb/>{}, <lb/>h&apos;aea0155667924dff8a24e4cb35b9&apos;, <lb/>] <lb/>After compression (14 bytes): <lb/>Flag byte: 0b00000000 = 0x00 (1 byte) <lb/>Option Value: 0x (0 bytes) <lb/>Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) <lb/>5. Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and <lb/>Partial IV = 0x07 <lb/>Before compression (21 bytes): <lb/>[ <lb/>h&apos;&apos;, <lb/>{ 6:h&apos;07&apos; }, <lb/>h&apos;aea0155667924dff8a24e4cb35b9&apos;, <lb/>] <lb/>After compression (16 bytes): <lb/>Flag byte: 0b00000001 = 0x01 (1 byte) <lb/>Option Value: 0x0107 (2 bytes) <lb/>Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 35] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>7. Message Binding, Sequence Numbers, Freshness, and Replay Protection <lb/>7.1. Message Binding <lb/>In order to prevent response delay and mismatch attacks <lb/>[CoAP-Actuators] from on-path attackers and compromised <lb/>intermediaries, OSCORE binds responses to the requests by including <lb/>the &apos;kid&apos; and Partial IV of the request in the AAD of the response. <lb/>Therefore, the server needs to store the &apos;kid&apos; and Partial IV of the <lb/>request until all responses have been sent. <lb/>7.2. Sequence Numbers <lb/>An AEAD nonce MUST NOT be used more than once per AEAD key. The <lb/>uniqueness of (key, nonce) pairs is shown in Appendix D.4, and in <lb/>particular depends on a correct usage of Partial IVs (which encode <lb/>the Sender Sequence Numbers, see Section 5). If messages are <lb/>processed concurrently, the operation of reading and increasing the <lb/>Sender Sequence Number MUST be atomic. <lb/>7.2.1. Maximum Sequence Number <lb/>The maximum Sender Sequence Number is algorithm dependent (see <lb/>Section 12) and SHALL be less than 2^40. If the Sender Sequence <lb/>Number exceeds the maximum, the endpoint MUST NOT process any more <lb/>messages with the given Sender Context. If necessary, the endpoint <lb/>SHOULD acquire a new security context before this happens. The <lb/>latter is out of scope of this document. <lb/>7.3. Freshness <lb/>For requests, OSCORE provides only the guarantee that the request is <lb/>not older than the security context. For applications having <lb/>stronger demands on request freshness (e.g., control of actuators), <lb/>OSCORE needs to be augmented with mechanisms providing freshness (for <lb/>example, as specified in [CoAP-ECHO-REQ-TAG]). <lb/>Assuming an honest server (see Appendix D), the message binding <lb/>guarantees that a response is not older than its request. For <lb/>responses that are not notifications (i.e., when there is a single <lb/>response to a request), this gives absolute freshness. For <lb/>notifications, the absolute freshness gets weaker with time, and it <lb/>is RECOMMENDED that the client regularly re-register the observation. <lb/>Note that the message binding does not guarantee that a misbehaving <lb/>server created the response before receiving the request, i.e., it <lb/>does not verify server aliveness. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 36] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>For requests and notifications, OSCORE also provides relative <lb/>freshness in the sense that the received Partial IV allows a <lb/>recipient to determine the relative order of requests or responses. <lb/>7.4. Replay Protection <lb/>In order to protect from replay of requests, the server&apos;s Recipient <lb/>Context includes a Replay Window. A server SHALL verify that the <lb/>Sender Sequence Number received in the &apos;Partial IV&apos; parameter of the <lb/>COSE object (see Section 6.1) has not been received before. If this <lb/>verification fails, the server SHALL stop processing the message, and <lb/>it MAY optionally respond with a 4.01 (Unauthorized) error message. <lb/>Also, the server MAY set an Outer Max-Age option with value zero to <lb/>inform any intermediary that the response is not to be cached. The <lb/>diagnostic payload MAY contain the string &quot;Replay detected&quot;. The <lb/>size and type of the Replay Window depends on the use case and the <lb/>protocol with which the OSCORE message is transported. In case of <lb/>reliable and ordered transport from endpoint to endpoint, e.g., TCP, <lb/>the server MAY just store the last received Partial IV and require <lb/>that newly received Partial IVs equal the last received Partial IV + <lb/>1. However, in the case of mixed reliable and unreliable transports <lb/>and where messages may be lost, such a replay mechanism may be too <lb/>restrictive and the default replay window may be more suitable (see <lb/>Section 3.2.2). <lb/>Responses (with or without Partial IV) are protected against replay <lb/>as they are bound to the request and the fact that only a single <lb/>response is accepted. In this case the Partial IV is not used for <lb/>replay protection of responses. <lb/>The operation of validating the Partial IV and updating the replay <lb/>protection MUST be atomic. <lb/>7.4.1. Replay Protection of Notifications <lb/>The following applies additionally when the Observe option is <lb/>supported. <lb/>The Notification Number (see Section 4.1.3.5.2) is initialized to the <lb/>Partial IV of the first successfully verified notification in <lb/>response to the registration request. A client MUST only accept at <lb/>most one Observe notification without Partial IV, and treat it as the <lb/>oldest notification received. A client receiving a notification <lb/>containing a Partial IV SHALL compare the Partial IV with the <lb/>Notification Number associated to that Observe registration. The <lb/>client MUST stop processing notifications with a Partial IV that has <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 37] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>been previously received. Applications MAY decide that a client only <lb/>processes notifications that have a greater Partial IV than the <lb/>Notification Number. <lb/>If the verification of the response succeeds, and the received <lb/>Partial IV was greater than the Notification Number, then the client <lb/>SHALL overwrite the corresponding Notification Number with the <lb/>received Partial IV. <lb/>7.5. Losing Part of the Context State <lb/>To prevent reuse of an AEAD nonce with the same AEAD key or the <lb/>acceptance of replayed messages, an endpoint needs to handle the <lb/>situation of losing rapidly changing parts of the context, such as <lb/>the Sender Sequence Number and Replay Window. These are typically <lb/>stored in RAM and therefore lost in the case of, e.g., an unplanned <lb/>reboot. There are different alternatives to recover, for example: <lb/>1. The endpoints can reuse an existing Security Context after <lb/>updating the mutable parts of the security context (Sender <lb/>Sequence Number and Replay Window). This requires that the <lb/>mutable parts of the security context are available throughout <lb/>the lifetime of the device or that the device can establish a <lb/>fresh security context after loss of mutable security context <lb/>data. Examples are given based on careful use of nonvolatile <lb/>memory, see Appendix B.1.1 and the use of the Echo option, see <lb/>Appendix B.1.2. If an endpoint makes use of a partial security <lb/>context stored in nonvolatile memory, it MUST NOT reuse a <lb/>previous Sender Sequence Number and MUST NOT accept previously <lb/>received messages. <lb/>2. The endpoints can reuse an existing shared Master Secret and <lb/>derive new Sender and Recipient Contexts, see Appendix B.2 for an <lb/>example. This typically requires a good source of randomness. <lb/>3. The endpoints can use a trusted third-party-assisted key <lb/>establishment protocol such as [OSCORE-PROFILE]. This requires <lb/>the execution of a three-party protocol and may require a good <lb/>source of randomness. <lb/>4. The endpoints can run a key exchange protocol providing forward <lb/>secrecy resulting in a fresh Master Secret, from which an <lb/>entirely new Security Context is derived. This requires a good <lb/>source of randomness, and additionally, the transmission and <lb/>processing of the protocol may have a non-negligible cost, e.g., <lb/>in terms of power consumption. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 38] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The endpoints need to be configured with information about which <lb/>method is used. The choice of method may depend on capabilities of <lb/>the devices deployed and the solution architecture. Using a key <lb/>exchange protocol is necessary for deployments that require forward <lb/>secrecy. <lb/>8. Processing <lb/>This section describes the OSCORE message processing. Additional <lb/>processing for Observe or Block-wise are described in subsections. <lb/>Note that, analogously to [RFC7252] where the Token and source/ <lb/>destination pair are used to match a response with a request, both <lb/>endpoints MUST keep the association (Token, {Security Context, <lb/>Partial IV of the request}), in order to be able to find the Security <lb/>Context and compute the AAD to protect or verify the response. The <lb/>association MAY be forgotten after it has been used to successfully <lb/>protect or verify the response, with the exception of Observe <lb/>processing, where the association MUST be kept as long as the <lb/>Observation is active. <lb/>The processing of the Sender Sequence Number follows the procedure <lb/>described in Section 3 of [IV-GEN]. <lb/>8.1. Protecting the Request <lb/>Given a CoAP request, the client SHALL perform the following steps to <lb/>create an OSCORE request: <lb/>1. Retrieve the Sender Context associated with the target resource. <lb/>2. Compose the AAD and the plaintext, as described in Sections 5.3 <lb/>and 5.4. <lb/>3. Encode the Partial IV (Sender Sequence Number in network byte <lb/>order) and increment the Sender Sequence Number by one. Compute <lb/>the AEAD nonce from the Sender ID, Common IV, and Partial IV as <lb/>described in Section 5.2. <lb/>4. Encrypt the COSE object using the Sender Key. Compress the COSE <lb/>object as specified in Section 6. <lb/>5. Format the OSCORE message according to Section 4. The OSCORE <lb/>option is added (see Section 4.1.2). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 39] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>8.2. Verifying the Request <lb/>A server receiving a request containing the OSCORE option SHALL <lb/>perform the following steps: <lb/>1. Discard Code and all Class E options (marked in Figure 5 with &apos;x&apos; <lb/>in column E) present in the received message. For example, an <lb/>If-Match Outer option is discarded, but an Uri-Host Outer option <lb/>is not discarded. <lb/>2. Decompress the COSE object (Section 6) and retrieve the Recipient <lb/>Context associated with the Recipient ID in the &apos;kid&apos; parameter, <lb/>additionally using the &apos;kid context&apos;, if present. Note that the <lb/>Recipient Context MAY be retrieved by deriving a new security <lb/>context, e.g. as described in Appendix B.2. If either the <lb/>decompression or the COSE message fails to decode, or the server <lb/>fails to retrieve a Recipient Context with Recipient ID <lb/>corresponding to the &apos;kid&apos; parameter received, then the server <lb/>SHALL stop processing the request. <lb/>* If either the decompression or the COSE message fails to <lb/>decode, the server MAY respond with a 4.02 (Bad Option) error <lb/>message. The server MAY set an Outer Max-Age option with <lb/>value zero. The diagnostic payload MAY contain the string <lb/>&quot;Failed to decode COSE&quot;. <lb/>* If the server fails to retrieve a Recipient Context with <lb/>Recipient ID corresponding to the &apos;kid&apos; parameter received, <lb/>the server MAY respond with a 4.01 (Unauthorized) error <lb/>message. The server MAY set an Outer Max-Age option with <lb/>value zero. The diagnostic payload MAY contain the string <lb/>&quot;Security context not found&quot;. <lb/>3. Verify that the Partial IV has not been received before using the <lb/>Replay Window, as described in Section 7.4. <lb/>4. Compose the AAD, as described in Section 5.4. <lb/>5. Compute the AEAD nonce from the Recipient ID, Common IV, and the <lb/>Partial IV, received in the COSE object. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 40] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>6. Decrypt the COSE object using the Recipient Key, as per <lb/>Section 5.3 of [RFC8152]. (The decrypt operation includes the <lb/>verification of the integrity.) <lb/>* If decryption fails, the server MUST stop processing the <lb/>request and MAY respond with a 4.00 (Bad Request) error <lb/>message. The server MAY set an Outer Max-Age option with <lb/>value zero. The diagnostic payload MAY contain the string <lb/>&quot;Decryption failed&quot;. <lb/>* If decryption succeeds, update the Replay Window, as described <lb/>in Section 7. <lb/>7. Add decrypted Code, options, and payload to the decrypted <lb/>request. The OSCORE option is removed. <lb/>8. The decrypted CoAP request is processed according to [RFC7252]. <lb/>8.2.1. Supporting Block-wise <lb/>If Block-wise is supported, insert the following step before any <lb/>other: <lb/>A. If Block-wise is present in the request, then process the Outer <lb/>Block options according to [RFC7959], until all blocks of the request <lb/>have been received (see Section 4.1.3.4). <lb/>8.3. Protecting the Response <lb/>If a CoAP response is generated in response to an OSCORE request, the <lb/>server SHALL perform the following steps to create an OSCORE <lb/>response. Note that CoAP error responses derived from CoAP <lb/>processing (step 8 in Section 8.2) are protected, as well as <lb/>successful CoAP responses, while the OSCORE errors (steps 2, 3, and 6 <lb/>in Section 8.2) do not follow the processing below but are sent as <lb/>simple CoAP responses, without OSCORE processing. <lb/>1. Retrieve the Sender Context in the Security Context associated <lb/>with the Token. <lb/>2. Compose the AAD and the plaintext, as described in Sections 5.3 <lb/>and 5.4. <lb/>3. Compute the AEAD nonce as described in Section 5.2: <lb/>* Either use the AEAD nonce from the request, or <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 41] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>* Encode the Partial IV (Sender Sequence Number in network byte <lb/>order) and increment the Sender Sequence Number by one. <lb/>Compute the AEAD nonce from the Sender ID, Common IV, and <lb/>Partial IV. <lb/>4. Encrypt the COSE object using the Sender Key. Compress the COSE <lb/>object as specified in Section 6. If the AEAD nonce was <lb/>constructed from a new Partial IV, this Partial IV MUST be <lb/>included in the message. If the AEAD nonce from the request was <lb/>used, the Partial IV MUST NOT be included in the message. <lb/>5. Format the OSCORE message according to Section 4. The OSCORE <lb/>option is added (see Section 4.1.2). <lb/>8.3.1. Supporting Observe <lb/>If Observe is supported, insert the following step between steps 2 <lb/>and 3 of Section 8.3: <lb/>A. If the response is an Observe notification: <lb/>o If the response is the first notification: <lb/>* compute the AEAD nonce as described in Section 5.2: <lb/>+ Either use the AEAD nonce from the request, or <lb/>+ Encode the Partial IV (Sender Sequence Number in network <lb/>byte order) and increment the Sender Sequence Number by one. <lb/>Compute the AEAD nonce from the Sender ID, Common IV, and <lb/>Partial IV. <lb/>Then, go to 4. <lb/>o If the response is not the first notification: <lb/>* encode the Partial IV (Sender Sequence Number in network byte <lb/>order) and increment the Sender Sequence Number by one. <lb/>Compute the AEAD nonce from the Sender ID, Common IV, and <lb/>Partial IV, then go to 4. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 42] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>8.4. Verifying the Response <lb/>A client receiving a response containing the OSCORE option SHALL <lb/>perform the following steps: <lb/>1. Discard Code and all Class E options (marked in Figure 5 with &apos;x&apos; <lb/>in column E) present in the received message. For example, ETag <lb/>Outer option is discarded, as well as Max-Age Outer option. <lb/>2. Retrieve the Recipient Context in the Security Context associated <lb/>with the Token. Decompress the COSE object (Section 6). If <lb/>either the decompression or the COSE message fails to decode, <lb/>then go to 8. <lb/>3. Compose the AAD, as described in Section 5.4. <lb/>4. Compute the AEAD nonce <lb/>* If the Partial IV is not present in the response, the AEAD <lb/>nonce from the request is used. <lb/>* If the Partial IV is present in the response, compute the AEAD <lb/>nonce from the Recipient ID, Common IV, and the Partial IV, <lb/>received in the COSE object. <lb/>5. Decrypt the COSE object using the Recipient Key, as per <lb/>Section 5.3 of [RFC8152]. (The decrypt operation includes the <lb/>verification of the integrity.) If decryption fails, then go to <lb/>8. <lb/>6. Add decrypted Code, options and payload to the decrypted request. <lb/>The OSCORE option is removed. <lb/>7. The decrypted CoAP response is processed according to [RFC7252]. <lb/>8. In case any of the previous erroneous conditions apply: the <lb/>client SHALL stop processing the response. <lb/>8.4.1. Supporting Block-wise <lb/>If Block-wise is supported, insert the following step before any <lb/>other: <lb/>A. If Block-wise is present in the response, then process the Outer <lb/>Block options according to [RFC7959], until all blocks of the <lb/>response have been received (see Section 4.1.3.4). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 43] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>8.4.2. Supporting Observe <lb/>If Observe is supported: <lb/>Insert the following step between step 5 and step 6: <lb/>A. If the request was an Observe registration, then: <lb/>o If the Partial IV is not present in the response, and the Inner <lb/>Observe option is present, and the AEAD nonce from the request was <lb/>already used once, then go to 8. <lb/>o If the Partial IV is present in the response and the Inner Observe <lb/>option is present, then follow the processing described in <lb/>Section 4.1.3.5.2 and Section 7.4.1, then: <lb/>* initialize the Notification Number (if first successfully <lb/>verified notification), or <lb/>* overwrite the Notification Number (if the received Partial IV <lb/>was greater than the Notification Number). <lb/>Replace step 8 of Section 8.4 with: <lb/>B. In case any of the previous erroneous conditions apply: the <lb/>client SHALL stop processing the response. An error condition <lb/>occurring while processing a response to an observation request does <lb/>not cancel the observation. A client MUST NOT react to failure by <lb/>re-registering the observation immediately. <lb/>9. Web Linking <lb/>The use of OSCORE MAY be indicated by a target &quot;osc&quot; attribute in a <lb/>web link [RFC8288] to a resource, e.g., using a link-format document <lb/>[RFC6690] if the resource is accessible over CoAP. <lb/>The &quot;osc&quot; attribute is a hint indicating that the destination of that <lb/>link is only accessible using OSCORE, and unprotected access to it is <lb/>not supported. Note that this is simply a hint, it does not include <lb/>any security context material or any other information required to <lb/>run OSCORE. <lb/>A value MUST NOT be given for the &quot;osc&quot; attribute; any present value <lb/>MUST be ignored by parsers. The &quot;osc&quot; attribute MUST NOT appear more <lb/>than once in a given link-value; occurrences after the first MUST be <lb/>ignored by parsers. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 44] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The example in Figure 11 shows a use of the &quot;osc&quot; attribute: the <lb/>client does resource discovery on a server and gets back a list of <lb/>resources, one of which includes the &quot;osc&quot; attribute indicating that <lb/>the resource is protected with OSCORE. The link-format notation (see <lb/>Section 5 of [RFC6690]) is used. <lb/>REQ: GET /.well-known/core <lb/>RES: 2.05 Content <lb/>&lt;/sensors/temp&gt;;osc, <lb/>&lt;/sensors/light&gt;;if=&quot;sensor&quot; <lb/>Figure 11: The Web Link <lb/>10. CoAP-to-CoAP Forwarding Proxy <lb/>CoAP is designed for proxy operations (see Section 5.7 of [RFC7252]). <lb/>OSCORE is designed to work with OSCORE-unaware CoAP proxies. <lb/>Security requirements for forwarding are listed in Section 2.2.1 of <lb/>[CoAP-E2E-Sec]. Proxy processing of the (Outer) Proxy-Uri option <lb/>works as defined in [RFC7252]. Proxy processing of the (Outer) Block <lb/>options works as defined in [RFC7959]. <lb/>However, not all CoAP proxy operations are useful: <lb/>o Since a CoAP response is only applicable to the original CoAP <lb/>request, caching is in general not useful. In support of existing <lb/>proxies, OSCORE uses the Outer Max-Age option, see <lb/>Section 4.1.3.1. <lb/>o Proxy processing of the (Outer) Observe option as defined in <lb/>[RFC7641] is specified in Section 4.1.3.5. <lb/>Optionally, a CoAP proxy MAY detect OSCORE and act accordingly. An <lb/>OSCORE-aware CoAP proxy: <lb/>o SHALL bypass caching for the request if the OSCORE option is <lb/>present. <lb/>o SHOULD avoid caching responses to requests with an OSCORE option. <lb/>In the case of Observe (see Section 4.1.3.5), the OSCORE-aware CoAP <lb/>proxy: <lb/>o SHALL NOT initiate an Observe registration. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 45] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o MAY verify the order of notifications using Partial IV rather than <lb/>the Observe option. <lb/>11. HTTP Operations <lb/>The CoAP request/response model may be mapped to HTTP and vice versa <lb/>as described in Section 10 of [RFC7252]. The HTTP-CoAP mapping is <lb/>further detailed in [RFC8075]. This section defines the components <lb/>needed to map and transport OSCORE messages over HTTP hops. By <lb/>mapping between HTTP and CoAP and by using cross-protocol proxies, <lb/>OSCORE may be used end-to-end between, e.g., an HTTP client and a <lb/>CoAP server. Examples are provided in Sections 11.5 and 11.6. <lb/>11.1. The HTTP OSCORE Header Field <lb/>The HTTP OSCORE header field (see Section 13.4) is used for carrying <lb/>the content of the CoAP OSCORE option when transporting OSCORE <lb/>messages over HTTP hops. <lb/>The HTTP OSCORE header field is only used in POST requests and <lb/>responses with HTTP Status Code 200 (OK). When used, the HTTP header <lb/>field Content-Type is set to &apos;application/oscore&apos; (see Section 13.5) <lb/>indicating that the HTTP body of this message contains the OSCORE <lb/>payload (see Section 6.2). No additional semantics are provided by <lb/>other message fields. <lb/>Using the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], <lb/>including the following core ABNF syntax rules defined by that <lb/>specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP <lb/>OSCORE header field value is as follows. <lb/>base64url-char = ALPHA / DIGIT / &quot;-&quot; / &quot;_&quot; <lb/>OSCORE = 2*base64url-char <lb/>The HTTP OSCORE header field is not appropriate to list in the <lb/>Connection header field (see Section 6.1 of [RFC7230]) since it is <lb/>not hop-by-hop. OSCORE messages are generally not useful when served <lb/>from cache (i.e., they will generally be marked Cache-Control: no-<lb/>cache) and so interaction with Vary is not relevant (Section 7.1.4 of <lb/>[RFC7231]). Since the HTTP OSCORE header field is critical for <lb/>message processing, moving it from headers to trailers renders the <lb/>message unusable in case trailers are ignored (see Section 4.1 of <lb/>[RFC7230]). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 46] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>In general, intermediaries are not allowed to insert, delete, or <lb/>modify the OSCORE header. In general, changes to the HTTP OSCORE <lb/>header field will violate the integrity of the OSCORE message <lb/>resulting in an error. For the same reason the HTTP OSCORE header <lb/>field is generally not preserved across redirects. <lb/>Since redirects are not defined in the mappings between HTTP and CoAP <lb/>([RFC8075] [RFC7252]), a number of conditions need to be fulfilled <lb/>for redirects to work. For CoAP-client-to-HTTP-server redirects, <lb/>such conditions include: <lb/>o the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP <lb/>client as in the HTTP case. <lb/>o the CoAP-to-HTTP proxy copies the HTTP OSCORE header field and <lb/>body to the new request. <lb/>o the target of the redirect has the necessary OSCORE security <lb/>context required to decrypt and verify the message. <lb/>Since OSCORE requires the HTTP body to be preserved across redirects, <lb/>the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect) <lb/>or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302 <lb/>(Found). <lb/>For the case of HTTP-client-to-CoAP-server redirects, although <lb/>redirect is not defined for CoAP servers [RFC7252], an HTTP client <lb/>receiving a redirect should generate a new OSCORE request for the <lb/>server it was redirected to. <lb/>11.2. CoAP-to-HTTP Mapping <lb/>Section 10.1 of [RFC7252] describes the fundamentals of the CoAP-to-<lb/>HTTP cross-protocol mapping process. The additional rules for OSCORE <lb/>messages are as follows: <lb/>o The HTTP OSCORE header field value is set to: <lb/>* AA if the CoAP OSCORE option is empty; otherwise, <lb/>* the value of the CoAP OSCORE option (Section 6.1) in base64url <lb/>(Section 5 of [RFC4648]) encoding without padding. <lb/>Implementation notes for this encoding are given in Appendix C <lb/>of [RFC7515]. <lb/>o The HTTP Content-Type is set to &apos;application/oscore&apos; (see <lb/>Section 13.5), independent of CoAP Content-Format. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 47] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>11.3. HTTP-to-CoAP Mapping <lb/>Section 10.2 of [RFC7252] and [RFC8075] specify the behavior of an <lb/>HTTP-to-CoAP proxy. The additional rules for HTTP messages with the <lb/>OSCORE header field are as follows. <lb/>o The CoAP OSCORE option is set as follows: <lb/>* empty if the value of the HTTP OSCORE header field is a single <lb/>zero byte (0x00) represented by AA; otherwise, <lb/>* the value of the HTTP OSCORE header field decoded from <lb/>base64url (Section 5 of [RFC4648]) without padding. <lb/>Implementation notes for this encoding are given in Appendix C <lb/>of [RFC7515]. <lb/>o The CoAP Content-Format option is omitted, the content format for <lb/>OSCORE (Section 13.6) MUST NOT be used. <lb/>11.4. HTTP Endpoints <lb/>Restricted to subsets of HTTP and CoAP supporting a bijective <lb/>mapping, OSCORE can be originated or terminated in HTTP endpoints. <lb/>The sending HTTP endpoint uses [RFC8075] to translate the HTTP <lb/>message into a CoAP message. The CoAP message is then processed with <lb/>OSCORE as defined in this document. The OSCORE message is then <lb/>mapped to HTTP as described in Section 11.2 and sent in compliance <lb/>with the rules in Section 11.1. <lb/>The receiving HTTP endpoint maps the HTTP message to a CoAP message <lb/>using [RFC8075] and Section 11.3. The resulting OSCORE message is <lb/>processed as defined in this document. If successful, the plaintext <lb/>CoAP message is translated to HTTP for normal processing in the <lb/>endpoint. <lb/>11.5. Example: HTTP Client and CoAP Server <lb/>This section gives an example of what a request and a response <lb/>between an HTTP client and a CoAP server could look like. The <lb/>example is not a test vector but intended as an illustration of how <lb/>the message fields are translated in the different steps. <lb/>Mapping and notation here is based on &quot;Simple Form&quot; (Section 5.4.1 of <lb/>[RFC8075]). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 48] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>[HTTP request --Before client object security processing] <lb/>GET http://proxy.url/hc/?target_uri=coap://server.url/orders <lb/>HTTP/1.1 <lb/>[HTTP request --HTTP Client to Proxy] <lb/>POST http://proxy.url/hc/?target_uri=coap://server.url/ HTTP/1.1 <lb/>Content-Type: application/oscore <lb/>OSCORE: CSU <lb/>Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] <lb/>[CoAP request --Proxy to CoAP Server] <lb/>POST coap://server.url/ <lb/>OSCORE: 09 25 <lb/>Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] <lb/>[CoAP request --After server object security processing] <lb/>GET coap://server.url/orders <lb/>[CoAP response --Before server object security processing] <lb/>2.05 Content <lb/>Content-Format: 0 <lb/>Payload: Exterminate! Exterminate! <lb/>[CoAP response --CoAP Server to Proxy] <lb/>2.04 Changed <lb/>OSCORE: [empty] <lb/>Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] <lb/>[HTTP response --Proxy to HTTP Client] <lb/>HTTP/1.1 200 OK <lb/>Content-Type: application/oscore <lb/>OSCORE: AA <lb/>Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] <lb/>[HTTP response --After client object security processing] <lb/>HTTP/1.1 200 OK <lb/>Content-Type: text/plain <lb/>Body: Exterminate! Exterminate! <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 49] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Note that the HTTP Status Code 200 (OK) in the next-to-last message <lb/>is the mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status <lb/>Code 200 (OK) in the last message is the mapping of the CoAP Code <lb/>2.05 (Content), which was encrypted within the compressed COSE object <lb/>carried in the Body of the HTTP response. <lb/>11.6. Example: CoAP Client and HTTP Server <lb/>This section gives an example of what a request and a response <lb/>between a CoAP client and an HTTP server could look like. The <lb/>example is not a test vector but intended as an illustration of how <lb/>the message fields are translated in the different steps. <lb/>[CoAP request --Before client object security processing] <lb/>GET coap://proxy.url/ <lb/>Proxy-Uri=http://server.url/orders <lb/>[CoAP request --CoAP Client to Proxy] <lb/>POST coap://proxy.url/ <lb/>Proxy-Uri=http://server.url/ <lb/>OSCORE: 09 25 <lb/>Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] <lb/>[HTTP request --Proxy to HTTP Server] <lb/>POST http://server.url/ HTTP/1.1 <lb/>Content-Type: application/oscore <lb/>OSCORE: CSU <lb/>Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] <lb/>[HTTP request --After server object security processing] <lb/>GET http://server.url/orders HTTP/1.1 <lb/>[HTTP response --Before server object security processing] <lb/>HTTP/1.1 200 OK <lb/>Content-Type: text/plain <lb/>Body: Exterminate! Exterminate! <lb/>[HTTP response --HTTP Server to Proxy] <lb/>HTTP/1.1 200 OK <lb/>Content-Type: application/oscore <lb/>OSCORE: AA <lb/>Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 50] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>[CoAP response --Proxy to CoAP Client] <lb/>2.04 Changed <lb/>OSCORE: [empty] <lb/>Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] <lb/>[CoAP response --After client object security processing] <lb/>2.05 Content <lb/>Content-Format: 0 <lb/>Payload: Exterminate! Exterminate! <lb/>Note that the HTTP Code 2.04 (Changed) in the next-to-last message is <lb/>the mapping of HTTP Status Code 200 (OK), whereas the CoAP Code 2.05 <lb/>(Content) in the last message is the value that was encrypted within <lb/>the compressed COSE object carried in the Body of the HTTP response. <lb/>12. Security Considerations <lb/>An overview of the security properties is given in Appendix D. <lb/>12.1. End-to-end Protection <lb/>In scenarios with intermediary nodes such as proxies or gateways, <lb/>transport layer security such as (D)TLS only protects data hop-by-<lb/>hop. As a consequence, the intermediary nodes can read and modify <lb/>any information. The trust model where all intermediary nodes are <lb/>considered trustworthy is problematic, not only from a privacy <lb/>perspective, but also from a security perspective, as the <lb/>intermediaries are free to delete resources on sensors and falsify <lb/>commands to actuators (such as &quot;unlock door&quot;, &quot;start fire alarm&quot;, <lb/>&quot;raise bridge&quot;). Even in the rare cases where all the owners of the <lb/>intermediary nodes are fully trusted, attacks and data breaches make <lb/>such an architecture brittle. <lb/>(D)TLS protects hop-by-hop the entire message. OSCORE protects end-<lb/>to-end all information that is not required for proxy operations (see <lb/>Section 4). (D)TLS and OSCORE can be combined, thereby enabling end-<lb/>to-end security of the message payload, in combination with hop-by-<lb/>hop protection of the entire message, during transport between <lb/>endpoint and intermediary node. In particular, when OSCORE is used <lb/>with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED, <lb/>e.g., between an HTTP endpoint and a proxy translating between HTTP <lb/>and CoAP. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 51] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Applications need to consider that certain message fields and <lb/>messages types are not protected end-to-end and may be spoofed or <lb/>manipulated. The consequences of unprotected message fields are <lb/>analyzed in Appendix D.5. <lb/>12.2. Security Context Establishment <lb/>The use of COSE_Encrypt0 and AEAD to protect messages as specified in <lb/>this document requires an established security context. The method <lb/>to establish the security context described in Section 3.2 is based <lb/>on a common Master Secret and unique Sender IDs. The necessary input <lb/>parameters may be preestablished or obtained using a key <lb/>establishment protocol augmented with establishment of Sender/ <lb/>Recipient ID, such as a key exchange protocol or the OSCORE profile <lb/>of the Authentication and Authorization for Constrained Environments <lb/>(ACE) framework [OSCORE-PROFILE]. Such a procedure must ensure that <lb/>the requirements of the security context parameters for the intended <lb/>use are complied with (see Section 3.3) even in error situations. <lb/>While recipient IDs are allowed to coincide between different <lb/>security contexts (see Section 3.3), this may cause a server to <lb/>process multiple verifications before finding the right security <lb/>context or rejecting a message. Considerations for deploying OSCORE <lb/>with a fixed Master Secret are given in Appendix B. <lb/>12.3. Master Secret <lb/>OSCORE uses HKDF [RFC5869] and the established input parameters to <lb/>derive the security context. The required properties of the security <lb/>context parameters are discussed in Section 3.3; in this section, we <lb/>focus on the Master Secret. In this specification, HKDF denotes the <lb/>composition of the expand and extract functions as defined in <lb/>[RFC5869] and the Master Secret is used as Input Keying Material <lb/>(IKM). <lb/>Informally, HKDF takes as source an IKM containing some good amount <lb/>of randomness but not necessarily distributed uniformly (or for which <lb/>an attacker has some partial knowledge) and derive from it one or <lb/>more cryptographically strong secret keys [RFC5869]. <lb/>Therefore, the main requirement for the OSCORE Master Secret, in <lb/>addition to being secret, is that it have a good amount of <lb/>randomness. The selected key establishment schemes must ensure that <lb/>the necessary properties for the Master Secret are fulfilled. For <lb/>pre-shared key deployments and key transport solutions such as <lb/>[OSCORE-PROFILE], the Master Secret can be generated offline using a <lb/>good random number generator. Randomness requirements for security <lb/>are described in [RFC4086]. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 52] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>12.4. Replay Protection <lb/>Replay attacks need to be considered in different parts of the <lb/>implementation. Most AEAD algorithms require a unique nonce for each <lb/>message, for which the Sender Sequence Numbers in the COSE message <lb/>field &apos;Partial IV&apos; is used. If the recipient accepts any sequence <lb/>number larger than the one previously received, then the problem of <lb/>sequence number synchronization is avoided. With reliable transport, <lb/>it may be defined that only messages with sequence numbers that are <lb/>equal to the previous sequence number + 1 are accepted. An adversary <lb/>may try to induce a device reboot for the purpose of replaying a <lb/>message (see Section 7.5). <lb/>Note that sharing a security context between servers may open up for <lb/>replay attacks, for example, if the Replay Windows are not <lb/>synchronized. <lb/>12.5. Client Aliveness <lb/>A verified OSCORE request enables the server to verify the identity <lb/>of the entity who generated the message. However, it does not verify <lb/>that the client is currently involved in the communication, since the <lb/>message may be a delayed delivery of a previously generated request, <lb/>which now reaches the server. To verify the aliveness of the client <lb/>the server may use the Echo option in the response to a request from <lb/>the client (see [CoAP-ECHO-REQ-TAG]). <lb/>12.6. Cryptographic Considerations <lb/>The maximum Sender Sequence Number is dependent on the AEAD <lb/>algorithm. The maximum Sender Sequence Number is 2^40 -1, or any <lb/>algorithm-specific lower limit, after which a new security context <lb/>must be generated. The mechanism to build the AEAD nonce <lb/>(Section 5.2) assumes that the nonce is at least 56 bits, and the <lb/>Partial IV is at most 40 bits. The mandatory-to-implement AEAD <lb/>algorithm AES-CCM-16-64-128 is selected for compatibility with CCM*. <lb/>AEAD algorithms that require unpredictable nonces are not supported. <lb/>In order to prevent cryptanalysis when the same plaintext is <lb/>repeatedly encrypted by many different users with distinct AEAD keys, <lb/>the AEAD nonce is formed by mixing the sequence number with a secret <lb/>per-context initialization vector (Common IV) derived along with the <lb/>keys (see Section 3.1 of [RFC8152]), and by using a Master Salt in <lb/>the key derivation (see [MF00] for an overview). The Master Secret, <lb/>Sender Key, Recipient Key, and Common IV must be secret, the rest of <lb/>the parameters may be public. The Master Secret must have a good <lb/>amount of randomness (see Section 12.3). <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 53] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The ID Context, Sender ID, and Partial IV are always at least <lb/>implicitly integrity protected, as manipulation leads to the wrong <lb/>nonce or key being used and therefore results in decryption failure. <lb/>12.7. Message Segmentation <lb/>The Inner Block options enable the sender to split large messages <lb/>into OSCORE-protected blocks such that the receiving endpoint can <lb/>verify blocks before having received the complete message. The Outer <lb/>Block options allow for arbitrary proxy fragmentation operations that <lb/>cannot be verified by the endpoints but that can, by policy, be <lb/>restricted in size since the Inner Block options allow for secure <lb/>fragmentation of very large messages. A maximum message size (above <lb/>which the sending endpoint fragments the message and the receiving <lb/>endpoint discards the message, if complying to the policy) may be <lb/>obtained as part of normal resource discovery. <lb/>12.8. Privacy Considerations <lb/>Privacy threats executed through intermediary nodes are considerably <lb/>reduced by means of OSCORE. End-to-end integrity protection and <lb/>encryption of the message payload and all options that are not used <lb/>for proxy operations provide mitigation against attacks on sensor and <lb/>actuator communication, which may have a direct impact on the <lb/>personal sphere. <lb/>The unprotected options (Figure 5) may reveal privacy-sensitive <lb/>information, see Appendix D.5. CoAP headers sent in plaintext allow, <lb/>for example, matching of CON and ACK (CoAP Message Identifier), <lb/>matching of request and responses (Token) and traffic analysis. <lb/>OSCORE does not provide protection for HTTP header fields that are <lb/>not both CoAP-mappable and Class E. The HTTP message fields that are <lb/>visible to on-path entities are only used for the purpose of <lb/>transporting the OSCORE message, whereas the application-layer <lb/>message is encoded in CoAP and encrypted. <lb/>COSE message fields, i.e., the OSCORE option, may reveal information <lb/>about the communicating endpoints. For example, &apos;kid&apos; and &apos;kid <lb/>context&apos;, which are intended to help the server find the right <lb/>context, may reveal information about the client. Tracking &apos;kid&apos; and <lb/>&apos;kid context&apos; to one server may be used for correlating requests from <lb/>one client. <lb/>Unprotected error messages reveal information about the security <lb/>state in the communication between the endpoints. Unprotected <lb/>signaling messages reveal information about the reliable transport <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 54] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>used on a leg of the path. Using the mechanisms described in <lb/>Section 7.5 may reveal when a device goes through a reboot. This can <lb/>be mitigated by the device storing the precise state of Sender <lb/>Sequence Number and Replay Window on a clean shutdown. <lb/>The length of message fields can reveal information about the <lb/>message. Applications may use a padding scheme to protect against <lb/>traffic analysis. <lb/>13. IANA Considerations <lb/>13.1. COSE Header Parameters Registry <lb/>The &apos;kid context&apos; parameter has been added to the &quot;COSE Header <lb/>Parameters&quot; registry: <lb/>o Name: kid context <lb/>o Label: 10 <lb/>o Value Type: bstr <lb/>o Value Registry: <lb/>o Description: Identifies the context for the key identifier <lb/>o Reference: Section 5.1 of this document <lb/>13.2. CoAP Option Numbers Registry <lb/>The OSCORE option has been added to the &quot;CoAP Option Numbers&quot; <lb/>registry: <lb/>+--------+-----------------+-------------------+ <lb/>| Number | Name <lb/>| Reference <lb/>| <lb/>+--------+-----------------+-------------------+ <lb/>| <lb/>9 | OSCORE <lb/>| [RFC8613] <lb/>| <lb/>+--------+-----------------+-------------------+ <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 55] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Furthermore, the following existing entries in the &quot;CoAP Option <lb/>Numbers&quot; registry have been updated with a reference to the document <lb/>specifying OSCORE processing of that option: <lb/>+--------+-----------------+-------------------------------+ <lb/>| Number | Name <lb/>| <lb/>Reference <lb/>| <lb/>+--------+-----------------+-------------------------------+ <lb/>| <lb/>1 <lb/>| If-Match <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| <lb/>3 <lb/>| Uri-Host <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| <lb/>4 <lb/>| ETag <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| <lb/>5 <lb/>| If-None-Match <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| <lb/>6 <lb/>| Observe <lb/>| [RFC7641] [RFC8613] <lb/>| <lb/>| <lb/>7 <lb/>| Uri-Port <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| <lb/>8 <lb/>| Location-Path <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 11 <lb/>| Uri-Path <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 12 <lb/>| Content-Format | [RFC7252] [RFC8613] <lb/>| <lb/>| 14 <lb/>| Max-Age <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 15 <lb/>| Uri-Query <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 17 <lb/>| Accept <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 20 <lb/>| Location-Query | [RFC7252] [RFC8613] <lb/>| <lb/>| 23 <lb/>| Block2 <lb/>| [RFC7959] [RFC8323] [RFC8613] | <lb/>| 27 <lb/>| Block1 <lb/>| [RFC7959] [RFC8323] [RFC8613] | <lb/>| 28 <lb/>| Size2 <lb/>| [RFC7959] [RFC8613] <lb/>| <lb/>| 35 <lb/>| Proxy-Uri <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 39 <lb/>| Proxy-Scheme <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 60 <lb/>| Size1 <lb/>| [RFC7252] [RFC8613] <lb/>| <lb/>| 258 <lb/>| No-Response <lb/>| [RFC7967] [RFC8613] <lb/>| <lb/>+--------+-----------------+-------------------------------+ <lb/>Future additions to the &quot;CoAP Option Numbers&quot; registry need to <lb/>provide a reference to the document where the OSCORE processing of <lb/>that CoAP Option is defined. <lb/>13.3. CoAP Signaling Option Numbers Registry <lb/>The OSCORE option has been added to the &quot;CoAP Signaling Option <lb/>Numbers&quot; registry: <lb/>+------------+--------+---------------------+-------------------+ <lb/>| Applies to | Number | Name <lb/>| Reference <lb/>| <lb/>+------------+--------+---------------------+-------------------+ <lb/>| 7.xx (all) | <lb/>9 | OSCORE <lb/>| [RFC8613] <lb/>| <lb/>+------------+--------+---------------------+-------------------+ <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 56] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>13.4. Header Field Registrations <lb/>The HTTP OSCORE header field has been added to the &quot;Message Headers&quot; <lb/>registry: <lb/>+-------------------+----------+----------+---------------------+ <lb/>| Header Field Name | Protocol | Status <lb/>| Reference <lb/>| <lb/>+-------------------+----------+----------+---------------------+ <lb/>| OSCORE <lb/>| http <lb/>| standard | [RFC8613], <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Section 11.1 <lb/>| <lb/>+-------------------+----------+----------+---------------------+ <lb/>13.5. Media Type Registration <lb/>This section registers the &apos;application/oscore&apos; media type in the <lb/>&quot;Media Types&quot; registry. This media type is used to indicate that the <lb/>content is an OSCORE message. The OSCORE body cannot be understood <lb/>without the OSCORE header field value and the security context. <lb/>Type name: application <lb/>Subtype name: oscore <lb/>Required parameters: N/A <lb/>Optional parameters: N/A <lb/>Encoding considerations: binary <lb/>Security considerations: See the Security Considerations section <lb/>of [RFC8613]. <lb/>Interoperability considerations: N/A <lb/>Published specification: [RFC8613] <lb/>Applications that use this media type: IoT applications sending <lb/>security content over HTTP(S) transports. <lb/>Fragment identifier considerations: N/A <lb/>Additional information: <lb/>* Deprecated alias names for this type: N/A <lb/>* Magic number(s): N/A <lb/>* File extension(s): N/A <lb/>* Macintosh file type code(s): N/A <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 57] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Person &amp; email address to contact for further information: <lb/>IESG &lt;iesg@ietf.org&gt; <lb/>Intended usage: COMMON <lb/>Restrictions on usage: N/A <lb/>Author: Goeran Selander &lt;goran.selander@ericsson.com&gt; <lb/>Change Controller: IESG <lb/>Provisional registration? No <lb/>13.6. CoAP Content-Formats Registry <lb/>This section registers the media type &apos;application/oscore&apos; media type <lb/>in the &quot;CoAP Content-Formats&quot; registry. This Content-Format for the <lb/>OSCORE payload is defined for potential future use cases and SHALL <lb/>NOT be used in the OSCORE message. The OSCORE payload cannot be <lb/>understood without the OSCORE option value and the security context. <lb/>+----------------------+----------+----------+-------------------+ <lb/>| Media Type <lb/>| Encoding | <lb/>ID <lb/>| <lb/>Reference <lb/>| <lb/>+----------------------+----------+----------+-------------------+ <lb/>| application/oscore <lb/>| <lb/>| 10001 <lb/>| [RFC8613] <lb/>| <lb/>+----------------------+----------+----------+-------------------+ <lb/>13.7. OSCORE Flag Bits Registry <lb/>This document defines a subregistry for the OSCORE flag bits within <lb/>the &quot;CoRE Parameters&quot; registry. The name of the subregistry is <lb/>&quot;OSCORE Flag Bits&quot;. The registry has been created with the Expert <lb/>Review policy [RFC8126]. Guidelines for the experts are provided in <lb/>Section 13.8. <lb/>The columns of the registry are as follows: <lb/>o Bit Position: This indicates the position of the bit in the set of <lb/>OSCORE flag bits, starting at 0 for the most significant bit. The <lb/>bit position must be an integer or a range of integers, in the <lb/>range 0 to 63. <lb/>o Name: The name is present to make it easier to refer to and <lb/>discuss the registration entry. The value is not used in the <lb/>protocol. Names are to be unique in the table. <lb/>o Description: This contains a brief description of the use of the <lb/>bit. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 58] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Reference: This contains a pointer to the specification defining <lb/>the entry. <lb/>The initial contents of the registry are in the table below. The <lb/>reference column for all rows is this document. The entries with Bit <lb/>Position of 0 and 1 are marked as &apos;Reserved&apos;. The entry with Bit <lb/>Position of 1 will be specified in a future document and will be used <lb/>to expand the space for the OSCORE flag bits in Section 6.1, so that <lb/>entries 8-63 of the registry are defined. <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| Bit Position | Name <lb/>| Description <lb/>| Reference | <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>0 <lb/>| Reserved <lb/>| <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>1 <lb/>| Reserved <lb/>| <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>2 <lb/>| Unassigned | <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>3 <lb/>| Kid Context | Set to 1 if kid context <lb/>| [RFC8613] | <lb/>| <lb/>| Flag <lb/>| is present in the <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| compressed COSE object <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>4 <lb/>| Kid Flag <lb/>| Set to 1 if kid is present | [RFC8613] | <lb/>| <lb/>| <lb/>| in the compressed COSE <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| object <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>5-7 <lb/>| Partial IV | Encodes the Partial IV <lb/>| [RFC8613] | <lb/>| <lb/>| Length <lb/>| length; can have value <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0 to 5 <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>| <lb/>8-63 <lb/>| Unassigned | <lb/>| <lb/>| <lb/>+--------------+-------------+-----------------------------+-----------+ <lb/>13.8. Expert Review Instructions <lb/>The expert reviewers for the registry defined in this document are <lb/>expected to ensure that the usage solves a valid use case that could <lb/>not be solved better in a different way, that it is not going to <lb/>duplicate one that is already registered, and that the registered <lb/>point is likely to be used in deployments. They are furthermore <lb/>expected to check the clarity of purpose and use of the requested <lb/>code points. Experts should take into account the expected usage of <lb/>entries when approving point assignment, and the length of the <lb/>encoded value should be weighed against the number of code points <lb/>left that encode to that size and the size of device it will be used <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 59] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>on. Experts should block registration for entries 8-63 until these <lb/>points are defined (i.e., until the mechanism for the OSCORE flag <lb/>bits expansion via bit 1 is specified). <lb/></body>

			<listBibl>14. References <lb/>14.1. Normative References <lb/>[RFC2119] Bradner, S., &quot;Key words for use in RFCs to Indicate <lb/>Requirement Levels&quot;, BCP 14, RFC 2119, <lb/>DOI 10.17487/RFC2119, March 1997, <lb/>&lt;https://www.rfc-editor.org/info/rfc2119&gt;. <lb/>[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, <lb/>&quot;Randomness Requirements for Security&quot;, BCP 106, RFC 4086, <lb/>DOI 10.17487/RFC4086, June 2005, <lb/>&lt;https://www.rfc-editor.org/info/rfc4086&gt;. <lb/>[RFC4648] Josefsson, S., &quot;The Base16, Base32, and Base64 Data <lb/>Encodings&quot;, RFC 4648, DOI 10.17487/RFC4648, October 2006, <lb/>&lt;https://www.rfc-editor.org/info/rfc4648&gt;. <lb/>[RFC5234] Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax <lb/>Specifications: ABNF&quot;, STD 68, RFC 5234, <lb/>DOI 10.17487/RFC5234, January 2008, <lb/>&lt;https://www.rfc-editor.org/info/rfc5234&gt;. <lb/>[RFC6347] Rescorla, E. and N. Modadugu, &quot;Datagram Transport Layer <lb/>Security Version 1.2&quot;, RFC 6347, DOI 10.17487/RFC6347, <lb/>January 2012, &lt;https://www.rfc-editor.org/info/rfc6347&gt;. <lb/>[RFC7049] Bormann, C. and P. Hoffman, &quot;Concise Binary Object <lb/>Representation (CBOR)&quot;, RFC 7049, DOI 10.17487/RFC7049, <lb/>October 2013, &lt;https://www.rfc-editor.org/info/rfc7049&gt;. <lb/>[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer <lb/>Protocol (HTTP/1.1): Message Syntax and Routing&quot;, <lb/>RFC 7230, DOI 10.17487/RFC7230, June 2014, <lb/>&lt;https://www.rfc-editor.org/info/rfc7230&gt;. <lb/>[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer <lb/>Protocol (HTTP/1.1): Semantics and Content&quot;, RFC 7231, <lb/>DOI 10.17487/RFC7231, June 2014, <lb/>&lt;https://www.rfc-editor.org/info/rfc7231&gt;. <lb/></listBibl>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 60] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<listBibl>[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, &quot;The Constrained <lb/>Application Protocol (CoAP)&quot;, RFC 7252, <lb/>DOI 10.17487/RFC7252, June 2014, <lb/>&lt;https://www.rfc-editor.org/info/rfc7252&gt;. <lb/>[RFC7641] Hartke, K., &quot;Observing Resources in the Constrained <lb/>Application Protocol (CoAP)&quot;, RFC 7641, <lb/>DOI 10.17487/RFC7641, September 2015, <lb/>&lt;https://www.rfc-editor.org/info/rfc7641&gt;. <lb/>[RFC7959] Bormann, C. and Z. Shelby, Ed., &quot;Block-Wise Transfers in <lb/>the Constrained Application Protocol (CoAP)&quot;, RFC 7959, <lb/>DOI 10.17487/RFC7959, August 2016, <lb/>&lt;https://www.rfc-editor.org/info/rfc7959&gt;. <lb/>[RFC8075] Castellani, A., Loreto, S., Rahman, A., Fossati, T., and <lb/>E. Dijk, &quot;Guidelines for Mapping Implementations: HTTP to <lb/>the Constrained Application Protocol (CoAP)&quot;, RFC 8075, <lb/>DOI 10.17487/RFC8075, February 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8075&gt;. <lb/>[RFC8132] van der Stok, P., Bormann, C., and A. Sehgal, &quot;PATCH and <lb/>FETCH Methods for the Constrained Application Protocol <lb/>(CoAP)&quot;, RFC 8132, DOI 10.17487/RFC8132, April 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8132&gt;. <lb/>[RFC8152] Schaad, J., &quot;CBOR Object Signing and Encryption (COSE)&quot;, <lb/>RFC 8152, DOI 10.17487/RFC8152, July 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8152&gt;. <lb/>[RFC8174] Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in RFC <lb/>2119 Key Words&quot;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, <lb/>May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;. <lb/>[RFC8288] Nottingham, M., &quot;Web Linking&quot;, RFC 8288, <lb/>DOI 10.17487/RFC8288, October 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8288&gt;. <lb/>[RFC8323] Bormann, C., Lemay, S., Tschofenig, H., Hartke, K., <lb/>Silverajan, B., and B. Raymor, Ed., &quot;CoAP (Constrained <lb/>Application Protocol) over TCP, TLS, and WebSockets&quot;, <lb/>RFC 8323, DOI 10.17487/RFC8323, February 2018, <lb/>&lt;https://www.rfc-editor.org/info/rfc8323&gt;. <lb/>[RFC8446] Rescorla, E., &quot;The Transport Layer Security (TLS) Protocol <lb/>Version 1.3&quot;, RFC 8446, DOI 10.17487/RFC8446, August 2018, <lb/>&lt;https://www.rfc-editor.org/info/rfc8446&gt;. <lb/></listBibl>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 61] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, &quot;Concise Data <lb/>Definition Language (CDDL): A Notational Convention to <lb/>Express Concise Binary Object Representation (CBOR) and <lb/>JSON Data Structures&quot;, RFC 8610, DOI 10.17487/RFC8610, <lb/>June 2019, &lt;https://www.rfc-editor.org/info/rfc8610&gt;. <lb/>14.2. Informative References <lb/>[ACE-OAuth] <lb/>Seitz, L., Selander, G., Wahlstroem, E., Erdtman, S., and <lb/>H. Tschofenig, &quot;Authentication and Authorization for <lb/>Constrained Environments (ACE) using the OAuth 2.0 <lb/>Framework (ACE-OAuth)&quot;, Work in Progress, draft-ietf-ace-<lb/>oauth-authz-24, March 2019. <lb/>[CoAP-802.15.4] <lb/>Bormann, C., &quot;Constrained Application Protocol (CoAP) over <lb/>IEEE 802.15.4 Information Element for IETF&quot;, Work in <lb/>Progress, draft-bormann-6lo-coap-802-15-ie-00, April 2016. <lb/>[CoAP-Actuators] <lb/>Mattsson, J., Fornehed, J., Selander, G., Palombini, F., <lb/>and C. Amsuess, &quot;Controlling Actuators with CoAP&quot;, Work in <lb/>Progress, draft-mattsson-core-coap-actuators-06, September <lb/>2018. <lb/>[CoAP-E2E-Sec] <lb/>Selander, G., Palombini, F., and K. Hartke, &quot;Requirements <lb/>for CoAP End-To-End Security&quot;, Work in Progress, draft-<lb/>hartke-core-e2e-security-reqs-03, July 2017. <lb/>[CoAP-ECHO-REQ-TAG] <lb/>Amsuess, C., Mattsson, J., and G. Selander, &quot;CoAP: Echo, <lb/>Request-Tag, and Token Processing&quot;, Work in Progress, <lb/>draft-ietf-core-echo-request-tag-04, March 2019. <lb/>[Group-OSCORE] <lb/>Tiloca, M., Selander, G., Palombini, F., and J. Park, <lb/>&quot;Group OSCORE -Secure Group Communication for CoAP&quot;, Work <lb/>in Progress, draft-ietf-core-oscore-groupcomm-04, March <lb/>2019. <lb/>[IV-GEN] <lb/>McGrew, D., &quot;Generation of Deterministic Initialization <lb/>Vectors (IVs) and Nonces&quot;, Work in Progress, draft-mcgrew-<lb/>iv-gen-03, October 2013. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 62] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<listBibl>[MF00] <lb/>McGrew, D. and S. Fluhrer, &quot;Attacks on Additive Encryption <lb/>of Redundant Plaintext and Implications on Internet <lb/>Security&quot;, Proceedings of the Seventh Annual Workshop on <lb/>Selected Areas in Cryptography (SAC 2000) Springer-<lb/>Verlag., pp. 14-28, 2000. <lb/>[OSCORE-PROFILE] <lb/>Palombini, F., Seitz, L., Selander, G., and M. Gunnarsson, <lb/>&quot;OSCORE profile of the Authentication and Authorization <lb/>for Constrained Environments Framework&quot;, Work in <lb/>Progress, draft-ietf-ace-oscore-profile-07, February 2019. <lb/>[REST] <lb/>Fielding, R., &quot;Architectural Styles and the Design of <lb/>Network-based Software Architectures&quot;, Ph.D. <lb/>Dissertation, University of California, Irvine, 2010. <lb/>[RFC3552] Rescorla, E. and B. Korver, &quot;Guidelines for Writing RFC <lb/>Text on Security Considerations&quot;, BCP 72, RFC 3552, <lb/>DOI 10.17487/RFC3552, July 2003, <lb/>&lt;https://www.rfc-editor.org/info/rfc3552&gt;. <lb/>[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform <lb/>Resource Identifier (URI): Generic Syntax&quot;, STD 66, <lb/>RFC 3986, DOI 10.17487/RFC3986, January 2005, <lb/>&lt;https://www.rfc-editor.org/info/rfc3986&gt;. <lb/>[RFC5116] McGrew, D., &quot;An Interface and Algorithms for Authenticated <lb/>Encryption&quot;, RFC 5116, DOI 10.17487/RFC5116, January 2008, <lb/>&lt;https://www.rfc-editor.org/info/rfc5116&gt;. <lb/>[RFC5869] Krawczyk, H. and P. Eronen, &quot;HMAC-based Extract-and-Expand <lb/>Key Derivation Function (HKDF)&quot;, RFC 5869, <lb/>DOI 10.17487/RFC5869, May 2010, <lb/>&lt;https://www.rfc-editor.org/info/rfc5869&gt;. <lb/>[RFC6690] Shelby, Z., &quot;Constrained RESTful Environments (CoRE) Link <lb/>Format&quot;, RFC 6690, DOI 10.17487/RFC6690, August 2012, <lb/>&lt;https://www.rfc-editor.org/info/rfc6690&gt;. <lb/>[RFC7228] Bormann, C., Ersue, M., and A. Keranen, &quot;Terminology for <lb/>Constrained-Node Networks&quot;, RFC 7228, <lb/>DOI 10.17487/RFC7228, May 2014, <lb/>&lt;https://www.rfc-editor.org/info/rfc7228&gt;. <lb/>[RFC7515] Jones, M., Bradley, J., and N. Sakimura, &quot;JSON Web <lb/>Signature (JWS)&quot;, RFC 7515, DOI 10.17487/RFC7515, May <lb/>2015, &lt;https://www.rfc-editor.org/info/rfc7515&gt;. <lb/></listBibl>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 63] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>[RFC7967] Bhattacharyya, A., Bandyopadhyay, S., Pal, A., and T. <lb/>Bose, &quot;Constrained Application Protocol (CoAP) Option for <lb/>No Server Response&quot;, RFC 7967, DOI 10.17487/RFC7967, <lb/>August 2016, &lt;https://www.rfc-editor.org/info/rfc7967&gt;. <lb/>[RFC8126] Cotton, M., Leiba, B., and T. Narten, &quot;Guidelines for <lb/>Writing an IANA Considerations Section in RFCs&quot;, BCP 26, <lb/>RFC 8126, DOI 10.17487/RFC8126, June 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8126&gt;. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 64] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Appendix A. Scenario Examples <lb/>This section gives examples of OSCORE, targeting scenarios in <lb/>Section 2.2.1.1 of [CoAP-E2E-Sec]. The message exchanges are made, <lb/>based on the assumption that there is a security context established <lb/>between client and server. For simplicity, these examples only <lb/>indicate the content of the messages without going into detail of the <lb/>(compressed) COSE message format. <lb/>A.1. Secure Access to Sensor <lb/>This example illustrates a client requesting the alarm status from a <lb/>server. <lb/>Client Proxy Server <lb/>| <lb/>| <lb/>| <lb/>+------&gt;| <lb/>| <lb/>Code: 0.02 (POST) <lb/>| POST | <lb/>| <lb/>Token: 0x8c <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [kid:5f, Partial IV:42] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:0.01, <lb/>| <lb/>| <lb/>| <lb/>Uri-Path:&quot;alarm_status&quot;} <lb/>| <lb/>| <lb/>| <lb/>| <lb/>+------&gt;| <lb/>Code: 0.02 (POST) <lb/>| <lb/>| POST | <lb/>Token: 0x7b <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [kid:5f, Partial IV:42] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:0.01, <lb/>| <lb/>| <lb/>| <lb/>Uri-Path:&quot;alarm_status&quot;} <lb/>| <lb/>| <lb/>| <lb/>| <lb/>|&lt;------+ <lb/>Code: 2.04 (Changed) <lb/>| <lb/>| 2.04 | <lb/>Token: 0x7b <lb/>| <lb/>| <lb/>| <lb/>OSCORE: -<lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, &quot;0&quot;} <lb/>| <lb/>| <lb/>| <lb/>|&lt;------+ <lb/>| <lb/>Code: 2.04 (Changed) <lb/>| 2.04 | <lb/>| <lb/>Token: 0x8c <lb/>| <lb/>| <lb/>| <lb/>OSCORE: -<lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, &quot;0&quot;} <lb/>| <lb/>| <lb/>| <lb/>Square brackets [ ... ] indicate content of compressed COSE object. <lb/>Curly brackets { ... } indicate encrypted data. <lb/>Figure 12: Secure Access to Sensor <lb/>The CoAP request/response Codes are encrypted by OSCORE and only <lb/>dummy Codes (POST/Changed) are visible in the header of the OSCORE <lb/>message. The option Uri-Path (&quot;alarm_status&quot;) and payload (&quot;0&quot;) are <lb/>encrypted. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 65] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The COSE header of the request contains an identifier (5f), <lb/>indicating which security context was used to protect the message and <lb/>a Partial IV (42). <lb/>The server verifies the request as specified in Section 8.2. The <lb/>client verifies the response as specified in Section 8.4. <lb/>A.2. Secure Subscribe to Sensor <lb/>This example illustrates a client requesting subscription to a blood <lb/>sugar measurement resource (GET /glucose), first receiving the value <lb/>220 mg/dl and then a second value 180 mg/dl. <lb/>Client Proxy Server <lb/>| <lb/>| <lb/>| <lb/>+------&gt;| <lb/>| <lb/>Code: 0.05 (FETCH) <lb/>| FETCH | <lb/>| <lb/>Token: 0x83 <lb/>| <lb/>| <lb/>| <lb/>Observe: 0 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [kid:ca, Partial IV:15] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:0.01, <lb/>| <lb/>| <lb/>| <lb/>Observe:0, <lb/>| <lb/>| <lb/>| <lb/>Uri-Path:&quot;glucose&quot;} <lb/>| <lb/>| <lb/>| <lb/>| <lb/>+------&gt;| <lb/>Code: 0.05 (FETCH) <lb/>| <lb/>| FETCH | <lb/>Token: 0xbe <lb/>| <lb/>| <lb/>| <lb/>Observe: 0 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [kid:ca, Partial IV:15] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:0.01, <lb/>| <lb/>| <lb/>| <lb/>Observe:0, <lb/>| <lb/>| <lb/>| <lb/>Uri-Path:&quot;glucose&quot;} <lb/>| <lb/>| <lb/>| <lb/>| <lb/>|&lt;------+ <lb/>Code: 2.05 (Content) <lb/>| <lb/>| 2.05 | <lb/>Token: 0xbe <lb/>| <lb/>| <lb/>| <lb/>Observe: 7 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: -<lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, <lb/>| <lb/>| <lb/>| <lb/>Observe:-, <lb/>| <lb/>| <lb/>| <lb/>Content-Format:0, &quot;220&quot;} <lb/>| <lb/>| <lb/>| <lb/>|&lt;------+ <lb/>| <lb/>Code: 2.05 (Content) <lb/>| 2.05 | <lb/>| <lb/>Token: 0x83 <lb/>| <lb/>| <lb/>| <lb/>Observe: 7 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: -<lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, <lb/>| <lb/>| <lb/>| <lb/>Observe:-, <lb/>| <lb/>| <lb/>| <lb/>Content-Format:0, &quot;220&quot;} <lb/>... <lb/>... <lb/>... <lb/>| <lb/>| <lb/>| <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 66] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>| <lb/>|&lt;------+ <lb/>Code: 2.05 (Content) <lb/>| <lb/>| 2.05 | <lb/>Token: 0xbe <lb/>| <lb/>| <lb/>| <lb/>Observe: 8 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [Partial IV:36] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, <lb/>| <lb/>| <lb/>| <lb/>Observe:-, <lb/>| <lb/>| <lb/>| <lb/>Content-Format:0, &quot;180&quot;} <lb/>| <lb/>| <lb/>| <lb/>|&lt;------+ <lb/>| <lb/>Code: 2.05 (Content) <lb/>| 2.05 | <lb/>| <lb/>Token: 0x83 <lb/>| <lb/>| <lb/>| <lb/>Observe: 8 <lb/>| <lb/>| <lb/>| <lb/>OSCORE: [Partial IV:36] <lb/>| <lb/>| <lb/>| <lb/>Payload: {Code:2.05, <lb/>| <lb/>| <lb/>| <lb/>Observe:-, <lb/>| <lb/>| <lb/>| <lb/>Content-Format:0, &quot;180&quot;} <lb/>| <lb/>| <lb/>| <lb/>Square brackets [ ... ] indicate content of compressed COSE object <lb/>header. Curly brackets { ... } indicate encrypted data. <lb/>Figure 13: Secure Subscribe to Sensor <lb/>The dummy Codes (FETCH/Content) are used to allow forwarding of <lb/>Observe messages. The options Content-Format (0) and the payload <lb/>(&quot;220&quot; and &quot;180&quot;) are encrypted. <lb/>The COSE header of the request contains an identifier (ca), <lb/>indicating the security context used to protect the message and a <lb/>Partial IV (15). The COSE header of the second response contains the <lb/>Partial IV (36). The first response uses the Partial IV of the <lb/>request. <lb/>The server verifies that the Partial IV has not been received before. <lb/>The client verifies that the responses are bound to the request and <lb/>that the Partial IVs are greater than any Partial IV previously <lb/>received in a response bound to the request, except for the <lb/>notification without Partial IV, which is considered the oldest. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 67] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Appendix B. Deployment Examples <lb/>For many Internet of Things (IoT) deployments, a 128-bit uniformly <lb/>random Master Key is sufficient for encrypting all data exchanged <lb/>with the IoT device throughout its lifetime. Two examples are given <lb/>in this section. In the first example, the security context is only <lb/>derived once from the Master Secret. In the second example, security <lb/>contexts are derived multiple times using random inputs. <lb/>B.1. Security Context Derived Once <lb/>An application that only derives the security context once needs to <lb/>handle the loss of mutable security context parameters, e.g., due to <lb/>reboot. <lb/>B.1.1. Sender Sequence Number <lb/>In order to handle loss of Sender Sequence Numbers, the device may <lb/>implement procedures for writing to nonvolatile memory during normal <lb/>operations and updating the security context after reboot, provided <lb/>that the procedures comply with the requirements on the security <lb/>context parameters (Section 3.3). This section gives an example of <lb/>such a procedure. <lb/>There are known issues related to writing to nonvolatile memory. For <lb/>example, flash drives may have a limited number of erase operations <lb/>during its lifetime. Also, the time for a write operation to <lb/>nonvolatile memory to be completed may be unpredictable, e.g., due to <lb/>caching, which could result in important security context data not <lb/>being stored at the time when the device reboots. <lb/>However, many devices have predictable limits for writing to <lb/>nonvolatile memory, are physically limited to only send a small <lb/>amount of messages per minute, and may have no good source of <lb/>randomness. <lb/>To prevent reuse of Sender Sequence Number, an endpoint may perform <lb/>the following procedure during normal operations: <lb/>o Before using a Sender Sequence Number that is evenly divisible by <lb/>K, where K is a positive integer, store the Sender Sequence Number <lb/>(SSN1) in nonvolatile memory. After booting, the endpoint <lb/>initiates the new Sender Sequence Number (SSN2) to the value <lb/>stored in persistent memory plus K plus F: SSN2 = SSN1 + K + F, <lb/>where F is a positive integer. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 68] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>* Writing to nonvolatile memory can be costly; the value K gives <lb/>a trade-off between frequency of storage operations and <lb/>efficient use of Sender Sequence Numbers. <lb/>* Writing to nonvolatile memory may be subject to delays, or <lb/>failure; F MUST be set so that the last Sender Sequence Number <lb/>used before reboot is never larger than SSN2. <lb/>If F cannot be set so SSN2 is always larger than the last Sender <lb/>Sequence Number used before reboot, the method described in this <lb/>section MUST NOT be used. <lb/>B.1.2. Replay Window <lb/>In case of loss of security context on the server, to prevent <lb/>accepting replay of previously received requests, the server may <lb/>perform the following procedure after booting: <lb/>o The server updates its Sender Sequence Number as specified in <lb/>Appendix B.1.1 to be used as Partial IV in the response containing <lb/>the Echo option (next bullet). <lb/>o For each stored security context, the first time after booting, <lb/>the server receives an OSCORE request, the server responds with an <lb/>OSCORE protected 4.01 (Unauthorized), containing only the Echo <lb/>option [CoAP-ECHO-REQ-TAG] and no diagnostic payload. The server <lb/>MUST use its Partial IV when generating the AEAD nonce and MUST <lb/>include the Partial IV in the response (see Section 5). If the <lb/>server with use of the Echo option can verify a second OSCORE <lb/>request as fresh, then the Partial IV of the second request is set <lb/>as the lower limit of the Replay Window of that security context. <lb/>B.1.3. Notifications <lb/>To prevent the acceptance of replay of previously received <lb/>notifications, the client may perform the following procedure after <lb/>booting: <lb/>o The client forgets about earlier registrations and removes all <lb/>Notification Numbers. The client then registers again using the <lb/>Observe option. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 69] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>B.2. Security Context Derived Multiple Times <lb/>An application that does not require forward secrecy may allow <lb/>multiple security contexts to be derived from one Master Secret. The <lb/>requirements on the security context parameters MUST be fulfilled <lb/>(Section 3.3) even if the client or server is rebooted, <lb/>recommissioned, or in error cases. <lb/>This section gives an example of a protocol that adds randomness to <lb/>the ID Context parameter and uses that together with input parameters <lb/>preestablished between client and server, in particular Master <lb/>Secret, Master Salt, and Sender/Recipient ID (see Section 3.2), to <lb/>derive new security contexts. The random input is transported <lb/>between client and server in the &apos;kid context&apos; parameter. This <lb/>protocol MUST NOT be used unless both endpoints have good sources of <lb/>randomness. <lb/>During normal requests, the ID Context of an established security <lb/>context may be sent in the &apos;kid context&apos;, which, together with &apos;kid&apos;, <lb/>facilitates for the server to locate a security context. <lb/>Alternatively, the &apos;kid context&apos; may be omitted since the ID Context <lb/>is expected to be known to both client and server; see Section 5.1. <lb/>The protocol described in this section may only be needed when the <lb/>mutable part of security context is lost in the client or server, <lb/>e.g., when the endpoint has rebooted. The protocol may additionally <lb/>be used whenever the client and server need to derive a new security <lb/>context. For example, if a device is provisioned with one fixed set <lb/>of input parameters (including Master Secret, Sender and Recipient <lb/>Identifiers), then a randomized ID Context ensures that the security <lb/>context is different for each deployment. <lb/>Note that the server needs to be configured to run this protocol when <lb/>it is not able to retrieve an existing security context, instead of <lb/>stopping processing the message as described in step 2 of <lb/>Section 8.2. <lb/>The protocol is described below with reference to Figure 14. The <lb/>client or the server may initiate the protocol, in the latter case <lb/>step 1 is omitted. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 70] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Client <lb/>Server <lb/>| <lb/>| <lb/>1. Protect with <lb/>| <lb/>request #1 <lb/>| <lb/>ID Context = ID1 <lb/>|---------------------&gt;| 2. Verify with <lb/>| kid_context = ID1 <lb/>| <lb/>ID Context = ID1 <lb/>| <lb/>| <lb/>| <lb/>response #1 <lb/>| <lb/>Protect with <lb/>3. Verify with <lb/>|&lt;---------------------| <lb/>ID Context = R2||ID1 <lb/>ID Context = R2||ID1 | <lb/>kid_context = R2 <lb/>| <lb/>| <lb/>| <lb/>Protect with <lb/>| <lb/>request #2 <lb/>| <lb/>ID Context = R2||R3 |---------------------&gt;| 4. Verify with <lb/>| kid_context = R2||R3 | <lb/>ID Context = R2||R3 <lb/>| <lb/>| <lb/>| <lb/>response #2 <lb/>| <lb/>Protect with <lb/>5. Verify with <lb/>|&lt;---------------------| <lb/>ID Context = R2||R3 <lb/>ID Context = R2||R3 | <lb/>| <lb/>Figure 14: Protocol for Establishing a New Security Context <lb/>1. (Optional) If the client does not have a valid security context <lb/>with the server, e.g., because of reboot or because this is the <lb/>first time it contacts the server, then it generates a random <lb/>string R1 and uses this as ID Context together with the input <lb/>parameters shared with the server to derive a first security <lb/>context. The client sends an OSCORE request to the server <lb/>protected with the first security context, containing R1 wrapped <lb/>in a CBOR bstr as &apos;kid context&apos;. The request may target a <lb/>special resource used for updating security contexts. <lb/>2. The server receives an OSCORE request for which it does not have <lb/>a valid security context, either because the client has generated <lb/>a new security context ID1 = R1 or because the server has lost <lb/>part of its security context, e.g., ID Context, Sender Sequence <lb/>Number or Replay Window. If the server is able to verify the <lb/>request (see Section 8.2) with the new derived first security <lb/>context using the received ID1 (transported in &apos;kid context&apos;) as <lb/>ID Context and the input parameters associated to the received <lb/>&apos;kid&apos;, then the server generates a random string R2 and derives a <lb/>second security context with ID Context = ID2 = R2 || ID1. The <lb/>server sends a 4.01 (Unauthorized) response protected with the <lb/>second security context, containing R2 wrapped in a CBOR bstr as <lb/>&apos;kid context&apos;, and caches R2. R2 MUST NOT be reused as that may <lb/>lead to reuse of key and nonce in response #1. Note that the <lb/>server may receive several requests #1 associated with one <lb/>security context, leading to multiple parallel protocol runs. <lb/>Multiple instances of R2 may need to be cached until one of the <lb/>protocol runs is completed, see Appendix B.2.1. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 71] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>3. The client receives a response with &apos;kid context&apos; containing a <lb/>CBOR bstr wrapping R2 to an OSCORE request it made with ID <lb/>Context = ID1. The client derives a second security context <lb/>using ID Context = ID2 = R2 || ID1. If the client can verify the <lb/>response (see Section 8.4) using the second security context, <lb/>then the client makes a request protected with a third security <lb/>context derived from ID Context = ID3 = R2 || R3, where R3 is a <lb/>random byte string generated by the client. The request includes <lb/>R2 || R3 wrapped in a CBOR bstr as &apos;kid context&apos;. <lb/>4. If the server receives a request with &apos;kid context&apos; containing a <lb/>CBOR bstr wrapping ID3, where the first part of ID3 is identical <lb/>to an R2 sent in a previous response #1, which it has not <lb/>received before, then the server derives a third security context <lb/>with ID Context = ID3. The server MUST NOT accept replayed <lb/>request #2 messages. If the server can verify the request (see <lb/>Section 8.2) with the third security context, then the server <lb/>marks the third security context to be used with this client and <lb/>removes all instances of R2 associated to this security context <lb/>from the cache. This security context replaces the previous <lb/>security context with the client, and the first and the second <lb/>security contexts are deleted. The server responds using the <lb/>same security context as in the request. <lb/>5. If the client receives a response to the request with the third <lb/>security context and the response verifies (see Section 8.4), <lb/>then the client marks the third security context to be used with <lb/>this server. This security context replaces the previous <lb/>security context with the server, and the first and second <lb/>security contexts are deleted. <lb/>If verification fails in any step, the endpoint stops processing that <lb/>message. <lb/>The length of the nonces R1, R2, and R3 is application specific. The <lb/>application needs to set the length of each nonce such that the <lb/>probability of its value being repeated is negligible; typically, at <lb/>least 8 bytes long. Since R2 may be generated as the result of a <lb/>replayed request #1, the probability for collision of R2s is impacted <lb/>by the birthday paradox. For example, setting the length of R2 to 8 <lb/>bytes results in an average collision after 2^32 response #1 <lb/>messages, which should not be an issue for a constrained server <lb/>handling on the order of one request per second. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 72] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Request #2 can be an ordinary request. The server performs the <lb/>action of the request and sends response #2 after having successfully <lb/>completed the operations related to the security context in step 4. <lb/>The client acts on response #2 after having successfully completed <lb/>step 5. <lb/>When sending request #2, the client is assured that the Sender Key <lb/>(derived with the random value R3) has never been used before. When <lb/>receiving response #2, the client is assured that the response <lb/>(protected with a key derived from the random value R3 and the Master <lb/>Secret) was created by the server in response to request #2. <lb/>Similarly, when receiving request #2, the server is assured that the <lb/>request (protected with a key derived from the random value R2 and <lb/>the Master Secret) was created by the client in response to response <lb/>#1. When sending response #2, the server is assured that the Sender <lb/>Key (derived with the random value R2) has never been used before. <lb/>Implementation and denial-of-service considerations are made in <lb/>Appendix B.2.1 and Appendix B.2.2. <lb/>B.2.1. Implementation Considerations <lb/>This section add some implementation considerations to the protocol <lb/>described in the previous section. <lb/>The server may only have space for a few security contexts or only be <lb/>able to handle a few protocol runs in parallel. The server may <lb/>legitimately receive multiple request #1 messages using the same <lb/>immutable security context, e.g., because of packet loss. Replays of <lb/>old request #1 messages could be difficult for the server to <lb/>distinguish from legitimate. The server needs to handle the case <lb/>when the maximum number of cached R2s is reached. If the server <lb/>receives a request #1 and is not capable of executing it then it may <lb/>respond with an unprotected 5.03 (Service Unavailable) error message. <lb/>The server may clear up state from protocol runs that never complete, <lb/>e.g., set a timer when caching R2, and remove R2 and the associated <lb/>security contexts from the cache at timeout. Additionally, state <lb/>information can be flushed at reboot. <lb/>As an alternative to caching R2, the server could generate R2 in such <lb/>a way that it can be sent (in response #1) and verified (at reception <lb/>of request #2) as the value of R2 it had generated. Such a procedure <lb/>MUST NOT lead to the server accepting replayed request #2 messages. <lb/>One construction described in the following is based on using a <lb/>secret random HMAC key K_HMAC per set of immutable security context <lb/>parameters associated with a client. This construction allows the <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 73] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>server to handle verification of R2 in response #2 at the cost of <lb/>storing the K_HMAC keys and a slightly larger message overhead in <lb/>response #1. Steps below refer to modifications to Appendix B.2: <lb/>o In step 2, R2 is generated in the following way. First, the <lb/>server generates a random K_HMAC (unless it already has one <lb/>associated with the security context), then it sets R2 = S2 || <lb/>HMAC(K_HMAC, S2) where S2 is a random byte string, and the HMAC is <lb/>truncated to 8 bytes. K_HMAC may have an expiration time, after <lb/>which it is erased. Note that neither R2, S2, nor the derived <lb/>first and second security contexts need to be cached. <lb/>o In step 4, instead of verifying that R2 coincides with a cached <lb/>value, the server looks up the associated K_HMAC and verifies the <lb/>truncated HMAC, and the processing continues accordingly depending <lb/>on verification success or failure. K_HMAC is used until a run of <lb/>the protocol is completed (after verification of request #2), or <lb/>until it expires (whatever comes first), after which K_HMAC is <lb/>erased. (The latter corresponds to removing the cached values of <lb/>R2 in step 4 of Appendix B.2 and makes the server reject replays <lb/>of request #2.) <lb/>The length of S2 is application specific and the probability for <lb/>collision of S2s is impacted by the birthday paradox. For example, <lb/>setting the length of S2 to 8 bytes results in an average collision <lb/>after 2^32 response #1 messages, which should not be an issue for a <lb/>constrained server handling on the order of one request per second. <lb/>Two endpoints sharing a security context may accidentally initiate <lb/>two instances of the protocol at the same time, each in the role of <lb/>client, e.g., after a power outage affecting both endpoints. Such a <lb/>race condition could potentially lead to both protocols failing, and <lb/>both endpoints repeatedly reinitiating the protocol without <lb/>converging. Both endpoints can detect this situation, and it can be <lb/>handled in different ways. The requests could potentially be more <lb/>spread out in time, for example, by only initiating this protocol <lb/>when the endpoint actually needs to make a request, potentially <lb/>adding a random delay before requests immediately after reboot or if <lb/>such parallel protocol runs are detected. <lb/>B.2.2. Attack Considerations <lb/>An on-path attacker may inject a message causing the endpoint to <lb/>process verification of the message. A message crafted without <lb/>access to the Master Secret will fail to verify. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 74] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>Replaying an old request with a value of &apos;kid_context&apos; that the <lb/>server does not recognize could trigger the protocol. This causes <lb/>the server to generate the first and second security context and send <lb/>a response. But if the client did not expect a response, it will be <lb/>discarded. This may still result in a denial-of-service attack <lb/>against the server, e.g., because of not being able to manage the <lb/>state associated with many parallel protocol runs, and it may prevent <lb/>legitimate client requests. Implementation alternatives with less <lb/>data caching per request #1 message are favorable in this respect; <lb/>see Appendix B.2.1. <lb/>Replaying response #1 in response to some request other than request <lb/>#1 will fail to verify, since response #1 is associated to request <lb/>#1, through the dependencies of ID Contexts and the Partial IV of <lb/>request #1 included in the external_aad of response #1. <lb/>If request #2 has already been well received, then the server has a <lb/>valid security context, so a replay of request #2 is handled by the <lb/>normal replay protection mechanism. Similarly, if response #2 has <lb/>already been received, a replay of response #2 to some other request <lb/>from the client will fail by the normal verification of binding of <lb/>response to request. <lb/>Appendix C. Test Vectors <lb/>This appendix includes the test vectors for different examples of <lb/>CoAP messages using OSCORE. Given a set of inputs, OSCORE defines <lb/>how to set up the Security Context in both the client and the server. <lb/>Note that in Appendix C.4 and all following test vectors the Token <lb/>and the Message ID of the OSCORE-protected CoAP messages are set to <lb/>the same value of the unprotected CoAP message to help the reader <lb/>with comparisons. <lb/>C.1. Test Vector 1: Key Derivation with Master Salt <lb/>In this test vector, a Master Salt of 8 bytes is used. The default <lb/>values are used for AEAD Algorithm and HKDF. <lb/>C.1.1. Client <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Master Salt: 0x9e7ca92223786340 (8 bytes) <lb/>o Sender ID: 0x (0 byte) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 75] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Recipient ID: 0x01 (1 byte) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x8540f60a634b657910 (9 bytes) <lb/>o info (for Recipient Key): 0x854101f60a634b657910 (10 bytes) <lb/>o info (for Common IV): 0x8540f60a6249560d (8 bytes) <lb/>Outputs: <lb/>o Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes) <lb/>o Recipient Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/>o Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>o recipient nonce: 0x4722d4dd6d944169eefb54987c (13 bytes) <lb/>C.1.2. Server <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Master Salt: 0x9e7ca92223786340 (8 bytes) <lb/>o Sender ID: 0x01 (1 byte) <lb/>o Recipient ID: 0x (0 byte) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x854101f60a634b657910 (10 bytes) <lb/>o info (for Recipient Key): 0x8540f60a634b657910 (9 bytes) <lb/>o info (for Common IV): 0x8540f60a6249560d (8 bytes) <lb/>Outputs: <lb/>o Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 76] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Recipient Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes) <lb/>o Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0x4722d4dd6d944169eefb54987c (13 bytes) <lb/>o recipient nonce: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>C.2. Test Vector 2: Key Derivation without Master Salt <lb/>In this test vector, the default values are used for AEAD Algorithm, <lb/>HKDF, and Master Salt. <lb/>C.2.1. Client <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Sender ID: 0x00 (1 byte) <lb/>o Recipient ID: 0x01 (1 byte) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x854100f60a634b657910 (10 bytes) <lb/>o info (for Recipient Key): 0x854101f60a634b657910 (10 bytes) <lb/>o info (for Common IV): 0x8540f60a6249560d (8 bytes) <lb/>Outputs: <lb/>o Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes) <lb/>o Recipient Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes) <lb/>o Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes) <lb/>o recipient nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 77] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>C.2.2. Server <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Sender ID: 0x01 (1 byte) <lb/>o Recipient ID: 0x00 (1 byte) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x854101f60a634b657910 (10 bytes) <lb/>o info (for Recipient Key): 0x854100f60a634b657910 (10 bytes) <lb/>o info (for Common IV): 0x8540f60a6249560d (8 bytes) <lb/>Outputs: <lb/>o Sender Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes) <lb/>o Recipient Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes) <lb/>o Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes) <lb/>o recipient nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes) <lb/>C.3. Test Vector 3: Key Derivation with ID Context <lb/>In this test vector, a Master Salt of 8 bytes and an ID Context of 8 <lb/>bytes are used. The default values are used for AEAD Algorithm and <lb/>HKDF. <lb/>C.3.1. Client <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Master Salt: 0x9e7ca92223786340 (8 bytes) <lb/>o Sender ID: 0x (0 byte) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 78] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Recipient ID: 0x01 (1 byte) <lb/>o ID Context: 0x37cbf3210017a2d3 (8 bytes) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x85404837cbf3210017a2d30a634b657910 (17 <lb/>bytes) <lb/>o info (for Recipient Key): 0x8541014837cbf3210017a2d30a634b657910 <lb/>(18 bytes) <lb/>o info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 <lb/>bytes) <lb/>Outputs: <lb/>o Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes) <lb/>o Recipient Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes) <lb/>o Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes) <lb/>o recipient nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes) <lb/>C.3.2. Server <lb/>Inputs: <lb/>o Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes) <lb/>o Master Salt: 0x9e7ca92223786340 (8 bytes) <lb/>o Sender ID: 0x01 (1 byte) <lb/>o Recipient ID: 0x (0 byte) <lb/>o ID Context: 0x37cbf3210017a2d3 (8 bytes) <lb/>From the previous parameters, <lb/>o info (for Sender Key): 0x8541014837cbf3210017a2d30a634b657910 (18 <lb/>bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 79] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o info (for Recipient Key): 0x85404837cbf3210017a2d30a634b657910 (17 <lb/>bytes) <lb/>o info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 <lb/>bytes) <lb/>Outputs: <lb/>o Sender Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes) <lb/>o Recipient Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes) <lb/>o Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes) <lb/>From the previous parameters and a Partial IV equal to 0 (both for <lb/>sender and recipient): <lb/>o sender nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes) <lb/>o recipient nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes) <lb/>C.4. Test Vector 4: OSCORE Request, Client <lb/>This section contains a test vector for an OSCORE-protected CoAP GET <lb/>request using the security context derived in Appendix C.1. The <lb/>unprotected request only contains the Uri-Path and Uri-Host options. <lb/>Unprotected CoAP request: <lb/>0x44015d1f00003974396c6f63616c686f737483747631 (22 bytes) <lb/>Common Context: <lb/>o AEAD Algorithm: 10 (AES-CCM-16-64-128) <lb/>o Key Derivation Function: HKDF SHA-256 <lb/>o Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>Sender Context: <lb/>o Sender ID: 0x (0 byte) <lb/>o Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes) <lb/>o Sender Sequence Number: 20 <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 80] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>The following COSE and cryptographic parameters are derived: <lb/>o Partial IV: 0x14 (1 byte) <lb/>o kid: 0x (0 byte) <lb/>o aad_array: 0x8501810a40411440 (8 bytes) <lb/>o AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes) <lb/>o plaintext: 0x01b3747631 (5 bytes) <lb/>o encryption key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes) <lb/>o nonce: 0x4622d4dd6d944168eefb549868 (13 bytes) <lb/>From the previous parameter, the following is derived: <lb/>o OSCORE option value: 0x0914 (2 bytes) <lb/>o ciphertext: 0x612f1092f1776f1c1668b3825e (13 bytes) <lb/>From there: <lb/>o Protected CoAP request (OSCORE message): 0x44025d1f00003974396c6f6 <lb/>3616c686f7374620914ff612f1092f1776f1c1668b3825e (35 bytes) <lb/>C.5. Test Vector 5: OSCORE Request, Client <lb/>This section contains a test vector for an OSCORE-protected CoAP GET <lb/>request using the security context derived in Appendix C.2. The <lb/>unprotected request only contains the Uri-Path and Uri-Host options. <lb/>Unprotected CoAP request: <lb/>0x440171c30000b932396c6f63616c686f737483747631 (22 bytes) <lb/>Common Context: <lb/>o AEAD Algorithm: 10 (AES-CCM-16-64-128) <lb/>o Key Derivation Function: HKDF SHA-256 <lb/>o Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes) <lb/>Sender Context: <lb/>o Sender ID: 0x00 (1 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 81] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes) <lb/>o Sender Sequence Number: 20 <lb/>The following COSE and cryptographic parameters are derived: <lb/>o Partial IV: 0x14 (1 byte) <lb/>o kid: 0x00 (1 byte) <lb/>o aad_array: 0x8501810a4100411440 (9 bytes) <lb/>o AAD: 0x8368456e63727970743040498501810a4100411440 (21 bytes) <lb/>o plaintext: 0x01b3747631 (5 bytes) <lb/>o encryption key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes) <lb/>o nonce: 0xbf35ae297d2dace910c52e99ed (13 bytes) <lb/>From the previous parameter, the following is derived: <lb/>o OSCORE option value: 0x091400 (3 bytes) <lb/>o ciphertext: 0x4ed339a5a379b0b8bc731fffb0 (13 bytes) <lb/>From there: <lb/>o Protected CoAP request (OSCORE message): 0x440271c30000b932396c6f6 <lb/>3616c686f737463091400ff4ed339a5a379b0b8bc731fffb0 (36 bytes) <lb/>C.6. Test Vector 6: OSCORE Request, Client <lb/>This section contains a test vector for an OSCORE-protected CoAP GET <lb/>request for an application that sets the ID Context and requires it <lb/>to be sent in the request, so &apos;kid context&apos; is present in the <lb/>protected message. This test vector uses the security context <lb/>derived in Appendix C.3. The unprotected request only contains the <lb/>Uri-Path and Uri-Host options. <lb/>Unprotected CoAP request: <lb/>0x44012f8eef9bbf7a396c6f63616c686f737483747631 (22 bytes) <lb/>Common Context: <lb/>o AEAD Algorithm: 10 (AES-CCM-16-64-128) <lb/>o Key Derivation Function: HKDF SHA-256 <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 82] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>o Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes) <lb/>o ID Context: 0x37cbf3210017a2d3 (8 bytes) <lb/>Sender Context: <lb/>o Sender ID: 0x (0 bytes) <lb/>o Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes) <lb/>o Sender Sequence Number: 20 <lb/>The following COSE and cryptographic parameters are derived: <lb/>o Partial IV: 0x14 (1 byte) <lb/>o kid: 0x (0 byte) <lb/>o kid context: 0x37cbf3210017a2d3 (8 bytes) <lb/>o aad_array: 0x8501810a40411440 (8 bytes) <lb/>o AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes) <lb/>o plaintext: 0x01b3747631 (5 bytes) <lb/>o encryption key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes) <lb/>o nonce: 0x2ca58fb85ff1b81c0b7181b84a (13 bytes) <lb/>From the previous parameter, the following is derived: <lb/>o OSCORE option value: 0x19140837cbf3210017a2d3 (11 bytes) <lb/>o ciphertext: 0x72cd7273fd331ac45cffbe55c3 (13 bytes) <lb/>From there: <lb/>o Protected CoAP request (OSCORE message): <lb/>0x44022f8eef9bbf7a396c6f63616c686f73746b19140837cbf3210017a2d3ff <lb/>72cd7273fd331ac45cffbe55c3 (44 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 83] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>C.7. Test Vector 7: OSCORE Response, Server <lb/>This section contains a test vector for an OSCORE-protected 2.05 <lb/>(Content) response to the request in Appendix C.4. The unprotected <lb/>response has payload &quot;Hello World!&quot; and no options. The protected <lb/>response does not contain a &apos;kid&apos; nor a Partial IV. Note that some <lb/>parameters are derived from the request. <lb/>Unprotected CoAP response: <lb/>0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes) <lb/>Common Context: <lb/>o AEAD Algorithm: 10 (AES-CCM-16-64-128) <lb/>o Key Derivation Function: HKDF SHA-256 <lb/>o Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>Sender Context: <lb/>o Sender ID: 0x01 (1 byte) <lb/>o Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/>o Sender Sequence Number: 0 <lb/>The following COSE and cryptographic parameters are derived: <lb/>o aad_array: 0x8501810a40411440 (8 bytes) <lb/>o AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes) <lb/>o plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes) <lb/>o encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/>o nonce: 0x4622d4dd6d944168eefb549868 (13 bytes) <lb/>From the previous parameter, the following is derived: <lb/>o OSCORE option value: 0x (0 bytes) <lb/>o ciphertext: 0xdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (22 <lb/>bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 84] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>From there: <lb/>o Protected CoAP response (OSCORE message): <lb/>0x64445d1f0000397490ffdbaad1e9a7e7b2a813d3c31524378303cdafae119106 <lb/>(32 bytes) <lb/>C.8. Test Vector 8: OSCORE Response with Partial IV, Server <lb/>This section contains a test vector for an OSCORE protected 2.05 <lb/>(Content) response to the request in Appendix C.4. The unprotected <lb/>response has payload &quot;Hello World!&quot; and no options. The protected <lb/>response does not contain a &apos;kid&apos;, but contains a Partial IV. Note <lb/>that some parameters are derived from the request. <lb/>Unprotected CoAP response: <lb/>0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes) <lb/>Common Context: <lb/>o AEAD Algorithm: 10 (AES-CCM-16-64-128) <lb/>o Key Derivation Function: HKDF SHA-256 <lb/>o Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes) <lb/>Sender Context: <lb/>o Sender ID: 0x01 (1 byte) <lb/>o Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/>o Sender Sequence Number: 0 <lb/>The following COSE and cryptographic parameters are derived: <lb/>o Partial IV: 0x00 (1 byte) <lb/>o aad_array: 0x8501810a40411440 (8 bytes) <lb/>o AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes) <lb/>o plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes) <lb/>o encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes) <lb/>o nonce: 0x4722d4dd6d944169eefb54987c (13 bytes) <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 85] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>From the previous parameter, the following is derived: <lb/>o OSCORE option value: 0x0100 (2 bytes) <lb/>o ciphertext: 0x4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (22 <lb/>bytes) <lb/>From there: <lb/>o Protected CoAP response (OSCORE message): 0x64445d1f00003974920100 <lb/>ff4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (34 bytes) <lb/>Appendix D. Overview of Security Properties <lb/>D.1. Threat Model <lb/>This section describes the threat model using the terms of [RFC3552]. <lb/>It is assumed that the endpoints running OSCORE have not themselves <lb/>been compromised. The attacker is assumed to have control of the <lb/>CoAP channel over which the endpoints communicate, including <lb/>intermediary nodes. The attacker is capable of launching any passive <lb/>or active on-path or off-path attacks; including eavesdropping, <lb/>traffic analysis, spoofing, insertion, modification, deletion, delay, <lb/>replay, man-in-the-middle, and denial-of-service attacks. This means <lb/>that the attacker can read any CoAP message on the network and <lb/>undetectably remove, change, or inject forged messages onto the wire. <lb/>OSCORE targets the protection of the CoAP request/response layer <lb/>(Section 2 of [RFC7252]) between the endpoints, including the CoAP <lb/>Payload, Code, Uri-Path/Uri-Query, and the other Class E option <lb/>instances (Section 4.1). <lb/>OSCORE does not protect the CoAP messaging layer (Section 2 of <lb/>[RFC7252]) or other lower layers involved in routing and transporting <lb/>the CoAP requests and responses. <lb/>Additionally, OSCORE does not protect Class U option instances <lb/>(Section 4.1), as these are used to support CoAP forward proxy <lb/>operations (see Section 5.7.2 of [RFC7252]). The supported proxies <lb/>(forwarding, cross-protocol, e.g., CoAP to CoAP-mappable protocols <lb/>such as HTTP) must be able to change certain Class U options (by <lb/>instruction from the Client), resulting in the CoAP request being <lb/>redirected to the server. Changes caused by the proxy may result in <lb/>the request not reaching the server or reaching the wrong server. <lb/>For cross-protocol proxies, mappings are done on the Outer part of <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 86] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>the message so these protocols are essentially used as transport. <lb/>Manipulation of these options may thus impact whether the protected <lb/>message reaches or does not reach the destination endpoint. <lb/>Attacks on unprotected CoAP message fields generally causes denial-<lb/>of-service attacks which are out of scope of this document, more <lb/>details are given in Appendix D.5. <lb/>Attacks against the CoAP request-response layer are in scope. OSCORE <lb/>is intended to protect against eavesdropping, spoofing, insertion, <lb/>modification, deletion, replay, and man-in-the middle attacks. <lb/>OSCORE is susceptible to traffic analysis as discussed later in <lb/>Appendix D. <lb/>D.2. Supporting Proxy Operations <lb/>CoAP is designed to work with intermediaries reading and/or changing <lb/>CoAP message fields to perform supporting operations in constrained <lb/>environments, e.g., forwarding and cross-protocol translations. <lb/>Securing CoAP on the transport layer protects the entire message <lb/>between the endpoints, in which case CoAP proxy operations are not <lb/>possible. In order to enable proxy operations, security on the <lb/>transport layer needs to be terminated at the proxy; in which case, <lb/>the CoAP message in its entirety is unprotected in the proxy. <lb/>Requirements for CoAP end-to-end security are specified in <lb/>[CoAP-E2E-Sec], in particular, forwarding is detailed in <lb/>Section 2.2.1. The client and server are assumed to be honest, while <lb/>proxies and gateways are only trusted to perform their intended <lb/>operations. <lb/>By working at the CoAP layer, OSCORE enables different CoAP message <lb/>fields to be protected differently, which allows message fields <lb/>required for proxy operations to be available to the proxy while <lb/>message fields intended for the other endpoint remain protected. In <lb/>the remainder of this section, we analyze how OSCORE protects the <lb/>protected message fields and the consequences of message fields <lb/>intended for proxy operation being unprotected. <lb/>D.3. Protected Message Fields <lb/>Protected message fields are included in the plaintext (Section 5.3) <lb/>and the AAD (Section 5.4) of the COSE_Encrypt0 object and encrypted <lb/>using an AEAD algorithm. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 87] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>OSCORE depends on a preestablished random Master Secret <lb/>(Section 12.3) used to derive encryption keys, and a construction for <lb/>making (key, nonce) pairs unique (Appendix D.4). Assuming this is <lb/>true, and the keys are used for no more data than indicated in <lb/>Section 7.2.1, OSCORE should provide the following guarantees: <lb/>o Confidentiality: An attacker should not be able to determine the <lb/>plaintext contents of a given OSCORE message or determine that <lb/>different plaintexts are related (Section 5.3). <lb/>o Integrity: An attacker should not be able to craft a new OSCORE <lb/>message with protected message fields different from an existing <lb/>OSCORE message that will be accepted by the receiver. <lb/>o Request-response binding: An attacker should not be able to make a <lb/>client match a response to the wrong request. <lb/>o Non-replayability: An attacker should not be able to cause the <lb/>receiver to accept a message that it has previously received and <lb/>accepted. <lb/>In the above, the attacker is anyone except the endpoints, e.g., a <lb/>compromised intermediary. Informally, OSCORE provides these <lb/>properties by AEAD-protecting the plaintext with a strong key and <lb/>uniqueness of (key, nonce) pairs. AEAD encryption [RFC5116] provides <lb/>confidentiality and integrity for the data. Response-request binding <lb/>is provided by including the &apos;kid&apos; and Partial IV of the request in <lb/>the AAD of the response. Non-replayability of requests and <lb/>notifications is provided by using unique (key, nonce) pairs and a <lb/>replay protection mechanism (application dependent, see Section 7.4). <lb/>OSCORE is susceptible to a variety of traffic analysis attacks based <lb/>on observing the length and timing of encrypted packets. OSCORE does <lb/>not provide any specific defenses against this form of attack, but <lb/>the application may use a padding mechanism to prevent an attacker <lb/>from directly determining the length of the padding. However, <lb/>information about padding may still be revealed by side-channel <lb/>attacks observing differences in timing. <lb/>D.4. Uniqueness of (key, nonce) <lb/>In this section, we show that (key, nonce) pairs are unique as long <lb/>as the requirements in Sections 3.3 and 7.2.1 are followed. <lb/>Fix a Common Context (Section 3.1) and an endpoint, called the <lb/>encrypting endpoint. An endpoint may alternate between client and <lb/>server roles, but each endpoint always encrypts with the Sender Key <lb/>of its Sender Context. Sender Keys are (stochastically) unique since <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 88] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>they are derived with HKDF using unique Sender IDs, so messages <lb/>encrypted by different endpoints use different keys. It remains to <lb/>be proven that the nonces used by the fixed endpoint are unique. <lb/>Since the Common IV is fixed, the nonces are determined by PIV, where <lb/>PIV takes the value of the Partial IV of the request or of the <lb/>response, and by the Sender ID of the endpoint generating that <lb/>Partial IV (ID_PIV). The nonce construction (Section 5.2) with the <lb/>size of the ID_PIV (S) creates unique nonces for different (ID_PIV, <lb/>PIV) pairs. There are two cases: <lb/>A. For requests, and responses with Partial IV (e.g., Observe <lb/>notifications): <lb/>o ID_PIV = Sender ID of the encrypting endpoint <lb/>o PIV = current Partial IV of the encrypting endpoint <lb/>Since the encrypting endpoint steps the Partial IV for each use, the <lb/>nonces used in case A are all unique as long as the number of <lb/>encrypted messages is kept within the required range (Section 7.2.1). <lb/>B. For responses without Partial IV (e.g., single response to a <lb/>request): <lb/>o ID_PIV = Sender ID of the endpoint generating the request <lb/>o PIV = Partial IV of the request <lb/>Since the Sender IDs are unique, ID_PIV is different from the Sender <lb/>ID of the encrypting endpoint. Therefore, the nonces in case B are <lb/>different compared to nonces in case A, where the encrypting endpoint <lb/>generated the Partial IV. Since the Partial IV of the request is <lb/>verified for replay (Section 7.4) associated to this Recipient <lb/>Context, PIV is unique for this ID_PIV, which makes all nonces in <lb/>case B distinct. <lb/>D.5. Unprotected Message Fields <lb/>This section analyzes attacks on message fields that are not <lb/>protected by OSCORE according to the threat model Appendix D.1. <lb/>D.5.1. CoAP Header Fields <lb/>o Version. The CoAP version [RFC7252] is not expected to be <lb/>sensitive to disclosure. Currently, there is only one CoAP <lb/>version defined. A change of this parameter is potentially a <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 89] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>denial-of-service attack. Future versions of CoAP need to analyze <lb/>attacks to OSCORE-protected messages due to an adversary changing <lb/>the CoAP version. <lb/>o Token/Token Length. The Token field is a client-local identifier <lb/>for differentiating between concurrent requests [RFC7252]. CoAP <lb/>proxies are allowed to read and change Token and Token Length <lb/>between hops. An eavesdropper reading the Token can match <lb/>requests to responses that can be used in traffic analysis. In <lb/>particular, this is true for notifications, where multiple <lb/>responses are matched to one request. Modifications of Token and <lb/>Token Length by an on-path attacker may become a denial-of-service <lb/>attack, since it may prevent the client to identify to which <lb/>request the response belongs or to find the correct information to <lb/>verify integrity of the response. <lb/>o Code. The Outer CoAP Code of an OSCORE message is POST or FETCH <lb/>for requests with corresponding response codes. An endpoint <lb/>receiving the message discards the Outer CoAP Code and uses the <lb/>Inner CoAP Code instead (see Section 4.2). Hence, modifications <lb/>from attackers to the Outer Code do not impact the receiving <lb/>endpoint. However, changing the Outer Code from FETCH to a Code <lb/>value for a method that does not work with Observe (such as POST) <lb/>may, depending on proxy implementation since Observe is undefined <lb/>for several Codes, cause the proxy to not forward notifications, <lb/>which is a denial-of-service attack. The use of FETCH rather than <lb/>POST reveals no more than what is revealed by the presence of the <lb/>Outer Observe option. <lb/>o Type/Message ID. The Type/Message ID fields [RFC7252] reveal <lb/>information about the UDP transport binding, e.g., an eavesdropper <lb/>reading the Type or Message ID gain information about how UDP <lb/>messages are related to each other. CoAP proxies are allowed to <lb/>change Type and Message ID. These message fields are not present <lb/>in CoAP over TCP [RFC8323] and do not impact the request/response <lb/>message. A change of these fields in a UDP hop is a denial-of-<lb/>service attack. By sending an ACK, an attacker can make the <lb/>endpoint believe that it does not need to retransmit the previous <lb/>message. By sending a RST, an attacker may be able to cancel an <lb/>observation. By changing a NON to a CON, the attacker can cause <lb/>the receiving endpoint to ACK messages for which no ACK was <lb/>requested. <lb/>o Length. This field contains the length of the message [RFC8323], <lb/>which may be used for traffic analysis. This message field is not <lb/>present in CoAP over UDP and does not impact the request/response <lb/>message. A change of Length is a denial-of-service attack similar <lb/>to changing TCP header fields. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 90] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>D.5.2. CoAP Options <lb/>o Max-Age. The Outer Max-Age is set to zero to avoid unnecessary <lb/>caching of OSCORE error responses. Changing this value thus may <lb/>cause unnecessary caching. No additional information is carried <lb/>with this option. <lb/>o Proxy-Uri/Proxy-Scheme. These options are used in CoAP forward <lb/>proxy deployments. With OSCORE, the Proxy-Uri option does not <lb/>contain the Uri-Path/Uri-Query parts of the URI. The other parts <lb/>of Proxy-Uri cannot be protected because forward proxies need to <lb/>change them in order to perform their functions. The server can <lb/>verify what scheme is used in the last hop, but not what was <lb/>requested by the client or what was used in previous hops. <lb/>o Uri-Host/Uri-Port. In forward proxy deployments, the Uri-Host/ <lb/>Uri-Port may be changed by an adversary, and the application needs <lb/>to handle the consequences of that (see Section 4.1.3.2). The <lb/>Uri-Host may either be omitted, reveal information equivalent to <lb/>that of the IP address, or reveal more privacy-sensitive <lb/>information, which is discouraged. <lb/>o Observe. The Outer Observe option is intended for a proxy to <lb/>support forwarding of Observe messages, but it is ignored by the <lb/>endpoints since the Inner Observe option determines the processing <lb/>in the endpoints. Since the Partial IV provides absolute ordering <lb/>of notifications, it is not possible for an intermediary to spoof <lb/>reordering (see Section 4.1.3.5). The absence of Partial IV, <lb/>since only allowed for the first notification, does not prevent <lb/>correct ordering of notifications. The size and distributions of <lb/>notifications over time may reveal information about the content <lb/>or nature of the notifications. Cancellations (Section 4.1.3.5.1) <lb/>are not bound to the corresponding registrations in the same way <lb/>responses are bound to requests in OSCORE (see Appendix D.3). <lb/>However, that does not make attacks based on mismatched <lb/>cancellations possible, since for cancellations to be accepted, <lb/>all options in the decrypted message except for ETag options MUST <lb/>be the same (see Section 4.1.3.5). <lb/>o Block1/Block2/Size1/Size2. The Outer Block options enable <lb/>fragmentation of OSCORE messages in addition to segmentation <lb/>performed by the Inner Block options. The presence of these <lb/>options indicates a large message being sent, and the message size <lb/>can be estimated and used for traffic analysis. Manipulating <lb/>these options is a potential denial-of-service attack, e.g., <lb/>injection of alleged Block fragments. The specification of a <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 91] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>maximum size of message, MAX_UNFRAGMENTED_SIZE <lb/>(Section 4.1.3.4.2), above which messages will be dropped, is <lb/>intended as one measure to mitigate this kind of attack. <lb/>o No-Response. The Outer No-Response option is used to support <lb/>proxy functionality, specifically to avoid error transmissions <lb/>from proxies to clients, and to avoid bandwidth reduction to <lb/>servers by proxies applying congestion control when not receiving <lb/>responses. Modifying or introducing this option is a potential <lb/>denial-of-service attack against the proxy operations, but since <lb/>the option has an Inner value, its use can be securely agreed upon <lb/>between the endpoints. The presence of this option is not <lb/>expected to reveal any sensitive information about the message <lb/>exchange. <lb/>o OSCORE. The OSCORE option contains information about the <lb/>compressed COSE header. Changing this field may cause OSCORE <lb/>verification to fail. <lb/>D.5.3. Error and Signaling Messages <lb/>Error messages occurring during CoAP processing are protected end-to-<lb/>end. Error messages occurring during OSCORE processing are not <lb/>always possible to protect, e.g., if the receiving endpoint cannot <lb/>locate the right security context. For this setting, unprotected <lb/>error messages are allowed as specified to prevent extensive <lb/>retransmissions. Those error messages can be spoofed or manipulated, <lb/>which is a potential denial-of-service attack. <lb/>This document specifies OPTIONAL error codes and specific diagnostic <lb/>payloads for OSCORE processing error messages. Such messages might <lb/>reveal information about how many and which security contexts exist <lb/>on the server. Servers MAY want to omit the diagnostic payload of <lb/>error messages, use the same error code for all errors, or avoid <lb/>responding altogether in case of OSCORE processing errors, if that is <lb/>a security concern for the application. Moreover, clients MUST NOT <lb/>rely on the error code or the diagnostic payload to trigger specific <lb/>actions, as these errors are unprotected and can be spoofed or <lb/>manipulated. <lb/>Signaling messages used in CoAP over TCP [RFC8323] are intended to be <lb/>hop-by-hop; spoofing signaling messages can be used as a denial-of-<lb/>service attack of a TCP connection. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 92] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<body>D.5.4. HTTP Message Fields <lb/>In contrast to CoAP, where OSCORE does not protect header fields to <lb/>enable CoAP-CoAP proxy operations, the use of OSCORE with HTTP is <lb/>restricted to transporting a protected CoAP message over an HTTP hop. <lb/>Any unprotected HTTP message fields may reveal information about the <lb/>transport of the OSCORE message and enable various denial-of-service <lb/>attacks. It is RECOMMENDED to additionally use TLS [RFC8446] for <lb/>HTTP hops, which enables encryption and integrity protection of <lb/>headers, but still leaves some information for traffic analysis. <lb/>Appendix E. CDDL Summary <lb/>Data structure definitions in the present specification employ the <lb/>CDDL language for conciseness and precision [RFC8610]. This appendix <lb/>summarizes the small subset of CDDL that is used in the present <lb/>specification. <lb/>Within the subset being used here, a CDDL rule is of the form &quot;name = <lb/>type&quot;, where &quot;name&quot; is the name given to the &quot;type&quot;. A &quot;type&quot; can be <lb/>one of: <lb/>o a reference to another named type, by giving its name. The <lb/>predefined named types used in the present specification are as <lb/>follows: &quot;uint&quot;, an unsigned integer (as represented in CBOR by <lb/>major type 0); &quot;int&quot;, an unsigned or negative integer (as <lb/>represented in CBOR by major type 0 or 1); &quot;bstr&quot;, a byte string <lb/>(as represented in CBOR by major type 2); &quot;tstr&quot;, a text string <lb/>(as represented in CBOR by major type 3); <lb/>o a choice between two types, by giving both types separated by a <lb/>&quot;/&quot;; <lb/>o an array type (as represented in CBOR by major type 4), where the <lb/>sequence of elements of the array is described by giving a <lb/>sequence of entries separated by commas &quot;,&quot;, and this sequence is <lb/>enclosed by square brackets &quot;[&quot; and &quot;]&quot;. Arrays described by an <lb/>array description contain elements that correspond one-to-one to <lb/>the sequence of entries given. Each entry of an array description <lb/>is of the form &quot;name : type&quot;, where &quot;name&quot; is the name given to <lb/>the entry and &quot;type&quot; is the type of the array element <lb/>corresponding to this entry. <lb/></body>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 93] <lb/></page>

			<note place="headnote">RFC 8613 <lb/>OSCORE <lb/>July 2019 <lb/></note>

			<div type="acknowledgement">Acknowledgments <lb/>The following individuals provided input to this document: Christian <lb/>Amsuess, Tobias Andersson, Carsten Bormann, Joakim Brorsson, Ben <lb/>Campbell, Esko Dijk, Jaro Fietz, Thomas Fossati, Martin Gunnarsson, <lb/>Klaus Hartke, Rikard Hoeglund, Mirja Kuehlewind, Kathleen Moriarty, <lb/>Eric Rescorla, Michael Richardson, Adam Roach, Jim Schaad, Peter van <lb/>der Stok, Dave Thaler, Martin Thomson, Marco Tiloca, William Vignat, <lb/>and Malisa Vucinic. <lb/>Ludwig Seitz and Goeran Selander worked on this document as part of <lb/>the CelticPlus project CyberWI, with funding from Vinnova. Ludwig <lb/>Seitz had additional funding from the SSF project SEC4Factory under <lb/>the grant RIT17-0032. <lb/></div>

			Authors&apos; Addresses <lb/>			

			<front>Goeran Selander <lb/>Ericsson AB <lb/>Email: goran.selander@ericsson.com <lb/>John Mattsson <lb/>Ericsson AB <lb/>Email: john.mattsson@ericsson.com <lb/>Francesca Palombini <lb/>Ericsson AB <lb/>Email: francesca.palombini@ericsson.com <lb/>Ludwig Seitz <lb/>RISE <lb/>Email: ludwig.seitz@ri.se <lb/></front>

			<note place="footnote">Selander, et al. <lb/>Standards Track <lb/></note>

			<page>[Page 94] </page>


	</text>
</tei>
