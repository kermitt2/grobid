<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>server date 20190710; downloaded by EPO on 20190711 <lb/>Internet Research Task Force (IRTF) <lb/>M. Mosko <lb/>Request for Comments: 8609 <lb/>PARC, Inc. <lb/>Category: Experimental <lb/>I. Solis <lb/>ISSN: 2070-1721 <lb/>LinkedIn <lb/>C. Wood <lb/>University of California Irvine <lb/>July 2019 <lb/>Content-Centric Networking (CCNx) Messages in TLV Format <lb/>Abstract <lb/>Content-Centric Networking (CCNx) is a network protocol that uses a <lb/>hierarchical name to forward requests and to match responses to <lb/>requests. This document specifies the encoding of CCNx messages in a <lb/>TLV packet format, including the TLV types used by each message <lb/>element and the encoding of each value. The semantics of CCNx <lb/>messages follow the encoding-independent CCNx Semantics <lb/>specification. <lb/>This document is a product of the Information Centric Networking <lb/>research group (ICNRG). The document received wide review among <lb/>ICNRG participants and has two full implementations currently in <lb/>active use, which have informed the technical maturity of the <lb/>protocol specification. <lb/>Status of This Memo <lb/>This document is not an Internet Standards Track specification; it is <lb/>published for examination, experimental implementation, and <lb/>evaluation. <lb/>This document defines an Experimental Protocol for the Internet <lb/>community. This document is a product of the Internet Research Task <lb/>Force (IRTF). The IRTF publishes the results of Internet-related <lb/>research and development activities. These results might not be <lb/>suitable for deployment. This RFC represents the consensus of the <lb/>Information-Centric Networking Research Group of the Internet <lb/>Research Task Force (IRTF). Documents approved for publication by <lb/>the IRSG are not candidates for any level of Internet Standard; see <lb/>Section 2 of RFC 7841. <lb/>Information about the current status of this document, any errata, <lb/>and how to provide feedback on it may be obtained at <lb/>https://www.rfc-editor.org/info/rfc8609. <lb/>Mosko, et al. <lb/>Experimental <lb/>[Page 1] <lb/>RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/>Copyright Notice <lb/>Copyright (c) 2019 IETF Trust and the persons identified as the <lb/>document authors. All rights reserved. <lb/>This document is subject to BCP 78 and the IETF Trust&apos;s Legal <lb/>Provisions Relating to IETF Documents <lb/>(https://trustee.ietf.org/license-info) in effect on the date of <lb/>publication of this document. Please review these documents <lb/>carefully, as they describe your rights and restrictions with respect <lb/>to this document. <lb/></front>

			<div type="toc">Table of Contents <lb/>1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . <lb/>3 <lb/>1.1. Requirements Language . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>2. Definitions . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>3. Type-Length-Value (TLV) Packets . . . . . . . . . . . . . . . <lb/>5 <lb/>3.1. Overall Packet Format . . . . . . . . . . . . . . . . . . <lb/>7 <lb/>3.2. Fixed Headers . . . . . . . . . . . . . . . . . . . . . . <lb/>8 <lb/>3.2.1. Interest Fixed Header . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.2.1.1. Interest HopLimit . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.2.2. Content Object Fixed Header . . . . . . . . . . . . . <lb/>9 <lb/>3.2.3. Interest Return Fixed Header . . . . . . . . . . . . 10 <lb/>3.2.3.1. Interest Return HopLimit . . . . . . . . . . . . 10 <lb/>3.2.3.2. Interest Return Flags . . . . . . . . . . . . . . 10 <lb/>3.2.3.3. Return Code . . . . . . . . . . . . . . . . . . . 10 <lb/>3.3. Global Formats . . . . . . . . . . . . . . . . . . . . . 11 <lb/>3.3.1. Pad . . . . . . . . . . . . . . . . . . . . . . . . . 11 <lb/>3.3.2. Organization-Specific TLVs . . . . . . . . . . . . . 12 <lb/>3.3.3. Hash Format . . . . . . . . . . . . . . . . . . . . . 12 <lb/>3.3.4. Link . . . . . . . . . . . . . . . . . . . . . . . . 13 <lb/>3.4. Hop-by-Hop TLV Headers . . . . . . . . . . . . . . . . . 14 <lb/>3.4.1. Interest Lifetime . . . . . . . . . . . . . . . . . . 14 <lb/>3.4.2. Recommended Cache Time . . . . . . . . . . . . . . . 15 <lb/>3.4.3. Message Hash . . . . . . . . . . . . . . . . . . . . 16 <lb/>3.5. Top-Level Types . . . . . . . . . . . . . . . . . . . . . 17 <lb/>3.6. CCNx Message TLV . . . . . . . . . . . . . . . . . . . . 18 <lb/>3.6.1. Name . . . . . . . . . . . . . . . . . . . . . . . . 19 <lb/>3.6.1.1. Name Segments . . . . . . . . . . . . . . . . . . 20 <lb/>3.6.1.2. Interest Payload ID . . . . . . . . . . . . . . . 20 <lb/>3.6.2. Message TLVs . . . . . . . . . . . . . . . . . . . . 21 <lb/>3.6.2.1. Interest Message TLVs . . . . . . . . . . . . . . 21 <lb/>3.6.2.2. Content Object Message TLVs . . . . . . . . . . . 23 <lb/>3.6.3. Payload . . . . . . . . . . . . . . . . . . . . . . . 25 <lb/>3.6.4. Validation . . . . . . . . . . . . . . . . . . . . . 25 <lb/>3.6.4.1. Validation Algorithm . . . . . . . . . . . . . . 25 <lb/>3.6.4.2. Validation Payload . . . . . . . . . . . . . . . 32 <lb/></div>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 2] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<div type="toc">4. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 33 <lb/>4.1. Packet Type Registry . . . . . . . . . . . . . . . . . . 33 <lb/>4.2. Interest Return Code Registry . . . . . . . . . . . . . . 34 <lb/>4.3. Hop-by-Hop Type Registry . . . . . . . . . . . . . . . . 35 <lb/>4.4. Top-Level Type Registry . . . . . . . . . . . . . . . . . 36 <lb/>4.5. Name Segment Type Registry . . . . . . . . . . . . . . . 37 <lb/>4.6. Message Type Registry . . . . . . . . . . . . . . . . . . 37 <lb/>4.7. Payload Type Registry . . . . . . . . . . . . . . . . . . 38 <lb/>4.8. Validation Algorithm Type Registry . . . . . . . . . . . 39 <lb/>4.9. Validation-Dependent Data Type Registry . . . . . . . . . 40 <lb/>4.10. Hash Function Type Registry . . . . . . . . . . . . . . . 40 <lb/>5. Security Considerations . . . . . . . . . . . . . . . . . . . 41 <lb/>6. References . . . . . . . . . . . . . . . . . . . . . . . . . 44 <lb/>6.1. Normative References . . . . . . . . . . . . . . . . . . 44 <lb/>6.2. Informative References . . . . . . . . . . . . . . . . . 44 <lb/>Authors&apos; Addresses . . . . . . . . . . . . . . . . . . . . . . . 46 <lb/></div>

			<body>1. Introduction <lb/>This document specifies a Type-Length-Value (TLV) packet format and <lb/>
			the TLV type and value encodings for CCNx messages. A full <lb/>description of the CCNx network protocol, providing an encoding-free <lb/>description of CCNx messages and message elements, may be found in <lb/>[RFC8569]. CCNx is a network protocol that uses a hierarchical name <lb/>to forward requests and to match responses to requests. It does not <lb/>use endpoint addresses; the Internet Protocol does. Restrictions in <lb/>a request can limit the response by the public key of the response&apos;s <lb/>signer or the cryptographic hash of the response. Every CCNx <lb/>forwarder along the path does the name matching and restriction <lb/>checking. The CCNx protocol fits within the broader framework of <lb/>Information-Centric Networking (ICN) protocols [RFC7927]. <lb/>This document describes a TLV scheme using a fixed 2-byte T and a <lb/>fixed 2-byte L field. The rational for this choice is described in <lb/>Section 5. Briefly, this choice avoids multiple encodings of the <lb/>same value (aliases) and reduces the work of a validator to ensure <lb/>compliance. Unlike some uses of TLV in networking, each network hop <lb/>must evaluate the encoding, so even small validation latencies at <lb/>each hop could add up to a large overall forwarding delay. For very <lb/>small packets or low-throughput links, where the extra bytes may <lb/>become a concern, one may use a TLV compression protocol, for <lb/>example, [compress] and [CCNxz]. <lb/>This document uses the terms CCNx Packet, CCNx Message, and CCNx <lb/>Message TLV. A CCNx Packet refers to the entire Layer 3 datagram as <lb/>specified in Section 3.1. A CCNx Message is the ABNF token defined <lb/>in the CCNx Semantics document [RFC8569]. A CCNx Message TLV refers <lb/>to the encoding of a CCNx Message as specified in Section 3.6. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 3] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>This document specifies: <lb/>o the CCNx Packet format, <lb/>o the CCNx Message TLV format, <lb/>o the TLV types used by CCNx messages, <lb/>o the encoding of values for each type, <lb/>o top-level types that exist at the outermost containment, <lb/>o Interest TLVs that exist within Interest containment, and <lb/>o Content Object TLVs that exist within Content Object containment. <lb/>This document is supplemented by these documents: <lb/>o [RFC8569], which covers message semantics and the protocol <lb/>operation regarding Interest and Content Object, including the <lb/>Interest Return protocol. <lb/>o [CCNxURI], which covers the CCNx URI notation. <lb/>The type values in Section 4 conform to the IANA-assigned numbers for <lb/>the CCNx protocol. This document uses the symbolic names defined in <lb/>that section. All TLV type values are relative to their parent <lb/>containers. For example, each level of a nested TLV structure might <lb/>define a &quot;type = 1&quot; with a completely different meaning. <lb/>Packets are represented as 32-bit wide words using ASCII art. Due to <lb/>the nested levels of TLV encoding and the presence of optional fields <lb/>and variable sizes, there is no concise way to represent all <lb/>possibilities. We use the convention that ASCII art fields enclosed <lb/>by vertical bars &quot;|&quot; represent exact bit widths. Fields with a <lb/>forward slash &quot;/&quot; are variable bit widths, which we typically pad out <lb/>to word alignment for picture readability. <lb/>The document represents the consensus of the ICN RG. It is the first <lb/>ICN protocol from the RG, created from the early CCNx protocol [nnc] <lb/>with significant revision and input from the ICN community and RG <lb/>members. The document has received critical reading by several <lb/>members of the ICN community and the RG. The authors and RG chairs <lb/>approve of the contents. The document is sponsored under the IRTF <lb/>and is not issued by the IETF and is not an IETF standard. This is <lb/>an experimental protocol and may not be suitable for any specific <lb/>application and the specification may change in the future. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 4] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1.1. Requirements Language <lb/>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, <lb/>&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and <lb/>&quot;OPTIONAL&quot; in this document are to be interpreted as described in <lb/>BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all <lb/>capitals, as shown here. <lb/>2. Definitions <lb/>These definitions summarize items defined in [RFC8569]. This <lb/>document defines their encodings. <lb/>o Name: A hierarchically structured variable-length identifier. It <lb/>is an ordered list of path segments, which are variable-length <lb/>octet strings. In human-readable form, it is represented in URI <lb/>format as &quot;ccnx:/path/part&quot;. There is no host or query string. <lb/>See [CCNxURI] for complete details. <lb/>o Interest: A message requesting a Content Object with a matching <lb/>Name and other optional selectors to choose from multiple objects <lb/>with the same Name. Any Content Object with a Name and attributes <lb/>that matches the Name and optional selectors of the Interest is <lb/>said to satisfy the Interest. <lb/>o Content Object: A data object sent in response to an Interest <lb/>request. It has an optional Name and a content payload that are <lb/>bound together via cryptographic means. <lb/>3. Type-Length-Value (TLV) Packets <lb/>We use 16-bit Type and 16-bit Length fields to encode TLV-based <lb/>packets. This provides 65,536 different possible types and value <lb/>field lengths of up to 64 KiB. With 65,536 possible types at each <lb/>level of TLV encoding, there should be sufficient space for basic <lb/>protocol types, while also allowing ample room for experimentation, <lb/>application use, vendor extensions, and growth. This encoding does <lb/>not allow for jumbo packets beyond 64 KiB total length. If used on a <lb/>media that allows for jumbo frames, we suggest defining a media <lb/>adaptation envelope that allows for multiple smaller frames. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 5] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>+--------+------------------+---------------------------------------+ <lb/>| Abbrev | <lb/>Name <lb/>| Description <lb/>| <lb/>+--------+------------------+---------------------------------------+ <lb/>| T_ORG | Vendor Specific | Information specific to a vendor <lb/>| <lb/>| <lb/>| <lb/>Information <lb/>| implementation (Section 3.3.2). <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_PAD | <lb/>Padding <lb/>| Adds padding to a field (Section <lb/>| <lb/>| <lb/>| <lb/>| 3.3.1). <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| n/a <lb/>| <lb/>Experimental <lb/>| Experimental use. <lb/>| <lb/>+--------+------------------+---------------------------------------+ <lb/>Table 1: Reserved TLV Types <lb/>There are several global TLV definitions that we reserve at all <lb/>hierarchical contexts. The TLV types in the range 0x1000 -0x1FFF <lb/>are Reserved for Experimental Use. The TLV type T_ORG is also <lb/>Reserved for Vendor Extensions (see Section 3.3.2). The TLV type <lb/>T_PAD is used to optionally pad a field out to some desired <lb/>alignment. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Type <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 1: Type and Length encoding <lb/>The Length field contains the length of the Value field in octets. <lb/>It does not include the length of the Type and Length fields. The <lb/>Length MAY be zero. <lb/>TLV structures are nestable, allowing the Value field of one TLV <lb/>structure to contain additional TLV structures. The enclosing TLV <lb/>structure is called the container of the enclosed TLV. <lb/>Type values are context dependent. Within a TLV container, one may <lb/>reuse previous type values for new context-dependent purposes. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 6] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.1. Overall Packet Format <lb/>Each CCNx Packet includes the 8-byte fixed header, described below, <lb/>followed by a set of TLV fields. These fields are optional hop-by-<lb/>hop headers and the Packet Payload. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Version <lb/>| PacketType <lb/>| <lb/>PacketLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>PacketType-specific fields <lb/>| HeaderLength | <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional hop-by-hop header TLVs <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ PacketPayload TLVs <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 2: Overall Packet Format <lb/>The PacketPayload of a CCNx Packet is the protocol message itself. <lb/>The Content Object Hash is computed over the PacketPayload only, <lb/>excluding the fixed and hop-by-hop headers, as those might change <lb/>from hop to hop. Signed information or similarity hashes should not <lb/>include any of the fixed or hop-by-hop headers. The PacketPayload <lb/>should be self-sufficient in the event that the fixed and hop-by-hop <lb/>headers are removed. See Message Hash (Section 3.4.3). <lb/>Following the CCNx Message TLV, the PacketPayload may include <lb/>optional Validation TLVs. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| CCNx Message TLV <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional CCNx ValidationAlgorithm TLV <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional CCNx ValidationPayload TLV (ValidationAlg required) / <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 3: PacketPayload TLVs <lb/>After discarding the fixed and hop-by-hop headers, the remaining <lb/>PacketPayload should be a valid protocol message. Therefore, the <lb/>PacketPayload always begins with 4 bytes of type-length that <lb/>specifies the protocol message (whether it is an Interest, Content <lb/>Object, or other message type) and its total length. The embedding <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 7] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>of a self-sufficient protocol data unit inside the fixed and hop-by-<lb/>hop headers allows a network stack to discard the headers and operate <lb/>only on the embedded message. It also decouples the PacketType field <lb/>--which specifies how to forward the packet --from the <lb/>PacketPayload. <lb/>The range of bytes protected by the Validation includes the CCNx <lb/>Message TLV and the ValidationAlgorithm TLV. <lb/>The ContentObjectHash begins with the CCNx Message TLV and ends at <lb/>the tail of the CCNx Packet. <lb/>3.2. Fixed Headers <lb/>In Figure 2, the fixed header fields are: <lb/>o Version: defines the version of the packet, which MUST be 1. <lb/>o HeaderLength: The length of the fixed header (8 bytes) and hop-by-<lb/>hop headers. The minimum value MUST be 8. <lb/>o PacketType: describes forwarder actions to take on the packet. <lb/>o PacketLength: Total octets of packet including all headers (fixed <lb/>header plus hop-by-hop headers) and protocol message. <lb/>o PacketType-specific Fields: specific PacketTypes define the use of <lb/>these bits. <lb/>The PacketType field indicates how the forwarder should process the <lb/>packet. A Request Packet (Interest) has PacketType PT_INTEREST, a <lb/>Response (Content Object) has PacketType PT_CONTENT, and an Interest <lb/>Return has PacketType PT_RETURN. <lb/>HeaderLength is the number of octets from the start of the CCNx <lb/>Packet (Version) to the end of the hop-by-hop headers. PacketLength <lb/>is the number of octets from the start of the packet to the end of <lb/>the packet. Both lengths have a minimum value of 8 (the fixed header <lb/>itself). <lb/>The PacketType-specific fields are reserved bits whose use depends on <lb/>the PacketType. They are used for network-level signaling. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 8] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.2.1. Interest Fixed Header <lb/>If the PacketType is PT_INTEREST, it indicates that the packet should <lb/>be forwarded following the Interest pipeline in Section 2.4.4 of <lb/>[RFC8569]. For this type of packet, the Fixed Header includes a <lb/>field for a HopLimit as well as Reserved and Flags fields. The <lb/>Reserved field MUST be set to 0 in an Interest. There are currently <lb/>no flags defined, so the Flags field MUST be set to 0. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Version <lb/>| PT_INTEREST | <lb/>PacketLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>HopLimit <lb/>| <lb/>Reserved <lb/>| <lb/>Flags <lb/>| HeaderLength | <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 4: Interest Header <lb/>3.2.1.1. Interest HopLimit <lb/>For an Interest message, the HopLimit is a counter that is <lb/>decremented with each hop. It limits the distance an Interest may <lb/>travel on the network. The node originating the Interest MAY put in <lb/>any value up to the maximum of 255. Each node that receives an <lb/>Interest with a HopLimit decrements the value upon reception. If the <lb/>value is 0 after the decrement, the Interest MUST NOT be forwarded <lb/>off the node. <lb/>It is an error to receive an Interest from a remote node with the <lb/>HopLimit field set to 0. <lb/>3.2.2. Content Object Fixed Header <lb/>If the PacketType is PT_CONTENT, it indicates that the packet should <lb/>be forwarded following the Content Object pipeline in Section 2.4.4 <lb/>of [RFC8569]. A Content Object defines a Flags field; however, there <lb/>are currently no flags defined, so the Flags field must be set to 0. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Version <lb/>| PT_CONTENT <lb/>| <lb/>PacketLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Reserved <lb/>| <lb/>Flags <lb/>| HeaderLength | <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 5: Content Object Header <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 9] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.2.3. Interest Return Fixed Header <lb/>If the PacketType is PT_RETURN, it indicates that the packet should <lb/>be processed following the Interest Return rules in Section 10 of <lb/>[RFC8569]. The only difference between this Interest Return message <lb/>and the original Interest is that the PacketType is changed to <lb/>PT_RETURN and a ReturnCode is put into the ReturnCode field. All <lb/>other fields are unchanged from the Interest packet. The purpose of <lb/>this encoding is to prevent packet length changes so no additional <lb/>bytes are needed to return an Interest to the previous hop. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>Version <lb/>| <lb/>PT_RETURN <lb/>| <lb/>PacketLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>HopLimit <lb/>| ReturnCode <lb/>| <lb/>Flags <lb/>| HeaderLength | <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 6: Interest Return Header <lb/>3.2.3.1. Interest Return HopLimit <lb/>This is the original Interest&apos;s HopLimit, as received before <lb/>decrement at the node sending the Interest Return. <lb/>3.2.3.2. Interest Return Flags <lb/>These are the original Flags as set in the Interest. <lb/>3.2.3.3. Return Code <lb/>This section maps the Return Code name [RFC8569] to the TLV symbolic <lb/>name. Section 4.2 maps the symbolic names to numeric values. This <lb/>field is set by the node creating the Interest Return. <lb/>A return code of &quot;0&quot; MUST NOT be used, as it indicates that the <lb/>returning system did not modify the Return Code field. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 10] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>+-------------------------------------+-----------------------------+ <lb/>| <lb/>Return Type <lb/>| Name in RFC 8569 <lb/>| <lb/>+-------------------------------------+-----------------------------+ <lb/>| <lb/>T_RETURN_NO_ROUTE <lb/>| No Route <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_LIMIT_EXCEEDED <lb/>| Hop Limit Exceeded <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_NO_RESOURCES <lb/>| No Resources <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_PATH_ERROR <lb/>| Path Error <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_PROHIBITED <lb/>| Prohibited <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_CONGESTED <lb/>| Congested <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_MTU_TOO_LARGE <lb/>| MTU too large <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_RETURN_UNSUPPORTED_HASH_RESTRICTI | Unsupported ContentObjectHa | <lb/>| <lb/>ON <lb/>| shRestriction <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RETURN_MALFORMED_INTEREST <lb/>| Malformed Interest <lb/>| <lb/>+-------------------------------------+-----------------------------+ <lb/>Table 2: Return Codes <lb/>3.3. Global Formats <lb/>This section defines global formats that may be nested within other <lb/>TLVs. <lb/>3.3.1. Pad <lb/>The pad type may be used by sources that prefer word-aligned data. <lb/>Padding 4-byte words, for example, would use a 1-byte, 2-byte, and <lb/>3-byte Length. Padding 8-byte words would use a (0, 1, 2, 3, 5, 6, <lb/>7)-byte Length. <lb/>One MUST NOT pad inside a Name. Apart from that, a pad MAY be <lb/>inserted after any other TLV in the CCNx Message TLV or in the <lb/>ValidationAlgorithm TLV. In the remainder of this document, we will <lb/>not show optional Pad TLVs. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 11] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_PAD <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>variable-length pad MUST be zeros <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 7: Pad Encoding <lb/>3.3.2. Organization-Specific TLVs <lb/>Organization-specific TLVs (also known as Vendor TLVs) MUST use the <lb/>T_ORG type. The Length field is the length of the organization-<lb/>specific information plus 3. The Value begins with the 3 byte <lb/>organization number derived from the network byte order encoding of <lb/>the IANA &quot;Private Enterprise Numbers&quot; registry [IANA-PEN], followed <lb/>by the organization-specific information. <lb/>A T_ORG MAY be used as a path segment in a Name. It is treated like <lb/>any other path segment. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_ORG <lb/>| <lb/>Length (3+value length) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>PEN[0] <lb/>| <lb/>PEN[1] <lb/>| <lb/>PEN[2] <lb/>| <lb/>/ <lb/>+---------------+---------------+---------------+ <lb/>+ <lb/>/ <lb/>Vendor Specific Value <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 8: Organization-Specific TLVs <lb/>3.3.3. Hash Format <lb/>Hash values are used in several fields throughout a packet. This TLV <lb/>encoding is commonly embedded inside those fields to specify the <lb/>specific hash function used and its value. Note that the reserved <lb/>TLV types are also reserved here for user-defined experimental <lb/>functions. <lb/>The LENGTH field of the hash value MUST be less than or equal to the <lb/>hash function length. If the LENGTH is less than the full length, it <lb/>is taken as the left LENGTH bytes of the hash function output. Only <lb/>specified truncations are allowed, not arbitrary truncations. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 12] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>This nested format is used because it allows binary comparison of <lb/>hash values for certain fields without a router needing to understand <lb/>a new hash function. For example, the KeyIdRestriction is bit-wise <lb/>compared between an Interest&apos;s KeyIdRestriction field and a <lb/>ContentObject&apos;s KeyId field. This format means the outer field <lb/>values do not change with differing hash functions so a router can <lb/>still identify those fields and do a binary comparison of the hash <lb/>TLV without need to understand the specific hash used. An <lb/>alternative approach, such as using T_KEYID_SHA512-256, would require <lb/>each router keeps an up-to-date parser and supporting user-defined <lb/>hash functions here would explode the parsing state-space. <lb/>A CCNx entity MUST support the hash type T_SHA-256. An entity MAY <lb/>support the remaining hash types. <lb/>+-----------+------------------------+ <lb/>| <lb/>Abbrev | <lb/>Lengths (octets) <lb/>| <lb/>+-----------+------------------------+ <lb/>| T_SHA-256 | <lb/>32 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_SHA-512 | <lb/>64, 32 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>n/a <lb/>| Experimental TLV types | <lb/>+-----------+------------------------+ <lb/>Table 3: CCNx Hash Functions <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_FOO <lb/>| <lb/>36 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_SHA512 <lb/>| <lb/>32 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>32-byte hash value <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 9: Example nesting inside type T_FOO <lb/>3.3.4. Link <lb/>A Link is the tuple: {Name, [KeyIdRestr], [ContentObjectHashRestr]}. <lb/>It is a general encoding that is used in both the payload of a <lb/>Content Object with PayloadType = &quot;Link&quot; and in a Content Object&apos;s <lb/>KeyLink field. A Link is essentially the body of an Interest. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 13] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Mandatory CCNx Name <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional KeyIdRestriction <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional ContentObjectHashRestriction <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 10: Link Encoding <lb/>3.4. Hop-by-Hop TLV Headers <lb/>Hop-by-hop TLV headers are unordered and meaning MUST NOT be attached <lb/>to their ordering. Three hop-by-hop headers are described in this <lb/>document: <lb/>+-------------+--------------------+--------------------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+-------------+--------------------+--------------------------------+ <lb/>| T_INTLIFE | Interest Lifetime | The time an Interest should <lb/>| <lb/>| <lb/>| (Section 3.4.1) <lb/>| stay pending at an <lb/>| <lb/>| <lb/>| <lb/>| intermediate node. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_CACHETIME | Recommended Cache | The Recommended Cache Time for | <lb/>| <lb/>| <lb/>Time (Section <lb/>| Content Objects. <lb/>| <lb/>| <lb/>| <lb/>3.4.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_MSGHASH | <lb/>Message Hash <lb/>| A cryptographic hash (Section | <lb/>| <lb/>| (Section 3.4.3) <lb/>| 3.3.3). <lb/>| <lb/>+-------------+--------------------+--------------------------------+ <lb/>Table 4: Hop-by-Hop Header Types <lb/>Additional hop-by-hop headers are defined in higher level <lb/>specifications such as the fragmentation specification. <lb/>3.4.1. Interest Lifetime <lb/>The Interest Lifetime is the time that an Interest should stay <lb/>pending at an intermediate node. It is expressed in milliseconds as <lb/>an unsigned integer in network byte order. <lb/>A value of 0 (encoded as 1 byte 0x00) indicates the Interest does not <lb/>elicit a Content Object response. It should still be forwarded, but <lb/>no reply is expected and a forwarder could skip creating a PIT entry. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 14] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_INTLIFE <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>/ <lb/>/ <lb/>Lifetime (Length octets) <lb/>/ <lb/>/ <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 11: Interest Lifetime Encoding <lb/>3.4.2. Recommended Cache Time <lb/>The Recommended Cache Time (RCT) is a measure of the useful lifetime <lb/>of a Content Object as assigned by a content producer or upstream <lb/>node. It serves as a guideline to the Content Store cache in <lb/>determining how long to keep the Content Object. It is a <lb/>recommendation only and may be ignored by the cache. This is in <lb/>contrast to the ExpiryTime (described in Section 3.6.2.2.2) which <lb/>takes precedence over the RCT and must be obeyed. <lb/>Because the Recommended Cache Time is an optional hop-by-hop header <lb/>and not a part of the signed message, a content producer may re-issue <lb/>a previously signed Content Object with an updated RCT without <lb/>needing to re-sign the message. There is little ill effect from an <lb/>attacker changing the RCT as the RCT serves as a guideline only. <lb/>The Recommended Cache Time (a millisecond timestamp) is an unsigned <lb/>integer in network byte order that indicates the time when the <lb/>payload expires (as the number of milliseconds since the epoch in <lb/>UTC). It is a 64-bit field. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_CACHETIME <lb/>| <lb/>8 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>/ <lb/>/ <lb/>Recommended Cache Time <lb/>/ <lb/>/ <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 12: Recommended Cache Time Encoding <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 15] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.4.3. Message Hash <lb/>Within a trusted domain, an operator may calculate the message hash <lb/>at a border device and insert that value into the hop-by-hop headers <lb/>of a message. An egress device should remove the value. This <lb/>permits intermediate devices within that trusted domain to match <lb/>against a ContentObjectHashRestriction without calculating it at <lb/>every hop. <lb/>The message hash is a cryptographic hash from the start of the CCNx <lb/>Message TLV to the end of the packet. It is used to match against <lb/>the ContentObjectHashRestriction (Section 3.6.2.1.2). The Message <lb/>Hash may be of longer length than an Interest&apos;s restriction, in which <lb/>case the device should use the left bytes of the Message Hash to <lb/>check against the Interest&apos;s value. <lb/>The Message Hash may only carry one hash type and there may only be <lb/>one Message Hash header. <lb/>The Message Hash header is unprotected, so this header is only of <lb/>practical use within a trusted domain, such as an operator&apos;s <lb/>autonomous system. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_MSGHASH <lb/>| <lb/>(length + 4) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>hash type <lb/>| <lb/>length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>hash value <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 13: Message Hash Header <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 16] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.5. Top-Level Types <lb/>The top-level TLV types listed below exist at the outermost level of <lb/>a CCNx Message TLV. <lb/>+----------------------+------------+-------------------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+----------------------+------------+-------------------------------+ <lb/>| <lb/>T_INTEREST <lb/>| Interest | An Interest MessageType. <lb/>| <lb/>| <lb/>| (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_OBJECT <lb/>| Content <lb/>| A Content Object MessageType | <lb/>| <lb/>| <lb/>Object <lb/>| <lb/>| <lb/>| <lb/>| (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_VALIDATION_ALG <lb/>| Validation | The method of message <lb/>| <lb/>| <lb/>| Algorithm | verification such as a <lb/>| <lb/>| <lb/>| (Section | Message Integrity Check <lb/>| <lb/>| <lb/>| 3.6.4.1) | (MIC), Message Authentication | <lb/>| <lb/>| <lb/>| Code (MAC), or cryptographic | <lb/>| <lb/>| <lb/>| signature. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_VALIDATION_PAYLOAD | Validation | The validation output, such <lb/>| <lb/>| <lb/>| Payload <lb/>| as the CRC32C code or the RSA | <lb/>| <lb/>| (Section | signature. <lb/>| <lb/>| <lb/>| 3.6.4.2) | <lb/>| <lb/>+----------------------+------------+-------------------------------+ <lb/>Table 5: CCNx Top Level Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 17] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6. CCNx Message TLV <lb/>This is the format for the CCNx Message itself. The CCNx Message TLV <lb/>is the portion of the CCNx Packet between the hop-by-hop headers and <lb/>the Validation TLVs. The figure below is an expansion of the &quot;CCNx <lb/>Message TLV&quot; depicted in the beginning of Section 3. The CCNx <lb/>Message TLV begins with MessageType and runs through the optional <lb/>Payload. The same general format is used for both Interest and <lb/>Content Object messages which are differentiated by the MessageType <lb/>field. The first enclosed TLV of a CCNx Message TLV is always the <lb/>Name TLV, if present. This is followed by an optional Message TLVs <lb/>and an optional Payload TLV. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>MessageType <lb/>| <lb/>MessageLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Name TLV <lb/>(Type = T_NAME) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional Message TLVs <lb/>(Various Types) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional Payload TLV (Type = T_PAYLOAD) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 14: CCNx Message TLV Encoding <lb/>+-----------+---------------+---------------------------------------+ <lb/>| <lb/>Abbrev | <lb/>Name <lb/>| Description <lb/>| <lb/>+-----------+---------------+---------------------------------------+ <lb/>| <lb/>T_NAME | Name (Section | The CCNx Name requested in an <lb/>| <lb/>| <lb/>| <lb/>3.6.1) <lb/>| Interest or published in a Content <lb/>| <lb/>| <lb/>| <lb/>| Object. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_PAYLOAD | <lb/>Payload <lb/>| The message payload. <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.6.3) <lb/>| <lb/>| <lb/>+-----------+---------------+---------------------------------------+ <lb/>Table 6: CCNx Message TLV Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 18] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.1. Name <lb/>A Name is a TLV encoded sequence of segments. The table below lists <lb/>the type values appropriate for these name segments. A Name MUST NOT <lb/>include Pad TLVs. <lb/>As described in CCNx Semantics [RFC8569], using the CCNx URI <lb/>[CCNxURI] notation, a T_NAME with zero length corresponds to &quot;ccnx:/&quot; <lb/>(the default route). The message grammar does not allow the first <lb/>name segment to have zero length in a CCNx Message TLV Name. In the <lb/>TLV encoding, &quot;ccnx:/&quot; corresponds to T_NAME with zero length. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_NAME <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Name segment TLVs <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 15: Name Encoding <lb/>+---------------+-------------+-------------------------------------+ <lb/>| Symbolic Name | <lb/>Name <lb/>| Description <lb/>| <lb/>+---------------+-------------+-------------------------------------+ <lb/>| T_NAMESEGMENT | <lb/>Name <lb/>| A generic name segment. <lb/>| <lb/>| <lb/>| <lb/>segment <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.1.1) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_IPID <lb/>| <lb/>Interest | An identifier that represents the <lb/>| <lb/>| <lb/>| Payload ID | Interest Payload field. As an <lb/>| <lb/>| <lb/>| <lb/>(Section | example, the Payload ID might be a | <lb/>| <lb/>| <lb/>3.6.1.2) | hash of the Interest Payload. This | <lb/>| <lb/>| <lb/>| provides a way to differentiate <lb/>| <lb/>| <lb/>| <lb/>| between Interests based on their <lb/>| <lb/>| <lb/>| <lb/>| payloads without having to parse <lb/>| <lb/>| <lb/>| <lb/>| all the bytes of the payload <lb/>| <lb/>| <lb/>| <lb/>| itself, and instead using only this | <lb/>| <lb/>| <lb/>| Payload ID name segment. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_APP:00 -| Application | Application-specific payload in a <lb/>| <lb/>| <lb/>T_APP:4096 | Components | name segment. An application may <lb/>| <lb/>| <lb/>| <lb/>(Section | apply its own semantics to the 4096 | <lb/>| <lb/>| <lb/>3.6.1.1) | reserved types. <lb/>| <lb/>+---------------+-------------+-------------------------------------+ <lb/>Table 7: CCNx Name Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 19] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.1.1. Name Segments <lb/>4096 special application payload name segments are allocated. These <lb/>have application semantics applied to them. A good convention is to <lb/>put the application&apos;s identity in the name prior to using these name <lb/>segments. <lb/>For example, a name like &quot;ccnx:/foo/bar/hi&quot; would be encoded as: <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>(T_NAME) <lb/>| <lb/>0x14 (20) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>(T_NAME_SEGMENT) <lb/>| <lb/>0x03 (3) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>f <lb/>o <lb/>o <lb/>|(T_NAME_SEGMENT) <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>| <lb/>0x03 (3) <lb/>| <lb/>b <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>a <lb/>r <lb/>| <lb/>(T_NAME_SEGMENT) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>0x02 (2) <lb/>| <lb/>h <lb/>| <lb/>i <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 16: Name Encoding Example <lb/>3.6.1.2. Interest Payload ID <lb/>The InterestPayloadID is a name segment created by the origin of an <lb/>Interest to represent the Interest Payload. This allows the proper <lb/>multiplexing of Interests based on their name if they have different <lb/>payloads. A common representation is to use a hash of the Interest <lb/>Payload as the InterestPayloadID. <lb/>As part of the Value of the TLV, the InterestPayloadID contains a <lb/>one-octet identifier of the method used to create the <lb/>InterestPayloadID followed by a variable-length octet string. An <lb/>implementation is not required to implement any of the methods to <lb/>receive an Interest; the InterestPayloadID may be treated only as an <lb/>opaque octet string for the purposes of multiplexing Interests with <lb/>different payloads. Only a device creating an InterestPayloadID name <lb/>segment or a device verifying such a segment needs to implement the <lb/>algorithms. <lb/>It uses the encoding of hash values specified in Section 3.3.3. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 20] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>In normal operations, we recommend displaying the InterestPayloadID <lb/>as an opaque octet string in a CCNx URI, as this is the common <lb/>denominator for implementation parsing. <lb/>The InterestPayloadID, even if it is a hash, should not convey any <lb/>security context. If a system requires confirmation that a specific <lb/>entity created the InterestPayload, it should use a cryptographic <lb/>signature on the Interest via the ValidationAlgorithm and <lb/>ValidationPayload or use its own methods inside the Interest Payload. <lb/>3.6.2. Message TLVs <lb/>Each message type (Interest or Content Object) is associated with a <lb/>set of optional Message TLVs. Additional specification documents may <lb/>extend the types associated with each. <lb/>3.6.2.1. Interest Message TLVs <lb/>There are two Message TLVs currently associated with an Interest <lb/>message: the KeyIdRestriction selector and the ContentObjectHashRestr <lb/>selector are used to narrow the universe of acceptable Content <lb/>Objects that would satisfy the Interest. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>MessageType <lb/>| <lb/>MessageLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| Name TLV <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional KeyIdRestriction TLV <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>/ Optional ContentObjectHashRestriction TLV <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>Figure 17: Interest Message TLVs <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 21] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>+----------------+------------------------------+-------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+----------------+------------------------------+-------------------+ <lb/>| T_KEYIDRESTR | KeyIdRestriction (Section <lb/>| A representation | <lb/>| <lb/>| <lb/>3.6.2.1.1) <lb/>| (as per Section <lb/>| <lb/>| <lb/>| <lb/>| 3.3.3) of the <lb/>| <lb/>| <lb/>| <lb/>| KeyId <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_OBJHASHRESTR | ContentObjectHashRestriction | A representation | <lb/>| <lb/>| <lb/>(Section 3.6.2.1.2) <lb/>| (as per Section <lb/>| <lb/>| <lb/>| <lb/>| 3.3.3) of the <lb/>| <lb/>| <lb/>| <lb/>| hash of the <lb/>| <lb/>| <lb/>| <lb/>| specific Content | <lb/>| <lb/>| <lb/>| Object that would | <lb/>| <lb/>| <lb/>| satisfy the <lb/>| <lb/>| <lb/>| <lb/>| Interest. <lb/>| <lb/>+----------------+------------------------------+-------------------+ <lb/>Table 8: CCNx Interest Message TLV Types <lb/>3.6.2.1.1. KeyIdRestriction <lb/>An Interest MAY include a KeyIdRestriction selector. This ensures <lb/>that only Content Objects with matching KeyIds will satisfy the <lb/>Interest. See Section 3.6.4.1.4.1 for the format of a KeyId. <lb/>3.6.2.1.2. ContentObjectHashRestriction <lb/>An Interest MAY contain a ContentObjectHashRestriction selector. <lb/>This is the hash of the Content Object --the self-certifying name <lb/>restriction that must be verified in the network, if an Interest <lb/>carried this restriction (see Message Hash (Section 3.4.3)). The <lb/>LENGTH MUST be from one of the allowed values for that hash (see <lb/>Section 3.3.3). <lb/>The ContentObjectHashRestriction SHOULD be of type T_SHA-256 and of <lb/>length 32 bytes. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 22] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_OBJHASHRESTR <lb/>| <lb/>(LENGTH+4) <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>hash type <lb/>| <lb/>LENGTH <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>LENGTH octets of hash <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 18: ContentObjectHashRestriction Encoding <lb/>3.6.2.2. Content Object Message TLVs <lb/>The following message TLVs are currently defined for Content Objects: <lb/>PayloadType (optional) and ExpiryTime (optional). <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>MessageType <lb/>| <lb/>MessageLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| Name TLV <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Optional PayloadType TLV <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>/ Optional ExpiryTime TLV <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>Figure 19: Content Object Message TLVs <lb/>+-------------+-------------+---------------------------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+-------------+-------------+---------------------------------------+ <lb/>| T_PAYLDTYPE | PayloadType | Indicates the type of Payload <lb/>| <lb/>| <lb/>| <lb/>(Section | contents. <lb/>| <lb/>| <lb/>| 3.6.2.2.1) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_EXPIRY | ExpiryTime | The time at which the Payload <lb/>| <lb/>| <lb/>| <lb/>(Section | expires, as expressed in the number <lb/>| <lb/>| <lb/>| 3.6.2.2.2) | of milliseconds since the epoch in <lb/>| <lb/>| <lb/>| <lb/>| UTC. If missing, Content Object may | <lb/>| <lb/>| <lb/>| be used as long as desired. <lb/>| <lb/>+-------------+-------------+---------------------------------------+ <lb/>Table 9: CCNx Content Object Message TLV Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 23] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.2.2.1. PayloadType <lb/>The PayloadType is an octet representing the general type of the <lb/>Payload TLV. <lb/>o T_PAYLOADTYPE_DATA: Data (possibly encrypted) <lb/>o T_PAYLOADTYPE_KEY: Key <lb/>o T_PAYLOADTYPE_LINK: Link <lb/>The Data type indicates that the Payload of the ContentObject is <lb/>opaque application bytes. The Key type indicates that the Payload is <lb/>a DER-encoded public key. The Link type indicates that the Payload <lb/>is one or more Links (Section 3.3.4). If this field is missing, a <lb/>Data type is assumed. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_PAYLDTYPE <lb/>| <lb/>1 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| PayloadType | <lb/>+---------------+ <lb/>Figure 20: PayloadType Encoding <lb/>3.6.2.2.2. ExpiryTime <lb/>The ExpiryTime is the time at which the Payload expires, as expressed <lb/>by a timestamp containing the number of milliseconds since the epoch <lb/>in UTC. It is a network byte order unsigned integer in a 64-bit <lb/>field. A cache or end system should not respond with a Content <lb/>Object past its ExpiryTime. Routers forwarding a Content Object do <lb/>not need to check the ExpiryTime. If the ExpiryTime field is <lb/>missing, the Content Object has no expressed expiration, and a cache <lb/>or end system may use the Content Object for as long as desired. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_EXPIRY <lb/>| <lb/>8 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>ExpiryTime <lb/>/ <lb/>/ <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 21: ExpiryTime encoding <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 24] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.3. Payload <lb/>The Payload TLV contains the content of the packet. It MAY be of <lb/>zero length. If a packet does not have any payload, this field <lb/>SHOULD be omitted, rather than being of zero length. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_PAYLOAD <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>Payload Contents <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 22: Payload Encoding <lb/>3.6.4. Validation <lb/>Both Interests and Content Objects have the option to include <lb/>information about how to validate the CCNx Message. This information <lb/>is contained in two TLVs: the ValidationAlgorithm TLV and the <lb/>ValidationPayload TLV. The ValidationAlgorithm TLV specifies the <lb/>mechanism to be used to verify the CCNx Message. Examples include <lb/>verification with a Message Integrity Check (MIC), a Message <lb/>Authentication Code (MAC), or a cryptographic signature. The <lb/>ValidationPayload TLV contains the validation output, such as the <lb/>CRC32C code or the RSA signature. <lb/>An Interest would most likely only use a MIC type of validation --a <lb/>CRC, checksum, or digest. <lb/>3.6.4.1. Validation Algorithm <lb/>The ValidationAlgorithm is a set of nested TLVs containing all of the <lb/>information needed to verify the message. The outermost container <lb/>has type = T_VALIDATION_ALG. The first nested TLV defines the <lb/>specific type of validation to be performed on the message. The type <lb/>is identified with the &quot;ValidationType&quot; as shown in the figure below <lb/>and elaborated in the table below. Nested within that container are <lb/>the TLVs for any ValidationType-dependent data --for example, a Key <lb/>Id, Key Locator, etc. <lb/>Complete examples of several types may be found in Section 3.6.4.1.5. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 25] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_VALIDATION_ALG <lb/>| <lb/>ValidationAlgLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>ValidationType <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ ValidationType-dependent data <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 23: Validation Algorithm Encoding <lb/>+-----------------+---------------+---------------------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+-----------------+---------------+---------------------------------+ <lb/>| <lb/>T_CRC32C <lb/>| <lb/>CRC32C <lb/>| Castagnoli CRC32 (iSCSI, ext4, | <lb/>| <lb/>| <lb/>(Section <lb/>| etc.) with normal form <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.1) | polynomial 0x1EDC6F41. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_HMAC-SHA256 | HMAC-SHA256 | HMAC (RFC 2104) using SHA256 <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| hash. <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.2) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_RSA-SHA256 | <lb/>RSA-SHA256 | RSA public-key signature using | <lb/>| <lb/>| <lb/>(Section <lb/>| SHA256 digest. <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_EC-SECP-256K1 | <lb/>SECP-256K1 | Elliptic Curve signature with <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| SECP-256K1 parameters (see <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.3) | [ECC]). <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_EC-SECP-384R1 | <lb/>SECP-384R1 | Elliptic Curve signature with <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| SECP-384R1 parameters (see <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.3) | [ECC]). <lb/>| <lb/>+-----------------+---------------+---------------------------------+ <lb/>Table 10: CCNx Validation Types <lb/>3.6.4.1.1. Message Integrity Checks <lb/>MICs do not require additional data in order to perform the <lb/>verification. An example is CRC32C that has a zero-length value. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 26] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.4.1.2. Message Authentication Codes <lb/>MACs are useful for communication between two trusting parties who <lb/>have already shared secret keys. An example is the HMAC algorithm. <lb/>A MAC uses the KeyId field to identify which shared secret is in use. <lb/>The meaning of the KeyId is specific to the two parties involved and <lb/>could be simply an integer to enumerate keys. If a new MAC requires <lb/>an additional field, such as an Initialization Vector, that field <lb/>would need to be defined as part of the updated specification. <lb/>3.6.4.1.3. Signature <lb/>Signature type Validators specify a digest mechanism and a signing <lb/>algorithm to verify the message. Examples include an RSA signature <lb/>on a SHA256 digest, an Elliptic Curve signature with SECP-256K1 <lb/>parameters, etc. These Validators require a KeyId and a mechanism <lb/>for locating the publisher&apos;s public key (a KeyLocator) --and <lb/>optionally a PublicKey or Certificate or KeyLink. <lb/>3.6.4.1.4. Validation-Dependent Data <lb/>Different Validation Algorithms require access to different pieces of <lb/>data contained in the ValidationAlgorithm TLV. As described above, <lb/>Key Ids, Key Locators, Public Keys, Certificates, Links, and Key <lb/>Names all play a role in different Validation Algorithms. Any number <lb/>of Validation-Dependent Data containers can be present in a <lb/>Validation Algorithm TLV. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 27] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>Below is a table of CCNx ValidationType-dependent data types: <lb/>+-------------+-----------------+-----------------------------------+ <lb/>| <lb/>Abbrev <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+-------------+-----------------+-----------------------------------+ <lb/>| <lb/>T_KEYID <lb/>| <lb/>SignerKeyId <lb/>| An identifier of the shared <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| secret or public key associated <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.4.1) | with a MAC or Signature. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_PUBLICKEY | <lb/>Public Key <lb/>| DER-encoded public key. <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.4.2) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>T_CERT <lb/>| <lb/>Certificate <lb/>| DER-encoded X.509 certificate. <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.4.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_KEYLINK | <lb/>KeyLink <lb/>| A CCNx Link object. <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.4.4) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| T_SIGTIME | SignatureTime | A millisecond timestamp <lb/>| <lb/>| <lb/>| <lb/>(Section <lb/>| indicating the time when the <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1.4.5) | signature was created. <lb/>| <lb/>+-------------+-----------------+-----------------------------------+ <lb/>Table 11: CCNx Validation-Dependent Data Types <lb/>3.6.4.1.4.1. KeyId <lb/>The KeyId for a signature is the publisher key identifier. It is <lb/>similar to a Subject Key Identifier from X.509 (see Section 4.2.1.2 <lb/>of [RFC5280]). It should be derived from the key used to sign, such <lb/>as from the SHA-256 hash of the key. It applies to both public and <lb/>private key systems and to symmetric key systems. <lb/>The KeyId is represented using the hash format in Section 3.3.3. If <lb/>an application protocol uses a non-hash identifier, it should use one <lb/>of the reserved values. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 28] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_KEYID <lb/>| <lb/>LENGTH+4 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>&lt;hash type&gt; <lb/>| <lb/>LENGTH <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>LENGTH octets of hash <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 24: KeyId Encoding <lb/>3.6.4.1.4.2. Public Key <lb/>A Public Key is a DER-encoded Subject Public Key Info block, as in an <lb/>X.509 certificate. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_PUBLICKEY <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>Public Key (DER-encoded SPKI) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 25: Public Key Encoding <lb/>3.6.4.1.4.3. Certificate <lb/>A Certificate is a DER-encoded X.509 certificate. The KeyId <lb/>(Section 3.6.4.1.4.1) is derived from this encoding. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_CERT <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>Certificate (DER-encoded X.509) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 26: Certificate Encoding <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 29] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.4.1.4.4. KeyLink <lb/>A KeyLink type KeyLocator is a Link. <lb/>The KeyLink ContentObjectHashRestr, if included, is the digest of the <lb/>Content Object identified by KeyLink, not the digest of the public <lb/>key. Likewise, the KeyIdRestr of the KeyLink is the KeyId of the <lb/>ContentObject, not necessarily of the wrapped key. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+-------------------------------+ <lb/>| <lb/>T_KEYLINK <lb/>| <lb/>Length <lb/>| <lb/>+---------------+---------------+-------------------------------+ <lb/>/ Link <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>Figure 27: KeyLink Encoding <lb/>3.6.4.1.4.5. SignatureTime <lb/>The SignatureTime is a millisecond timestamp indicating the time at <lb/>which a signature was created. The signer sets this field to the <lb/>current time when creating a signature. A verifier may use this time <lb/>to determine whether or not the signature was created during the <lb/>validity period of a key, or if it occurred in a reasonable sequence <lb/>with other associated signatures. The SignatureTime is unrelated to <lb/>any time associated with the actual CCNx Message, which could have <lb/>been created long before the signature. The default behavior is to <lb/>always include a SignatureTime when creating an authenticated message <lb/>(e.g., HMAC or RSA). <lb/>SignatureTime is an unsigned integer in network byte order that <lb/>indicates when the signature was created (as the number of <lb/>milliseconds since the epoch in UTC). It is a fixed 64-bit field. <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+-------------------------------+ <lb/>| <lb/>T_SIGTIME <lb/>| <lb/>8 <lb/>| <lb/>+---------------+---------------+-------------------------------+ <lb/>/ <lb/>SignatureTime <lb/>/ <lb/>+---------------------------------------------------------------+ <lb/>Figure 28: SignatureTime Encoding <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 30] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>3.6.4.1.5. Validation Examples <lb/>As an example of a MIC-type validation, the encoding for CRC32C <lb/>validation would be: <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_VALIDATION_ALG <lb/>| <lb/>4 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_CRC32C <lb/>| <lb/>0 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 29: CRC32C Encoding Example <lb/>As an example of a MAC-type validation, the encoding for an HMAC <lb/>using a SHA256 hash would be: <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_VALIDATION_ALG <lb/>| <lb/>40 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_HMAC-SHA256 <lb/>| <lb/>36 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_KEYID <lb/>| <lb/>32 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>KeyId <lb/>/ <lb/>/---------------+---------------+-------------------------------+ <lb/>Figure 30: HMAC-SHA256 Encoding Example <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 31] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>As an example of a Signature-type validation, the encoding for an RSA <lb/>public-key signature using a SHA256 digest and Public Key would be: <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_VALIDATION_ALG <lb/>| <lb/>44 octets + Variable Length | <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_RSA-SHA256 <lb/>| <lb/>40 octets + Variable Length | <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_KEYID <lb/>| <lb/>32 <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>KeyId <lb/>/ <lb/>/---------------+---------------+-------------------------------+ <lb/>| <lb/>T_PUBLICKEY <lb/>| Variable Length (~160 octets)| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ <lb/>Public Key (DER-encoded SPKI) <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 31: RSA-SHA256 Encoding Example <lb/>3.6.4.2. Validation Payload <lb/>1 <lb/>2 <lb/>3 <lb/>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 <lb/>+---------------+---------------+---------------+---------------+ <lb/>| <lb/>T_VALIDATION_PAYLOAD <lb/>| ValidationPayloadLength <lb/>| <lb/>+---------------+---------------+---------------+---------------+ <lb/>/ Type-dependent data <lb/>/ <lb/>+---------------+---------------+---------------+---------------+ <lb/>Figure 32: Validation Payload Encoding <lb/>The ValidationPayload contains the validation output, such as the <lb/>CRC32C code or the RSA signature. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 32] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4. IANA Considerations <lb/>This section details each kind of CCNx protocol value that can be <lb/>registered. Each type registry can be updated by incrementally <lb/>expanding the type space, i.e., by allocating and reserving new <lb/>types. As per [RFC8126], this section details the creation of the <lb/>&quot;Content-Centric Networking (CCNx)&quot; registry and several <lb/>subregistries. <lb/>4.1. Packet Type Registry <lb/>IANA has created the &quot;CCNx Packet Types&quot; registry and allocated the <lb/>packet types described below. The registration procedure is RFC <lb/>Required. The Type value is 1 octet. The range is 0x00-0xFF. <lb/>+------+-------------+----------------------------------+ <lb/>| Type | <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+------+-------------+----------------------------------+ <lb/>| 0x00 | PT_INTEREST | Fixed Header Types (Section 3.2) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x01 | PT_CONTENT | Fixed Header Types (Section 3.2) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x02 | PT_RETURN | Fixed Header Types (Section 3.2) | <lb/>+------+-------------+----------------------------------+ <lb/>Packet Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 33] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.2. Interest Return Code Registry <lb/>IANA has created the &quot;CCNx Interest Return Code Types&quot; registry and <lb/>allocated the Interest Return code types described below. The <lb/>registration procedure is Specification Required. The Type value is <lb/>1 octet. The range is 0x00-0xFF. <lb/>+------+---------------------------------------+--------------------+ <lb/>| Type | <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+------+---------------------------------------+--------------------+ <lb/>| 0x00 | <lb/>Reserved <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x01 | <lb/>T_RETURN_NO_ROUTE <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x02 | <lb/>T_RETURN_LIMIT_EXCEEDED <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x03 | <lb/>T_RETURN_NO_RESOURCES <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x04 | <lb/>T_RETURN_PATH_ERROR <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x05 | <lb/>T_RETURN_PROHIBITED <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x06 | <lb/>T_RETURN_CONGESTED <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x07 | <lb/>T_RETURN_MTU_TOO_LARGE <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x08 | T_RETURN_UNSUPPORTED_HASH_RESTRICTION | Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x09 | <lb/>T_RETURN_MALFORMED_INTEREST <lb/>| Fixed Header Types | <lb/>| <lb/>| <lb/>| (Section 3.2.3.3) | <lb/>+------+---------------------------------------+--------------------+ <lb/>CCNx Interest Return Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 34] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.3. Hop-by-Hop Type Registry <lb/>IANA has created the &quot;CCNx Hop-by-Hop Types&quot; registry and allocated <lb/>the hop-by-hop types described below. The registration procedure is <lb/>RFC Required. The Type value is 2 octets. The range is <lb/>0x0000-0xFFFF. <lb/>+---------------+-------------+-------------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+---------------+-------------+-------------------------------------+ <lb/>| <lb/>0x0000 <lb/>| <lb/>Reserved | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0001 <lb/>| T_INTLIFE | <lb/>Hop-by-hop TLV headers (Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0002 <lb/>| T_CACHETIME | <lb/>Hop-by-hop TLV headers (Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0003 <lb/>| T_MSGHASH | <lb/>Hop-by-hop TLV headers (Section <lb/>| <lb/>| <lb/>| <lb/>| <lb/>3.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0004 -<lb/>| <lb/>Reserved | <lb/>| <lb/>| <lb/>0x0007 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFE <lb/>| <lb/>T_PAD <lb/>| <lb/>Pad (Section 3.3.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| Organization-Specific TLVs (Section | <lb/>| <lb/>| <lb/>| <lb/>3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x1000-0x1FFF | <lb/>Reserved | <lb/>Experimental Use (Section 3) <lb/>| <lb/>+---------------+-------------+-------------------------------------+ <lb/>CCNx Hop-by-Hop Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 35] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.4. Top-Level Type Registry <lb/>IANA has created the &quot;CCNx Top-Level Types&quot; registry and allocated <lb/>the top-level types described below. The registration procedure is <lb/>RFC Required. The Type value is 2 octets. The range is <lb/>0x0000-0xFFFF. <lb/>+--------+----------------------+-------------------------------+ <lb/>| Type | <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+--------+----------------------+-------------------------------+ <lb/>| 0x0000 | <lb/>Reserved <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x0001 | <lb/>T_INTEREST <lb/>| Top-Level Types (Section 3.5) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x0002 | <lb/>T_OBJECT <lb/>| Top-Level Types (Section 3.5) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x0003 | <lb/>T_VALIDATION_ALG <lb/>| Top-Level Types (Section 3.5) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x0004 | T_VALIDATION_PAYLOAD | Top-Level Types (Section 3.5) | <lb/>+--------+----------------------+-------------------------------+ <lb/>CCNx Top-Level Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 36] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.5. Name Segment Type Registry <lb/>IANA has created the &quot;CCNx Name Segment Types&quot; registry and allocated <lb/>the name segment types described below. The registration procedure <lb/>is Specification Required. The Type value is 2 octets. The range is <lb/>0x0000-0xFFFF. <lb/>+--------------+------------------+---------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+--------------+------------------+---------------------------------+ <lb/>| <lb/>0x0000 <lb/>| <lb/>Reserved <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0001 <lb/>| T_NAMESEGMENT <lb/>| <lb/>Name (Section 3.6.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0002 <lb/>| <lb/>T_IPID <lb/>| <lb/>Name (Section 3.6.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0010 -<lb/>| <lb/>Reserved <lb/>| <lb/>RFC 8609 <lb/>| <lb/>| <lb/>0x0013 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| <lb/>Organization-Specific TLVs <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x1000 -<lb/>| <lb/>T_APP:00 -<lb/>| Application Components (Section | <lb/>| <lb/>0x1FFF <lb/>| <lb/>T_APP:4096 <lb/>| <lb/>3.6.1) <lb/>| <lb/>+--------------+------------------+---------------------------------+ <lb/>CCNx Name Segment Types <lb/>4.6. Message Type Registry <lb/>IANA has created the &quot;CCNx Message Types&quot; registry and registered the <lb/>message segment types described below. The registration procedure is <lb/>RFC Required. The Type value is 2 octets. The range is <lb/>0x0000-0xFFFF. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 37] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>+---------------+----------------+----------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+---------------+----------------+----------------------------------+ <lb/>| <lb/>0x0000 <lb/>| <lb/>T_NAME <lb/>| <lb/>Message Types (Section 3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0001 <lb/>| <lb/>T_PAYLOAD <lb/>| <lb/>Message Types (Section 3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0002 <lb/>| T_KEYIDRESTR | <lb/>Message Types (Section 3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0003 <lb/>| T_OBJHASHRESTR | <lb/>Message Types (Section 3.6) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0005 <lb/>| T_PAYLDTYPE <lb/>| <lb/>Content Object Message Types <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.2.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0006 <lb/>| <lb/>T_EXPIRY <lb/>| <lb/>Content Object Message Types <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.2.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0007 -<lb/>| <lb/>Reserved <lb/>| <lb/>RFC 8609 <lb/>| <lb/>| <lb/>0x000C <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFE <lb/>| <lb/>T_PAD <lb/>| <lb/>Pad (Section 3.3.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| <lb/>Organization-Specific TLVs <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x1000-0x1FFF | <lb/>Reserved <lb/>| <lb/>Experimental Use (Section 3) <lb/>| <lb/>+---------------+----------------+----------------------------------+ <lb/>CCNx Message Types <lb/>4.7. Payload Type Registry <lb/>IANA has created the &quot;CCNx Payload Types&quot; registry and allocated the <lb/>payload types described below. The registration procedure is <lb/>Specification Required. The Type value is 1 octet. The range is <lb/>0x00-0xFF. <lb/>+------+--------------------+-----------------------------------+ <lb/>| Type | <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+------+--------------------+-----------------------------------+ <lb/>| 0x00 | T_PAYLOADTYPE_DATA | Payload Types (Section 3.6.2.2.1) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x01 | T_PAYLOADTYPE_KEY | Payload Types (Section 3.6.2.2.1) | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x02 | T_PAYLOADTYPE_LINK | Payload Types (Section 3.6.2.2.1) | <lb/>+------+--------------------+-----------------------------------+ <lb/>CCNx Payload Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 38] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.8. Validation Algorithm Type Registry <lb/>IANA has created the &quot;CCNx Validation Algorithm Types&quot; registry and <lb/>allocated the validation algorithm types described below. The <lb/>registration procedure is Specification Required. The Type value is <lb/>2 octets. The range is 0x0000-0xFFFF. <lb/>+---------------+-----------------+---------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+---------------+-----------------+---------------------------------+ <lb/>| <lb/>0x0000 <lb/>| <lb/>Reserved <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0002 <lb/>| <lb/>T_CRC32C <lb/>| Validation Algorithm (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0004 <lb/>| T_HMAC-SHA256 | Validation Algorithm (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0005 <lb/>| <lb/>T_RSA-SHA256 | Validation Algorithm (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0006 <lb/>| T_EC-SECP-256K1 | Validation Algorithm (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0007 <lb/>| T_EC-SECP-384R1 | Validation Algorithm (Section | <lb/>| <lb/>| <lb/>| <lb/>3.6.4.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFE <lb/>| <lb/>T_PAD <lb/>| <lb/>Pad (Section 3.3.1) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| <lb/>Organization-Specific TLVs <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x1000-0x1FFF | <lb/>Reserved <lb/>| <lb/>Experimental Use (Section 3) | <lb/>+---------------+-----------------+---------------------------------+ <lb/>CCNx Validation Algorithm Types <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 39] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>4.9. Validation-Dependent Data Type Registry <lb/>IANA has created the &quot;CCNx Validation-Dependent Data Types&quot; registry <lb/>and allocated the validation-dependent data types described below. <lb/>The registration procedure is RFC Required. The Type value is 2 <lb/>octets. The range is 0x0000-0xFFFF. <lb/>+---------------+----------------+----------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+---------------+----------------+----------------------------------+ <lb/>| <lb/>0x0000 <lb/>| <lb/>Reserved <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0009 <lb/>| <lb/>T_KEYID <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000A <lb/>| T_PUBLICKEYLOC | <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000B <lb/>| T_PUBLICKEY <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000C <lb/>| <lb/>T_CERT <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000D <lb/>| <lb/>T_LINK <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000E <lb/>| <lb/>T_KEYLINK <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x000F <lb/>| <lb/>T_SIGTIME <lb/>| <lb/>Validation-Dependent Data <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.6.4.1.4) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| <lb/>Organization-Specific TLVs <lb/>| <lb/>| <lb/>| <lb/>| <lb/>(Section 3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x1000-0x1FFF | <lb/>Reserved <lb/>| <lb/>Experimental Use (Section 3) <lb/>| <lb/>+---------------+----------------+----------------------------------+ <lb/>CCNx Validation-Dependent Data Types <lb/>4.10. Hash Function Type Registry <lb/>IANA has created the &quot;CCNx Hash Function Types&quot; registry and <lb/>allocated the hash function types described below. The registration <lb/>procedure is Specification Required. The Type value is 2 octets. <lb/>The range is 0x0000-0xFFFF. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 40] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>+---------------+-----------+---------------------------------------+ <lb/>| <lb/>Type <lb/>| <lb/>Name <lb/>| <lb/>Reference <lb/>| <lb/>+---------------+-----------+---------------------------------------+ <lb/>| <lb/>0x0000 <lb/>| Reserved | <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0001 <lb/>| T_SHA-256 | <lb/>Hash Format (Section 3.3.3) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0002 <lb/>| T_SHA-512 | <lb/>Hash Format (Section 3.3.3) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>0x0FFF <lb/>| <lb/>T_ORG <lb/>| Organization-Specific TLVs (Section | <lb/>| <lb/>| <lb/>| <lb/>3.3.2) <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| 0x1000-0x1FFF | Reserved | <lb/>Experimental Use (Section 3) <lb/>| <lb/>+---------------+-----------+---------------------------------------+ <lb/>CCNx Hash Function Types <lb/>5. Security Considerations <lb/>The CCNx protocol is a Layer 3 network protocol, which may also <lb/>operate as an overlay using other transports such as UDP or other <lb/>tunnels. It includes intrinsic support for message authentication <lb/>via a signature (e.g., RSA or elliptic curve) or Message <lb/>Authentication Code (e.g., HMAC). In lieu of an authenticator, it <lb/>may instead use a Message Integrity Check (e.g., SHA or CRC). CCNx <lb/>does not specify an encryption envelope; that function is left to a <lb/>high-layer protocol (e.g., Encrypted Sessions in CCNx [esic]). <lb/>The CCNx Packet format includes the ability to attach MICs (e.g., <lb/>SHA-256 or CRC), MACs (e.g., HMAC), and Signatures (e.g., RSA or <lb/>ECDSA) to all packet types. Because Interest packets can be sent at <lb/>will, an application should carefully select when to use a given <lb/>ValidationAlgorithm in an Interest to avoid DoS attacks. MICs, for <lb/>example, are inexpensive and could be used as desired, whereas MACs <lb/>and Signatures are more expensive and their inappropriate use could <lb/>open a computational DoS attack surface. Applications should use an <lb/>explicit protocol to guide their use of packet signatures. As a <lb/>general guideline, an application might use a MIC on an Interest to <lb/>detect unintentionally corrupted packets. If one wishes to secure an <lb/>Interest, one should consider using an encrypted wrapper and a <lb/>protocol that prevents replay attacks, especially if the Interest is <lb/>being used as an actuator. Simply using an authentication code or <lb/>signature does not make an Interest secure. There are several <lb/>examples in the literature on how to secure ICN-style messaging <lb/>[mobile] [ace]. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 41] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>As a Layer 3 protocol, this document does not describe how one <lb/>arrives at keys or how one trusts keys. The CCNx content object may <lb/>include a public key embedded in the object or may use the <lb/>PublicKeyLocator field to point to a public key (or public-key <lb/>certificate) that authenticates the message. One key exchange <lb/>specification is CCNxKE [ccnxke] [mobile], which is similar to the <lb/>TLS 1.3 key exchange except it is over the CCNx Layer 3 messages. <lb/>Trust is beyond the scope of a Layer 3 protocol and is left to <lb/>applications or application frameworks. <lb/>The combination of an ephemeral key exchange (e.g., CCNxKE [ccnxke]) <lb/>and an encapsulating encryption (e.g., [esic]) provides the <lb/>equivalent of a TLS tunnel. Intermediate nodes may forward the <lb/>Interests and Content Objects but have no visibility inside. It also <lb/>completely hides the internal names in those used by the encryption <lb/>layer. This type of tunneling encryption is useful for content that <lb/>has little or no cacheability, as it can only be used by someone with <lb/>the ephemeral key. Short-term caching may help with lossy links or <lb/>mobility, but long-term caching is usually not of interest. <lb/>Broadcast encryption or proxy re-encryption may be useful for content <lb/>with multiple uses over time or many consumers. There is currently <lb/>no recommendation for this form of encryption. <lb/>The specific encoding of messages will have security implications. <lb/>This document uses a Type-Length-Value (TLV) encoding. We chose to <lb/>compromise between extensibility and unambiguous encodings of types <lb/>and lengths. Some TLV encodings use variable-length T and variable-<lb/>length L fields to accommodate a wide gamut of values while trying to <lb/>be byte efficient. Our TLV encoding uses a fixed length 2-byte T and <lb/>2-byte L. Using fixed-length T and L fields solves two problems. <lb/>The first is aliases. If one is able to encode the same value, such <lb/>as 0x02 and 0x0002, in different byte lengths, then one must decide <lb/>if they mean the same thing, if they are different, or if one is <lb/>illegal. If they are different, then one must always compare on the <lb/>buffers not the integer equivalents. If one is illegal, then one <lb/>must validate the TLV encoding --every field of every packet at <lb/>every hop. If they are the same, then one has the second problem: <lb/>how to specify packet filters. For example, if a name has 6 name <lb/>components, then there are 7 T fields and 7 L fields, each of which <lb/>might have up to 4 representations of the same value. That would be <lb/>14 fields with 4 encodings each, or 1001 combinations. It also means <lb/>that one cannot compare, for example, a name via a memory function, <lb/>as one needs to consider that any embedded T or L might have a <lb/>different format. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 42] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>The Interest Return message has no authenticator from the previous <lb/>hop. Therefore, the payload of the Interest Return should only be <lb/>used locally to match an Interest. A node should never forward that <lb/>Interest payload as an Interest. It should also verify that it sent <lb/>the Interest in the Interest Return to that node and not allow anyone <lb/>to negate Interest messages. <lb/>Caching nodes must take caution when processing content objects. It <lb/>is essential that the Content Store obey the rules outlined in <lb/>[RFC8569] to avoid certain types of attacks. CCNx 1.0 has no <lb/>mechanism to work around an undesired result from the network (there <lb/>are no &quot;excludes&quot;), so if a cache becomes poisoned with bad content <lb/>it might cause problems retrieving content. There are three types of <lb/>access to content from a Content Store: unrestricted, signature <lb/>restricted, and hash restricted. If an Interest has no restrictions, <lb/>then the requester is not particular about what they get back, so any <lb/>matching cached object is OK. In the hash restricted case, the <lb/>requester is very specific about what they want, and the Content <lb/>Store (and every forward hop) can easily verify that the content <lb/>matches the request. In the signature restricted case (which is <lb/>often used for initial manifest discovery), the requester only knows <lb/>the KeyId that signed the content. This case requires the closest <lb/>attention in the Content Store to avoid amplifying bad data. The <lb/>Content Store must only respond with a content object if it can <lb/>verify the signature --this means either the content object carries <lb/>the public key inside it or the Interest carries the public key in <lb/>addition to the KeyId. If that is not the case, then the Content <lb/>Store should treat the Interest as a cache miss and let an endpoint <lb/>respond. <lb/>A user-level cache could perform full signature verification by <lb/>fetching a public key according to the PublicKeyLocator. However, <lb/>that is not a burden we wish to impose on the forwarder. A user-<lb/>level cache could also rely on out-of-band attestation, such as the <lb/>cache operator only inserting content that it knows has the correct <lb/>signature. <lb/>The CCNx grammar allows for hash algorithm agility via the HashType. <lb/>It specifies a short list of acceptable hash algorithms that should <lb/>be implemented at each forwarder. Some hash values only apply to end <lb/>systems, so updating the hash algorithm does not affect forwarders --<lb/>they would simply match the buffer that includes the type-length-hash <lb/>buffer. Some fields, such as the ConObjHash, must be verified at <lb/>each hop, so a forwarder (or related system) must know the hash <lb/>algorithm, and it could cause backward compatibility problems if the <lb/>hash type is updated. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 43] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<body>A CCNx name uses binary matching, whereas a URI uses a case-<lb/>insensitive hostname. Some systems may also use case-insensitive <lb/>matching of the URI path to a resource. An implication of this is <lb/>that human-entered CCNx names will likely have case or non-ASCII <lb/>symbol mismatches unless one uses a consistent URI normalization for <lb/>the CCNx name. It also means that an entity that registers a CCNx-<lb/>routable prefix --say, &quot;ccnx:/example.com&quot; --would need separate <lb/>registrations for simple variations like &quot;ccnx:/Example.com&quot;. Unless <lb/>this is addressed in URI normalization and routing protocol <lb/>conventions, there could be phishing attacks. <lb/>For a more general introduction to ICN-related security concerns and <lb/>approaches, see [RFC7927] and [RFC7945]. <lb/></body>

			<listBibl>6. References <lb/>6.1. Normative References <lb/>[RFC2119] Bradner, S., &quot;Key words for use in RFCs to Indicate <lb/>Requirement Levels&quot;, BCP 14, RFC 2119, <lb/>DOI 10.17487/RFC2119, March 1997, <lb/>&lt;https://www.rfc-editor.org/info/rfc2119&gt;. <lb/>[RFC8174] Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in RFC <lb/>2119 Key Words&quot;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, <lb/>May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;. <lb/>6.2. Informative References <lb/>[ace] <lb/>Shang, W., Yu, Y., Liang, T., Zhang, B., and L. Zhang, <lb/>&quot;NDN-ACE: Access control for constrained environments over <lb/>named data networking&quot;, NDN Technical Report NDN-0036, <lb/>2015, &lt;http://new.named-data.net/wp-content/uploads/2015/ <lb/>12/ndn-0036-1-ndn-ace.pdf&gt;. <lb/>[ccnxke] <lb/>Mosko, M., Uzun, E., and C. Wood, &quot;CCNx Key Exchange <lb/>Protocol Version 1.0&quot;, Work in Progress, draft-wood-icnrg-<lb/>ccnxkeyexchange-02, March 2017. <lb/>[CCNxURI] Mosko, M. and C. Wood, &quot;The CCNx URI Scheme&quot;, Work in <lb/>Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016. <lb/>[CCNxz] <lb/>Mosko, M., &quot;CCNxz TLV Header Compression Experimental <lb/>Code&quot;, commit f1093a2, March 2018, <lb/>&lt;https://github.com/PARC/CCNxz&gt;. <lb/></listBibl>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 44] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<listBibl>[compress] Mosko, M., &quot;Header Compression for TLV-based Packets&quot;, <lb/>ICNRG Interim Meeting, 2016, <lb/>&lt;https://datatracker.ietf.org/meeting/interim-2016-icnrg-<lb/>02/materials/slides-interim-2016-icnrg-2-7&gt;. <lb/>[ECC] <lb/>Certicom Research, &quot;SEC 2: Recommended Elliptic Curve <lb/>Domain Parameters&quot;, 2010, <lb/>&lt;http://www.secg.org/sec2-v2.pdf&gt;. <lb/>[esic] <lb/>Mosko, M. and C. Wood, &quot;Encrypted Sessions In CCNx <lb/>(ESIC)&quot;, Work in Progress, draft-wood-icnrg-esic-01, <lb/>September 2017. <lb/>[IANA-PEN] IANA, &quot;Private Enterprise Numbers&quot;, <lb/>&lt;http://www.iana.org/assignments/enterprise-numbers&gt;. <lb/>[mobile] <lb/>Mosko, M., Uzun, E., and C. Wood, &quot;Mobile Sessions in <lb/>Content-Centric Networks&quot;, IFIP Networking, 2017, <lb/>&lt;http://dl.ifip.org/db/conf/networking/ <lb/>networking2017/1570334964.pdf&gt;. <lb/>[nnc] <lb/>Jacobson, V., Smetters, D., Thornton, J., Plass, M., <lb/>Briggs, N., and R. Braynard, &quot;Networking Named Content&quot;, <lb/>Proceedings of the 5th international conference on <lb/>Emerging networking experiments and technologies (CoNEXT <lb/>&apos;09), 2009, &lt;http://dx.doi.org/10.1145/1658939.1658941&gt;. <lb/>[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., <lb/>Housley, R., and W. Polk, &quot;Internet X.509 Public Key <lb/>Infrastructure Certificate and Certificate Revocation List <lb/>(CRL) Profile&quot;, RFC 5280, DOI 10.17487/RFC5280, May 2008, <lb/>&lt;https://www.rfc-editor.org/info/rfc5280&gt;. <lb/>[RFC7927] Kutscher, D., Ed., Eum, S., Pentikousis, K., Psaras, I., <lb/>Corujo, D., Saucez, D., Schmidt, T., and M. Waehlisch, <lb/>&quot;Information-Centric Networking (ICN) Research <lb/>Challenges&quot;, RFC 7927, DOI 10.17487/RFC7927, July 2016, <lb/>&lt;https://www.rfc-editor.org/info/rfc7927&gt;. <lb/>[RFC7945] Pentikousis, K., Ed., Ohlman, B., Davies, E., Spirou, S., <lb/>and G. Boggia, &quot;Information-Centric Networking: Evaluation <lb/>and Security Considerations&quot;, RFC 7945, <lb/>DOI 10.17487/RFC7945, September 2016, <lb/>&lt;https://www.rfc-editor.org/info/rfc7945&gt;. <lb/></listBibl>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 45] <lb/></page>

			<note place="headnote">RFC 8609 <lb/>CCNx TLV <lb/>July 2019 <lb/></note>

			<listBibl>[RFC8126] Cotton, M., Leiba, B., and T. Narten, &quot;Guidelines for <lb/>Writing an IANA Considerations Section in RFCs&quot;, BCP 26, <lb/>RFC 8126, DOI 10.17487/RFC8126, June 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8126&gt;. <lb/>[RFC8569] Mosko, M., Solis, I., and C. Wood, &quot;Content-Centric <lb/>Networking (CCNx) Semantics&quot;, RFC 8569, <lb/>DOI 10.17487/RFC8569, July 2019, <lb/>&lt;https://www.rfc-editor.org/info/rfc8569&gt;. <lb/></listBibl>

			Authors&apos; Addresses <lb/>		

			<front>Marc Mosko <lb/>PARC, Inc. <lb/>Palo Alto, California 94304 <lb/>United States of America <lb/>Phone: +01 650-812-4405 <lb/>Email: mmosko@parc.com <lb/>Ignacio Solis <lb/>LinkedIn <lb/>Mountain View, California 94043 <lb/>United States of America <lb/>Email: nsolis@linkedin.com <lb/>Christopher A. Wood <lb/>University of California, Irvine <lb/>Irvine, California 92697 <lb/>United States of America <lb/>Phone: +01 315-806-5939 <lb/>Email: woodc1@uci.edu <lb/></front>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 46] </page>


	</text>
</tei>
