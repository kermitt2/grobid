<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>server date 20190806; downloaded by EPO on 20190807 <lb/>Network Working Group <lb/>U. Carion <lb/>Internet-Draft <lb/>August 05, 2019 <lb/>Intended status: Informational <lb/>Expires: February 6, 2020 <lb/>JSON Schema Language <lb/>draft-ucarion-json-schema-language-00 <lb/>Abstract <lb/>JSON Schema Language (JSL) is a portable method for describing the <lb/>format of JavaScript Object Notation (JSON) data and the errors <lb/>associated with ill-formed data. JSL is designed to enable code <lb/>generation from schemas. <lb/>Status of This Memo <lb/>This Internet-Draft is submitted in full conformance with the <lb/>provisions of BCP 78 and BCP 79. <lb/>Internet-Drafts are working documents of the Internet Engineering <lb/>Task Force (IETF). Note that other groups may also distribute <lb/>working documents as Internet-Drafts. The list of current Internet-<lb/>Drafts is at https://datatracker.ietf.org/drafts/current/. <lb/>Internet-Drafts are draft documents valid for a maximum of six months <lb/>and may be updated, replaced, or obsoleted by other documents at any <lb/>time. It is inappropriate to use Internet-Drafts as reference <lb/>material or to cite them other than as &quot;work in progress.&quot; <lb/>This Internet-Draft will expire on February 6, 2020. <lb/>Copyright Notice <lb/>Copyright (c) 2019 IETF Trust and the persons identified as the <lb/>document authors. All rights reserved. <lb/>This document is subject to BCP 78 and the IETF Trust&apos;s Legal <lb/>Provisions Relating to IETF Documents <lb/>(https://trustee.ietf.org/license-info) in effect on the date of <lb/>publication of this document. Please review these documents <lb/>carefully, as they describe your rights and restrictions with respect <lb/>to this document. Code Components extracted from this document must <lb/>include Simplified BSD License text as described in Section 4.e of <lb/>the Trust Legal Provisions and are provided without warranty as <lb/>described in the Simplified BSD License. <lb/></front>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 1] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<div type="toc">Table of Contents <lb/>1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . <lb/>2 <lb/>1.1. Terminology . . . . . . . . . . . . . . . . . . . . . . . <lb/>3 <lb/>2. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>3 <lb/>3. Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.1. Strict instance semantics . . . . . . . . . . . . . . . . <lb/>9 <lb/>3.2. Errors . . . . . . . . . . . . . . . . . . . . . . . . . 10 <lb/>3.3. Forms . . . . . . . . . . . . . . . . . . . . . . . . . . 10 <lb/>3.3.1. Empty . . . . . . . . . . . . . . . . . . . . . . . . 11 <lb/>3.3.2. Ref . . . . . . . . . . . . . . . . . . . . . . . . . 11 <lb/>3.3.3. Type . . . . . . . . . . . . . . . . . . . . . . . . 12 <lb/>3.3.4. Enum . . . . . . . . . . . . . . . . . . . . . . . . 15 <lb/>3.3.5. Elements . . . . . . . . . . . . . . . . . . . . . . 15 <lb/>3.3.6. Properties . . . . . . . . . . . . . . . . . . . . . 16 <lb/>3.3.7. Values . . . . . . . . . . . . . . . . . . . . . . . 18 <lb/>3.3.8. Discriminator . . . . . . . . . . . . . . . . . . . . 19 <lb/>4. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 22 <lb/>5. Security Considerations . . . . . . . . . . . . . . . . . . . 23 <lb/>6. Normative References . . . . . . . . . . . . . . . . . . . . 23 <lb/>Appendix A. Comparison with CDDL . . . . . . . . . . . . . . . . 23 <lb/>Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . 26 <lb/>Author&apos;s Address . . . . . . . . . . . . . . . . . . . . . . . . 26 <lb/></div>

			<body>1. Introduction <lb/>This document describes a schema language for JSON [RFC8259] called <lb/>JSON Schema Language (JSL). <lb/>The goals of JSL are to: <lb/>o Provide an unambiguous description of the overall structure of a <lb/>JSON document. <lb/>o Be able to describe common JSON datatypes and structures. <lb/>o Provide a single format that is readable and editable by both <lb/>humans and machines, and which can be embedded within other JSON <lb/>documents. <lb/>o Enable code generation from schemas. <lb/>o Provide a standardized format for errors when data does not <lb/>conform with a schema. <lb/>JSL is intentionally designed as a rather minimal schema language. <lb/>For example, JSL is homoiconic (it both describes, and is written in, <lb/>JSON) yet is incapable of describing in detail its own structure. By <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 2] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>keeping the expressiveness of the schema language minimal, JSL makes <lb/>code generation and standardized errors easier to implement. <lb/>It is expected that for many use-cases, a schema language of JSL&apos;s <lb/>expressiveness is sufficient. Where a more expressive language is <lb/>required, alternatives exist in CDDL ([RFC8610], Concise Data <lb/>Definition Language) and others. <lb/>This document has the following structure: <lb/>The syntax of JSL is defined in Section 2. Section 3 describes the <lb/>semantics of JSL; this includes determining whether some data <lb/>satisfies a schema and what errors should be produced when the data <lb/>is unsatisfactory. Appendix A presents various JSL schemas and their <lb/>CDDL equivalents. <lb/>1.1. Terminology <lb/>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, <lb/>&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and <lb/>&quot;OPTIONAL&quot; in this document are to be interpreted as described in <lb/>BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all <lb/>capitals, as shown here. These words may also appear in this <lb/>document in lower case as plain English words, absent their normative <lb/>meanings. <lb/>The term &quot;JSON Pointer&quot;, when it appears in this document, is to be <lb/>understood as it is defined in [RFC6901]. <lb/>The terms &quot;object&quot;, &quot;member&quot;, &quot;array&quot;, &quot;number&quot;, &quot;name&quot;, and &quot;string&quot; <lb/>in this document are to be interpreted as described in [RFC8259]. <lb/>The term &quot;instance&quot;, when it appears in this document, refers to a <lb/>JSON value being validated against a JSL schema. <lb/>2. Syntax <lb/>This section describes when a JSON document is a correct JSL schema. <lb/>JSL schemas may recursively contain other schemas. In this document, <lb/>a &quot;root schema&quot; is one which is not contained within another schema, <lb/>i.e. it is &quot;top level&quot;. <lb/>A correct JSL schema MUST match the &quot;schema&quot; CDDL rule described in <lb/>this section. A JSL schema is a JSON object taking on an appropriate <lb/>form. It may optionally contain definitions (a mapping from names to <lb/>schemas) and additional data. <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 3] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>schema = { <lb/>form, <lb/>? definitions: { * tstr =&gt; schema } <lb/>} <lb/>Figure 1: CDDL Definition of a Schema <lb/>This is not a correct JSL schema, as its &quot;definitions&quot; object <lb/>contains a number, which is not a schema: <lb/>{ &quot;definitions&quot;: { &quot;foo&quot;: 3 }} <lb/>JSL schemas can take on one of eight forms. These forms are defined <lb/>so as to be mutually exclusive; a schema cannot satisfy multiple <lb/>forms at once. <lb/>form = empty / <lb/>ref / <lb/>type / <lb/>enum / <lb/>elements / <lb/>properties / <lb/>values / <lb/>discriminator <lb/>Figure 2: CDDL Definition of the Schema Forms <lb/>The first form, &quot;empty&quot;, is trivial. It is meant for matching any <lb/>instance: <lb/>empty = {} <lb/>Figure 3: CDDL Definition of the Empty Form <lb/>Thus, this is a correct schema: <lb/>{} <lb/>The second form, &quot;ref&quot;, is for when a schema is meant to be defined <lb/>in terms of something in &quot;definitions&quot;: <lb/>ref = { ref: tstr } <lb/>Figure 4: CDDL Definition of the Ref Form <lb/>For a schema to be correct, the &quot;ref&quot; value must refer to one of the <lb/>definitions found at the root level of the schema it appears in. <lb/>More formally, for a schema _S_ of the &quot;ref&quot; form: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 4] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>o Let _B_ be the root schema containing the schema, or the schema <lb/>itself if it is a root schema. <lb/>o Let _R_ be the value of the member of _S_ with the name &quot;ref&quot;. <lb/>If the schema is correct, then _B_ must have a member _D_ with the <lb/>name &quot;definitions&quot;, and _D_ must contain a member whose name equals <lb/>_R_. <lb/>Here is a correct example of &quot;ref&quot; being used to avoid re-defining <lb/>the same thing twice: <lb/>{ <lb/>&quot;definitions&quot;: { <lb/>&quot;coordinates&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;lat&quot;: { &quot;type&quot;: &quot;number&quot; }, <lb/>&quot;lng&quot;: { &quot;type&quot;: &quot;number&quot; } <lb/>} <lb/>} <lb/>}, <lb/>&quot;properties&quot;: { <lb/>&quot;user_location&quot;: { &quot;ref&quot;: &quot;coordinates&quot; }, <lb/>&quot;server_location&quot;: { &quot;ref&quot;: &quot;coordinates&quot; } <lb/>} <lb/>} <lb/>However, this schema is incorrect, as it refers to a definition that <lb/>doesn&apos;t exist: <lb/>{ <lb/>&quot;definitions&quot;: { &quot;foo&quot;: { &quot;type&quot;: &quot;number&quot; }}, <lb/>&quot;ref&quot;: &quot;bar&quot; <lb/>} <lb/>This schema is incorrect as well, as it refers to a definition that <lb/>doesn&apos;t exist at the root level. The non-root definition is <lb/>immaterial: <lb/>{ <lb/>&quot;definitions&quot;: { &quot;foo&quot;: { &quot;type&quot;: &quot;number&quot; }}, <lb/>&quot;elements&quot;: { <lb/>&quot;definitions&quot;: { &quot;bar&quot;: { &quot;type&quot;: &quot;number&quot; }}, <lb/>&quot;ref&quot;: &quot;bar&quot; <lb/>} <lb/>} <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 5] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>The third form, &quot;type&quot;, constrains instances to have a particular <lb/>primitive type. The precise meaning of each of the primitive types <lb/>is described in Section 3. <lb/>type = { type: &quot;boolean&quot; / num-type / &quot;string&quot; / &quot;timestamp&quot; } <lb/>num-type = &quot;number&quot; / &quot;float32&quot; / &quot;float64&quot; / <lb/>&quot;int8&quot; / &quot;uint8&quot; / &quot;int16&quot; / &quot;uint16&quot; / &quot;int32&quot; / &quot;uint32&quot; <lb/>Figure 5: CDDL Definition of the Type Form <lb/>For example, this schema constrains instances to be strings that are <lb/>correct [RFC3339] timestamps: <lb/>{ &quot;type&quot;: &quot;timestamp&quot; } <lb/>The fourth form, &quot;enum&quot;, describes instances whose value must be one <lb/>of a finite, predetermined set of values: <lb/>enum = { enum: [+ tstr] } <lb/>Figure 6: CDDL Definition of the Enum Form <lb/>The values within &quot;[+ tstr]&quot; MUST NOT contain duplicates. Thus, the <lb/>following is a correct schema: <lb/>{ &quot;enum&quot;: [&quot;IN_PROGRESS&quot;, &quot;DONE&quot;, &quot;CANCELED&quot;] } <lb/>But this is not a correct schema, as &quot;B&quot; is duplicated: <lb/>{ &quot;enum&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;B&quot;] } <lb/>The fifth form, &quot;elements&quot;, describes instances that must be arrays. <lb/>A further sub-schema describes the elements of the array. <lb/>elements = { elements: schema } <lb/>Figure 7: CDDL Definition of the Elements Form <lb/>Here is a schema describing an array of [RFC3339] timestamps: <lb/>{ &quot;elements&quot;: { &quot;type&quot;: &quot;timestamp&quot; }} <lb/>The sixth form, &quot;properties&quot;, describes JSON objects being used as a <lb/>&quot;struct&quot;. A schema of this form specifies the names of required and <lb/>optional properties, as well as the schemas each of those properties <lb/>must satisfy: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 6] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>; One of properties or optionalProperties may be omitted, <lb/>; but not both. <lb/>properties = with-properties / with-optional-properties <lb/>with-properties = { <lb/>properties: * tstr =&gt; schema, <lb/>? optionalProperties * tstr =&gt; schema <lb/>} <lb/>with-optional-properties = { <lb/>? properties: * tstr =&gt; schema, <lb/>optionalProperties: * tstr =&gt; schema <lb/>} <lb/>Figure 8: CDDL Definition of the Properties Form <lb/>If a schema has both a member named &quot;properties&quot; (with value _P_) and <lb/>another member named &quot;optionalProperties&quot; (with value _O_), then _O_ <lb/>and _P_ MUST NOT have any member names in common. This is to prevent <lb/>ambiguity as to whether a property is optional or required. <lb/>Thus, this is not a correct schema, as &quot;confusing&quot; appears in both <lb/>&quot;properties&quot; and &quot;optionalProperties&quot;: <lb/>{ <lb/>&quot;properties&quot;: { &quot;confusing&quot;: {} }, <lb/>&quot;optionalProperties&quot;: { &quot;confusing&quot;: {} } <lb/>} <lb/>Here is a correct schema, describing a paginated list of users: <lb/>{ <lb/>&quot;properties&quot;: { <lb/>&quot;users&quot;: { <lb/>&quot;elements&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;id&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;name&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;create_time&quot;: { &quot;type&quot;: &quot;timestamp&quot; } <lb/>}, <lb/>&quot;optionalProperties&quot;: { <lb/>&quot;delete_time&quot;: { &quot;type&quot;: &quot;timestamp&quot; } <lb/>} <lb/>} <lb/>}, <lb/>&quot;next_page_token&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>} <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 7] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>The seventh form, &quot;values&quot;, describes JSON objects being used as an <lb/>associative array. A schema of this form specifies the form all <lb/>member values must satisfy, but places no constraints on the member <lb/>names: <lb/>values = { values: * tstr =&gt; schema } <lb/>Figure 9: CDDL Definition of the Values Form <lb/>Thus, this is a correct schema, describing a mapping from strings to <lb/>numbers: <lb/>{ &quot;values&quot;: { &quot;type&quot;: &quot;number&quot; }} <lb/>Finally, the eighth form, &quot;discriminator&quot;, describes JSON objects <lb/>being used as a discriminated union. A schema of this form specifies <lb/>the &quot;tag&quot; (or &quot;discriminator&quot;) of the union, as well as a mapping <lb/>from tag values to the appropriate schema to use. <lb/>; Note well: the values of mapping are of the properties form. <lb/>discriminator = { tag: tstr, mapping: * tstr =&gt; properties } <lb/>Figure 10: CDDL Definition of the Discriminator Form <lb/>To prevent ambiguous or unsatisfiable contstraints on the &quot;tag&quot; of a <lb/>discriminator, an additional constraint on schemas of the <lb/>discriminator form exists. For schemas of the discriminator form: <lb/>o Let _D_ be the schema member with the name &quot;discriminator&quot;. <lb/>o Let _T_ be the member of _D_ with the name &quot;tag&quot;. <lb/>o Let _M_ be the member of _D_ with the name &quot;mapping&quot;. <lb/>If the schema is correct, then all member values _S_ of _M_ will be <lb/>schemas of the &quot;properties&quot; form. For each member _P_ of _S_ whose <lb/>name equals &quot;properties&quot; or &quot;optionalProperties&quot;, _P_&apos;s value, which <lb/>must be an object, MUST NOT contain any members whose name equals <lb/>_T_&apos;s value. <lb/>Thus, this is an incorrect schema, as &quot;event_type&quot; is both the value <lb/>of &quot;tag&quot; and a member name in one of the &quot;mapping&quot; member <lb/>&quot;properties&quot;: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 8] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>{ <lb/>&quot;tag&quot;: &quot;event_type&quot;, <lb/>&quot;mapping&quot;: { <lb/>&quot;is_event_type_a_string_or_a_number?&quot;: { <lb/>&quot;properties&quot;: { &quot;event_type&quot;: { &quot;type&quot;: &quot;number&quot; }} <lb/>} <lb/>} <lb/>} <lb/>However, this is a correct schema, describing a pattern of data <lb/>common in JSON-based messaging systems: <lb/>{ <lb/>&quot;tag&quot;: &quot;event_type&quot;, <lb/>&quot;mapping&quot;: { <lb/>&quot;account_deleted&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;account_id&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>}, <lb/>&quot;account_payment_plan_changed&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;account_id&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;payment_plan&quot;: { &quot;enum&quot;: [&quot;FREE&quot;, &quot;PAID&quot;] } <lb/>}, <lb/>&quot;optionalProperties&quot;: { <lb/>&quot;upgraded_by&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>} <lb/>} <lb/>} <lb/>3. Semantics <lb/>This section describes when an instance is valid against a correct <lb/>JSL schema, and the standardized errors to produce when an instance <lb/>is invalid. <lb/>3.1. Strict instance semantics <lb/>Users will have different desired behavior with respect to <lb/>&quot;unspcecified&quot; members in an instance. For example: <lb/>{ &quot;properties&quot;: { &quot;a&quot;: { &quot;type&quot;: &quot;string&quot; }}} <lb/>Some users may expect that {&quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;} satisfies the <lb/>above schema. Others may disagree. JSL addresses this point of <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 9] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>contention by leaving it to implementations whether to accept such <lb/>&quot;unspecified&quot; members, or whether to reject them. <lb/>Rejecting &quot;unspecified&quot; members is called &quot;strict instance <lb/>semantics&quot;. Whether to use strict instance semantics is not <lb/>specified within a schema -it is considered out-of-band information. <lb/>Implementations MAY allow users to choose whether to use strict <lb/>instance semantics. Implementations SHOULD document whether they use <lb/>strict instance semantics by default. <lb/>See Section 3.3.6 for how strict instance semantics affects schema <lb/>evaluation. <lb/>3.2. Errors <lb/>To facilitate consistent validation error handling, this document <lb/>specifies a standard error format. Implementations SHOULD support <lb/>producing errors in this standard form. <lb/>The standard error format is a JSON array. The order of the elements <lb/>of this array is not specified. The elements of this array are JSON <lb/>objects with two members: <lb/>o A member with the name &quot;instancePath&quot;, whose value is a JSON <lb/>string encoding a JSON Pointer. This JSON Pointer will point to <lb/>the part of the instance that was rejected. <lb/>o A member with the name &quot;schemaPath&quot;, whose value is a JSON string <lb/>encoding a JSON Pointer. This JSON Pointer will point to the part <lb/>of the schema that rejected the instance. <lb/>The values for &quot;instancePath&quot; and &quot;schemaPath&quot; depend on the form of <lb/>the schema, and are described in detail in Section 3.3. <lb/>3.3. Forms <lb/>This section describes, for each of the eight JSL schema forms, the <lb/>rules dictating whether an instance is accepted, as well as the <lb/>standardized errors to produce when an instance is invalid. <lb/>The forms a correct schema may take on are formally described in <lb/>Section 2. <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 10] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>3.3.1. Empty <lb/>The empty form is meant to describe instances whose values are <lb/>unknown, unpredictable, or otherwise unconstrained by the schema. <lb/>If a schema is of the empty form, then it accepts all instances. A <lb/>schema of the empty form will never produce any errors. <lb/>3.3.2. Ref <lb/>The ref form is for when a schema is meant to be defined in terms of <lb/>something in the &quot;definitions&quot; of the root schema. The ref form <lb/>enables schemas to be less repetitive, and also enables describing <lb/>recursive structures. <lb/>If a schema is of the ref form, then: <lb/>o Let _B_ be the root schema containing the schema, or the schema <lb/>itself if it is a root schema. <lb/>o Let _D_ be the member of _B_ with the name &quot;definitions&quot;. By <lb/>Section 2, _D_ exists. <lb/>o Let _R_ be the value of the schema member with the name &quot;ref&quot;. <lb/>o Let _S_ be the value of the member of _D_ whose name equals _R_. <lb/>By Section 2, _S_ exists, and is a schema. <lb/>The schema accepts the instance if and only if _S_ accepts the <lb/>instance. Otherwise, the standard errors to return in this case are <lb/>the union of the errors from evaluating _S_ against the instance. <lb/>For example, the schema: <lb/>{ <lb/>&quot;definitions&quot;: { &quot;a&quot;: { &quot;type&quot;: &quot;number&quot; }}, <lb/>&quot;ref&quot;: &quot;a&quot; <lb/>} <lb/>Accepts 123 but not false. The standard errors to produce when <lb/>evaluting false against this schema are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/definitions/a/type&quot; }] <lb/>Note that the ref form is defined to only look up definitions at the <lb/>root level. Thus, with the schema: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 11] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>{ <lb/>&quot;definitions&quot;: { &quot;a&quot;: { &quot;type&quot;: &quot;number&quot; }}, <lb/>&quot;elements&quot;: { <lb/>&quot;definitions&quot;: { &quot;a&quot;: { &quot;type&quot;: &quot;boolean&quot; }}, <lb/>&quot;ref&quot;: &quot;foo&quot; <lb/>} <lb/>} <lb/>The instance 123 is accepted, and false is rejected. The standard <lb/>errors to produce when evaluating false against this schema are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/definitions/a/type&quot; }] <lb/>Though non-root definitions are not syntactically disallowed in <lb/>correct schemas, they are entirely immaterial to evaluating <lb/>references. <lb/>3.3.3. Type <lb/>The type form is meant to describe instances whose value is a <lb/>boolean, number, string, or timestamp ([RFC3339]). <lb/>If a schema is of the type form, then let _T_ be the value of the <lb/>member with the name &quot;type&quot;. The following table describes whether <lb/>the instance is accepted, as a function of _T_&apos;s value: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 12] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>+-------------------+----------------------------------------------+ <lb/>| If _T_ equals ... | then the instance is accepted if it is ... <lb/>| <lb/>+-------------------+----------------------------------------------+ <lb/>| boolean <lb/>| equal to &quot;true&quot; or &quot;false&quot; <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| number <lb/>| a JSON number <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| float32 <lb/>| a JSON number <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| float64 <lb/>| a JSON number <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| int8 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint8 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| int16 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint16 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| int32 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint32 <lb/>| See Table 2 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| string <lb/>| a JSON string <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| timestamp <lb/>| a JSON string encoding a [RFC3339] timestamp | <lb/>+-------------------+----------------------------------------------+ <lb/>Table 1: Accepted Values for Type <lb/>&quot;float32&quot; and &quot;float64&quot; are distinguished from &quot;number&quot; in their <lb/>intent. &quot;float32&quot; indicates data intended to be processed as an IEEE <lb/>754 single-precision float, whereas &quot;float64&quot; indicates data intended <lb/>to be processed as an IEEE 754 double-precision float. &quot;number&quot; <lb/>indicates no specific intent. Tools which generate code from JSL <lb/>schemas will likely produce different code for &quot;float32&quot;, &quot;float64&quot;, <lb/>and &quot;number&quot;. <lb/>If _T_ starts with &quot;int&quot; or &quot;uint&quot;, then the instance is accepted if <lb/>and only if it is a JSON number encoding a value with zero fractional <lb/>part. Depending on the value of _T_, this encoded number must <lb/>additionally fall within a particular range: <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 13] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>+--------+---------------------------+---------------------------+ <lb/>| _T_ <lb/>| Minimum Value (Inclusive) | Maximum Value (Inclusive) | <lb/>+--------+---------------------------+---------------------------+ <lb/>| int8 <lb/>| -128 <lb/>| 127 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint8 | 0 <lb/>| 255 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| int16 | -32,768 <lb/>| 32,767 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint16 | 0 <lb/>| 65,535 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| int32 | -2,147,483,648 <lb/>| 2,147,483,647 <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| uint32 | 0 <lb/>| 4,294,967,295 <lb/>| <lb/>+--------+---------------------------+---------------------------+ <lb/>Table 2: Ranges for Integer Types <lb/>Note that 10, 10.0, and 1.0e1 encode values with zero fractional <lb/>part. 10.5 encodes a number with a non-zero fractional part. Thus <lb/>{&quot;type&quot;: &quot;int8&quot;} accepts 10, 10.0, and 1.0e1, but not 10.5. <lb/>If the instance is not accepted, then the standard error for this <lb/>case shall have an &quot;instancePath&quot; pointing to the instance, and a <lb/>&quot;schemaPath&quot; pointing to the schema member with the name &quot;type&quot;. <lb/>For example: <lb/>o The schema {&quot;type&quot;: &quot;boolean&quot;} accepts false, but rejects 127. <lb/>o The schema {&quot;type&quot;: &quot;number&quot;} accepts 10.5, 127 and 128, but <lb/>rejects false. <lb/>o The schema {&quot;type&quot;: &quot;int8&quot;} accepts 127, but rejects 10.5, 128 and <lb/>false. <lb/>o The schema {&quot;type&quot;: &quot;string&quot;} accepts &quot;1985-04-12T23:20:50.52Z&quot; <lb/>and &quot;foo&quot;, but rejects 127. <lb/>o The schema {&quot;type&quot;: &quot;timestamp&quot;} accepts <lb/>&quot;1985-04-12T23:20:50.52Z&quot;, but rejects &quot;foo&quot; and 127. <lb/>In all of the rejected examples just given, the standard error to <lb/>produce is: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/type&quot; }] <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 14] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>3.3.4. Enum <lb/>The enum form is meant to describe instances whose value must be one <lb/>of a finite, predetermined set of string values. <lb/>If a schema is of the enum form, then let _E_ be the value of the <lb/>schema member with the name &quot;enum&quot;. The instance is accepted if and <lb/>only if it is equal to one of the elements of _E_. <lb/>If the instance is not accepted, then the standard error for this <lb/>case shall have an &quot;instancePath&quot; pointing to the instance, and a <lb/>&quot;schemaPath&quot; pointing to the schema member with the name &quot;enum&quot;. <lb/>For example, the schema: <lb/>{ &quot;enum&quot;: [&quot;PENDING&quot;, &quot;DONE&quot;, &quot;CANCELED&quot;] } <lb/>Accepts &quot;PENDING&quot;, &quot;DONE&quot;, and &quot;CANCELED&quot;, but it rejects both 123 <lb/>and &quot;UNKNOWN&quot; with the standard errors: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/enum&quot; }] <lb/>3.3.5. Elements <lb/>The elements form is meant to describe instances that must be arrays. <lb/>A further sub-schema describes the elements of the array. <lb/>If a schema is of the elements form, then let _S_ be the value of the <lb/>schema member with the name &quot;elements&quot;. The instance is accepted if <lb/>and only if all of the following are true: <lb/>o The instance is an array. Otherwise, the standard error for this <lb/>case shall have an &quot;instancePath&quot; pointing to the instance, and a <lb/>&quot;schemaPath&quot; pointing to the schema member with the name <lb/>&quot;elements&quot;. <lb/>o If the instance is an array, then every element of the instance <lb/>must be accepted by _S_. Otherwise, the standard errors for this <lb/>case are the union of all the errors arising from evaluating _S_ <lb/>against elements of the instance. <lb/>For example, if we have the schema: <lb/>{ <lb/>&quot;elements&quot;: { <lb/>&quot;type&quot;: &quot;number&quot; <lb/>} <lb/>} <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 15] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>Then the instances [] and [1, 2, 3] are accepted. If instead we <lb/>evaluate false against that schema, the standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/elements&quot; }] <lb/>Finally, if we evaluate the instance: <lb/>[1, 2, &quot;foo&quot;, 3, &quot;bar&quot;] <lb/>The standard errors are: <lb/>[ <lb/>{ &quot;instancePath&quot;: &quot;/2&quot;, &quot;schemaPath&quot;: &quot;/elements/type&quot; }, <lb/>{ &quot;instancePath&quot;: &quot;/4&quot;, &quot;schemaPath&quot;: &quot;/elements/type&quot; } <lb/>] <lb/>3.3.6. Properties <lb/>The properties form is meant to describe JSON objects being used as a <lb/>&quot;struct&quot;. <lb/>If a schema is of the properties form, then the instance is accepted <lb/>if and only if all of the following are true: <lb/>o The instance is an object. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to the instance, and a &quot;schemaPath&quot; <lb/>pointing to the schema member with the name &quot;properties&quot; if such a <lb/>schema member exists; if such a member doesn&apos;t exist, &quot;schemaPath&quot; <lb/>shall point to the schema member with the name <lb/>&quot;optionalProperties&quot;. <lb/>o If the instance is an object and the schema has a member named <lb/>&quot;properties&quot;, then let _P_ be the value of the schema member named <lb/>&quot;properties&quot;. _P_, by Section 2, must be an object. For every <lb/>member name in _P_, a member of the same name in the instance must <lb/>exist. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to the instance, and a &quot;schemaPath&quot; <lb/>pointing to the member of _P_ failing the requirement just <lb/>described. <lb/>o If the instance is an object, then let _P_ be the value of the <lb/>schema member named &quot;properties&quot; (if it exists), and _O_ be the <lb/>value of the schema member named &quot;optionalProperties&quot; (if it <lb/>exists). <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 16] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>For every member _I_ of the instance, find a member with the same <lb/>name as _I_&apos;s in _P_ or _O_. By Section 2, it is not possible for <lb/>both _P_ and _O_ to have such a member. If the &quot;discriminator tag <lb/>exemption&quot; is in effect on _I_ (see Section 3.3.8), then ignore <lb/>_I_. Otherwise: <lb/>* If no such member in _P_ or _O_ exists and validation is using <lb/>strict instance semantics, then the instance is rejected. <lb/>The standard error for this case has an &quot;instancePath&quot; pointing <lb/>_I_, and a &quot;schemaPath&quot; pointing to the schema. <lb/>* If such a member in _P_ or _O_ does exist, then call this <lb/>member _S_. If _S_ rejects _I_&apos;s value, then the instance is <lb/>rejected. <lb/>The standard error for this case is the union of the errors <lb/>from evaluating _S_ against _I_&apos;s value. <lb/>An instance may have multiple errors arising from the second and <lb/>third bullet in the above. In this case, the standard errors are the <lb/>union of the errors. <lb/>For example, if we have the schema: <lb/>{ <lb/>&quot;properties&quot;: { <lb/>&quot;a&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;b&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>}, <lb/>&quot;optionalProperties&quot;: { <lb/>&quot;c&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;d&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>} <lb/>Then each of the following instances (one on each line) are accepted: <lb/>{ &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot; } <lb/>{ &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;, &quot;c&quot;: &quot;baz&quot; } <lb/>{ &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;, &quot;c&quot;: &quot;baz&quot;, &quot;d&quot;: &quot;quux&quot; } <lb/>{ &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;, &quot;d&quot;: &quot;quux&quot; } <lb/>If we evaluate the instance 123 against this schema, then the <lb/>standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/properties&quot; }] <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 17] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>If instead we evalute the instance: <lb/>{ &quot;b&quot;: 3, &quot;c&quot;: 3, &quot;e&quot;: 3 } <lb/>The standard errors, using strict instance semantics, are: <lb/>[ <lb/>{ &quot;instancePath&quot;: &quot;&quot;, <lb/>&quot;schemaPath&quot;: &quot;/properties/a&quot; }, <lb/>{ &quot;instancePath&quot;: &quot;/b&quot;, <lb/>&quot;schemaPath&quot;: &quot;/properties/b/type&quot; }, <lb/>{ &quot;instancePath&quot;: &quot;/c&quot;, <lb/>&quot;schemaPath&quot;: &quot;/optionalProperties/c/type&quot; }, <lb/>{ &quot;instancePath&quot;: &quot;/e&quot;, <lb/>&quot;schemaPath&quot;: &quot;&quot; } <lb/>] <lb/>If we the same instance were evaluated, but without strict instance <lb/>semantics, the final element of the above array of errors would not <lb/>be present. <lb/>3.3.7. Values <lb/>The elements form is meant to describe instances that are JSON <lb/>objects being used as an associative array. <lb/>If a schema is of the values form, then let _S_ be the value of the <lb/>schema member with the name &quot;values&quot;. The instance is accepted if <lb/>and only if all of the following are true: <lb/>o The instance is an object. Otherwise, the standard error for this <lb/>case shall have an &quot;instancePath&quot; pointing to the instance, and a <lb/>&quot;schemaPath&quot; pointing to the schema member with the name &quot;values&quot;. <lb/>o If the instance is an object, then every member value of the <lb/>instance must be accepted by _S_. Otherwise, the standard errors <lb/>for this case are the union of all the errors arising from <lb/>evaluating _S_ against member values of the instance. <lb/>For example, if we have the schema: <lb/>{ <lb/>&quot;values&quot;: { <lb/>&quot;type&quot;: &quot;number&quot; <lb/>} <lb/>} <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 18] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>Then the instances {} and {&quot;a&quot;: 1, &quot;b&quot;: 2} are accepted. If instead <lb/>we evaluate false against that schema, the standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/values&quot; }] <lb/>Finally, if we evaluate the instance: <lb/>{ &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &quot;foo&quot;, &quot;d&quot;: 3, &quot;e&quot;: &quot;bar&quot; } <lb/>The standard errors are: <lb/>[ <lb/>{ &quot;instancePath&quot;: &quot;/c&quot;, &quot;schemaPath&quot;: &quot;/values/type&quot; }, <lb/>{ &quot;instancePath&quot;: &quot;/e&quot;, &quot;schemaPath&quot;: &quot;/values/type&quot; } <lb/>] <lb/>3.3.8. Discriminator <lb/>The discriminator form is meant to describe JSON objects being used <lb/>in a fashion similar to a discriminated union construct in C-like <lb/>languages. When a schema is of the &quot;discriminator&quot; form, it <lb/>validates: <lb/>o That the instance is an object, <lb/>o That the instance has a particular &quot;tag&quot; property, <lb/>o That this &quot;tag&quot; property&apos;s value is a string within a set of valid <lb/>values, and <lb/>o That the instance satisfies another schema, where this other <lb/>schema is chosen based on the value of the &quot;tag&quot; property. <lb/>The behavior of the discriminator form is more complex than the other <lb/>keywords. Readers familiar with CDDL may find the final example in <lb/>Appendix A helpful in understanding its behavior. What follows in <lb/>this section is a description of the discriminator form&apos;s behavior, <lb/>as well as some examples. <lb/>If a schema is of the &quot;discriminator&quot; form, then: <lb/>o Let _D_ be the schema member with the name &quot;discriminator&quot;. <lb/>o Let _T_ be the member of _D_ with the name &quot;tag&quot;. <lb/>o Let _M_ be the member of _D_ with the name &quot;mapping&quot;. <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 19] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>o Let _I_ be the instance member whose name equals _T_&apos;s value. _I_ <lb/>may, for some rejected instances, not exist. <lb/>o Let _S_ be the member of _M_ whose name equals _I_&apos;s value. _S_ <lb/>may, for some rejected instances, not exist. <lb/>The instance is accepted if and only if: <lb/>o The instance is an object. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to the instance, and a &quot;schemaPath&quot; <lb/>pointing to _D_. <lb/>o If the instance is a JSON object, then _I_ must exist. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to the instance, and a &quot;schemaPath&quot; <lb/>pointing to _T_. <lb/>o If the instance is a JSON object and _I_ exists, _I_&apos;s value must <lb/>be a string. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to _I_, and a &quot;schemaPath&quot; pointing to <lb/>_T_. <lb/>o If the instance is a JSON object and _I_ exists and has a string <lb/>value, then _S_ must exist. <lb/>Otherwise, the standard error for this case shall have an <lb/>&quot;instancePath&quot; pointing to _I_, and a &quot;schemaPath&quot; pointing to <lb/>_M_. <lb/>o If the instance is a JSON object, _I_ exists, and _S_ exists, then <lb/>the instance must satisfy _S_&apos;s value. By Section 2, _S_&apos;s value <lb/>must have the properties form. Apply the &quot;discriminator tag <lb/>exemption&quot; afforded in Section 3.3.6 to _I_ when evaluating <lb/>whether the instance satisfies _S_&apos;s value. <lb/>Otherwise, the standard errors for this case shall be standard <lb/>errors from evaluating _S_&apos;s value against the instance, with the <lb/>&quot;discriminator tag exemption&quot; applied to _I_. <lb/>Each of the list items above are defined to be mutually exclusive. <lb/>For the same instance and schema, only one of the list items above <lb/>will apply. <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 20] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>To illustrate the discriminator form, if we have the schema: <lb/>{ <lb/>&quot;discriminator&quot;: { <lb/>&quot;tag&quot;: &quot;version&quot;, <lb/>&quot;mapping&quot;: { <lb/>&quot;v1&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;a&quot;: { &quot;type&quot;: &quot;number&quot; } <lb/>} <lb/>}, <lb/>&quot;v2&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;a&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>} <lb/>} <lb/>} <lb/>} <lb/>Then if we evaluate the instance: <lb/>&quot;example&quot; <lb/>Against this schema, the standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/discriminator&quot; }] <lb/>(This is the case of the instance not being an object.) <lb/>If we instead evaluate the instance: <lb/>{} <lb/>Then the standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;&quot;, &quot;schemaPath&quot;: &quot;/discriminator/tag&quot; }] <lb/>(This is the case of _I_ not existing.) <lb/>If we instead evaluate the instance: <lb/>{ &quot;version&quot;: 1 } <lb/>Then the standard errors are: <lb/>[{ &quot;instancePath&quot;: &quot;/version&quot;, &quot;schemaPath&quot;: &quot;/discriminator/tag&quot; }] <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 21] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>(This is the case of _I_ existing, but having a string value.) <lb/>If we instead evaluate the instance: <lb/>{ &quot;version&quot;: &quot;v3&quot; } <lb/>Then the standard errors are: <lb/>[ <lb/>{ &quot;instancePath&quot;: &quot;/version&quot;, <lb/>&quot;schemaPath&quot;: &quot;/discriminator/mapping&quot; } <lb/>] <lb/>(This is the case of _I_ existing and having a string value, but _S_ <lb/>not existing.) <lb/>If the instance evaluated were: <lb/>{ &quot;version&quot;: &quot;v2&quot;, &quot;a&quot;: 3 } <lb/>Then the standard errors are: <lb/>[ <lb/>{ <lb/>&quot;instancePath&quot;: &quot;/a&quot;, <lb/>&quot;schemaPath&quot;: &quot;/discriminator/mapping/v2/properties/a/type&quot; <lb/>} <lb/>] <lb/>(This is the case of _I_ and _S_ existing, but the instance not <lb/>satisfying _S_&apos;s value.) <lb/>Finally, if instead the instance were: <lb/>{ &quot;version&quot;: &quot;v2&quot;, &quot;a&quot;: &quot;foo&quot; } <lb/>Then the instance satisfies the schema. No standard errors are <lb/>returned. This would be the case even if evaluation were using <lb/>strict instance semantics, as the &quot;discriminator tag exemption&quot; would <lb/>ensure that &quot;version&quot; is not treated as an unexpected property when <lb/>evaluating the instance against _S_&apos;s value. <lb/>4. IANA Considerations <lb/>No IANA considerations. <lb/></body>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 22] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<body>5. Security Considerations <lb/>Implementations of JSON Schema Language will necessarily be <lb/>manipulating JSON data. Therefore, the security considerations of <lb/>[RFC8259] are all relevant here. <lb/>Implementations which evaluate user-inputted schemas SHOULD implement <lb/>mechanisms to detect, and abort, circular references which might <lb/>cause a naive implementation to go into an infinite loop. Without <lb/>such mechanisms, implementations may be vulnerable to denial-of-<lb/>service attacks. <lb/></body>

			<listBibl>6. Normative References <lb/>[RFC2119] Bradner, S., &quot;Key words for use in RFCs to Indicate <lb/>Requirement Levels&quot;, BCP 14, RFC 2119, <lb/>DOI 10.17487/RFC2119, March 1997, <lb/>&lt;https://www.rfc-editor.org/info/rfc2119&gt;. <lb/>[RFC3339] Klyne, G. and C. Newman, &quot;Date and Time on the Internet: <lb/>Timestamps&quot;, RFC 3339, DOI 10.17487/RFC3339, July 2002, <lb/>&lt;https://www.rfc-editor.org/info/rfc3339&gt;. <lb/>[RFC6901] Bryan, P., Ed., Zyp, K., and M. Nottingham, Ed., <lb/>&quot;JavaScript Object Notation (JSON) Pointer&quot;, RFC 6901, <lb/>DOI 10.17487/RFC6901, April 2013, <lb/>&lt;https://www.rfc-editor.org/info/rfc6901&gt;. <lb/>[RFC8174] Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in RFC <lb/>2119 Key Words&quot;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, <lb/>May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;. <lb/>[RFC8259] Bray, T., Ed., &quot;The JavaScript Object Notation (JSON) Data <lb/>Interchange Format&quot;, STD 90, RFC 8259, <lb/>DOI 10.17487/RFC8259, December 2017, <lb/>&lt;https://www.rfc-editor.org/info/rfc8259&gt;. <lb/>[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, &quot;Concise Data <lb/>Definition Language (CDDL): A Notational Convention to <lb/>Express Concise Binary Object Representation (CBOR) and <lb/>JSON Data Structures&quot;, RFC 8610, DOI 10.17487/RFC8610, <lb/>June 2019, &lt;https://www.rfc-editor.org/info/rfc8610&gt;. <lb/></listBibl>

			<div type="annex">Appendix A. Comparison with CDDL <lb/>This appendix is informative. <lb/></div>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 23] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<div type="annex">To aid the reader familiar with CDDL, this section illustrates how <lb/>JSL works by presenting JSL schemas and CDDL schemas which accept and <lb/>reject the same instances. <lb/>The JSL schema {} accepts the same instances as the CDDL rule: <lb/>root = any <lb/>The JSL schema: <lb/>{ <lb/>&quot;definitions&quot;: { <lb/>&quot;a&quot;: { &quot;elements&quot;: { &quot;ref&quot;: &quot;b&quot; }}, <lb/>&quot;b&quot;: { &quot;type&quot;: &quot;number&quot; } <lb/>}, <lb/>&quot;elements&quot;: { <lb/>&quot;ref&quot;: &quot;a&quot; <lb/>} <lb/>} <lb/>Corresponds to the CDDL schema: <lb/>root = [* a] <lb/>a = [* b] <lb/>b = number <lb/>The JSL schema: <lb/>{ &quot;enum&quot;: [&quot;PENDING&quot;, &quot;DONE&quot;, &quot;CANCELED&quot;]} <lb/>Accepts the same instances as the CDDL rule: <lb/>root = &quot;PENDING&quot; / &quot;DONE&quot; / &quot;CANCELED&quot; <lb/>The JSL schema {&quot;type&quot;: &quot;boolean&quot;} corresponds to the CDDL rule: <lb/>root = bool <lb/>The JSL schema {&quot;type&quot;: &quot;number&quot;} corresponds to the CDDL rule: <lb/>root = number <lb/>The JSL schema {&quot;type&quot;: &quot;string&quot;} corresponds to the CDDL rule: <lb/>root = tstr <lb/>The JSL schema {&quot;type&quot;: &quot;timestamp&quot;} corresponds to the CDDL rule: <lb/></div>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 24] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<div type="annex">root = tdate <lb/>The JSL schema: <lb/>{ &quot;elements&quot;: { &quot;type&quot;: &quot;number&quot; }} <lb/>Corresponds to the CDDL rule: <lb/>root = [* number] <lb/>The JSL schema: <lb/>{ <lb/>&quot;properties&quot;: { <lb/>&quot;a&quot;: { &quot;type&quot;: &quot;boolean&quot; }, <lb/>&quot;b&quot;: { &quot;type&quot;: &quot;number&quot; } <lb/>}, <lb/>&quot;optionalProperties&quot;: { <lb/>&quot;c&quot;: { &quot;type&quot;: &quot;string&quot; }, <lb/>&quot;d&quot;: { &quot;type&quot;: &quot;timestamp&quot; } <lb/>} <lb/>} <lb/>Corresponds to the CDDL rule: <lb/>root = { a: bool, b: number, ? c: tstr, ? d: tdate } <lb/>The JSL schema: <lb/>{ &quot;values&quot;: { &quot;type&quot;: &quot;number&quot; }} <lb/>Corresponds to the CDDL rule: <lb/>root = { * tstr =&gt; number } <lb/>Finally, the JSL schema: <lb/></div>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 25] <lb/></page>

			<note place="headnote">Internet-Draft <lb/>JSON Schema Language <lb/>August 2019 <lb/></note>

			<div type="annex">{ <lb/>&quot;discriminator&quot;: { <lb/>&quot;tag&quot;: &quot;a&quot;, <lb/>&quot;mapping&quot;: { <lb/>&quot;foo&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;b&quot;: { &quot;type&quot;: &quot;number&quot; } <lb/>} <lb/>}, <lb/>&quot;bar&quot;: { <lb/>&quot;properties&quot;: { <lb/>&quot;b&quot;: { &quot;type&quot;: &quot;string&quot; } <lb/>} <lb/>} <lb/>} <lb/>} <lb/>} <lb/>Corresponds to the CDDL rule: <lb/>root = { a: &quot;foo&quot;, b: number } / { a: &quot;bar&quot;, b: tstr } <lb/></div>

			<div type="acknowledgement">Acknowledgments <lb/>Thanks to Gary Court, Francis Galiegue, Kris Zyp, Geraint Luff, Jason <lb/>Desrosiers, Daniel Perrett, Erik Wilde, Ben Hutton, Evgeny <lb/>Poberezkin, Brad Bowman, Gowry Sankar, Donald Pipowitch, Dave Finlay, <lb/>Denis Laxalde, Henry Andrews, and Austin Wright for their work on the <lb/>initial drafts of JSON Schema, which inspired JSON Schema Language. <lb/>Thanks to Tim Bray, Carsten Bormann, and James Manger for their help <lb/>on JSON Schema Language. <lb/></div>

			Author&apos;s Address <lb/>	
			
			<front>Ulysse Carion<lb/> Email: ulyssecarion@gmail.com<lb/></front>

			<note place="footnote">Carion <lb/>Expires February 6, 2020 <lb/></note>

			<page>[Page 26] </page>


	</text>
</tei>
