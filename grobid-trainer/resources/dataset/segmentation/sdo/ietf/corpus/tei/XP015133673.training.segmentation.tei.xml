<?xml version="1.0" ?>
<tei xml:space="preserve">
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front>server date 20190710; downloaded by EPO on 20190711 <lb/>Internet Research Task Force (IRTF) <lb/>M. Mosko <lb/>Request for Comments: 8569 <lb/>PARC, Inc. <lb/>Category: Experimental <lb/>I. Solis <lb/>ISSN: 2070-1721 <lb/>LinkedIn <lb/>C. Wood <lb/>University of California Irvine <lb/>July 2019 <lb/>Content-Centric Networking (CCNx) Semantics <lb/>Abstract <lb/>This document describes the core concepts of the Content-Centric <lb/>Networking (CCNx) architecture and presents a network protocol based <lb/>on two messages: Interests and Content Objects. It specifies the set <lb/>of mandatory and optional fields within those messages and describes <lb/>their behavior and interpretation. This architecture and protocol <lb/>specification is independent of a specific wire encoding. <lb/>The protocol also uses a control message called an Interest Return, <lb/>whereby one system can return an Interest message to the previous hop <lb/>due to an error condition. This indicates to the previous hop that <lb/>the current system will not respond to the Interest. <lb/>This document is a product of the Information-Centric Networking <lb/>Research Group (ICNRG). The document received wide review among <lb/>ICNRG participants. Two full implementations are in active use and <lb/>have informed the technical maturity of the protocol specification. <lb/>Mosko, et al. <lb/>Experimental <lb/>[Page 1] <lb/>RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/>Status of This Memo <lb/>This document is not an Internet Standards Track specification; it is <lb/>published for examination, experimental implementation, and <lb/>evaluation. <lb/>This document defines an Experimental Protocol for the Internet <lb/>community. This document is a product of the Internet Research Task <lb/>Force (IRTF). The IRTF publishes the results of Internet-related <lb/>research and development activities. These results might not be <lb/>suitable for deployment. This RFC represents the consensus of the <lb/>Information-Centric Networking Research Group of the Internet <lb/>Research Task Force (IRTF). Documents approved for publication by <lb/>the IRSG are not candidates for any level of Internet Standard; see <lb/>Section 2 of RFC 7841. <lb/>Information about the current status of this document, any errata, <lb/>and how to provide feedback on it may be obtained at <lb/>https://www.rfc-editor.org/info/rfc8569. <lb/>Copyright Notice <lb/>Copyright (c) 2019 IETF Trust and the persons identified as the <lb/>document authors. All rights reserved. <lb/>This document is subject to BCP 78 and the IETF Trust&apos;s Legal <lb/>Provisions Relating to IETF Documents <lb/>(https://trustee.ietf.org/license-info) in effect on the date of <lb/>publication of this document. Please review these documents <lb/>carefully, as they describe your rights and restrictions with respect <lb/>to this document. <lb/></front>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 2] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<div type="toc">Table of Contents <lb/>1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . <lb/>4 <lb/>1.1. Requirements Language . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>1.2. Architecture . . . . . . . . . . . . . . . . . . . . . . <lb/>5 <lb/>1.3. Protocol Overview . . . . . . . . . . . . . . . . . . . . <lb/>6 <lb/>2. Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . 10 <lb/>2.1. Message Grammar . . . . . . . . . . . . . . . . . . . . . 10 <lb/>2.2. Consumer Behavior . . . . . . . . . . . . . . . . . . . . 14 <lb/>2.3. Publisher Behavior . . . . . . . . . . . . . . . . . . . 15 <lb/>2.4. Forwarder Behavior . . . . . . . . . . . . . . . . . . . 16 <lb/>2.4.1. Interest HopLimit . . . . . . . . . . . . . . . . . . 16 <lb/>2.4.2. Interest Aggregation . . . . . . . . . . . . . . . . 17 <lb/>2.4.3. Content Store Behavior . . . . . . . . . . . . . . . 19 <lb/>2.4.4. Interest Pipeline . . . . . . . . . . . . . . . . . . 19 <lb/>2.4.5. Content Object Pipeline . . . . . . . . . . . . . . . 20 <lb/>3. Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 <lb/>3.1. Name Examples . . . . . . . . . . . . . . . . . . . . . . 23 <lb/>3.2. Interest Payload ID . . . . . . . . . . . . . . . . . . . 23 <lb/>4. Cache Control . . . . . . . . . . . . . . . . . . . . . . . . 23 <lb/>5. Content Object Hash . . . . . . . . . . . . . . . . . . . . . 24 <lb/>6. Link . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 <lb/>7. Hashes . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 <lb/>8. Validation . . . . . . . . . . . . . . . . . . . . . . . . . 25 <lb/>8.1. Validation Algorithm . . . . . . . . . . . . . . . . . . 25 <lb/>8.2. Message Integrity Codes . . . . . . . . . . . . . . . . . 26 <lb/>8.3. Message Authentication Codes . . . . . . . . . . . . . . 26 <lb/>8.4. Signature . . . . . . . . . . . . . . . . . . . . . . . . 26 <lb/>9. Interest to Content Object Matching . . . . . . . . . . . . . 28 <lb/>10. Interest Return . . . . . . . . . . . . . . . . . . . . . . . 29 <lb/>10.1. Message Format . . . . . . . . . . . . . . . . . . . . . 30 <lb/>10.2. ReturnCode Types . . . . . . . . . . . . . . . . . . . . 31 <lb/>10.3. Interest Return Protocol . . . . . . . . . . . . . . . . 32 <lb/>10.3.1. No Route . . . . . . . . . . . . . . . . . . . . . . 32 <lb/>10.3.2. HopLimit Exceeded . . . . . . . . . . . . . . . . . 33 <lb/>10.3.3. Interest MTU Too Large . . . . . . . . . . . . . . . 33 <lb/>10.3.4. No Resources . . . . . . . . . . . . . . . . . . . . 33 <lb/>10.3.5. Path Error . . . . . . . . . . . . . . . . . . . . . 33 <lb/>10.3.6. Prohibited . . . . . . . . . . . . . . . . . . . . . 33 <lb/>10.3.7. Congestion . . . . . . . . . . . . . . . . . . . . . 34 <lb/>10.3.8. Unsupported Content Object Hash Algorithm . . . . . 34 <lb/>10.3.9. Malformed Interest . . . . . . . . . . . . . . . . . 34 <lb/>11. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 34 <lb/>12. Security Considerations . . . . . . . . . . . . . . . . . . . 34 <lb/>13. References . . . . . . . . . . . . . . . . . . . . . . . . . 37 <lb/>13.1. Normative References . . . . . . . . . . . . . . . . . . 37 <lb/>13.2. Informative References . . . . . . . . . . . . . . . . . 37 <lb/>Authors&apos; Addresses . . . . . . . . . . . . . . . . . . . . . . . 40 <lb/></div>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 3] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>1. Introduction <lb/>This document describes the principles of the CCNx architecture. It <lb/>describes a network protocol that uses a hierarchical name to forward <lb/>requests and to match responses to requests. It does not use <lb/>endpoint addresses, such as Internet Protocol. Restrictions in a <lb/>request can limit the response by the public key of the response&apos;s <lb/>signer or the cryptographic hash of the response. Every CCNx <lb/>forwarder along the path does the name matching and restriction <lb/>checking. The CCNx protocol fits within the broader framework of <lb/>Information-Centric Networking (ICN) protocols [RFC7927]. This <lb/>document concerns the semantics of the protocol and is not dependent <lb/>on a specific wire encoding. The CCNx Messages [RFC8609] document <lb/>describes a type-length-value (TLV) wire-protocol encoding. This <lb/>section introduces the main concepts of CCNx, which are further <lb/>elaborated in the remainder of the document. <lb/>The CCNx protocol derives from the early ICN work by Jacobson, et al. <lb/>[nnc]. Jacobson&apos;s version of CCNx is known as the 0.x version (&quot;CCNx <lb/>0.x&quot;), and the present work is known as the 1.0 version (&quot;CCNx 1.0&quot;). <lb/>There are two active implementations of CCNx 1.0. The most complete <lb/>implementation is Community ICN (CICN) [cicn], a Linux Foundation <lb/>project hosted at fd.io. Another active implementation is CCN-lite <lb/>[ccn-lite], with support for Internet of Things (IoT) systems and the <lb/>RIOT operating system. CCNx 0.x formed the basis of the Named Data <lb/>Networking (NDN) [ndn] university project. <lb/>The current CCNx 1.0 specification diverges from CCNx 0.x in a few <lb/>significant areas. The most pronounced behavioral difference between <lb/>CCNx 0.x and CCNx 1.0 is that CCNx 1.0 has a simpler response <lb/>processing behavior. In both versions, a forwarder uses a <lb/>hierarchical longest prefix match of a request name against the <lb/>forwarding information base (FIB) to send the request through the <lb/>network to a system that can issue a response. A forwarder must then <lb/>match a response&apos;s name to a request&apos;s name to determine the reverse <lb/>path and deliver the response to the requester. In CCNx 0.x, the <lb/>Interest name may be a hierarchical prefix of the response name, <lb/>which allows a form of Layer 3 (L3) content discovery. In CCNx 1.0, <lb/>a response&apos;s name must exactly equal a request&apos;s name. Content <lb/>discovery is performed by a higher-layer protocol. <lb/>The selector protocol &quot;CCNx Selectors&quot; [selectors] is an example of <lb/>using a higher-layer protocol on top of the CCNx 1.0 L3 to perform <lb/>content discovery. The selector protocol uses a method similar to <lb/>the original CCNx 0.x techniques without requiring partial name <lb/>matching of a response to a request in the forwarder. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 4] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>This document represents the consensus of the Information-Centric <lb/>Networking Research Group (ICNRG). It is the first ICN protocol from <lb/>the RG, created from the early CCNx protocol [nnc] with significant <lb/>revision and input from the ICN community and RG members. This <lb/>document has received critical reading by several members of the ICN <lb/>community and the RG. The authors and RG chairs approve of the <lb/>contents. This document is sponsored under the IRTF, is not issued <lb/>by the IETF, and is not an IETF standard. This is an experimental <lb/>protocol and may not be suitable for any specific application. The <lb/>specification may change in the future. <lb/>1.1. Requirements Language <lb/>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, <lb/>&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and <lb/>&quot;OPTIONAL&quot; in this document are to be interpreted as described in <lb/>BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all <lb/>capitals, as shown here. <lb/>1.2. Architecture <lb/>We describe the architecture of the network in which CCNx operates <lb/>and introduce certain terminology from [terminology]. The detailed <lb/>behavior of each component and message grammar is in Section 2. <lb/>A producer (also called a &quot;publisher&quot;) is an endpoint that <lb/>encapsulates content in Content Objects for transport in the CCNx <lb/>network. A producer has a public/private keypair and signs (directly <lb/>or indirectly) the Content Objects. Usually, the producer&apos;s KeyId <lb/>(hash of the public key) is well known or may be derived from the <lb/>producer&apos;s namespace via standard means. <lb/>A producer operates within one or more namespaces. A namespace is a <lb/>name prefix that is represented in the forwarding information base <lb/>(FIB). This allows a request to reach the producer and fetch a <lb/>response (if one exists). <lb/>The FIB is a table that tells a forwarder where to send a request. <lb/>It may point to a local application, a local cache or Content Store, <lb/>or to a remote system. If there is no matching entry in the FIB, a <lb/>forwarder cannot process a request. The detailed rules on name <lb/>matching to the FIB are given in Section 2.4.4. An endpoint has a <lb/>FIB, though it may be a simple default route. An intermediate system <lb/>(i.e., a router) typically has a much larger FIB. A core CCNx <lb/>forwarder, for example, would know all the global routes. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 5] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>A consumer is an endpoint that requests a name. It is beyond the <lb/>scope of this document to describe how a consumer learns of a name or <lb/>publisher KeyId; higher-layer protocols built on top of CCNx handle <lb/>those tasks, such as search engines or lookup services or well-known <lb/>names. The consumer constructs a request, called an Interest, and <lb/>forwards it via the endpoint&apos;s FIB. The consumer should get back <lb/>either a response (called a Content Object) that matches the Interest <lb/>or a control message (called an Interest Return) that indicates the <lb/>network cannot handle the request. <lb/>There are three ways to detect errors in Interest handling. An <lb/>Interest Return is a network control message that indicates a low-<lb/>level error like &quot;no route&quot; or &quot;out of resources&quot;. If an Interest <lb/>arrives at a producer, but the producer does not have the requested <lb/>content, the producer should send an application-specific error <lb/>message (e.g., a &quot;not found&quot; message). Finally, a consumer may not <lb/>receive anything; in which case, it should timeout and, depending on <lb/>the application, retry the request or return an error to the <lb/>application. <lb/>1.3. Protocol Overview <lb/>The goal of CCNx is to name content and retrieve the content from the <lb/>network without binding it to a specific network endpoint. A routing <lb/>system (specified separately) populates the FIB tables at each CCNx <lb/>router with hierarchical name prefixes that point towards the content <lb/>producers under that prefix. A request finds matching content along <lb/>those paths, in which case a response carries the data, or, if no <lb/>match is found, a control message indicates the failure. A request <lb/>may further refine acceptable responses with a restriction on the <lb/>response&apos;s signer and the cryptographic hash of the response. The <lb/>details of these restrictions are described below. <lb/>The CCNx name is a hierarchical series of name segments. Each name <lb/>segment has a type and zero or more bytes. Matching two names is <lb/>done as a binary comparison of the type and value, and is done <lb/>segment by segment. The human-readable form is defined under a URI <lb/>scheme &quot;ccnx:&quot; [ccnx-uri], though the canonical encoding of a name is <lb/>a series of pairs (type, octet string). There is no requirement that <lb/>any name segment be human readable or UTF-8. The first few segments <lb/>in a name will be matched against the FIB, and a routing protocol may <lb/>put its own restrictions on the routable name components (e.g., a <lb/>maximum length or character-encoding rules). In principle, name <lb/>segments and names have unbounded length, though in practice they are <lb/>limited by the wire encoding and practical considerations imposed by <lb/>a routing protocol. Note that in CCNx, name segments use binary <lb/>comparison, whereas in a URI, the authority uses a case-insensitive <lb/>hostname (due to DNS). <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 6] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>The CCNx name, as used by the forwarder, is purposefully left as a <lb/>general octet-encoded type and value without any requirements on <lb/>human readability and character encoding. The reason for this is <lb/>that we are concerned with how a forwarder processes names. We <lb/>expect that applications, routing protocols, or other higher layers <lb/>will apply their own conventions and restrictions on the allowed name <lb/>segment types and name segment values. <lb/>CCNx is a request and response protocol that fetches chunks of data <lb/>using a name. The integrity of each chunk may be directly asserted <lb/>through a digital signature or Message Authentication Code (MAC), or, <lb/>alternatively, indirectly via hash chains. Chunks may also carry <lb/>weaker Message Integrity Codes (MICs) or no integrity protection <lb/>mechanism at all. Because provenance information is carried with <lb/>each chunk (or larger indirectly protected block), we no longer need <lb/>to rely on host identities, such as those derived from TLS <lb/>certificates, to ascertain the chunk legitimacy. Therefore, data <lb/>integrity is a core feature of CCNx; it does not rely on the data <lb/>transmission channel. There are several options for data <lb/>confidentiality, discussed later. <lb/>This document only defines the general properties of CCNx names. In <lb/>some isolated environments, CCNx users may be able to use any name <lb/>they choose and either inject that name (or prefix) into a routing <lb/>protocol or use other information foraging techniques. In the <lb/>Internet environment, there will be policies around the formats of <lb/>names and assignments of names to publishers, though those are not <lb/>specified here. <lb/>The key concept of CCNx is that a subjective name is <lb/>cryptographically bound to a fixed payload. These publisher-<lb/>generated bindings can therefore be cryptographically verified. A <lb/>named payload is thus the tuple {{Name, ExtraFields, Payload, <lb/>ValidationAlgorithm}, ValidationPayload}, where all fields in the <lb/>inner tuple are covered by the validation payload (e.g., signature). <lb/>Consumers of this data can check the binding integrity by recomputing <lb/>the same cryptographic hash and verifying the digital signature in <lb/>ValidationPayload. <lb/>In addition to digital signatures (e.g., RSA), CCNx also supports <lb/>message authentication codes (e.g., Hashed Message Authentication <lb/>Code (HMAC)) and message integrity codes (e.g., Cyclic Redundancy <lb/>Checks (CRC)). To maintain the cryptographic binding, there should <lb/>be at least one object with a signature or authentication code, but <lb/>not all objects require it. For example, a first object with a <lb/>signature could refer to other objects via a hash chain, a Merkle <lb/>tree, or a signed manifest. The later objects may not have any <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 7] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>validation and rely purely on the references. The use of an <lb/>integrity code (e.g., CRC) is intended for detecting accidental <lb/>corruption in an Interest. <lb/>CCNx specifies a network protocol around Interests (request messages) <lb/>and Content Objects (response messages) to move named payloads. An <lb/>Interest includes the Name field, which identifies the desired <lb/>response, and optional matching restrictions. Restrictions limit the <lb/>possible matching Content Objects. Two restrictions exist: the Key <lb/>ID restriction (KeyIdRestr) and Content Object Hash restriction <lb/>(ContentObjectHashRestr). The first restriction on the KeyId limits <lb/>responses to those signed with a ValidationAlgorithm KeyId field <lb/>equal to the restriction. The second is the Content Object Hash <lb/>restriction, which limits the response to one where the cryptographic <lb/>hash of the entire named payload is equal to the restriction. <lb/>Section 9 fully explains how these restrictions limit matching of a <lb/>Content Object to an Interest. <lb/>The hierarchy of a CCNx name is used for routing via the longest <lb/>matching prefix in a forwarder. The longest matching prefix is <lb/>computed name segment by name segment in the hierarchical name, where <lb/>each name segment must be exactly equal to match. There is no <lb/>requirement that the prefix be globally routable. Within a <lb/>deployment, any local routing may be used, even one that only uses a <lb/>single flat (nonhierarchical) name segment. <lb/>Another concept of CCNx is that there should be flow balance between <lb/>Interest messages and Content Object messages. At the network level, <lb/>an Interest traveling along a single path should elicit no more than <lb/>one Content Object response. If some node sends the Interest along <lb/>more than one path, that node should consolidate the responses such <lb/>that only one Content Object flows back towards the requester. If an <lb/>Interest is sent broadcast or multicast on a multiple-access media, <lb/>the sender should be prepared for multiple responses unless some <lb/>other media-dependent mechanism like gossip suppression or leader <lb/>election is used. <lb/>As an Interest travels the forward path following the FIB, it <lb/>establishes state at each forwarder such that a Content Object <lb/>response can trace its way back to the original requester(s) without <lb/>the requester needing to include a routable return address. We use <lb/>the notional Pending Interest Table (PIT) as a method to store state <lb/>that facilitates the return of a Content Object. <lb/>The notional PIT stores the last hop of an Interest plus its Name <lb/>field and optional restrictions. This is the data required to match <lb/>a Content Object to an Interest (see Section 9). When a Content <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 8] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>Object arrives, it must be matched against the PIT to determine which <lb/>entries it satisfies. For each such entry, at most one copy of the <lb/>Content Object is sent to each listed last hop in the PIT entries. <lb/>An actual PIT is not mandated by this specification. An <lb/>implementation may use any technique that gives the same external <lb/>behavior. There are, for example, research papers that use <lb/>techniques like label switching in some parts of the network to <lb/>reduce the per-node state incurred by the PIT [dart]. Some <lb/>implementations store the PIT state in the FIB, so there is not a <lb/>second table. <lb/>If multiple Interests with the same {Name, [KeyIdRestr], <lb/>[ContentObjectHashRestr]} tuple arrive at a node before a Content <lb/>Object matching the first Interest comes back, they are grouped in <lb/>the same PIT entry and their last hops are aggregated (see <lb/>Section 2.4.2). Thus, one Content Object might satisfy multiple <lb/>pending Interests in a PIT. <lb/>In CCNx, higher-layer protocols are often called &quot;name-based <lb/>protocols&quot; because they operate on the CCNx name. For example, a <lb/>versioning protocol might append additional name segments to convey <lb/>state about the version of payload. A content discovery protocol <lb/>might append certain protocol-specific name segments to a prefix to <lb/>discover content under that prefix. Many such protocols may exist <lb/>and apply their own rules to names. They may be layered with each <lb/>protocol encapsulating (to the left) a higher layer&apos;s name prefix. <lb/>This document also describes a control message called an Interest <lb/>Return. A network element may return an Interest message to a <lb/>previous hop if there is an error processing the Interest. The <lb/>returned Interest may be further processed at the previous hop or <lb/>returned towards the Interest origin. When a node returns an <lb/>Interest, it indicates that the previous hop should not expect a <lb/>response from that node for the Interest, i.e., there is no PIT entry <lb/>left at the returning node for a Content Object to follow. <lb/>There are multiple ways to describe larger objects in CCNx. <lb/>Aggregating L3 Content Objects into larger objects is beyond the <lb/>scope of this document. One proposed method, File-Like ICN <lb/>Collection (FLIC) [flic], uses a manifest to enumerate the pieces of <lb/>a larger object. Manifests are, themselves, Content Objects. <lb/>Another option is to use a convention in the Content Object name, as <lb/>in the CCNx Chunking [chunking] protocol where a large object is <lb/>broken into small chunks and each chunk receives a special name <lb/>component indicating its serial order. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 9] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>At the semantic level, described in this document, we do not address <lb/>fragmentation. One experimental fragmentation protocol, BeginEnd <lb/>Fragments [befrags], uses a multipoint PPP-style technique for use <lb/>over L2 interfaces with the specification for CCNx Messages [RFC8609] <lb/>in TLV wire encoding. <lb/>With these concepts, the remainder of the document specifies the <lb/>behavior of a forwarder in processing Interest, Content Object, and <lb/>Interest Return messages. <lb/>2. Protocol <lb/>This section defines the grammar of a CCNx Message (Interest, Content <lb/>Object, or Interest Return). It then presents typical behaviors for <lb/>a consumer, a publisher, and a forwarder. In the forwarder section, <lb/>there are detailed descriptions about how to handle the forwarder-<lb/>specific topics, such as HopLimit and Content Store, along with <lb/>detailed processing pipelines for Interest and Content Object <lb/>messages. <lb/>2.1. Message Grammar <lb/>The CCNx Message ABNF [RFC5234] grammar is shown in Figure 1. The <lb/>grammar does not include any encoding delimiters, such as TLVs. <lb/>Specific wire encodings are given in a separate document. If a <lb/>Validation section exists, the Validation Algorithm covers from the <lb/>Body (BodyName or BodyOptName) through the end of the ValidationAlg <lb/>section. The InterestLifetime, CacheTime, and Return Code fields <lb/>exist outside of the validation envelope and may be modified. <lb/>HashType, PayloadType, and Private Enterprise Number (PEN) need to <lb/>correspond to IANA values registered in the &quot;CCNx Hash Function <lb/>Types&quot; and &quot;CCNx Payload Types&quot; registries [ccnx-registry], as well <lb/>as the &quot;Private Enterprise Numbers&quot; registry [eprise-numbers], <lb/>respectively. <lb/>The various fields, in alphabetical order, are defined as: <lb/>AbsTime: Absolute times are conveyed as the 64-bit UTC time in <lb/>milliseconds since the epoch (standard POSIX time). <lb/>CacheTime: The absolute time after which the publisher believes <lb/>there is low value in caching the Content Object. This is a <lb/>recommendation to caches (see Section 4). <lb/>Cert: Some applications may wish to embed an X.509 certificate to <lb/>both validate the signature and provide a trust anchor. The Cert <lb/>is a DER-encoded X.509 certificate. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 10] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>ConObjField: These are optional fields that may appear in a Content <lb/>Object. <lb/>ConObjHash: The value of the Content Object Hash, which is the <lb/>SHA256-32 over the message from the beginning of the body to the <lb/>end of the message. Note that this coverage area is different <lb/>from the ValidationAlg. This value SHOULD NOT be trusted across <lb/>domains (see Section 5). <lb/>ContentObjectHashRestr: The Content Object Hash restriction. A <lb/>Content Object must hash to the same value as the restriction <lb/>using the same HashType. The ContentObjectHashRestr MUST use <lb/>SHA256-32. <lb/>ExpiryTime: An absolute time after which the Content Object should <lb/>be considered expired (see Section 4). <lb/>Hash: Hash values carried in a Message carry a HashType to identify <lb/>the algorithm used to generate the hash followed by the hash <lb/>value. This form is to allow hash agility. Some fields may <lb/>mandate a specific HashType. <lb/>HashType: The algorithm used to calculate a hash, which must <lb/>correspond to one of the IANA &quot;CCNx Hash Function Types&quot; <lb/>[ccnx-registry]. <lb/>HopLimit: Interest messages may loop if there are loops in the <lb/>forwarding plane. To eventually terminate loops, each Interest <lb/>carries a HopLimit that is decremented after each hop and no <lb/>longer forwarded when it reaches zero. See Section 2.4. <lb/>InterestField: These are optional fields that may appear in an <lb/>Interest message. <lb/>KeyId: An identifier for the key used in the ValidationAlg. See <lb/>Validation (Section 8) for a description of how it is used for <lb/>MACs and signatures. <lb/>KeyIdRestr: The KeyId Restriction. A Content Object must have a <lb/>KeyId with the same value as the restriction. <lb/>KeyLink: A Link (see Section 6) that names how to retrieve the key <lb/>used to verify the ValidationPayload (see Section 8). <lb/>Lifetime: The approximate time during which a requester is willing <lb/>to wait for a response, usually measured in seconds. It is not <lb/>strongly related to the network round-trip time, though it must <lb/>necessarily be larger. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 11] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>Name: A name is made up of a nonempty first segment followed by zero <lb/>or more additional segments, which may be of 0 length. Name <lb/>segments are opaque octet strings and are thus case sensitive if <lb/>encoding UTF-8. An Interest MUST have a Name. A Content Object <lb/>MAY have a Name (see Section 9). The segments of a name are said <lb/>to be complete if its segments uniquely identify a single Content <lb/>Object. A name is exact if its segments are complete. An <lb/>Interest carrying a full name is one that specifies an exact name <lb/>and the Content Object Hash restriction of the corresponding <lb/>Content Object. <lb/>Payload: The message&apos;s data, as defined by PayloadType. <lb/>PayloadType: The format of the Payload field. If missing, assume <lb/>Data type (T_PAYLOADTYPE_DATA) [ccnx-registry]. Data type means <lb/>the payload is opaque application bytes. Key type <lb/>(T_PAYLOADTYPE_KEY [ccnx-registry]) means the payload is a DER-<lb/>encoded public key or X.509 certificate. Link type <lb/>(T_PAYLOADTYPE_LINK [ccnx-registry]) means it is one or more Links <lb/>(see Section 6). <lb/>PublicKey: Some applications may wish to embed the public key used <lb/>to verify the signature within the message itself. The PublickKey <lb/>is DER encoded. <lb/>RelTime: A relative time, measured in milliseconds. <lb/>ReturnCode: States the reason an Interest message is being returned <lb/>to the previous hop (see Section 10.2). <lb/>SigTime: The absolute time (UTC milliseconds) when the signature was <lb/>generated. The signature time only applies to the validation <lb/>algorithm; it does not necessarily represent when the validated <lb/>message was created. <lb/>Vendor: Vendor-specific opaque data. The Vendor data includes the <lb/>IANA Private Enterprise Numbers [eprise-numbers], followed by <lb/>vendor-specific information. CCNx allows vendor-specific data in <lb/>most locations of the grammar. <lb/>Message <lb/>= Interest / ContentObject / InterestReturn <lb/>Interest <lb/>= IntHdr BodyName [Validation] <lb/>IntHdr <lb/>= HopLimit [Lifetime] *Vendor <lb/>ContentObject = ConObjHdr BodyOptName [Validation] <lb/>ConObjHdr <lb/>= [CacheTime / ConObjHash] *Vendor <lb/>InterestReturn= ReturnCode Interest <lb/>BodyName <lb/>= Name Common <lb/>BodyOptName <lb/>= [Name] Common <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 12] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>Common <lb/>= *Field [Payload] <lb/>Validation <lb/>= ValidationAlg ValidationPayload <lb/>Name <lb/>= FirstSegment *Segment <lb/>FirstSegment = 1*OCTET / Vendor <lb/>Segment <lb/>= *OCTET / Vendor <lb/>ValidationAlg = (RSA-SHA256 / EC-SECP-256K1 / EC-SECP-384R1 / <lb/>HMAC-SHA256 / CRC32C) *Vendor <lb/>ValidationPayload = 1*OCTET <lb/>PublicAlg <lb/>= KeyId [SigTime] [KeyLink] [PublicKey] [Cert] <lb/>RSA-SHA256 <lb/>= PublicAlg <lb/>EC-SECP-256K1 = PublicAlg <lb/>EC-SECP-384R1 = PublicAlg <lb/>HMAC-SHA256 <lb/>= KeyId [SigTime] [KeyLink] <lb/>CRC32C <lb/>= [SigTime] <lb/>AbsTime <lb/>= 8OCTET ; 64-bit UTC msec since epoch <lb/>CacheTime <lb/>= AbsTime <lb/>ConObjField <lb/>= ExpiryTime / PayloadType <lb/>ConObjHash <lb/>= Hash <lb/>ExpiryTime <lb/>= AbsTime <lb/>Field <lb/>= InterestField / ConObjField / Vendor <lb/>Hash <lb/>= HashType 1*OCTET <lb/>HashType <lb/>= 2OCTET ; IANA &quot;CCNx Hash Function Types&quot; <lb/>HopLimit <lb/>= OCTET <lb/>InterestField = KeyIdRestr / ContentObjectHashRestr <lb/>KeyId <lb/>= Hash <lb/>KeyIdRestr <lb/>= Hash <lb/>KeyLink <lb/>= Link <lb/>Lifetime <lb/>= RelTime <lb/>Link <lb/>= Name [KeyIdRestr] [ContentObjectHashRestr] <lb/>ContentObjectHashRestr = Hash <lb/>Payload <lb/>= *OCTET <lb/>PayloadType <lb/>= OCTET ; IANA &quot;CCNx Payload Types&quot; <lb/>PublicKey <lb/>= *OCTET ; DER-encoded public key <lb/>Cert <lb/>= *OCTET ; DER-encoded X.509 Certificate <lb/>RelTime <lb/>= 1*OCTET ; msec <lb/>ReturnCode <lb/>= OCTET ; see Section 10.2 <lb/>SigTime <lb/>= AbsTime <lb/>Vendor <lb/>= PEN *OCTET <lb/>PEN <lb/>= 1*OCTET ; IANA &quot;Private Enterprise Number&quot; <lb/>Figure 1: CCNx Message ABNF Grammar <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 13] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>2.2. Consumer Behavior <lb/>To request a piece of content for a given {Name, [KeyIdRest], <lb/>[ContentObjectHashRestr]} tuple, a consumer creates an Interest <lb/>message with those values. It MAY add a validation section, <lb/>typically only a CRC32C. A consumer MAY put a Payload field in an <lb/>Interest to send additional data to the producer beyond what is in <lb/>the name. The name is used for routing and may be remembered at each <lb/>hop in the notional PIT to facilitate returning a Content Object; <lb/>storing large amounts of state in the name could lead to high memory <lb/>requirements. Because the payload is not considered when forwarding <lb/>an Interest or matching a Content Object to an Interest, a consumer <lb/>SHOULD put an Interest Payload ID (see Section 3.2) as part of the <lb/>name to allow a forwarder to match Interests to Content Objects and <lb/>avoid aggregating Interests with different payloads. Similarly, if a <lb/>consumer uses a MAC or a signature, it SHOULD also include a unique <lb/>segment as part of the name to prevent the Interest from being <lb/>aggregated with other Interests or satisfied by a Content Object that <lb/>has no relation to the validation. <lb/>The consumer SHOULD specify an InterestLifetime, which is the length <lb/>of time the consumer is willing to wait for a response. The <lb/>InterestLifetime is an application-scale time, not a network round-<lb/>trip time (see Section 2.4.2). If not present, the InterestLifetime <lb/>will use a default value (2 seconds). <lb/>The consumer SHOULD set the Interest HopLimit to a reasonable value <lb/>or use the default 255. If the consumer knows the distances to the <lb/>producer via routing, it SHOULD use that value. <lb/>A consumer hands off the Interest to its first forwarder, which will <lb/>then forward the Interest over the network to a publisher (or <lb/>replica) that may satisfy it based on the name (see Section 2.4). <lb/>Interest messages are unreliable. A consumer SHOULD run a transport <lb/>protocol that will retry the Interest if it goes unanswered, up to <lb/>the InterestLifetime. No transport protocol is specified in this <lb/>document. <lb/>The network MAY send to the consumer an Interest Return message that <lb/>indicates the network cannot fulfill the Interest. The ReturnCode <lb/>specifies the reason for the failure, such as no route or congestion. <lb/>Depending on the ReturnCode, the consumer MAY retry the Interest or <lb/>MAY return an error to the requesting application. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 14] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>If the content was found and returned by the first forwarder, the <lb/>consumer will receive a Content Object. The consumer uses the <lb/>following set of checks to validate a received Content Object: <lb/>o The consumer MUST ensure the Content Object is properly formatted. <lb/>o The consumer MUST verify that the returned Content Object matches <lb/>one or more pending Interests as per Section 9. <lb/>o If the Content Object is signed, the consumer SHOULD <lb/>cryptographically verify the signature as per Section 8. If it <lb/>does not have the corresponding key, it SHOULD fetch the key, such <lb/>as from a key resolution service or via the KeyLink. <lb/>o If the signature has a SigTime, the consumer MAY use that in <lb/>considering if the signature is valid. For example, if the <lb/>consumer is asking for dynamically generated content, it should <lb/>expect the SigTime not to be before the time the Interest was <lb/>generated. <lb/>o If the Content Object is signed, the consumer SHOULD assert the <lb/>trustworthiness of the signing key to the namespace. Such an <lb/>assertion is beyond the scope of this document, though one may use <lb/>traditional PKI methods, a trusted key resolution service, or <lb/>methods like [trust]. <lb/>o The consumer MAY cache the Content Object for future use, up to <lb/>the ExpiryTime if present. <lb/>o The consumer MAY accept a Content Object off the wire that is <lb/>expired. A packet Content Object may expire while in flight; <lb/>there is no requirement that forwarders drop expired packets in <lb/>flight. The only requirement is that Content Stores, caches, or <lb/>producers MUST NOT respond with an expired Content Object. <lb/>2.3. Publisher Behavior <lb/>This document does not specify the method by which names populate a <lb/>FIB table at forwarders (see Section 2.4). A publisher is either <lb/>configured with one or more name prefixes under which it may create <lb/>content or it chooses its name prefixes and informs the routing layer <lb/>to advertise those prefixes. <lb/>When a publisher receives an Interest, it SHOULD: <lb/>o Verify that the Interest is part of the publisher&apos;s namespace(s). <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 15] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>o If the Interest has a Validation section, verify it as per <lb/>Section 8. Usually an Interest will only have a CRC32C, unless <lb/>the publisher application specifically accommodates other <lb/>validations. The publisher MAY choose to drop Interests that <lb/>carry a Validation section if the publisher application does not <lb/>expect those signatures, as this could be a form of computational <lb/>denial of service. If the signature requires a key that the <lb/>publisher does not have, it is NOT RECOMMENDED that the publisher <lb/>fetch the key over the network unless it is part of the <lb/>application&apos;s expected behavior. <lb/>o Retrieve or generate the requested Content Object and return it to <lb/>the Interest&apos;s previous hop. If the requested content cannot be <lb/>returned, the publisher SHOULD reply with an Interest Return or a <lb/>Content Object with application payload that says the content is <lb/>not available; this Content Object should have a short ExpiryTime <lb/>in the future or not be cacheable (i.e., an expiry time of 0). <lb/>2.4. Forwarder Behavior <lb/>A forwarder routes Interest messages based on a Forwarding <lb/>Information Base (FIB), returns Content Objects that match Interests <lb/>to the Interest&apos;s previous hop, and processes Interest Return control <lb/>messages. It may also keep a cache of Content Objects in the <lb/>notional Content Store table. This document does not specify the <lb/>internal behavior of a forwarder, only these and other external <lb/>behaviors. <lb/>In this document, we will use two processing pipelines: one for <lb/>Interests and one for Content Objects. Interest processing is made <lb/>up of checking for duplicate Interests in the PIT (see <lb/>Section 2.4.2), checking for a cached Content Object in the Content <lb/>Store (see Section 2.4.3), and forwarding an Interest via the FIB. <lb/>Content Store processing is made up of checking for matching <lb/>Interests in the PIT and forwarding to those previous hops. <lb/>2.4.1. Interest HopLimit <lb/>Interest looping is not prevented in CCNx. An Interest traversing <lb/>loops is eventually discarded using the hop-limit field of the <lb/>Interest, which is decremented at each hop traversed by the Interest. <lb/>A loop may also terminate because the Interest is aggregated with its <lb/>previous PIT entry along the loop. In this case, the Content Object <lb/>will be sent back along the loop and eventually return to a node that <lb/>already forwarded the content, so it will likely not have a PIT entry <lb/>anymore. When the content reaches a node without a PIT entry, it <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 16] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>will be discarded. It may be that a new Interest or another looped <lb/>Interest will return to that same node, in which case the node will <lb/>return a cached response to make a new PIT entry, as below. <lb/>The HopLimit is the last resort method to stop Interest loops where a <lb/>Content Object chases an Interest around a loop and where the <lb/>intermediate nodes, for whatever reason, no longer have a PIT entry <lb/>and do not cache the Content Object. <lb/>Every Interest MUST carry a HopLimit. An Interest received from a <lb/>local application MAY have a 0 HopLimit, which restricts the Interest <lb/>to other local sources. <lb/>When an Interest is received from another forwarder, the HopLimit <lb/>MUST be positive, otherwise the forwarder will discard the Interest. <lb/>A forwarder MUST decrement the HopLimit of an Interest by at least 1 <lb/>before it is forwarded. <lb/>If the decremented HopLimit equals 0, the Interest MUST NOT be <lb/>forwarded to another forwarder; it MAY be sent to a local publisher <lb/>application or serviced from a local Content Store. <lb/>A RECOMMENDED HopLimit-processing pipeline is below: <lb/>o If Interest received from a remote system: <lb/>* If received HopLimit is 0, optionally send Interest Return <lb/>(HopLimit Exceeded), and discard Interest. <lb/>* Otherwise, decrement the HopLimit by 1. <lb/>o Process as per Content Store and Aggregation rules. <lb/>o If the Interest will be forwarded: <lb/>* If the (potentially decremented) HopLimit is 0, restrict <lb/>forwarding to the local system. <lb/>* Otherwise, forward as desired to local or remote systems. <lb/>2.4.2. Interest Aggregation <lb/>Interest aggregation is when a forwarder receives an Interest message <lb/>that could be satisfied by the response to another Interest message <lb/>already forwarded by the node, so the forwarder suppresses forwarding <lb/>the new Interest; it only records the additional previous hop so a <lb/>Content Object sent in response to the first Interest will satisfy <lb/>both Interests. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 17] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>CCNx uses an Interest aggregation rule that assumes the <lb/>InterestLifetime is akin to a subscription time and is not a network <lb/>round-trip time. Some previous aggregation rules assumed the <lb/>lifetime was a round-trip time, but this leads to problems of <lb/>expiring an Interest before a response comes if the RTT is estimated <lb/>too short or interfering with an Automatic Repeat reQuest (ARQ) <lb/>scheme that wants to retransmit an Interest but a prior Interest <lb/>overestimated the RTT. <lb/>A forwarder MAY implement an Interest aggregation scheme. If it does <lb/>not, then it will forward all Interest messages. This does not imply <lb/>that multiple, possibly identical, Content Objects will come back. A <lb/>forwarder MUST still satisfy all pending Interests, so one Content <lb/>Object could satisfy multiple similar Interests, even if the <lb/>forwarder did not suppress duplicate Interest messages. <lb/>A RECOMMENDED Interest aggregation scheme is: <lb/>o Two Interests are considered &quot;similar&quot; if they have the same Name, <lb/>KeyIdRestr, and ContentObjectHashRestr, where a missing optional <lb/>field in one must be missing in the other. <lb/>o Let the notional value InterestExpiry (a local value at the <lb/>forwarder) be equal to the receive time plus the InterestLifetime <lb/>(or a platform-dependent default value if not present). <lb/>o An Interest record (PIT entry) is considered invalid if its <lb/>InterestExpiry time is in the past. <lb/>o The first reception of an Interest MUST be forwarded. <lb/>o A second or later reception of an Interest similar to a valid <lb/>pending Interest from the same previous hop MUST be forwarded. We <lb/>consider these a retransmission request. <lb/>o A second or later reception of an Interest similar to a valid <lb/>pending Interest from a new previous hop MAY be aggregated (not <lb/>forwarded). If this Interest has a larger HopLimit than the <lb/>pending Interest, it MUST be forwarded. <lb/>o Aggregating an Interest MUST extend the InterestExpiry time of the <lb/>Interest record. An implementation MAY keep a single <lb/>InterestExpiry time for all previous hops or MAY keep the <lb/>InterestExpiry time per previous hop. In the first case, the <lb/>forwarder might send a Content Object down a path that is no <lb/>longer waiting for it, in which case the previous hop (next hop of <lb/>the Content Object) would drop it. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 18] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>2.4.3. Content Store Behavior <lb/>The Content Store is a special cache that is an integral part of a <lb/>CCNx forwarder. It is an optional component. It serves to repair <lb/>lost packets and handle flash requests for popular content. It could <lb/>be prepopulated or use opportunistic caching. Because the Content <lb/>Store could serve to amplify an attack via cache poisoning, there are <lb/>special rules about how a Content Store behaves. <lb/>1. A forwarder MAY implement a Content Store. If it does, the <lb/>Content Store matches a Content Object to an Interest via the <lb/>normal matching rules (see Section 9). <lb/>2. If an Interest has a KeyId restriction, then the Content Store <lb/>MUST NOT reply unless it knows the signature on the matching <lb/>Content Object is correct. It may do this by external knowledge <lb/>(i.e., in a managed network or system with prepopulated caches) <lb/>or by having the public key and cryptographically verifying the <lb/>signature. A Content Store is NOT REQUIRED to verify signatures; <lb/>if it does not, then it treats these cases like a cache miss. <lb/>3. If a Content Store chooses to verify signatures, then it MAY do <lb/>so as follows. If the public key is provided in the Content <lb/>Object itself (i.e., in the PublicKey field) or in the Interest, <lb/>the Content Store MUST verify that the public key&apos;s hash is equal <lb/>to the KeyId and that it verifies the signature (see <lb/>Section 8.4). A Content Store MAY verify the digital signature <lb/>of a Content Object before it is cached, but it is not required <lb/>to do so. A Content Store SHOULD NOT fetch keys over the <lb/>network. If it cannot or has not yet verified the signature, it <lb/>should treat the Interest as a cache miss. <lb/>4. If an Interest has a Content Object Hash restriction, then the <lb/>Content Store MUST NOT reply unless it knows the matching Content <lb/>Object has the correct hash. If it cannot verify the hash, then <lb/>it should treat the Interest as a cache miss. <lb/>5. It must obey the cache control directives (see Section 4). <lb/>2.4.4. Interest Pipeline <lb/>1. Perform the HopLimit check (see Section 2.4.1). <lb/>2. If the Interest carries a validation, such as a MIC or a <lb/>signature with an embedded public key or certificate, a forwarder <lb/>MAY validate the Interest as per Section 8. A forwarder SHOULD <lb/>NOT fetch keys via a KeyLink. If the forwarder drops an Interest <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 19] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>due to failed validation, it MAY send an Interest Return <lb/>(Section 10.3.9). <lb/>3. Determine if the Interest can be aggregated as per Section 2.4.2. <lb/>If it can be, aggregate and do not forward the Interest. <lb/>4. If forwarding the Interest, check for a hit in the Content Store <lb/>as per Section 2.4.3. If a matching Content Object is found, <lb/>return it to the Interest&apos;s previous hop. This injects the <lb/>Content Store as per Section 2.4.5. <lb/>5. Look up the Interest in the FIB. Longest Prefix Match (LPM) is <lb/>performed name segment by name segment (not byte or bit). It <lb/>SHOULD exclude the Interest&apos;s previous hop. If a match is found, <lb/>forward the Interest. If no match is found or the forwarder <lb/>chooses not to forward due to a local condition (e.g., <lb/>congestion), it SHOULD send an Interest Return message as per <lb/>Section 10. <lb/>2.4.5. Content Object Pipeline <lb/>1. It is RECOMMENDED that a forwarder that receives a Content Object <lb/>check that the Content Object came from an expected previous hop. <lb/>An expected previous hop is one pointed to by the FIB or one <lb/>recorded in the PIT as having had a matching Interest sent that <lb/>way. <lb/>2. A Content Object MUST be matched to all pending Interests that <lb/>satisfy the matching rules (see Section 9). Each satisfied <lb/>pending Interest MUST then be removed from the set of pending <lb/>Interests. <lb/>3. A forwarder SHOULD NOT send more than one copy of the received <lb/>Content Object to the same Interest previous hop. It may happen, <lb/>for example, that two Interests ask for the same Content Object <lb/>in different ways (e.g., by name and by name and KeyId), and that <lb/>they both come from the same previous hop. It is normal to send <lb/>the same Content Object multiple times on the same interface, <lb/>such as Ethernet, if it is going to different previous hops. <lb/>4. A Content Object SHOULD only be put in the Content Store if it <lb/>satisfied an Interest (and passed rule #1 above). This is to <lb/>reduce the chances of cache poisoning. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 20] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>3. Names <lb/>A CCNx name is a composition of name segments. Each name segment <lb/>carries a label identifying the purpose of the name segment, and a <lb/>value. For example, some name segments are general names and some <lb/>serve specific purposes such as carrying version information or the <lb/>sequencing of many chunks of a large object into smaller, signed <lb/>Content Objects. <lb/>There are three different types of names in CCNx: prefix, exact, and <lb/>full names. A prefix name is simply a name that does not uniquely <lb/>identify a single Content Object, but rather a namespace or prefix of <lb/>an existing Content Object name. An exact name is one that uniquely <lb/>identifies the name of a Content Object. A full name is one that is <lb/>exact and is accompanied by an explicit or implicit ConObjHash. The <lb/>ConObjHash is explicit in an Interest and implicit in a Content <lb/>Object. <lb/>Note that a forwarder does not need to know any semantics about a <lb/>name. It only needs to be able to match a prefix to forward <lb/>Interests and match an exact or full name to forward Content Objects. <lb/>It is not sensitive to the name segment types. <lb/>The name segment labels specified in this document are given in <lb/>Table 1. Name Segment is a general name segment, typically occurring <lb/>in the routable prefix and user-specified content name. Interest <lb/>Payload ID is a name segment to identify the Interest&apos;s payload. <lb/>Application Components are a set of name segment types reserved for <lb/>application use. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 21] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>+-------------+-----------------------------------------------------+ <lb/>| <lb/>Type <lb/>| Description <lb/>| <lb/>+-------------+-----------------------------------------------------+ <lb/>| <lb/>Name <lb/>| A generic name segment that includes arbitrary <lb/>| <lb/>| <lb/>Segment <lb/>| octets. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>Interest | An octet string that identifies the payload carried | <lb/>| Payload ID | in an Interest. As an example, the Payload ID <lb/>| <lb/>| <lb/>| might be a hash of the Interest Payload. This <lb/>| <lb/>| <lb/>| provides a way to differentiate between Interests <lb/>| <lb/>| <lb/>| based on the payload solely through a name segment | <lb/>| <lb/>| without having to include all the extra bytes of <lb/>| <lb/>| <lb/>| the payload itself. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Application | An application-specific payload in a name segment. | <lb/>| Components | An application may apply its own semantics to these | <lb/>| <lb/>| components. A good practice is to identify the <lb/>| <lb/>| <lb/>| application in a name segment prior to the <lb/>| <lb/>| <lb/>| application component segments. <lb/>| <lb/>+-------------+-----------------------------------------------------+ <lb/>Table 1: CCNx Name Segment Types <lb/>At the lowest level, a forwarder does not need to understand the <lb/>semantics of name segments; it need only identify name segment <lb/>boundaries and be able to compare two name segments (both label and <lb/>value) for equality. The forwarder matches names segment by segment <lb/>against its forwarding table to determine a next hop. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 22] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>3.1. Name Examples <lb/>This section uses the CCNx URI [ccnx-uri] representation of CCNx <lb/>names. Note that as per the message grammar, an Interest must have a <lb/>Name with at least one name segment that must have at least 1 octet <lb/>of value. A Content Object must have a similar name or no name at <lb/>all. The FIB, on the other hand, could have 0-length names (a <lb/>default route), or a first name segment with no value, or a regular <lb/>name. <lb/>+--------------------------+----------------------------------------+ <lb/>| <lb/>Name <lb/>| Description <lb/>| <lb/>+--------------------------+----------------------------------------+ <lb/>| <lb/>ccnx:/ <lb/>| A 0-length name, corresponds to a <lb/>| <lb/>| <lb/>| default route. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| <lb/>ccnx:/NAME= <lb/>| A name with 1 segment of 0 length, <lb/>| <lb/>| <lb/>| distinct from ccnx:/. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| ccnx:/NAME=foo/APP:0=bar | A 2-segment name, where the first <lb/>| <lb/>| <lb/>| segment is of type NAME and the second | <lb/>| <lb/>| segment is of type APP:0. <lb/>| <lb/>+--------------------------+----------------------------------------+ <lb/>Table 2: CCNx Name Examples <lb/>3.2. Interest Payload ID <lb/>An Interest may also have a Payload field that carries state about <lb/>the Interest but is not used to match a Content Object. If an <lb/>Interest contains a payload, the Interest name should contain an <lb/>Interest Payload ID (IPID). The IPID allows a PIT entry to correctly <lb/>multiplex Content Objects in response to a specific Interest with a <lb/>specific payload ID. The IPID could be derived from a hash of the <lb/>payload or could be a Globally Unique Identifier (GUID) or a nonce. <lb/>An optional Metadata field defines the IPID field so other systems <lb/>can verify the IPID, such as when it is derived from a hash of the <lb/>payload. No system is required to verify the IPID. <lb/>4. Cache Control <lb/>CCNx supports two fields that affect cache control. These determine <lb/>how a cache or Content Store handles a Content Object. They are not <lb/>used in the fast path; they are only used to determine if a Content <lb/>Object can be injected onto the fast path in response to an Interest. <lb/>The ExpiryTime is a field that exists within the signature envelope <lb/>of a Validation Algorithm. It is the UTC time in milliseconds after <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 23] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>which the Content Object is considered expired and MUST no longer be <lb/>used to respond to an Interest from a cache. Stale content MAY be <lb/>flushed from the cache. <lb/>The Recommended Cache Time (RCT) is a field that exists outside the <lb/>signature envelope. It is the UTC time in milliseconds after which <lb/>the publisher considers the Content Object to be of low value to <lb/>cache. A cache SHOULD discard it after the RCT, though it MAY keep <lb/>it and still respond with it. A cache MAY also discard the Content <lb/>Object before the RCT time; there is no contractual obligation to <lb/>remember anything. <lb/>This formulation allows a producer to create a Content Object with a <lb/>long ExpiryTime but short RCT and keep republishing the same signed <lb/>Content Object over and over again by extending the RCT. This allows <lb/>a form of &quot;phone home&quot; where the publisher wants to periodically see <lb/>that the content is being used. <lb/>5. Content Object Hash <lb/>CCNx allows an Interest to restrict a response to a specific hash. <lb/>The hash covers the Content Object message body and the validation <lb/>sections, if present. Thus, if a Content Object is signed, its hash <lb/>includes that signature value. The hash does not include the fixed <lb/>or hop-by-hop headers of a Content Object. Because it is part of the <lb/>matching rules (see Section 9), the hash is used at every hop. <lb/>There are two options for matching the Content Object Hash <lb/>restriction in an Interest. First, a forwarder could compute for <lb/>itself the hash value and compare it to the restriction. This is an <lb/>expensive operation. The second option is for a border device to <lb/>compute the hash once and place the value in a header (ConObjHash) <lb/>that is carried through the network. The second option, of course, <lb/>removes any security properties from matching the hash, so it SHOULD <lb/>only be used within a trusted domain. The header SHOULD be removed <lb/>when crossing a trust boundary. <lb/>6. Link <lb/>A Link is the tuple {Name, [KeyIdRestr], [ContentObjectHashRestr]}. <lb/>The information in a Link comprises the fields of an Interest that <lb/>would retrieve the Link target. A Content Object with PayloadType of <lb/>&quot;Link&quot; is an object whose payload is one or more Links. This tuple <lb/>may be used as a KeyLink to identify a specific object with the <lb/>certificate-wrapped key. It is RECOMMENDED to include at least one <lb/>of either KeyId restriction or Content Object Hash restriction. If <lb/>neither restriction is present, then any Content Object with a <lb/>matching name from any publisher could be returned. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 24] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>7. Hashes <lb/>Several protocol fields use cryptographic hash functions, which must <lb/>be secure against attack and collisions. Because these hash <lb/>functions change over time, with better ones appearing and old ones <lb/>falling victim to attacks, it is important that a CCNx protocol <lb/>implementation supports hash agility. <lb/>In this document, we suggest certain hashes (e.g., SHA-256), but a <lb/>specific implementation may use what it deems best. The normative <lb/>CCNx Messages [RFC8609] specification should be taken as the <lb/>definition of acceptable hash functions and uses. <lb/>8. Validation <lb/>8.1. Validation Algorithm <lb/>The Validator consists of a ValidationAlgorithm that specifies how to <lb/>verify the message and a ValidationPayload containing the validation <lb/>output, e.g., the digital signature or MAC. The ValidationAlgorithm <lb/>section defines the type of algorithm to use and includes any <lb/>necessary additional information. The validation is calculated from <lb/>the beginning of the CCNx Message through the end of the <lb/>ValidationAlgorithm section (i.e., up to but not including the <lb/>validation payload). We refer to this as the validation region. The <lb/>ValidationPayload is the integrity value bytes, such as a MAC or <lb/>signature. <lb/>The CCNx Message Grammar (Section 2.1) shows the allowed validation <lb/>algorithms and their structure. In the case of a Vendor algorithm, <lb/>the vendor may use any desired structure. A Validator can only be <lb/>applied to an Interest or a Content Object, not an Interest Return. <lb/>An Interest inside an Interest Return would still have the original <lb/>validator, if any. <lb/>The grammar allows multiple Vendor extensions to the validation <lb/>algorithm. It is up to the vendor to describe the validation region <lb/>for each extension. A vendor may, for example, use a regular <lb/>signature in the validation algorithm, then append a proprietary MIC <lb/>to allow for in-network error checking without using expensive <lb/>signature verification. As part of this specification, we do not <lb/>allow for multiple Validation Algorithm blocks apart from these <lb/>vendor methods. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 25] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>8.2. Message Integrity Codes <lb/>If the validation algorithm is CRC32C, then the validation payload is <lb/>the output of the CRC over the validation region. This validation <lb/>algorithm allows for an optional signature time (SigTime) to <lb/>timestamp when the message was validated (calling it a &quot;signature&quot; <lb/>time is a slight misnomer, but we reuse the same field for this <lb/>purpose between MICs, MACs, and signatures). <lb/>MICs are usually used with an Interest to avoid accidental in-network <lb/>corruption. They are usually not used on Content Objects because the <lb/>objects are either signed or linked to by hash chains, so the CRC32C <lb/>is redundant. <lb/>8.3. Message Authentication Codes <lb/>If the validation algorithm is HMAC-SHA256, then the validation <lb/>payload is the output of the HMAC over the validation region. The <lb/>validation algorithm requires a KeyId and allows for a signature time <lb/>(SigTime) and KeyLink. <lb/>The KeyId field identifies the shared secret used between two parties <lb/>to authenticate messages. These secrets SHOULD be derived from a key <lb/>exchange protocol such as [ccnx-ke]. The KeyId, for a shared secret, <lb/>SHOULD be an opaque identifier not derived from the actual key; an <lb/>integer counter, for example, is a good choice. <lb/>The signature time is the timestamp when the authentication code was <lb/>computed and added to the messages. <lb/>The KeyLink field in a MAC indicates how to negotiate keys and should <lb/>point towards the key exchange endpoint. The use of a key <lb/>negotiation algorithm is beyond the scope of this specification, and <lb/>a key negotiation algorithm is not required to use this field. <lb/>8.4. Signature <lb/>Signature-validation algorithms use public key cryptographic <lb/>algorithms such as RSA and the Elliptic Curve Digital Signature <lb/>Algorithm (ECDSA). This specification and the corresponding wire <lb/>encoding [RFC8609] only support three specific signature algorithms: <lb/>RSA-SHA256, EC-SECP-256K1, and EC-SECP-384R1. Other algorithms may <lb/>be added in through other documents or by using experimental or <lb/>vendor-validation algorithm types. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 26] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>A signature that is public key based requires a KeyId field and may <lb/>optionally carry a signature time, an embedded public key, an <lb/>embedded certificate, and a KeyLink. The signature time behaves as <lb/>normal to timestamp when the signature was created. We describe the <lb/>use and relationship of the other fields here. <lb/>It is not common to use embedded certificates, as they can be very <lb/>large and may have validity periods different than the validated <lb/>data. The preferred method is to use a KeyLink to the validating <lb/>certificate. <lb/>The KeyId field in the ValidationAlgorithm identifies the public key <lb/>used to verify the signature. It is similar to a Subject Key <lb/>Identifier from X.509 (Section 4.2.1.2 of [RFC5280]). We define the <lb/>KeyId to be a cryptographic hash of the public key in DER form. All <lb/>implementations MUST support the SHA-256 digest as the KeyId hash. <lb/>The use of other algorithms for the KeyId is allowed, and it will not <lb/>cause problems at a forwarder because the forwarder only matches the <lb/>digest algorithm and digest output and does not compute the digest <lb/>(see Section 9). It may cause issues with a Content Store, which <lb/>needs to verify the KeyId and PublicKey match (see Section 2.4.3); <lb/>though in this case, it only causes a cache miss and the Interest <lb/>would still be forwarded to the publisher. As long as the publisher <lb/>and consumers support the hash, data will validate. <lb/>As per Section 9, a forwarder only matches the KeyId to a KeyId <lb/>restriction. It does not need to look at the other fields such as <lb/>the public key, certificate, or KeyLink. <lb/>If a message carries multiples of the KeyId, public key, certificate, <lb/>or KeyLink, an endpoint (consumer, cache, or Content Store) MUST <lb/>ensure that any fields it uses are consistent. The KeyId MUST be the <lb/>corresponding hash of the embedded public key or certificate public <lb/>key. The hash function to use is the KeyId&apos;s HashType. If there is <lb/>both an embedded public key and a certificate, the public keys MUST <lb/>be the same. <lb/>A message SHOULD NOT have both a PublicKey and a KeyLink to a public <lb/>key, as that is redundant. It MAY have a PublicKey and a KeyLink to <lb/>a certificate. <lb/>A KeyLink in a first Content Object may point to a second Content <lb/>Object with a DER-encoded public key in the PublicKey field and an <lb/>optional DER-encoded X.509 certificate in the payload. The second <lb/>Content Object&apos;s KeyId MUST equal the first object&apos;s KeyId. The <lb/>second object&apos;s PublicKey field MUST be the public key corresponding <lb/>to the KeyId. That key must validate both the first and second <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 27] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>object&apos;s signature. A DER-encoded X.509 certificate may be included <lb/>in the second object&apos;s payload and its embedded public key MUST match <lb/>the PublicKey. It must be issued by a trusted authority, preferably <lb/>specifying the valid namespace of the key in the distinguished name. <lb/>The second object MUST NOT have a KeyLink; we do not allow for <lb/>recursive key lookup. <lb/>9. Interest to Content Object Matching <lb/>A Content Object satisfies an Interest if and only if (a) the Content <lb/>Object name, if present, exactly matches the Interest name, (b) the <lb/>ValidationAlgorithm KeyId of the Content Object exactly equals the <lb/>Interest KeyId restriction, if present, and (c) the computed Content <lb/>Object Hash exactly equals the Interest Content Object Hash <lb/>restriction, if present. <lb/>The KeyId and KeyIdRestr use the Hash format (see Section 2.1). The <lb/>Hash format has an embedded HashType followed by the hash value. <lb/>When comparing a KeyId and KeyIdRestr, one compares both the HashType <lb/>and the value. <lb/>The matching rules are given by this predicate, which, if it <lb/>evaluates true, means the Content Object matches the Interest. Ni = <lb/>Name in the Interest (may not be empty), Ki = KeyIdRestr in the <lb/>Interest (may be empty), and Hi = ContentObjectHashRestr in the <lb/>Interest (may be empty). Likewise, No, Ko, and Ho are those <lb/>properties in the Content Object, where No and Ko may be empty; Ho <lb/>always exists (it is an intrinsic property of the Content Object). <lb/>For binary relations, we use &quot;&amp;&quot; for AND and &quot;|&quot; for OR. We use &quot;E&quot; <lb/>for the EXISTS (not empty) operator and &quot;!&quot; for the NOT EXISTS <lb/>operator. <lb/>As a special case, if the Content Object Hash restriction in the <lb/>Interest specifies an unsupported hash algorithm, then no Content <lb/>Object can match the Interest, so the system should drop the Interest <lb/>and MAY send an Interest Return to the previous hop. In this case, <lb/>the predicate below will never get executed because the Interest is <lb/>never forwarded. If the system is using the optional behavior of <lb/>having a different system calculate the hash for it, then the system <lb/>may assume all hash functions are supported and leave it to the other <lb/>system to accept or reject the Interest. <lb/>(!No | (Ni=No)) &amp; (!Ki | (Ki=Ko)) &amp; (!Hi | (Hi=Ho)) &amp; (E No | E Hi) <lb/>As one can see, there are two types of attributes one can match. The <lb/>first term depends on the existence of the attribute in the Content <lb/>Object while the next two terms depend on the existence of the <lb/>attribute in the Interest. The last term is the &quot;Nameless Object&quot; <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 28] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>restriction that states that if a Content Object does not have a <lb/>Name, then it must match the Interest on at least the Hash <lb/>restriction. <lb/>If a Content Object does not carry the Content Object Hash as an <lb/>expressed field, it must be calculated in network to match against. <lb/>It is sufficient within an autonomous system to calculate a Content <lb/>Object Hash at a border router and carry it via trusted means within <lb/>the autonomous system. If a Content Object ValidationAlgorithm does <lb/>not have a KeyId, then the Content Object cannot match an Interest <lb/>with a KeyId restriction. <lb/>10. Interest Return <lb/>This section describes the process whereby a network element may <lb/>return an Interest message to a previous hop if there is an error <lb/>processing the Interest. The returned Interest may be further <lb/>processed at the previous hop or returned towards the Interest <lb/>origin. When a node returns an Interest, it indicates that the <lb/>previous hop should not expect a response from that node for the <lb/>Interest, i.e., there is no PIT entry left at the returning node. <lb/>The returned message maintains compatibility with the existing TLV <lb/>packet format (a fixed header, optional hop-by-hop headers, and the <lb/>CCNx Message body). The returned Interest packet is modified in only <lb/>two ways: <lb/>o The PacketType is set to Interest Return to indicate a Feedback <lb/>message. <lb/>o The ReturnCode is set to the appropriate value to signal the <lb/>reason for the return. <lb/>The specific encodings of the Interest Return are specified in <lb/>[RFC8609]. <lb/>A forwarder is not required to send any Interest Return messages. <lb/>A forwarder is not required to process any received Interest Return <lb/>message. If a forwarder does not process Interest Return messages, <lb/>it SHOULD silently drop them. <lb/>The Interest Return message does not apply to a Content Object or any <lb/>other message type. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 29] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>An Interest Return message is a 1-hop message between peers. It is <lb/>not propagated multiple hops via the FIB. An intermediate node that <lb/>receives an Interest Return may take corrective actions or may <lb/>propagate its own Interest Return to previous hops as indicated in <lb/>the reverse path of a PIT entry. <lb/>10.1. Message Format <lb/>The Interest Return message looks exactly like the original Interest <lb/>message with the exception of the two modifications mentioned above. <lb/>The PacketType is set to indicate the message is an Interest Return, <lb/>and the reserved byte in the Interest header is used as a Return <lb/>Code. The numeric values for the PacketType and ReturnCodes are in <lb/>[RFC8609]. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 30] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>10.2. ReturnCode Types <lb/>This section defines the Interest Return ReturnCode introduced in <lb/>this RFC. The numeric values used in the packet are defined in <lb/>[RFC8609]. <lb/>+----------------------+--------------------------------------------+ <lb/>| Name <lb/>| Description <lb/>| <lb/>+----------------------+--------------------------------------------+ <lb/>| No Route (Section <lb/>| The returning forwarder has no route to <lb/>| <lb/>| 10.3.1) <lb/>| the Interest name. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| HopLimit Exceeded <lb/>| The HopLimit has decremented to 0 and <lb/>| <lb/>| (Section 10.3.2) <lb/>| needs to forward the packet. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Interest MTU too <lb/>| The Interest&apos;s MTU does not conform to the | <lb/>| large (Section <lb/>| required minimum and would require <lb/>| <lb/>| 10.3.3) <lb/>| fragmentation. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| No Resources <lb/>| The node does not have the resources to <lb/>| <lb/>| (Section 10.3.4) <lb/>| process the Interest. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Path error (Section | There was a transmission error when <lb/>| <lb/>| 10.3.5) <lb/>| forwarding the Interest along a route (a <lb/>| <lb/>| <lb/>| transient error). <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Prohibited (Section | An administrative setting prohibits <lb/>| <lb/>| 10.3.6) <lb/>| processing this Interest. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Congestion (Section | The Interest was dropped due to congestion | <lb/>| 10.3.7) <lb/>| (a transient error). <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Unsupported Content | The Interest was dropped because it <lb/>| <lb/>| Object Hash <lb/>| requested a Content Object Hash <lb/>| <lb/>| Algorithm (Section <lb/>| restriction using a hash algorithm that <lb/>| <lb/>| 10.3.8) <lb/>| cannot be computed. <lb/>| <lb/>| <lb/>| <lb/>| <lb/>| Malformed Interest <lb/>| The Interest was dropped because it did <lb/>| <lb/>| (Section 10.3.9) <lb/>| not correctly parse. <lb/>| <lb/>+----------------------+--------------------------------------------+ <lb/>Table 3: Interest Return Reason Codes <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 31] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>10.3. Interest Return Protocol <lb/>This section describes the forwarder behavior for the various Reason <lb/>codes for Interest Return. A forwarder is not required to generate <lb/>any of the codes, but if it does, it MUST conform to this <lb/>specification. <lb/>If a forwarder receives an Interest Return, it SHOULD take these <lb/>standard corrective actions. A forwarder is allowed to ignore <lb/>Interest Return messages, in which case its PIT entry would go <lb/>through normal timeout processes. <lb/>o Verify that the Interest Return came from a next hop to which it <lb/>actually sent the Interest. <lb/>o If a PIT entry for the corresponding Interest does not exist, the <lb/>forwarder should ignore the Interest Return. <lb/>o If a PIT entry for the corresponding Interest does exist, the <lb/>forwarder MAY do one of the following: <lb/>* Try a different forwarding path, if one exists, and discard the <lb/>Interest Return, or <lb/>* Clear the PIT state and send an Interest Return along the <lb/>reverse path. <lb/>If a forwarder tries alternate routes, it MUST ensure that it does <lb/>not use the same path multiple times. For example, it could keep <lb/>track of which next hops it has tried and not reuse them. <lb/>If a forwarder tries an alternate route, it may receive a second <lb/>Interest Return, possibly of a different type than the first Interest <lb/>Return. For example, node A sends an Interest to node B, which sends <lb/>a No Route return. Node A then tries node C, which sends a <lb/>Prohibited Interest Return. Node A should choose what it thinks is <lb/>the appropriate code to send back to its previous hop. <lb/>If a forwarder tries an alternate route, it should decrement the <lb/>Interest Lifetime to account for the time spent thus far processing <lb/>the Interest. <lb/>10.3.1. No Route <lb/>If a forwarder receives an Interest for which it has no route, or for <lb/>which the only route is back towards the system that sent the <lb/>Interest, the forwarder SHOULD generate a &quot;No Route&quot; Interest Return <lb/>message. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 32] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>How a forwarder manages the FIB table when it receives a No Route <lb/>message is implementation dependent. In general, receiving a No <lb/>Route Interest Return should not cause a forwarder to remove a route. <lb/>The dynamic routing protocol that installed the route should correct <lb/>the route, or the administrator who created a static route should <lb/>correct the configuration. A forwarder could suppress using that <lb/>next hop for some period of time. <lb/>10.3.2. HopLimit Exceeded <lb/>A forwarder MAY choose to send HopLimit Exceeded messages when it <lb/>receives an Interest that must be forwarded off system and the <lb/>HopLimit is 0. <lb/>10.3.3. Interest MTU Too Large <lb/>If a forwarder receives an Interest whose MTU exceeds the prescribed <lb/>minimum, it MAY send an &quot;Interest MTU Too Large&quot; message, or it may <lb/>silently discard the Interest. <lb/>If a forwarder receives an &quot;Interest MTU Too Large&quot; response, it <lb/>SHOULD NOT try alternate paths. It SHOULD propagate the Interest <lb/>Return to its previous hops. <lb/>10.3.4. No Resources <lb/>If a forwarder receives an Interest and it cannot process the <lb/>Interest due to lack of resources, it MAY send an Interest Return. A <lb/>lack of resources could mean the PIT is too large or that there is <lb/>some other capacity limit. <lb/>10.3.5. Path Error <lb/>If a forwarder detects an error forwarding an Interest, such as over <lb/>a reliable link, it MAY send a Path-Error Interest Return indicating <lb/>that it was not able to send or repair a forwarding error. <lb/>10.3.6. Prohibited <lb/>A forwarder may have administrative policies, such as access control <lb/>lists (ACLs), that prohibit receiving or forwarding an Interest. If <lb/>a forwarder discards an Interest due to a policy, it MAY send a <lb/>Prohibited Interest Return to the previous hop. For example, if <lb/>there is an ACL that says &quot;/example/private&quot; can only come from <lb/>interface e0, but the forwarder receives one from e1, the forwarder <lb/>must have a way to return the Interest with an explanation. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 33] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>10.3.7. Congestion <lb/>If a forwarder discards an Interest due to congestion, it MAY send a <lb/>Congestion Interest Return to the previous hop. <lb/>10.3.8. Unsupported Content Object Hash Algorithm <lb/>If a Content Object Hash restriction specifies a hash algorithm the <lb/>forwarder cannot verify, the Interest should not be accepted and the <lb/>forwarder MAY send an Interest Return to the previous hop. <lb/>10.3.9. Malformed Interest <lb/>If a forwarder detects a structural or syntactical error in an <lb/>Interest, it SHOULD drop the Interest and MAY send an Interest Return <lb/>to the previous hop. This does not imply that any router must <lb/>validate the entire structure of an Interest. <lb/>11. IANA Considerations <lb/>This document has no IANA actions. <lb/>12. Security Considerations <lb/>The CCNx protocol is an L3 network protocol, which may also operate <lb/>as an overlay using other transports such as UDP or other tunnels. <lb/>It includes intrinsic support for message authentication via a <lb/>signature (e.g., RSA or elliptic curve) or message authentication <lb/>code (e.g., HMAC). In lieu of an authenticator, it may instead use a <lb/>message integrity check (e.g., SHA or CRC). CCNx does not specify an <lb/>encryption envelope; that function is left to a high-layer protocol <lb/>(e.g., [esic]). <lb/>The CCNx message format includes the ability to attach MICs (e.g., <lb/>CRC32C), MACs (e.g., HMAC), and signatures (e.g., RSA or ECDSA) to <lb/>all packet types. This does not mean that it is a good idea to use <lb/>an arbitrary ValidationAlgorithm, nor to include computationally <lb/>expensive algorithms in Interest packets, as that could lead to <lb/>computational DoS attacks. Applications should use an explicit <lb/>protocol to guide their use of packet signatures. As a general <lb/>guideline, an application might use a MIC on an Interest to detect <lb/>unintentionally corrupted packets. If one wishes to secure an <lb/>Interest, one should consider using an encrypted wrapper and a <lb/>protocol that prevents replay attacks, especially if the Interest is <lb/>being used as an actuator. Simply using an authentication code or <lb/>signature does not make an Interest secure. There are several <lb/>examples in the literature on how to secure ICN-style messaging <lb/>[mobile] [ace]. <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 34] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>As an L3 protocol, this document does not describe how one arrives at <lb/>keys or how one trusts keys. The CCNx Content Object may include a <lb/>public key or certificate embedded in the object or may use the <lb/>KeyLink field to point to a public key or certificate that <lb/>authenticates the message. One key-exchange specification is CCNxKE <lb/>[ccnx-ke] [mobile], which is similar to the TLS 1.3 key exchange <lb/>except it is over the CCNx L3 messages. Trust is beyond the scope of <lb/>an L3 protocol and left to applications or application frameworks. <lb/>The combination of an ephemeral key exchange (e.g., CCNxKE [ccnx-ke]) <lb/>and an encapsulating encryption (e.g., [esic]) provides the <lb/>equivalent of a TLS tunnel. Intermediate nodes may forward the <lb/>Interests and Content Objects but have no visibility inside. It also <lb/>completely hides the internal names in those used by the encryption <lb/>layer. This type of tunneling encryption is useful for content that <lb/>has little or no cacheability, as it can only be used by someone with <lb/>the ephemeral key. Short-term caching may help with lossy links or <lb/>mobility, but long-term caching is usually not of interest. <lb/>Broadcast encryption or proxy re-encryption may be useful for content <lb/>with multiple uses over time or many consumers. There is currently <lb/>no recommendation for this form of encryption. <lb/>The specific encoding of messages will have security implications. <lb/>[RFC8609] uses a type-length-value (TLV) encoding. We chose to <lb/>compromise between extensibility and unambiguous encodings of types <lb/>and lengths. Some TLV encodings use variable-length &quot;T&quot; and <lb/>variable-length &quot;L&quot; fields to accommodate a wide gamut of values <lb/>while trying to be byte efficient. Our TLV encoding uses a fixed-<lb/>length 2-byte &quot;T&quot; and 2-byte &quot;L&quot;. Using a fixed-length &quot;T&quot; and &quot;L&quot; <lb/>field solves two problems. The first is aliases. If one is able to <lb/>encode the same value, such as %x02 and %x0002, in different byte <lb/>lengths, then one must decide if they mean the same thing, if they <lb/>are different, or if one is illegal. If they are different, then one <lb/>must always compare on the buffers, not the integer equivalents. If <lb/>one is illegal, then one must validate the TLV encoding, every field <lb/>of every packet at every hop. If they are the same, then one has the <lb/>second problem: how to specify packet filters. For example, if a <lb/>name has 6 name components, then there are 7 T&apos;s and 7 L&apos;s, each of <lb/>which might have up to 4 representations of the same value. That <lb/>would be 14 fields with 4 encodings each, or 1001 combinations. It <lb/>also means that one cannot compare, for example, a name via a memory <lb/>function as one needs to consider that any embedded &quot;T&quot; or &quot;L&quot; might <lb/>have a different format. <lb/>The Interest Return message has no authenticator from the previous <lb/>hop. Therefore, the payload of the Interest Return should only be <lb/>used locally to match an Interest. A node should never forward that <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 35] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>Interest Payload as an Interest. It should also verify that it sent <lb/>the Interest in the Interest Return to that node and not allow anyone <lb/>to negate Interest messages. <lb/>Caching nodes must take caution when processing Content Objects. It <lb/>is essential that the Content Store obey the rules outlined in <lb/>Section 2.4.3 to avoid certain types of attacks. CCNx 1.0 has no <lb/>mechanism to work around an undesired result from the network (there <lb/>are no &quot;excludes&quot;), so if a cache becomes poisoned with bad content, <lb/>it might cause problems retrieving content. There are three types of <lb/>access to content from a Content Store: unrestricted, signature <lb/>restricted, and hash restricted. If an Interest has no restrictions, <lb/>then the requester is not particular about what they get back, so any <lb/>matching cached object is OK. In the hash-restricted case, the <lb/>requester is very specific about what they want and the Content Store <lb/>(and every forward hop) can easily verify that the content matches <lb/>the request. In the signature-restricted case (often used for <lb/>initial manifest discovery), the requester only knows the KeyId that <lb/>signed the content. It is this case that requires the closest <lb/>attention in the Content Store to avoid amplifying bad data. The <lb/>Content Store must only respond with a Content Object if it can <lb/>verify the signature; this means either the Content Object carries <lb/>the public key inside it or the Interest carries the public key in <lb/>addition to the KeyId. If that is not the case, then the Content <lb/>Store should treat the Interest as a cache miss and let an endpoint <lb/>respond. <lb/>A user-level cache could perform full signature verification by <lb/>fetching a public key or certificate according to the KeyLink. That <lb/>is not, however, a burden we wish to impose on the forwarder. A <lb/>user-level cache could also rely on out-of-band attestation, such as <lb/>the cache operator only inserting content that it knows has the <lb/>correct signature. <lb/>The CCNx grammar allows for hash-algorithm agility via the HashType. <lb/>It specifies a short list of acceptable hash algorithms that should <lb/>be implemented at each forwarder. Some hash values only apply to end <lb/>systems, so updating the hash algorithm does not affect forwarders; <lb/>they would simply match the buffer that includes the type-length-hash <lb/>buffer. Some fields, such as the ConObjHash, must be verified at <lb/>each hop, so a forwarder (or related system) must know the hash <lb/>algorithm; it could cause backward compatibility problems if the hash <lb/>type is updated. [RFC8609] is the authoritative source for per-<lb/>field-allowed hash types in that encoding. <lb/>A CCNx name uses binary matching whereas a URI uses a case-<lb/>insensitive hostname. Some systems may also use case-insensitive <lb/>matching of the URI path to a resource. An implication of this is <lb/></body>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 36] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<body>that human-entered CCNx names will likely have case or non-ASCII <lb/>symbol mismatches unless one uses a consistent URI normalization to <lb/>the CCNx name. It also means that an entity that registers a CCNx <lb/>routable prefix, say &quot;ccnx:/example.com&quot;, would need separate <lb/>registrations for simple variations like &quot;ccnx:/Example.com&quot;. Unless <lb/>this is addressed in URI normalization and routing protocol <lb/>conventions, there could be phishing attacks. <lb/>For a more general introduction to ICN-related security concerns and <lb/>approaches, see [RFC7927] and [RFC7945]. <lb/></body>

			<listBibl>13. References <lb/>13.1. Normative References <lb/>[RFC2119] Bradner, S., &quot;Key words for use in RFCs to Indicate <lb/>Requirement Levels&quot;, BCP 14, RFC 2119, <lb/>DOI 10.17487/RFC2119, March 1997, <lb/>&lt;https://www.rfc-editor.org/info/rfc2119&gt;. <lb/>[RFC8174] Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in RFC <lb/>2119 Key Words&quot;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, <lb/>May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;. <lb/>13.2. Informative References <lb/>[ace] <lb/>Shang, W., Yu, Y., Liang, T., Zhang, B., and L. Zhang, <lb/>&quot;NDN-ACE: Access Control for Constrained Environments over <lb/>Named Data Networking&quot;, NDN Technical Report NDN-0036, <lb/>December 2015, &lt;http://new.named-data.net/ <lb/>wp-content/uploads/2015/12/ndn-0036-1-ndn-ace.pdf&gt;. <lb/>[befrags] Mosko, M. and C. Tschudin, &quot;ICN &quot;Begin-End&quot; Hop by Hop <lb/>Fragmentation&quot;, Work in Progress, draft-mosko-icnrg-<lb/>beginendfragment-02, December 2016. <lb/>[ccn-lite] Tschudin, C., et al., &quot;CCN-lite&quot;, University of Basel, <lb/>2011-2019, &lt;http://ccn-lite.net&gt;. <lb/>[ccnx-ke] Mosko, M., Uzun, E., and C. Wood, &quot;CCNx Key Exchange <lb/>Protocol Version 1.0&quot;, Work in Progress, draft-wood-icnrg-<lb/>ccnxkeyexchange-02, March 2017. <lb/>[ccnx-registry] <lb/>IANA, &quot;Content-Centric Networking (CCNx)&quot;, <lb/>&lt;https://www.iana.org/assignments/ccnx&gt;. <lb/></listBibl>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 37] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<listBibl>[ccnx-uri] Mosko, M. and C. Wood, &quot;The CCNx URI Scheme&quot;, Work in <lb/>Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016. <lb/>[chunking] Mosko, M., &quot;CCNx Content Object Chunking&quot;, Work in <lb/>Progress, draft-mosko-icnrg-ccnxchunking-02, June 2016. <lb/>[cicn] <lb/>FD.io, &quot;Community ICN (CICN)&quot;, February 2017, <lb/>&lt;https://wiki.fd.io/index.php?title=Cicn&amp;oldid=7191&gt;. <lb/>[dart] <lb/>Garcia-Luna-Aceves, J. and M. Mirzazad-Barijough, &quot;A <lb/>Light-Weight Forwarding Plane for Content-Centric <lb/>Networks&quot;, International Conference on Computing, <lb/>Networking, and Communications (ICNC), <lb/>DOI 10.1109/ICCNC.2016.7440637, February 2016, <lb/>&lt;https://arxiv.org/pdf/1603.06044.pdf&gt;. <lb/>[eprise-numbers] <lb/>IANA, &quot;IANA Private Enterprise Numbers&quot;, <lb/>&lt;https://www.iana.org/assignments/enterprise-numbers&gt;. <lb/>[esic] <lb/>Mosko, M. and C. Wood, &quot;Encrypted Sessions In CCNx <lb/>(ESIC)&quot;, Work in Progress, draft-wood-icnrg-esic-01, <lb/>September 2017. <lb/>[flic] <lb/>Tschudin, C. and C. Wood, &quot;File-Like ICN Collection <lb/>(FLIC)&quot;, Work in Progress, draft-tschudin-icnrg-flic-03, <lb/>March 2017. <lb/>[mobile] <lb/>Mosko, M., Uzun, E., and C. Wood, &quot;Mobile Sessions in <lb/>Content-Centric Networks&quot;, IFIP Networking Conference <lb/>(IFIP Networking) and Workshops, <lb/>DOI 10.23919/IFIPNetworking.2017.8264861, June 2017, <lb/>&lt;https://dl.ifip.org/db/conf/networking/ <lb/>networking2017/1570334964.pdf&gt;. <lb/>[ndn] <lb/>UCLA, &quot;Named Data Networking&quot;, 2019, <lb/>&lt;https://www.named-data.net&gt;. <lb/>[nnc] <lb/>Jacobson, V., Smetters, D., Thornton, J., Plass, M., <lb/>Briggs, N., and R. Braynard, &quot;Networking Named Content&quot;, <lb/>Proceedings of the 5th International Conference on <lb/>Emerging Networking Experiments and Technologies, <lb/>DOI 10.1145/1658939.1658941, December 2009, <lb/>&lt;https://dx.doi.org/10.1145/1658939.1658941&gt;. <lb/></listBibl>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 38] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			<listBibl>[RFC5234] Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax <lb/>Specifications: ABNF&quot;, STD 68, RFC 5234, <lb/>DOI 10.17487/RFC5234, January 2008, <lb/>&lt;https://www.rfc-editor.org/info/rfc5234&gt;. <lb/>[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., <lb/>Housley, R., and W. Polk, &quot;Internet X.509 Public Key <lb/>Infrastructure Certificate and Certificate Revocation List <lb/>(CRL) Profile&quot;, RFC 5280, DOI 10.17487/RFC5280, May 2008, <lb/>&lt;https://www.rfc-editor.org/info/rfc5280&gt;. <lb/>[RFC7927] Kutscher, D., Ed., Eum, S., Pentikousis, K., Psaras, I., <lb/>Corujo, D., Saucez, D., Schmidt, T., and M. Waehlisch, <lb/>&quot;Information-Centric Networking (ICN) Research <lb/>Challenges&quot;, RFC 7927, DOI 10.17487/RFC7927, July 2016, <lb/>&lt;https://www.rfc-editor.org/info/rfc7927&gt;. <lb/>[RFC7945] Pentikousis, K., Ed., Ohlman, B., Davies, E., Spirou, S., <lb/>and G. Boggia, &quot;Information-Centric Networking: Evaluation <lb/>and Security Considerations&quot;, RFC 7945, <lb/>DOI 10.17487/RFC7945, September 2016, <lb/>&lt;https://www.rfc-editor.org/info/rfc7945&gt;. <lb/>[RFC8609] Mosko, M., Solis, I., and C. Wood, &quot;Content-Centric <lb/>Networking (CCNx) Messages in TLV Format&quot;, RFC 8609, <lb/>DOI 10.17487/RFC8609, July 2019, <lb/>&lt;https://www.rfc-editor.org/info/rfc8609&gt;. <lb/>[selectors] <lb/>Mosko, M., &quot;CCNx Selector Based Discovery&quot;, Work in <lb/>Progress, draft-mosko-icnrg-selectors-01, May 2019. <lb/>[terminology] <lb/>Wissingh, B., Wood, C., Afanasyev, A., Zhang, L., Oran, <lb/>D., and C. Tschudin, &quot;Information-Centric Networking <lb/>(ICN): CCN and NDN Terminology&quot;, Work in Progress, <lb/>draft-irtf-icnrg-terminology-04, June 2019. <lb/>[trust] <lb/>Tschudin, C., Uzun, E., and C. Wood, &quot;Trust in <lb/>Information-Centric Networking: From Theory to Practice&quot;, <lb/>25th International Conference on Computer Communication <lb/>and Networks (ICCCN), DOI 10.1109/ICCCN.2016.7568589, <lb/>August 2016, &lt;https://doi.org/10.1109/ICCCN.2016.7568589&gt;. <lb/></listBibl>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 39] <lb/></page>

			<note place="headnote">RFC 8569 <lb/>CCNx Semantics <lb/>July 2019 <lb/></note>

			Authors&apos; Addresses <lb/>		

			<front>Marc Mosko <lb/>PARC, Inc. <lb/>Palo Alto, California 94304 <lb/>United States of America <lb/>Phone: +01 650-812-4405 <lb/>Email: marc.mosko@parc.com <lb/>Ignacio Solis <lb/>LinkedIn <lb/>Mountain View, California 94043 <lb/>United States of America <lb/>Email: nsolis@linkedin.com <lb/>Christopher A. Wood <lb/>University of California Irvine <lb/>Irvine, California 92697 <lb/>United States of America <lb/>Phone: +01 315-806-5939 <lb/>Email: woodc1@uci.edu <lb/></front>

			<note place="footnote">Mosko, et al. <lb/>Experimental <lb/></note>

			<page>[Page 40] </page>


	</text>
</tei>
